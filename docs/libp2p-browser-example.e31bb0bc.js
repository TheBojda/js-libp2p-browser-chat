// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/vue/dist/vue.runtime.esm.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = ('__proto__' in {}); // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if ("development" !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ("development" !== 'production' && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ("development" !== 'production' && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if ("development" !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if ("development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if ("development" !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if ("development" !== 'production') {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if ("development" !== 'production') {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if ("development" !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ("development" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if ("development" !== 'production' && // skip validation for weex recycle-list child component props
  !false) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ("development" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) {
    return t;
  });

  if (!valid && haveExpectedTypes) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType(value, type, vm) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}

var functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */

function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + styleValue(value, expectedType);
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + styleValue(value, receivedType) + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];

function isExplicable(value) {
  return EXPLICABLE_TYPES.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if ("development" !== 'production') {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */

/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if ("development" !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = (key in target);
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if ("development" !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if ("development" !== 'production') {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if ("development" !== 'production') {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if ("development" !== 'production') {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallbackRender, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }

  return eventKeyCode === undefined;
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ("development" !== 'production' && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if ("development" !== 'production') {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if ("development" !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't
vnode, // activeInstance in lifecycle state
parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ("development" !== 'production' && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }

      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if ("development" !== 'production') {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ("development" !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject("development" !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if ("development" !== 'production') {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if ("development" !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if ("development" !== 'production') {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if ("development" !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if ("development" !== 'production') {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ("development" !== 'production' && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = "development" !== 'production' ? expOrFn.toString() : ''; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
      "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        var info = "callback for watcher \"" + this.expression + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if ("development" !== 'production') {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if ("development" !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ("development" !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if ("development" !== 'production') {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn("The computed property \"" + key + "\" is already defined as a method.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if ("development" !== 'production') {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if ("development" !== 'production') {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      var info = "callback for immediate watcher \"" + watcher.expression + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if ("development" !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    } // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if ("development" !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ("development" !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ("development" !== 'production' && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var entry = cache[key];

    if (entry) {
      var name = entry.name;

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var entry = cache[key];

  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;

      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance
        };
        keys.push(keyToCache); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }

        this.vnodeToCache = null;
      }
    }
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  updated: function updated() {
    this.cacheVNode();
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if ("development" !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.14';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      "development" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if ("development" !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if ("development" !== 'production') {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if ("development" !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if ("development" !== 'production') {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if ("development" !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if ("development" !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

/*  */

/*  */

/*  */
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.

function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecessary `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ("development" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if ("development" !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if ("development" !== 'production' && "development" !== 'test') {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ("development" !== 'production' && "development" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var _default = Vue;
exports.default = _default;
},{}],"../../../../node_modules/core-js/modules/_global.js":[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"../../../../node_modules/core-js/modules/_has.js":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],"../../../../node_modules/core-js/modules/_fails.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],"../../../../node_modules/core-js/modules/_descriptors.js":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_core.js":[function(require,module,exports) {
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"../../../../node_modules/core-js/modules/_is-object.js":[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"../../../../node_modules/core-js/modules/_an-object.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_dom-create.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js"}],"../../../../node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_object-dp.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_ie8-dom-define":"../../../../node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_property-desc.js":[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],"../../../../node_modules/core-js/modules/_hide.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_uid.js":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"../../../../node_modules/core-js/modules/_library.js":[function(require,module,exports) {
module.exports = false;

},{}],"../../../../node_modules/core-js/modules/_shared.js":[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"../../../../node_modules/core-js/modules/_core.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_library":"../../../../node_modules/core-js/modules/_library.js"}],"../../../../node_modules/core-js/modules/_function-to-string.js":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js"}],"../../../../node_modules/core-js/modules/_redefine.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_function-to-string":"../../../../node_modules/core-js/modules/_function-to-string.js","./_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/core-js/modules/_a-function.js":[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],"../../../../node_modules/core-js/modules/_ctx.js":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js"}],"../../../../node_modules/core-js/modules/_export.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js"}],"../../../../node_modules/core-js/modules/_meta.js":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_wks.js":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_wks-define.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_wks-ext":"../../../../node_modules/core-js/modules/_wks-ext.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js"}],"../../../../node_modules/core-js/modules/_cof.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],"../../../../node_modules/core-js/modules/_iobject.js":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_defined.js":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],"../../../../node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_to-integer.js":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"../../../../node_modules/core-js/modules/_to-length.js":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js"}],"../../../../node_modules/core-js/modules/_to-absolute-index.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js"}],"../../../../node_modules/core-js/modules/_array-includes.js":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../../../node_modules/core-js/modules/_shared-key.js":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js"}],"../../../../node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":"../../../../node_modules/core-js/modules/_has.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js"}],"../../../../node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],"../../../../node_modules/core-js/modules/_object-keys.js":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"../../../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../../../node_modules/core-js/modules/_object-gops.js":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"../../../../node_modules/core-js/modules/_object-pie.js":[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],"../../../../node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js"}],"../../../../node_modules/core-js/modules/_is-array.js":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_to-object.js":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_object-dps.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/_html.js":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_object-create.js":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-dps":"../../../../node_modules/core-js/modules/_object-dps.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js","./_html":"../../../../node_modules/core-js/modules/_html.js"}],"../../../../node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"../../../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../../../node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js"}],"../../../../node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_ie8-dom-define":"../../../../node_modules/core-js/modules/_ie8-dom-define.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_shared":"../../../../node_modules/core-js/modules/_shared.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_wks-ext":"../../../../node_modules/core-js/modules/_wks-ext.js","./_wks-define":"../../../../node_modules/core-js/modules/_wks-define.js","./_enum-keys":"../../../../node_modules/core-js/modules/_enum-keys.js","./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_object-gopn-ext":"../../../../node_modules/core-js/modules/_object-gopn-ext.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js"}],"../../../../node_modules/core-js/modules/es6.object.create.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js"}],"../../../../node_modules/core-js/modules/es6.object.define-property.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js"}],"../../../../node_modules/core-js/modules/es6.object.define-properties.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-dps":"../../../../node_modules/core-js/modules/_object-dps.js"}],"../../../../node_modules/core-js/modules/_object-sap.js":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"../../../../node_modules/core-js/modules/_has.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_shared-key":"../../../../node_modules/core-js/modules/_shared-key.js"}],"../../../../node_modules/core-js/modules/es6.object.get-prototype-of.js":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.keys.js":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.get-own-property-names.js":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js","./_object-gopn-ext":"../../../../node_modules/core-js/modules/_object-gopn-ext.js"}],"../../../../node_modules/core-js/modules/es6.object.freeze.js":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.seal.js":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.prevent-extensions.js":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.is-frozen.js":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.is-sealed.js":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/es6.object.is-extensible.js":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../../../node_modules/core-js/modules/_object-sap.js"}],"../../../../node_modules/core-js/modules/_object-assign.js":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.object.assign.js":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-assign":"../../../../node_modules/core-js/modules/_object-assign.js"}],"../../../../node_modules/core-js/modules/_same-value.js":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"../../../../node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_same-value":"../../../../node_modules/core-js/modules/_same-value.js"}],"../../../../node_modules/core-js/modules/_set-proto.js":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js"}],"../../../../node_modules/core-js/modules/es6.object.set-prototype-of.js":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/_classof.js":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.object.to-string.js":[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/_invoke.js":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],"../../../../node_modules/core-js/modules/_bind.js":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_invoke":"../../../../node_modules/core-js/modules/_invoke.js"}],"../../../../node_modules/core-js/modules/es6.function.bind.js":[function(require,module,exports) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_bind":"../../../../node_modules/core-js/modules/_bind.js"}],"../../../../node_modules/core-js/modules/es6.function.name.js":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js"}],"../../../../node_modules/core-js/modules/es6.function.has-instance.js":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js"}],"../../../../node_modules/core-js/modules/_string-ws.js":[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],"../../../../node_modules/core-js/modules/_string-trim.js":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/_parse-int.js":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/es6.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-int":"../../../../node_modules/core-js/modules/_parse-int.js"}],"../../../../node_modules/core-js/modules/_parse-float.js":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../../../node_modules/core-js/modules/_string-ws.js"}],"../../../../node_modules/core-js/modules/es6.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-float":"../../../../node_modules/core-js/modules/_parse-float.js"}],"../../../../node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/es6.number.constructor.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/_a-number-value.js":[function(require,module,exports) {
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_string-repeat.js":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/es6.number.to-fixed.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_a-number-value":"../../../../node_modules/core-js/modules/_a-number-value.js","./_string-repeat":"../../../../node_modules/core-js/modules/_string-repeat.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.number.to-precision.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_a-number-value":"../../../../node_modules/core-js/modules/_a-number-value.js"}],"../../../../node_modules/core-js/modules/es6.number.epsilon.js":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.is-finite.js":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/es6.number.is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-integer":"../../../../node_modules/core-js/modules/_is-integer.js"}],"../../../../node_modules/core-js/modules/es6.number.is-nan.js":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.is-safe-integer.js":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-integer":"../../../../node_modules/core-js/modules/_is-integer.js"}],"../../../../node_modules/core-js/modules/es6.number.max-safe-integer.js":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.min-safe-integer.js":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.number.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-float":"../../../../node_modules/core-js/modules/_parse-float.js"}],"../../../../node_modules/core-js/modules/es6.number.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_parse-int":"../../../../node_modules/core-js/modules/_parse-int.js"}],"../../../../node_modules/core-js/modules/_math-log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"../../../../node_modules/core-js/modules/es6.math.acosh.js":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../../../node_modules/core-js/modules/_math-log1p.js"}],"../../../../node_modules/core-js/modules/es6.math.asinh.js":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.atanh.js":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_math-sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"../../../../node_modules/core-js/modules/es6.math.cbrt.js":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.clz32.js":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.cosh.js":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_math-expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"../../../../node_modules/core-js/modules/es6.math.expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js"}],"../../../../node_modules/core-js/modules/_math-fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-fround":"../../../../node_modules/core-js/modules/_math-fround.js"}],"../../../../node_modules/core-js/modules/es6.math.hypot.js":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.imul.js":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.math.log10.js":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../../../node_modules/core-js/modules/_math-log1p.js"}],"../../../../node_modules/core-js/modules/es6.math.log2.js":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.math.sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-sign":"../../../../node_modules/core-js/modules/_math-sign.js"}],"../../../../node_modules/core-js/modules/es6.math.sinh.js":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.math.tanh.js":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../../../node_modules/core-js/modules/_math-expm1.js"}],"../../../../node_modules/core-js/modules/es6.math.trunc.js":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.string.from-code-point.js":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../../../node_modules/core-js/modules/es6.string.raw.js":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/es6.string.trim.js":[function(require,module,exports) {
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js"}],"../../../../node_modules/core-js/modules/_string-at.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_iterators.js":[function(require,module,exports) {
module.exports = {};

},{}],"../../../../node_modules/core-js/modules/_iter-create.js":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_iter-define.js":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_iter-create":"../../../../node_modules/core-js/modules/_iter-create.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":"../../../../node_modules/core-js/modules/_string-at.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js"}],"../../../../node_modules/core-js/modules/es6.string.code-point-at.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-at":"../../../../node_modules/core-js/modules/_string-at.js"}],"../../../../node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_string-context.js":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.string.ends-with.js":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/es6.string.repeat.js":[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-repeat":"../../../../node_modules/core-js/modules/_string-repeat.js"}],"../../../../node_modules/core-js/modules/es6.string.starts-with.js":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../../../node_modules/core-js/modules/_string-html.js":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/es6.string.anchor.js":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.big.js":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.blink.js":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.bold.js":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.fixed.js":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.fontcolor.js":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.fontsize.js":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.italics.js":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.link.js":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.small.js":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.strike.js":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.sub.js":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.string.sup.js":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":"../../../../node_modules/core-js/modules/_string-html.js"}],"../../../../node_modules/core-js/modules/es6.date.now.js":[function(require,module,exports) {
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.date.to-json.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_date-to-iso-string.js":[function(require,module,exports) {
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.date.to-iso-string.js":[function(require,module,exports) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_date-to-iso-string":"../../../../node_modules/core-js/modules/_date-to-iso-string.js"}],"../../../../node_modules/core-js/modules/es6.date.to-string.js":[function(require,module,exports) {
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/_date-to-primitive.js":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js"}],"../../../../node_modules/core-js/modules/es6.date.to-primitive.js":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_date-to-primitive":"../../../../node_modules/core-js/modules/_date-to-primitive.js"}],"../../../../node_modules/core-js/modules/es6.array.is-array.js":[function(require,module,exports) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-array":"../../../../node_modules/core-js/modules/_is-array.js"}],"../../../../node_modules/core-js/modules/_iter-call.js":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_create-property.js":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js"}],"../../../../node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_iter-call":"../../../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js"}],"../../../../node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_strict-method.js":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.array.join.js":[function(require,module,exports) {
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.slice.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_html":"../../../../node_modules/core-js/modules/_html.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.array.sort.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"../../../../node_modules/core-js/modules/_array-species-constructor.js"}],"../../../../node_modules/core-js/modules/_array-methods.js":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_array-species-create":"../../../../node_modules/core-js/modules/_array-species-create.js"}],"../../../../node_modules/core-js/modules/es6.array.for-each.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.map.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.filter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.some.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.every.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/_array-reduce.js":[function(require,module,exports) {
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_iobject":"../../../../node_modules/core-js/modules/_iobject.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/es6.array.reduce.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-reduce":"../../../../node_modules/core-js/modules/_array-reduce.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.reduce-right.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-reduce":"../../../../node_modules/core-js/modules/_array-reduce.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/es6.array.last-index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_strict-method":"../../../../node_modules/core-js/modules/_strict-method.js"}],"../../../../node_modules/core-js/modules/_array-copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js"}],"../../../../node_modules/core-js/modules/es6.array.copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-copy-within":"../../../../node_modules/core-js/modules/_array-copy-within.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_array-fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/es6.array.fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_set-species.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.array.species.js":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/_iter-step.js":[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],"../../../../node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js","./_iter-step":"../../../../node_modules/core-js/modules/_iter-step.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js"}],"../../../../node_modules/core-js/modules/_flags.js":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.regexp.constructor.js":[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/_regexp-exec.js":[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":"../../../../node_modules/core-js/modules/_flags.js"}],"../../../../node_modules/core-js/modules/es6.regexp.exec.js":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js","./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.regexp.flags.js":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js"}],"../../../../node_modules/core-js/modules/es6.regexp.to-string.js":[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":"../../../../node_modules/core-js/modules/es6.regexp.flags.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/_advance-string-index.js":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"../../../../node_modules/core-js/modules/_string-at.js"}],"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js":[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js"}],"../../../../node_modules/core-js/modules/_fix-re-wks.js":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":"../../../../node_modules/core-js/modules/es6.regexp.exec.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js"}],"../../../../node_modules/core-js/modules/es6.regexp.match.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.replace.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.search.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_same-value":"../../../../node_modules/core-js/modules/_same-value.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/_species-constructor.js":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es6.regexp.split.js":[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_advance-string-index":"../../../../node_modules/core-js/modules/_advance-string-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_regexp-exec-abstract":"../../../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_regexp-exec":"../../../../node_modules/core-js/modules/_regexp-exec.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_fix-re-wks":"../../../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../../../node_modules/core-js/modules/_an-instance.js":[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],"../../../../node_modules/core-js/modules/_for-of.js":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_iter-call":"../../../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js"}],"../../../../node_modules/core-js/modules/_task.js":[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_invoke":"../../../../node_modules/core-js/modules/_invoke.js","./_html":"../../../../node_modules/core-js/modules/_html.js","./_dom-create":"../../../../node_modules/core-js/modules/_dom-create.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_microtask.js":[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_task":"../../../../node_modules/core-js/modules/_task.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/_new-promise-capability.js":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":"../../../../node_modules/core-js/modules/_a-function.js"}],"../../../../node_modules/core-js/modules/_perform.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],"../../../../node_modules/core-js/modules/_user-agent.js":[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/_promise-resolve.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_new-promise-capability":"../../../../node_modules/core-js/modules/_new-promise-capability.js"}],"../../../../node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":"../../../../node_modules/core-js/modules/_redefine.js"}],"../../../../node_modules/core-js/modules/es6.promise.js":[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_task":"../../../../node_modules/core-js/modules/_task.js","./_microtask":"../../../../node_modules/core-js/modules/_microtask.js","./_new-promise-capability":"../../../../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../../../../node_modules/core-js/modules/_perform.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js","./_promise-resolve":"../../../../node_modules/core-js/modules/_promise-resolve.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js"}],"../../../../node_modules/core-js/modules/_validate-collection.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_iter-define":"../../../../node_modules/core-js/modules/_iter-define.js","./_iter-step":"../../../../node_modules/core-js/modules/_iter-step.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js"}],"../../../../node_modules/core-js/modules/_collection.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js","./_inherit-if-required":"../../../../node_modules/core-js/modules/_inherit-if-required.js"}],"../../../../node_modules/core-js/modules/es6.map.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":"../../../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/es6.set.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":"../../../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/_collection-weak.js":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js"}],"../../../../node_modules/core-js/modules/es6.weak-map.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_meta":"../../../../node_modules/core-js/modules/_meta.js","./_object-assign":"../../../../node_modules/core-js/modules/_object-assign.js","./_collection-weak":"../../../../node_modules/core-js/modules/_collection-weak.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/es6.weak-set.js":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":"../../../../node_modules/core-js/modules/_collection-weak.js","./_validate-collection":"../../../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../../../node_modules/core-js/modules/_collection.js"}],"../../../../node_modules/core-js/modules/_typed.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js"}],"../../../../node_modules/core-js/modules/_to-index.js":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js"}],"../../../../node_modules/core-js/modules/_typed-buffer.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../../../node_modules/core-js/modules/_to-index.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_set-to-string-tag":"../../../../node_modules/core-js/modules/_set-to-string-tag.js"}],"../../../../node_modules/core-js/modules/es6.typed.array-buffer.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../../../node_modules/core-js/modules/_typed-buffer.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/es6.typed.data-view.js":[function(require,module,exports) {
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../../../node_modules/core-js/modules/_typed-buffer.js"}],"../../../../node_modules/core-js/modules/_typed-array.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_library":"../../../../node_modules/core-js/modules/_library.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_typed":"../../../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../../../node_modules/core-js/modules/_typed-buffer.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../../../node_modules/core-js/modules/_to-index.js","./_to-absolute-index":"../../../../node_modules/core-js/modules/_to-absolute-index.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_is-array-iter":"../../../../node_modules/core-js/modules/_is-array-iter.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./core.get-iterator-method":"../../../../node_modules/core-js/modules/core.get-iterator-method.js","./_uid":"../../../../node_modules/core-js/modules/_uid.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_array-methods":"../../../../node_modules/core-js/modules/_array-methods.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_iter-detect":"../../../../node_modules/core-js/modules/_iter-detect.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js","./_array-fill":"../../../../node_modules/core-js/modules/_array-fill.js","./_array-copy-within":"../../../../node_modules/core-js/modules/_array-copy-within.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js"}],"../../../../node_modules/core-js/modules/es6.typed.int8-array.js":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint8-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.int16-array.js":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint16-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.int32-array.js":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.uint32-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.float32-array.js":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.typed.float64-array.js":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../../../node_modules/core-js/modules/_typed-array.js"}],"../../../../node_modules/core-js/modules/es6.reflect.apply.js":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.reflect.construct.js":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-create":"../../../../node_modules/core-js/modules/_object-create.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_bind":"../../../../node_modules/core-js/modules/_bind.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es6.reflect.define-property.js":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js"}],"../../../../node_modules/core-js/modules/es6.reflect.delete-property.js":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.enumerate.js":[function(require,module,exports) {
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_iter-create":"../../../../node_modules/core-js/modules/_iter-create.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get.js":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.has.js":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es6.reflect.is-extensible.js":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/_own-keys.js":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"../../../../node_modules/core-js/modules/_object-gopn.js","./_object-gops":"../../../../node_modules/core-js/modules/_object-gops.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es6.reflect.own-keys.js":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_own-keys":"../../../../node_modules/core-js/modules/_own-keys.js"}],"../../../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.set.js":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../../../node_modules/core-js/modules/_has.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_property-desc":"../../../../node_modules/core-js/modules/_property-desc.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js"}],"../../../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_set-proto":"../../../../node_modules/core-js/modules/_set-proto.js"}],"../../../../node_modules/core-js/modules/es7.array.includes.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_array-includes":"../../../../node_modules/core-js/modules/_array-includes.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/_flatten-into-array.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":"../../../../node_modules/core-js/modules/_is-array.js","./_is-object":"../../../../node_modules/core-js/modules/_is-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/modules/es7.array.flat-map.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../../../../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_array-species-create":"../../../../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/es7.array.flatten.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../../../../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_to-integer":"../../../../node_modules/core-js/modules/_to-integer.js","./_array-species-create":"../../../../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../../../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../../../node_modules/core-js/modules/es7.string.at.js":[function(require,module,exports) {
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-at":"../../../../node_modules/core-js/modules/_string-at.js"}],"../../../../node_modules/core-js/modules/_string-pad.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_string-repeat":"../../../../node_modules/core-js/modules/_string-repeat.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js"}],"../../../../node_modules/core-js/modules/es7.string.pad-start.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-pad":"../../../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/es7.string.pad-end.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_string-pad":"../../../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/es7.string.trim-left.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js"}],"../../../../node_modules/core-js/modules/es7.string.trim-right.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":"../../../../node_modules/core-js/modules/_string-trim.js"}],"../../../../node_modules/core-js/modules/es7.string.match-all.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_defined":"../../../../node_modules/core-js/modules/_defined.js","./_to-length":"../../../../node_modules/core-js/modules/_to-length.js","./_is-regexp":"../../../../node_modules/core-js/modules/_is-regexp.js","./_flags":"../../../../node_modules/core-js/modules/_flags.js","./_iter-create":"../../../../node_modules/core-js/modules/_iter-create.js"}],"../../../../node_modules/core-js/modules/es7.symbol.async-iterator.js":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"../../../../node_modules/core-js/modules/_wks-define.js"}],"../../../../node_modules/core-js/modules/es7.symbol.observable.js":[function(require,module,exports) {
require('./_wks-define')('observable');

},{"./_wks-define":"../../../../node_modules/core-js/modules/_wks-define.js"}],"../../../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_own-keys":"../../../../node_modules/core-js/modules/_own-keys.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_create-property":"../../../../node_modules/core-js/modules/_create-property.js"}],"../../../../node_modules/core-js/modules/_object-to-array.js":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_to-iobject":"../../../../node_modules/core-js/modules/_to-iobject.js","./_object-pie":"../../../../node_modules/core-js/modules/_object-pie.js"}],"../../../../node_modules/core-js/modules/es7.object.values.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../../../node_modules/core-js/modules/_object-to-array.js"}],"../../../../node_modules/core-js/modules/es7.object.entries.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../../../node_modules/core-js/modules/_object-to-array.js"}],"../../../../node_modules/core-js/modules/_object-forced-pam.js":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_library":"../../../../node_modules/core-js/modules/_library.js","./_fails":"../../../../node_modules/core-js/modules/_fails.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es7.object.define-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es7.object.define-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es7.object.lookup-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/es7.object.lookup-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_to-object":"../../../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../../../node_modules/core-js/modules/_array-from-iterable.js":[function(require,module,exports) {
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":"../../../../node_modules/core-js/modules/_for-of.js"}],"../../../../node_modules/core-js/modules/_collection-to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_classof":"../../../../node_modules/core-js/modules/_classof.js","./_array-from-iterable":"../../../../node_modules/core-js/modules/_array-from-iterable.js"}],"../../../../node_modules/core-js/modules/es7.map.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_collection-to-json":"../../../../node_modules/core-js/modules/_collection-to-json.js"}],"../../../../node_modules/core-js/modules/es7.set.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_collection-to-json":"../../../../node_modules/core-js/modules/_collection-to-json.js"}],"../../../../node_modules/core-js/modules/_set-collection-of.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":"../../../../node_modules/core-js/modules/_set-collection-of.js"}],"../../../../node_modules/core-js/modules/es7.set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":"../../../../node_modules/core-js/modules/_set-collection-of.js"}],"../../../../node_modules/core-js/modules/es7.weak-map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":"../../../../node_modules/core-js/modules/_set-collection-of.js"}],"../../../../node_modules/core-js/modules/es7.weak-set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":"../../../../node_modules/core-js/modules/_set-collection-of.js"}],"../../../../node_modules/core-js/modules/_set-collection-from.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_ctx":"../../../../node_modules/core-js/modules/_ctx.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js"}],"../../../../node_modules/core-js/modules/es7.map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":"../../../../node_modules/core-js/modules/_set-collection-from.js"}],"../../../../node_modules/core-js/modules/es7.set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":"../../../../node_modules/core-js/modules/_set-collection-from.js"}],"../../../../node_modules/core-js/modules/es7.weak-map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":"../../../../node_modules/core-js/modules/_set-collection-from.js"}],"../../../../node_modules/core-js/modules/es7.weak-set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":"../../../../node_modules/core-js/modules/_set-collection-from.js"}],"../../../../node_modules/core-js/modules/es7.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es7.system.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_global":"../../../../node_modules/core-js/modules/_global.js"}],"../../../../node_modules/core-js/modules/es7.error.is-error.js":[function(require,module,exports) {
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/es7.math.clamp.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.deg-per-rad.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.degrees.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/_math-scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],"../../../../node_modules/core-js/modules/es7.math.fscale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-scale":"../../../../node_modules/core-js/modules/_math-scale.js","./_math-fround":"../../../../node_modules/core-js/modules/_math-fround.js"}],"../../../../node_modules/core-js/modules/es7.math.iaddh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.isubh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.imulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.rad-per-deg.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.radians.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_math-scale":"../../../../node_modules/core-js/modules/_math-scale.js"}],"../../../../node_modules/core-js/modules/es7.math.umulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.math.signbit.js":[function(require,module,exports) {
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js"}],"../../../../node_modules/core-js/modules/es7.promise.finally.js":[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../../../node_modules/core-js/modules/_species-constructor.js","./_promise-resolve":"../../../../node_modules/core-js/modules/_promise-resolve.js"}],"../../../../node_modules/core-js/modules/es7.promise.try.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_new-promise-capability":"../../../../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../../../../node_modules/core-js/modules/_perform.js"}],"../../../../node_modules/core-js/modules/_metadata.js":[function(require,module,exports) {
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./es6.map":"../../../../node_modules/core-js/modules/es6.map.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_shared":"../../../../node_modules/core-js/modules/_shared.js","./es6.weak-map":"../../../../node_modules/core-js/modules/es6.weak-map.js"}],"../../../../node_modules/core-js/modules/es7.reflect.define-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es7.reflect.delete-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es7.reflect.get-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js"}],"../../../../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":[function(require,module,exports) {
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./es6.set":"../../../../node_modules/core-js/modules/es6.set.js","./_array-from-iterable":"../../../../node_modules/core-js/modules/_array-from-iterable.js","./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js"}],"../../../../node_modules/core-js/modules/es7.reflect.get-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es7.reflect.has-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../../../../node_modules/core-js/modules/_object-gpo.js"}],"../../../../node_modules/core-js/modules/es7.reflect.has-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js"}],"../../../../node_modules/core-js/modules/es7.reflect.metadata.js":[function(require,module,exports) {
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_metadata":"../../../../node_modules/core-js/modules/_metadata.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js"}],"../../../../node_modules/core-js/modules/es7.asap.js":[function(require,module,exports) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_microtask":"../../../../node_modules/core-js/modules/_microtask.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_cof":"../../../../node_modules/core-js/modules/_cof.js"}],"../../../../node_modules/core-js/modules/es7.observable.js":[function(require,module,exports) {

'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_core":"../../../../node_modules/core-js/modules/_core.js","./_microtask":"../../../../node_modules/core-js/modules/_microtask.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js","./_a-function":"../../../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../../../node_modules/core-js/modules/_an-object.js","./_an-instance":"../../../../node_modules/core-js/modules/_an-instance.js","./_redefine-all":"../../../../node_modules/core-js/modules/_redefine-all.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_for-of":"../../../../node_modules/core-js/modules/_for-of.js","./_set-species":"../../../../node_modules/core-js/modules/_set-species.js"}],"../../../../node_modules/core-js/modules/web.timers.js":[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":"../../../../node_modules/core-js/modules/_global.js","./_export":"../../../../node_modules/core-js/modules/_export.js","./_user-agent":"../../../../node_modules/core-js/modules/_user-agent.js"}],"../../../../node_modules/core-js/modules/web.immediate.js":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_task":"../../../../node_modules/core-js/modules/_task.js"}],"../../../../node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","./_object-keys":"../../../../node_modules/core-js/modules/_object-keys.js","./_redefine":"../../../../node_modules/core-js/modules/_redefine.js","./_global":"../../../../node_modules/core-js/modules/_global.js","./_hide":"../../../../node_modules/core-js/modules/_hide.js","./_iterators":"../../../../node_modules/core-js/modules/_iterators.js","./_wks":"../../../../node_modules/core-js/modules/_wks.js"}],"../../../../node_modules/core-js/shim.js":[function(require,module,exports) {
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.exec');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/es6.symbol":"../../../../node_modules/core-js/modules/es6.symbol.js","./modules/es6.object.create":"../../../../node_modules/core-js/modules/es6.object.create.js","./modules/es6.object.define-property":"../../../../node_modules/core-js/modules/es6.object.define-property.js","./modules/es6.object.define-properties":"../../../../node_modules/core-js/modules/es6.object.define-properties.js","./modules/es6.object.get-own-property-descriptor":"../../../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","./modules/es6.object.get-prototype-of":"../../../../node_modules/core-js/modules/es6.object.get-prototype-of.js","./modules/es6.object.keys":"../../../../node_modules/core-js/modules/es6.object.keys.js","./modules/es6.object.get-own-property-names":"../../../../node_modules/core-js/modules/es6.object.get-own-property-names.js","./modules/es6.object.freeze":"../../../../node_modules/core-js/modules/es6.object.freeze.js","./modules/es6.object.seal":"../../../../node_modules/core-js/modules/es6.object.seal.js","./modules/es6.object.prevent-extensions":"../../../../node_modules/core-js/modules/es6.object.prevent-extensions.js","./modules/es6.object.is-frozen":"../../../../node_modules/core-js/modules/es6.object.is-frozen.js","./modules/es6.object.is-sealed":"../../../../node_modules/core-js/modules/es6.object.is-sealed.js","./modules/es6.object.is-extensible":"../../../../node_modules/core-js/modules/es6.object.is-extensible.js","./modules/es6.object.assign":"../../../../node_modules/core-js/modules/es6.object.assign.js","./modules/es6.object.is":"../../../../node_modules/core-js/modules/es6.object.is.js","./modules/es6.object.set-prototype-of":"../../../../node_modules/core-js/modules/es6.object.set-prototype-of.js","./modules/es6.object.to-string":"../../../../node_modules/core-js/modules/es6.object.to-string.js","./modules/es6.function.bind":"../../../../node_modules/core-js/modules/es6.function.bind.js","./modules/es6.function.name":"../../../../node_modules/core-js/modules/es6.function.name.js","./modules/es6.function.has-instance":"../../../../node_modules/core-js/modules/es6.function.has-instance.js","./modules/es6.parse-int":"../../../../node_modules/core-js/modules/es6.parse-int.js","./modules/es6.parse-float":"../../../../node_modules/core-js/modules/es6.parse-float.js","./modules/es6.number.constructor":"../../../../node_modules/core-js/modules/es6.number.constructor.js","./modules/es6.number.to-fixed":"../../../../node_modules/core-js/modules/es6.number.to-fixed.js","./modules/es6.number.to-precision":"../../../../node_modules/core-js/modules/es6.number.to-precision.js","./modules/es6.number.epsilon":"../../../../node_modules/core-js/modules/es6.number.epsilon.js","./modules/es6.number.is-finite":"../../../../node_modules/core-js/modules/es6.number.is-finite.js","./modules/es6.number.is-integer":"../../../../node_modules/core-js/modules/es6.number.is-integer.js","./modules/es6.number.is-nan":"../../../../node_modules/core-js/modules/es6.number.is-nan.js","./modules/es6.number.is-safe-integer":"../../../../node_modules/core-js/modules/es6.number.is-safe-integer.js","./modules/es6.number.max-safe-integer":"../../../../node_modules/core-js/modules/es6.number.max-safe-integer.js","./modules/es6.number.min-safe-integer":"../../../../node_modules/core-js/modules/es6.number.min-safe-integer.js","./modules/es6.number.parse-float":"../../../../node_modules/core-js/modules/es6.number.parse-float.js","./modules/es6.number.parse-int":"../../../../node_modules/core-js/modules/es6.number.parse-int.js","./modules/es6.math.acosh":"../../../../node_modules/core-js/modules/es6.math.acosh.js","./modules/es6.math.asinh":"../../../../node_modules/core-js/modules/es6.math.asinh.js","./modules/es6.math.atanh":"../../../../node_modules/core-js/modules/es6.math.atanh.js","./modules/es6.math.cbrt":"../../../../node_modules/core-js/modules/es6.math.cbrt.js","./modules/es6.math.clz32":"../../../../node_modules/core-js/modules/es6.math.clz32.js","./modules/es6.math.cosh":"../../../../node_modules/core-js/modules/es6.math.cosh.js","./modules/es6.math.expm1":"../../../../node_modules/core-js/modules/es6.math.expm1.js","./modules/es6.math.fround":"../../../../node_modules/core-js/modules/es6.math.fround.js","./modules/es6.math.hypot":"../../../../node_modules/core-js/modules/es6.math.hypot.js","./modules/es6.math.imul":"../../../../node_modules/core-js/modules/es6.math.imul.js","./modules/es6.math.log10":"../../../../node_modules/core-js/modules/es6.math.log10.js","./modules/es6.math.log1p":"../../../../node_modules/core-js/modules/es6.math.log1p.js","./modules/es6.math.log2":"../../../../node_modules/core-js/modules/es6.math.log2.js","./modules/es6.math.sign":"../../../../node_modules/core-js/modules/es6.math.sign.js","./modules/es6.math.sinh":"../../../../node_modules/core-js/modules/es6.math.sinh.js","./modules/es6.math.tanh":"../../../../node_modules/core-js/modules/es6.math.tanh.js","./modules/es6.math.trunc":"../../../../node_modules/core-js/modules/es6.math.trunc.js","./modules/es6.string.from-code-point":"../../../../node_modules/core-js/modules/es6.string.from-code-point.js","./modules/es6.string.raw":"../../../../node_modules/core-js/modules/es6.string.raw.js","./modules/es6.string.trim":"../../../../node_modules/core-js/modules/es6.string.trim.js","./modules/es6.string.iterator":"../../../../node_modules/core-js/modules/es6.string.iterator.js","./modules/es6.string.code-point-at":"../../../../node_modules/core-js/modules/es6.string.code-point-at.js","./modules/es6.string.ends-with":"../../../../node_modules/core-js/modules/es6.string.ends-with.js","./modules/es6.string.includes":"../../../../node_modules/core-js/modules/es6.string.includes.js","./modules/es6.string.repeat":"../../../../node_modules/core-js/modules/es6.string.repeat.js","./modules/es6.string.starts-with":"../../../../node_modules/core-js/modules/es6.string.starts-with.js","./modules/es6.string.anchor":"../../../../node_modules/core-js/modules/es6.string.anchor.js","./modules/es6.string.big":"../../../../node_modules/core-js/modules/es6.string.big.js","./modules/es6.string.blink":"../../../../node_modules/core-js/modules/es6.string.blink.js","./modules/es6.string.bold":"../../../../node_modules/core-js/modules/es6.string.bold.js","./modules/es6.string.fixed":"../../../../node_modules/core-js/modules/es6.string.fixed.js","./modules/es6.string.fontcolor":"../../../../node_modules/core-js/modules/es6.string.fontcolor.js","./modules/es6.string.fontsize":"../../../../node_modules/core-js/modules/es6.string.fontsize.js","./modules/es6.string.italics":"../../../../node_modules/core-js/modules/es6.string.italics.js","./modules/es6.string.link":"../../../../node_modules/core-js/modules/es6.string.link.js","./modules/es6.string.small":"../../../../node_modules/core-js/modules/es6.string.small.js","./modules/es6.string.strike":"../../../../node_modules/core-js/modules/es6.string.strike.js","./modules/es6.string.sub":"../../../../node_modules/core-js/modules/es6.string.sub.js","./modules/es6.string.sup":"../../../../node_modules/core-js/modules/es6.string.sup.js","./modules/es6.date.now":"../../../../node_modules/core-js/modules/es6.date.now.js","./modules/es6.date.to-json":"../../../../node_modules/core-js/modules/es6.date.to-json.js","./modules/es6.date.to-iso-string":"../../../../node_modules/core-js/modules/es6.date.to-iso-string.js","./modules/es6.date.to-string":"../../../../node_modules/core-js/modules/es6.date.to-string.js","./modules/es6.date.to-primitive":"../../../../node_modules/core-js/modules/es6.date.to-primitive.js","./modules/es6.array.is-array":"../../../../node_modules/core-js/modules/es6.array.is-array.js","./modules/es6.array.from":"../../../../node_modules/core-js/modules/es6.array.from.js","./modules/es6.array.of":"../../../../node_modules/core-js/modules/es6.array.of.js","./modules/es6.array.join":"../../../../node_modules/core-js/modules/es6.array.join.js","./modules/es6.array.slice":"../../../../node_modules/core-js/modules/es6.array.slice.js","./modules/es6.array.sort":"../../../../node_modules/core-js/modules/es6.array.sort.js","./modules/es6.array.for-each":"../../../../node_modules/core-js/modules/es6.array.for-each.js","./modules/es6.array.map":"../../../../node_modules/core-js/modules/es6.array.map.js","./modules/es6.array.filter":"../../../../node_modules/core-js/modules/es6.array.filter.js","./modules/es6.array.some":"../../../../node_modules/core-js/modules/es6.array.some.js","./modules/es6.array.every":"../../../../node_modules/core-js/modules/es6.array.every.js","./modules/es6.array.reduce":"../../../../node_modules/core-js/modules/es6.array.reduce.js","./modules/es6.array.reduce-right":"../../../../node_modules/core-js/modules/es6.array.reduce-right.js","./modules/es6.array.index-of":"../../../../node_modules/core-js/modules/es6.array.index-of.js","./modules/es6.array.last-index-of":"../../../../node_modules/core-js/modules/es6.array.last-index-of.js","./modules/es6.array.copy-within":"../../../../node_modules/core-js/modules/es6.array.copy-within.js","./modules/es6.array.fill":"../../../../node_modules/core-js/modules/es6.array.fill.js","./modules/es6.array.find":"../../../../node_modules/core-js/modules/es6.array.find.js","./modules/es6.array.find-index":"../../../../node_modules/core-js/modules/es6.array.find-index.js","./modules/es6.array.species":"../../../../node_modules/core-js/modules/es6.array.species.js","./modules/es6.array.iterator":"../../../../node_modules/core-js/modules/es6.array.iterator.js","./modules/es6.regexp.constructor":"../../../../node_modules/core-js/modules/es6.regexp.constructor.js","./modules/es6.regexp.exec":"../../../../node_modules/core-js/modules/es6.regexp.exec.js","./modules/es6.regexp.to-string":"../../../../node_modules/core-js/modules/es6.regexp.to-string.js","./modules/es6.regexp.flags":"../../../../node_modules/core-js/modules/es6.regexp.flags.js","./modules/es6.regexp.match":"../../../../node_modules/core-js/modules/es6.regexp.match.js","./modules/es6.regexp.replace":"../../../../node_modules/core-js/modules/es6.regexp.replace.js","./modules/es6.regexp.search":"../../../../node_modules/core-js/modules/es6.regexp.search.js","./modules/es6.regexp.split":"../../../../node_modules/core-js/modules/es6.regexp.split.js","./modules/es6.promise":"../../../../node_modules/core-js/modules/es6.promise.js","./modules/es6.map":"../../../../node_modules/core-js/modules/es6.map.js","./modules/es6.set":"../../../../node_modules/core-js/modules/es6.set.js","./modules/es6.weak-map":"../../../../node_modules/core-js/modules/es6.weak-map.js","./modules/es6.weak-set":"../../../../node_modules/core-js/modules/es6.weak-set.js","./modules/es6.typed.array-buffer":"../../../../node_modules/core-js/modules/es6.typed.array-buffer.js","./modules/es6.typed.data-view":"../../../../node_modules/core-js/modules/es6.typed.data-view.js","./modules/es6.typed.int8-array":"../../../../node_modules/core-js/modules/es6.typed.int8-array.js","./modules/es6.typed.uint8-array":"../../../../node_modules/core-js/modules/es6.typed.uint8-array.js","./modules/es6.typed.uint8-clamped-array":"../../../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","./modules/es6.typed.int16-array":"../../../../node_modules/core-js/modules/es6.typed.int16-array.js","./modules/es6.typed.uint16-array":"../../../../node_modules/core-js/modules/es6.typed.uint16-array.js","./modules/es6.typed.int32-array":"../../../../node_modules/core-js/modules/es6.typed.int32-array.js","./modules/es6.typed.uint32-array":"../../../../node_modules/core-js/modules/es6.typed.uint32-array.js","./modules/es6.typed.float32-array":"../../../../node_modules/core-js/modules/es6.typed.float32-array.js","./modules/es6.typed.float64-array":"../../../../node_modules/core-js/modules/es6.typed.float64-array.js","./modules/es6.reflect.apply":"../../../../node_modules/core-js/modules/es6.reflect.apply.js","./modules/es6.reflect.construct":"../../../../node_modules/core-js/modules/es6.reflect.construct.js","./modules/es6.reflect.define-property":"../../../../node_modules/core-js/modules/es6.reflect.define-property.js","./modules/es6.reflect.delete-property":"../../../../node_modules/core-js/modules/es6.reflect.delete-property.js","./modules/es6.reflect.enumerate":"../../../../node_modules/core-js/modules/es6.reflect.enumerate.js","./modules/es6.reflect.get":"../../../../node_modules/core-js/modules/es6.reflect.get.js","./modules/es6.reflect.get-own-property-descriptor":"../../../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","./modules/es6.reflect.get-prototype-of":"../../../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js","./modules/es6.reflect.has":"../../../../node_modules/core-js/modules/es6.reflect.has.js","./modules/es6.reflect.is-extensible":"../../../../node_modules/core-js/modules/es6.reflect.is-extensible.js","./modules/es6.reflect.own-keys":"../../../../node_modules/core-js/modules/es6.reflect.own-keys.js","./modules/es6.reflect.prevent-extensions":"../../../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js","./modules/es6.reflect.set":"../../../../node_modules/core-js/modules/es6.reflect.set.js","./modules/es6.reflect.set-prototype-of":"../../../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js","./modules/es7.array.includes":"../../../../node_modules/core-js/modules/es7.array.includes.js","./modules/es7.array.flat-map":"../../../../node_modules/core-js/modules/es7.array.flat-map.js","./modules/es7.array.flatten":"../../../../node_modules/core-js/modules/es7.array.flatten.js","./modules/es7.string.at":"../../../../node_modules/core-js/modules/es7.string.at.js","./modules/es7.string.pad-start":"../../../../node_modules/core-js/modules/es7.string.pad-start.js","./modules/es7.string.pad-end":"../../../../node_modules/core-js/modules/es7.string.pad-end.js","./modules/es7.string.trim-left":"../../../../node_modules/core-js/modules/es7.string.trim-left.js","./modules/es7.string.trim-right":"../../../../node_modules/core-js/modules/es7.string.trim-right.js","./modules/es7.string.match-all":"../../../../node_modules/core-js/modules/es7.string.match-all.js","./modules/es7.symbol.async-iterator":"../../../../node_modules/core-js/modules/es7.symbol.async-iterator.js","./modules/es7.symbol.observable":"../../../../node_modules/core-js/modules/es7.symbol.observable.js","./modules/es7.object.get-own-property-descriptors":"../../../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","./modules/es7.object.values":"../../../../node_modules/core-js/modules/es7.object.values.js","./modules/es7.object.entries":"../../../../node_modules/core-js/modules/es7.object.entries.js","./modules/es7.object.define-getter":"../../../../node_modules/core-js/modules/es7.object.define-getter.js","./modules/es7.object.define-setter":"../../../../node_modules/core-js/modules/es7.object.define-setter.js","./modules/es7.object.lookup-getter":"../../../../node_modules/core-js/modules/es7.object.lookup-getter.js","./modules/es7.object.lookup-setter":"../../../../node_modules/core-js/modules/es7.object.lookup-setter.js","./modules/es7.map.to-json":"../../../../node_modules/core-js/modules/es7.map.to-json.js","./modules/es7.set.to-json":"../../../../node_modules/core-js/modules/es7.set.to-json.js","./modules/es7.map.of":"../../../../node_modules/core-js/modules/es7.map.of.js","./modules/es7.set.of":"../../../../node_modules/core-js/modules/es7.set.of.js","./modules/es7.weak-map.of":"../../../../node_modules/core-js/modules/es7.weak-map.of.js","./modules/es7.weak-set.of":"../../../../node_modules/core-js/modules/es7.weak-set.of.js","./modules/es7.map.from":"../../../../node_modules/core-js/modules/es7.map.from.js","./modules/es7.set.from":"../../../../node_modules/core-js/modules/es7.set.from.js","./modules/es7.weak-map.from":"../../../../node_modules/core-js/modules/es7.weak-map.from.js","./modules/es7.weak-set.from":"../../../../node_modules/core-js/modules/es7.weak-set.from.js","./modules/es7.global":"../../../../node_modules/core-js/modules/es7.global.js","./modules/es7.system.global":"../../../../node_modules/core-js/modules/es7.system.global.js","./modules/es7.error.is-error":"../../../../node_modules/core-js/modules/es7.error.is-error.js","./modules/es7.math.clamp":"../../../../node_modules/core-js/modules/es7.math.clamp.js","./modules/es7.math.deg-per-rad":"../../../../node_modules/core-js/modules/es7.math.deg-per-rad.js","./modules/es7.math.degrees":"../../../../node_modules/core-js/modules/es7.math.degrees.js","./modules/es7.math.fscale":"../../../../node_modules/core-js/modules/es7.math.fscale.js","./modules/es7.math.iaddh":"../../../../node_modules/core-js/modules/es7.math.iaddh.js","./modules/es7.math.isubh":"../../../../node_modules/core-js/modules/es7.math.isubh.js","./modules/es7.math.imulh":"../../../../node_modules/core-js/modules/es7.math.imulh.js","./modules/es7.math.rad-per-deg":"../../../../node_modules/core-js/modules/es7.math.rad-per-deg.js","./modules/es7.math.radians":"../../../../node_modules/core-js/modules/es7.math.radians.js","./modules/es7.math.scale":"../../../../node_modules/core-js/modules/es7.math.scale.js","./modules/es7.math.umulh":"../../../../node_modules/core-js/modules/es7.math.umulh.js","./modules/es7.math.signbit":"../../../../node_modules/core-js/modules/es7.math.signbit.js","./modules/es7.promise.finally":"../../../../node_modules/core-js/modules/es7.promise.finally.js","./modules/es7.promise.try":"../../../../node_modules/core-js/modules/es7.promise.try.js","./modules/es7.reflect.define-metadata":"../../../../node_modules/core-js/modules/es7.reflect.define-metadata.js","./modules/es7.reflect.delete-metadata":"../../../../node_modules/core-js/modules/es7.reflect.delete-metadata.js","./modules/es7.reflect.get-metadata":"../../../../node_modules/core-js/modules/es7.reflect.get-metadata.js","./modules/es7.reflect.get-metadata-keys":"../../../../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js","./modules/es7.reflect.get-own-metadata":"../../../../node_modules/core-js/modules/es7.reflect.get-own-metadata.js","./modules/es7.reflect.get-own-metadata-keys":"../../../../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js","./modules/es7.reflect.has-metadata":"../../../../node_modules/core-js/modules/es7.reflect.has-metadata.js","./modules/es7.reflect.has-own-metadata":"../../../../node_modules/core-js/modules/es7.reflect.has-own-metadata.js","./modules/es7.reflect.metadata":"../../../../node_modules/core-js/modules/es7.reflect.metadata.js","./modules/es7.asap":"../../../../node_modules/core-js/modules/es7.asap.js","./modules/es7.observable":"../../../../node_modules/core-js/modules/es7.observable.js","./modules/web.timers":"../../../../node_modules/core-js/modules/web.timers.js","./modules/web.immediate":"../../../../node_modules/core-js/modules/web.immediate.js","./modules/web.dom.iterable":"../../../../node_modules/core-js/modules/web.dom.iterable.js","./modules/_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

},{}],"../../../../node_modules/core-js/modules/_replacer.js":[function(require,module,exports) {
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],"../../../../node_modules/core-js/modules/core.regexp.escape.js":[function(require,module,exports) {
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":"../../../../node_modules/core-js/modules/_export.js","./_replacer":"../../../../node_modules/core-js/modules/_replacer.js"}],"../../../../node_modules/core-js/fn/regexp/escape.js":[function(require,module,exports) {
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/core.regexp.escape":"../../../../node_modules/core-js/modules/core.regexp.escape.js","../../modules/_core":"../../../../node_modules/core-js/modules/_core.js"}],"../../../../node_modules/babel-polyfill/lib/index.js":[function(require,module,exports) {
var global = arguments[3];

"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
},{"core-js/shim":"../../../../node_modules/core-js/shim.js","regenerator-runtime/runtime":"../../../../node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js","core-js/fn/regexp/escape":"../../../../node_modules/core-js/fn/regexp/escape.js"}],"node_modules/ms/index.js":[function(require,module,exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"node_modules/debug/src/common.js":[function(require,module,exports) {
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function () {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function (v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;
},{"ms":"node_modules/ms/index.js"}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/debug/src/browser.js":[function(require,module,exports) {
var process = require("process");
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = undefined;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var {
  formatters: formatters
} = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};
},{"./common":"node_modules/debug/src/common.js","process":"node_modules/process/browser.js"}],"node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"node_modules/err-code/index.js":[function(require,module,exports) {
'use strict';

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;

},{}],"node_modules/multiformats/cjs/vendor/varint.js":[function(require,module,exports) {
'use strict';

var encode_1 = encode;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode,
  encodingLength: length
};
var _brrp_varint = varint;
var varint$1 = _brrp_varint;

module.exports = varint$1;

},{}],"node_modules/multiformats/cjs/src/varint.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var varint$1 = require('../vendor/varint.js');

const decode = data => {
  const code = varint$1.decode(data);
  return [
    code,
    varint$1.decode.bytes
  ];
};
const encodeTo = (int, target, offset = 0) => {
  varint$1.encode(int, target, offset);
  return target;
};
const encodingLength = int => {
  return varint$1.encodingLength(int);
};

exports.decode = decode;
exports.encodeTo = encodeTo;
exports.encodingLength = encodingLength;

},{"../vendor/varint.js":"node_modules/multiformats/cjs/vendor/varint.js"}],"node_modules/multiformats/cjs/src/bytes.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const empty = new Uint8Array(0);
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = hex => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;
};
const equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error('Unknown type, must be binary type');
};
const isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = str => new TextEncoder().encode(str);
const toString = b => new TextDecoder().decode(b);

exports.coerce = coerce;
exports.empty = empty;
exports.equals = equals;
exports.fromHex = fromHex;
exports.fromString = fromString;
exports.isBinary = isBinary;
exports.toHex = toHex;
exports.toString = toString;

},{}],"node_modules/multiformats/cjs/src/hashes/digest.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bytes = require('../bytes.js');
var varint = require('../varint.js');

const create = (code, digest) => {
  const size = digest.byteLength;
  const sizeOffset = varint.encodingLength(code);
  const digestOffset = sizeOffset + varint.encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  varint.encodeTo(code, bytes, 0);
  varint.encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
const decode = multihash => {
  const bytes$1 = bytes.coerce(multihash);
  const [code, sizeOffset] = varint.decode(bytes$1);
  const [size, digestOffset] = varint.decode(bytes$1.subarray(sizeOffset));
  const digest = bytes$1.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }
  return new Digest(code, size, digest, bytes$1);
};
const equals = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
  }
};
class Digest {
  constructor(code, size, digest, bytes) {
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
}

exports.Digest = Digest;
exports.create = create;
exports.decode = decode;
exports.equals = equals;

},{"../bytes.js":"node_modules/multiformats/cjs/src/bytes.js","../varint.js":"node_modules/multiformats/cjs/src/varint.js"}],"node_modules/multiformats/cjs/vendor/base-x.js":[function(require,module,exports) {
'use strict';

function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array);
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === ' ') {
      return;
    }
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    if (source[psz] === ' ') {
      return;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${ name } character`);
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;

module.exports = _brrp__multiformats_scope_baseX;

},{}],"node_modules/multiformats/cjs/src/bases/base.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var baseX$1 = require('../../vendor/base-x.js');
var bytes = require('../bytes.js');

class Encoder {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${ this.prefix }${ this.baseEncode(bytes) }`;
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}
class Decoder {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === 'string') {
      switch (text[0]) {
      case this.prefix: {
          return this.baseDecode(text.slice(1));
        }
      default: {
          throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);
        }
      }
    } else {
      throw Error('Can only multibase decode strings');
    }
  }
  or(decoder) {
    const decoders = {
      [this.prefix]: this,
      ...decoder.decoders || { [decoder.prefix]: decoder }
    };
    return new ComposedDecoder(decoders);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    const other = decoder.decoders || { [decoder.prefix]: decoder };
    return new ComposedDecoder({
      ...this.decoders,
      ...other
    });
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);
    }
  }
}
class Codec {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);
const baseX = ({prefix, name, alphabet}) => {
  const {encode, decode} = baseX$1(alphabet, name);
  return from({
    prefix,
    name,
    encode,
    decode: text => bytes.coerce(decode(text))
  });
};
const decode = (string, alphabet, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }
  let end = string.length;
  while (string[end - 1] === '=') {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError(`Non-${ name } character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }
  return out;
};
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '=';
  const mask = (1 << bitsPerChar) - 1;
  let out = '';
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }
  return out;
};
const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet, bitsPerChar, name);
    }
  });
};

exports.Codec = Codec;
exports.baseX = baseX;
exports.from = from;
exports.rfc4648 = rfc4648;

},{"../../vendor/base-x.js":"node_modules/multiformats/cjs/vendor/base-x.js","../bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/multiformats/cjs/src/bases/base58.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base58btc = base.baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = base.baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

exports.base58btc = base58btc;
exports.base58flickr = base58flickr;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/bases/base32.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base32 = base.rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
const base32upper = base.rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
const base32pad = base.rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
const base32padupper = base.rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
const base32hex = base.rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
const base32hexupper = base.rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
const base32hexpad = base.rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
const base32hexpadupper = base.rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
const base32z = base.rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

exports.base32 = base32;
exports.base32hex = base32hex;
exports.base32hexpad = base32hexpad;
exports.base32hexpadupper = base32hexpadupper;
exports.base32hexupper = base32hexupper;
exports.base32pad = base32pad;
exports.base32padupper = base32padupper;
exports.base32upper = base32upper;
exports.base32z = base32z;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/cid.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var varint = require('./varint.js');
var digest = require('./hashes/digest.js');
var base58 = require('./bases/base58.js');
var base32 = require('./bases/base32.js');
var bytes = require('./bytes.js');

class CID {
  constructor(version, code, multihash, bytes) {
    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
    case 0: {
        return this;
      }
    default: {
        const {code, multihash} = this;
        if (code !== DAG_PB_CODE) {
          throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
    case 0: {
        const {code, digest: digest$1} = this.multihash;
        const multihash = digest.create(code, digest$1);
        return CID.createV1(this.code, multihash);
      }
    case 1: {
        return this;
      }
    default: {
        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);
  }
  toString(base) {
    const {bytes, version, _baseCache} = this;
    switch (version) {
    case 0:
      return toStringV0(bytes, _baseCache, base || base58.base58btc.encoder);
    default:
      return toStringV1(bytes, _baseCache, base || base32.base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return 'CID';
  }
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return 'CID(' + this.toString() + ')';
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error('Deprecated, use .toString()');
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const {version, code, multihash, bytes} = value;
      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const {version, multihash, code} = value;
      const digest$1 = digest.decode(multihash);
      return CID.create(version, code, digest$1);
    } else {
      return null;
    }
  }
  static create(version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported');
    }
    switch (version) {
    case 0: {
        if (code !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);
        } else {
          return new CID(version, code, digest, digest.bytes);
        }
      }
    case 1: {
        const bytes = encodeCID(version, code, digest.bytes);
        return new CID(version, code, digest, bytes);
      }
    default: {
        throw new Error('Invalid version');
      }
    }
  }
  static createV0(digest) {
    return CID.create(0, DAG_PB_CODE, digest);
  }
  static createV1(code, digest) {
    return CID.create(1, code, digest);
  }
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error('Incorrect length');
    }
    return cid;
  }
  static decodeFirst(bytes$1) {
    const specs = CID.inspectBytes(bytes$1);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length');
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);
    return [
      cid,
      bytes$1.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length] = varint.decode(initialBytes.subarray(offset));
      offset += length;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else if (version === 1) {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${ version }`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base);
    const cid = CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base) => {
  switch (source[0]) {
  case 'Q': {
      const decoder = base || base58.base58btc;
      return [
        base58.base58btc.prefix,
        decoder.decode(`${ base58.base58btc.prefix }${ source }`)
      ];
    }
  case base58.base58btc.prefix: {
      const decoder = base || base58.base58btc;
      return [
        base58.base58btc.prefix,
        decoder.decode(source)
      ];
    }
  case base32.base32.prefix: {
      const decoder = base || base32.base32;
      return [
        base32.base32.prefix,
        decoder.decode(source)
      ];
    }
  default: {
      if (base == null) {
        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
      }
      return [
        source[0],
        base.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes, cache, base) => {
  const {prefix} = base;
  if (prefix !== base58.base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes).slice(1);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes, cache, base) => {
  const {prefix} = base;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash) => {
  const codeOffset = varint.encodingLength(version);
  const hashOffset = codeOffset + varint.encodingLength(code);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  varint.encodeTo(version, bytes, 0);
  varint.encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
const readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version = '0.0.0-dev';
const deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

exports.CID = CID;

},{"./varint.js":"node_modules/multiformats/cjs/src/varint.js","./hashes/digest.js":"node_modules/multiformats/cjs/src/hashes/digest.js","./bases/base58.js":"node_modules/multiformats/cjs/src/bases/base58.js","./bases/base32.js":"node_modules/multiformats/cjs/src/bases/base32.js","./bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/multiformats/cjs/src/bases/base36.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base36 = base.baseX({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = base.baseX({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});

exports.base36 = base36;
exports.base36upper = base36upper;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/bases/base64.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base64 = base.rfc4648({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
});
const base64pad = base.rfc4648({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
});
const base64url = base.rfc4648({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
});
const base64urlpad = base.rfc4648({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
});

exports.base64 = base64;
exports.base64pad = base64pad;
exports.base64url = base64url;
exports.base64urlpad = base64urlpad;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/bases/base16.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base16 = base.rfc4648({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
});
const base16upper = base.rfc4648({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
});

exports.base16 = base16;
exports.base16upper = base16upper;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/@protobufjs/aspromise/index.js":[function(require,module,exports) {
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],"node_modules/@protobufjs/base64/index.js":[function(require,module,exports) {
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],"node_modules/@protobufjs/eventemitter/index.js":[function(require,module,exports) {
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],"node_modules/@protobufjs/float/index.js":[function(require,module,exports) {
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],"node_modules/@protobufjs/inquire/index.js":[function(require,module,exports) {
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],"node_modules/@protobufjs/utf8/index.js":[function(require,module,exports) {
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],"node_modules/@protobufjs/pool/index.js":[function(require,module,exports) {
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],"node_modules/protobufjs/src/util/longbits.js":[function(require,module,exports) {
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/node-libs-browser/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/node-libs-browser/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/node-libs-browser/node_modules/isarray/index.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/protobufjs/src/util/minimal.js":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"@protobufjs/aspromise":"node_modules/@protobufjs/aspromise/index.js","@protobufjs/base64":"node_modules/@protobufjs/base64/index.js","@protobufjs/eventemitter":"node_modules/@protobufjs/eventemitter/index.js","@protobufjs/float":"node_modules/@protobufjs/float/index.js","@protobufjs/inquire":"node_modules/@protobufjs/inquire/index.js","@protobufjs/utf8":"node_modules/@protobufjs/utf8/index.js","@protobufjs/pool":"node_modules/@protobufjs/pool/index.js","./longbits":"node_modules/protobufjs/src/util/longbits.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/protobufjs/src/writer.js":[function(require,module,exports) {
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/protobufjs/src/writer_buffer.js":[function(require,module,exports) {
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./writer":"node_modules/protobufjs/src/writer.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/protobufjs/src/reader.js":[function(require,module,exports) {
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/protobufjs/src/reader_buffer.js":[function(require,module,exports) {
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":"node_modules/protobufjs/src/reader.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/protobufjs/src/rpc/service.js":[function(require,module,exports) {
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":"node_modules/protobufjs/src/util/minimal.js"}],"node_modules/protobufjs/src/rpc.js":[function(require,module,exports) {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":"node_modules/protobufjs/src/rpc/service.js"}],"node_modules/protobufjs/src/roots.js":[function(require,module,exports) {
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],"node_modules/protobufjs/src/index-minimal.js":[function(require,module,exports) {
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./writer":"node_modules/protobufjs/src/writer.js","./writer_buffer":"node_modules/protobufjs/src/writer_buffer.js","./reader":"node_modules/protobufjs/src/reader.js","./reader_buffer":"node_modules/protobufjs/src/reader_buffer.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js","./rpc":"node_modules/protobufjs/src/rpc.js","./roots":"node_modules/protobufjs/src/roots.js"}],"node_modules/protobufjs/minimal.js":[function(require,module,exports) {
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":"node_modules/protobufjs/src/index-minimal.js"}],"node_modules/libp2p-crypto/src/keys/keys.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-crypto-keys"] || ($protobuf.roots["libp2p-crypto-keys"] = {});
/**
 * KeyType enum.
 * @exports KeyType
 * @enum {number}
 * @property {number} RSA=0 RSA value
 * @property {number} Ed25519=1 Ed25519 value
 * @property {number} Secp256k1=2 Secp256k1 value
 */

$root.KeyType = function () {
  var valuesById = {},
      values = Object.create(valuesById);
  values[valuesById[0] = "RSA"] = 0;
  values[valuesById[1] = "Ed25519"] = 1;
  values[valuesById[2] = "Secp256k1"] = 2;
  return values;
}();

$root.PublicKey = function () {
  /**
   * Properties of a PublicKey.
   * @exports IPublicKey
   * @interface IPublicKey
   * @property {KeyType} Type PublicKey Type
   * @property {Uint8Array} Data PublicKey Data
   */

  /**
   * Constructs a new PublicKey.
   * @exports PublicKey
   * @classdesc Represents a PublicKey.
   * @implements IPublicKey
   * @constructor
   * @param {IPublicKey=} [p] Properties to set
   */
  function PublicKey(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * PublicKey Type.
   * @member {KeyType} Type
   * @memberof PublicKey
   * @instance
   */


  PublicKey.prototype.Type = 0;
  /**
   * PublicKey Data.
   * @member {Uint8Array} Data
   * @memberof PublicKey
   * @instance
   */

  PublicKey.prototype.Data = $util.newBuffer([]);
  /**
   * Encodes the specified PublicKey message. Does not implicitly {@link PublicKey.verify|verify} messages.
   * @function encode
   * @memberof PublicKey
   * @static
   * @param {IPublicKey} m PublicKey message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  PublicKey.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    w.uint32(8).int32(m.Type);
    w.uint32(18).bytes(m.Data);
    return w;
  };
  /**
   * Decodes a PublicKey message from the specified reader or buffer.
   * @function decode
   * @memberof PublicKey
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {PublicKey} PublicKey
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  PublicKey.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.PublicKey();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;

        case 2:
          m.Data = r.bytes();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    if (!m.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", {
      instance: m
    });
    if (!m.hasOwnProperty("Data")) throw $util.ProtocolError("missing required 'Data'", {
      instance: m
    });
    return m;
  };
  /**
   * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof PublicKey
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {PublicKey} PublicKey
   */


  PublicKey.fromObject = function fromObject(d) {
    if (d instanceof $root.PublicKey) return d;
    var m = new $root.PublicKey();

    switch (d.Type) {
      case "RSA":
      case 0:
        m.Type = 0;
        break;

      case "Ed25519":
      case 1:
        m.Type = 1;
        break;

      case "Secp256k1":
      case 2:
        m.Type = 2;
        break;
    }

    if (d.Data != null) {
      if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;
    }

    return m;
  };
  /**
   * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
   * @function toObject
   * @memberof PublicKey
   * @static
   * @param {PublicKey} m PublicKey
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  PublicKey.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      d.Type = o.enums === String ? "RSA" : 0;
      if (o.bytes === String) d.Data = "";else {
        d.Data = [];
        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
      }
    }

    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
    }

    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }

    return d;
  };
  /**
   * Converts this PublicKey to JSON.
   * @function toJSON
   * @memberof PublicKey
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  PublicKey.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return PublicKey;
}();

$root.PrivateKey = function () {
  /**
   * Properties of a PrivateKey.
   * @exports IPrivateKey
   * @interface IPrivateKey
   * @property {KeyType} Type PrivateKey Type
   * @property {Uint8Array} Data PrivateKey Data
   */

  /**
   * Constructs a new PrivateKey.
   * @exports PrivateKey
   * @classdesc Represents a PrivateKey.
   * @implements IPrivateKey
   * @constructor
   * @param {IPrivateKey=} [p] Properties to set
   */
  function PrivateKey(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * PrivateKey Type.
   * @member {KeyType} Type
   * @memberof PrivateKey
   * @instance
   */


  PrivateKey.prototype.Type = 0;
  /**
   * PrivateKey Data.
   * @member {Uint8Array} Data
   * @memberof PrivateKey
   * @instance
   */

  PrivateKey.prototype.Data = $util.newBuffer([]);
  /**
   * Encodes the specified PrivateKey message. Does not implicitly {@link PrivateKey.verify|verify} messages.
   * @function encode
   * @memberof PrivateKey
   * @static
   * @param {IPrivateKey} m PrivateKey message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  PrivateKey.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    w.uint32(8).int32(m.Type);
    w.uint32(18).bytes(m.Data);
    return w;
  };
  /**
   * Decodes a PrivateKey message from the specified reader or buffer.
   * @function decode
   * @memberof PrivateKey
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {PrivateKey} PrivateKey
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  PrivateKey.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.PrivateKey();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;

        case 2:
          m.Data = r.bytes();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    if (!m.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", {
      instance: m
    });
    if (!m.hasOwnProperty("Data")) throw $util.ProtocolError("missing required 'Data'", {
      instance: m
    });
    return m;
  };
  /**
   * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof PrivateKey
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {PrivateKey} PrivateKey
   */


  PrivateKey.fromObject = function fromObject(d) {
    if (d instanceof $root.PrivateKey) return d;
    var m = new $root.PrivateKey();

    switch (d.Type) {
      case "RSA":
      case 0:
        m.Type = 0;
        break;

      case "Ed25519":
      case 1:
        m.Type = 1;
        break;

      case "Secp256k1":
      case 2:
        m.Type = 2;
        break;
    }

    if (d.Data != null) {
      if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;
    }

    return m;
  };
  /**
   * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.
   * @function toObject
   * @memberof PrivateKey
   * @static
   * @param {PrivateKey} m PrivateKey
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  PrivateKey.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      d.Type = o.enums === String ? "RSA" : 0;
      if (o.bytes === String) d.Data = "";else {
        d.Data = [];
        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
      }
    }

    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
    }

    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }

    return d;
  };
  /**
   * Converts this PrivateKey to JSON.
   * @function toJSON
   * @memberof PrivateKey
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  PrivateKey.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return PrivateKey;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/node-forge/lib/forge.js":[function(require,module,exports) {
/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */
module.exports = {
  // default options
  options: {
    usePureJavaScript: false
  }
};
},{}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/node-forge/lib/baseN.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var api = {};
module.exports = api; // baseN alphabet indexes

var _reverseAlphabets = {};
/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */

api.encode = function (input, alphabet, maxline) {
  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  if (maxline !== undefined && typeof maxline !== 'number') {
    throw new TypeError('"maxline" must be a number.');
  }

  var output = '';

  if (!(input instanceof Uint8Array)) {
    // assume forge byte buffer
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];

    for (i = 0; i < input.length; ++i) {
      for (var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }

      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    } // deal with leading zeros


    for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first;
    } // convert digits to a string


    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }

  if (maxline) {
    var regex = new RegExp('.{1,' + maxline + '}', 'g');
    output = output.match(regex).join('\r\n');
  }

  return output;
};
/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */


api.decode = function (input, alphabet) {
  if (typeof input !== 'string') {
    throw new TypeError('"input" must be a string.');
  }

  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  var table = _reverseAlphabets[alphabet];

  if (!table) {
    // compute reverse alphabet
    table = _reverseAlphabets[alphabet] = [];

    for (var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  } // remove whitespace characters


  input = input.replace(/\s/g, '');
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var bytes = [0];

  for (var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];

    if (value === undefined) {
      return;
    }

    for (var j = 0, carry = value; j < bytes.length; ++j) {
      carry += bytes[j] * base;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }

    while (carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  } // deal with leading zeros


  for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }

  if (typeof Buffer !== 'undefined') {
    return Buffer.from(bytes.reverse());
  }

  return new Uint8Array(bytes.reverse());
};

function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var digits = [0];

  for (i = 0; i < input.length(); ++i) {
    for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = carry / base | 0;
    }

    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }

  var output = ''; // deal with leading zeros

  for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first;
  } // convert digits to a string


  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }

  return output;
}
},{"buffer":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/node-forge/lib/util.js":[function(require,module,exports) {
var process = require("process");
var global = arguments[3];
var Buffer = require("buffer").Buffer;
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */
var forge = require('./forge');

var baseN = require('./baseN');
/* Utilities API */


var util = module.exports = forge.util = forge.util || {}; // define setImmediate and nextTick

(function () {
  // use native nextTick (unless we're in webpack)
  // webpack (or better node-libs-browser polyfill) sets process.browser.
  // this way we can detect webpack properly
  if (typeof process !== 'undefined' && process.nextTick && !true) {
    util.nextTick = process.nextTick;

    if (typeof setImmediate === 'function') {
      util.setImmediate = setImmediate;
    } else {
      // polyfill setImmediate with nextTick, older versions of node
      // (those w/o setImmediate) won't totally starve IO
      util.setImmediate = util.nextTick;
    }

    return;
  } // polyfill nextTick with native setImmediate


  if (typeof setImmediate === 'function') {
    util.setImmediate = function () {
      return setImmediate.apply(undefined, arguments);
    };

    util.nextTick = function (callback) {
      return setImmediate(callback);
    };

    return;
  }
  /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */
  // polyfill with setTimeout


  util.setImmediate = function (callback) {
    setTimeout(callback, 0);
  }; // upgrade polyfill to use postMessage


  if (typeof window !== 'undefined' && typeof window.postMessage === 'function') {
    var handler = function (event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function (callback) {
          callback();
        });
      }
    };

    var msg = 'forge.setImmediate';
    var callbacks = [];

    util.setImmediate = function (callback) {
      callbacks.push(callback); // only send message when one hasn't been sent in
      // the current turn of the event loop

      if (callbacks.length === 1) {
        window.postMessage(msg, '*');
      }
    };

    window.addEventListener('message', handler, true);
  } // upgrade polyfill to use MutationObserver


  if (typeof MutationObserver !== 'undefined') {
    // polyfill with MutationObserver
    var now = Date.now();
    var attr = true;
    var div = document.createElement('div');
    var callbacks = [];
    new MutationObserver(function () {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function (callback) {
        callback();
      });
    }).observe(div, {
      attributes: true
    });
    var oldSetImmediate = util.setImmediate;

    util.setImmediate = function (callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback); // only trigger observer when it hasn't been triggered in
        // the current turn of the event loop

        if (callbacks.length === 1) {
          div.setAttribute('a', attr = !attr);
        }
      }
    };
  }

  util.nextTick = util.setImmediate;
})(); // check if running under Node.js


util.isNodejs = typeof process !== 'undefined' && process.versions && process.versions.node; // 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.

util.globalScope = function () {
  if (util.isNodejs) {
    return global;
  }

  return typeof self === 'undefined' ? window : self;
}(); // define isArray


util.isArray = Array.isArray || function (x) {
  return Object.prototype.toString.call(x) === '[object Array]';
}; // define isArrayBuffer


util.isArrayBuffer = function (x) {
  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
}; // define isArrayBufferView


util.isArrayBufferView = function (x) {
  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};
/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */


function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  }
} // TODO: set ByteBuffer to best available backing


util.ByteBuffer = ByteStringBuffer;
/** Buffer w/BinaryString backing */

/**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */

function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API
  // the data in this buffer
  this.data = ''; // the pointer for reading from this buffer

  this.read = 0;

  if (typeof b === 'string') {
    this.data = b;
  } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    if (typeof Buffer !== 'undefined' && b instanceof Buffer) {
      this.data = b.toString('binary');
    } else {
      // convert native buffer to forge buffer
      // FIXME: support native buffers internally instead
      var arr = new Uint8Array(b);

      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if (b instanceof ByteStringBuffer || _typeof(b) === 'object' && typeof b.data === 'string' && typeof b.read === 'number') {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  } // used for v8 optimization


  this._constructedStringLength = 0;
}

util.ByteStringBuffer = ByteStringBuffer;
/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */

var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;

util.ByteStringBuffer.prototype._optimizeConstructedString = function (x) {
  this._constructedStringLength += x;

  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */


util.ByteStringBuffer.prototype.length = function () {
  return this.data.length - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.ByteStringBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putByte = function (b) {
  return this.putBytes(String.fromCharCode(b));
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.fillWithByte = function (b, n) {
  b = String.fromCharCode(b);
  var d = this.data;

  while (n > 0) {
    if (n & 1) {
      d += b;
    }

    n >>>= 1;

    if (n > 0) {
      b += b;
    }
  }

  this.data = d;

  this._optimizeConstructedString(n);

  return this;
};
/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a binary encoded string) to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBytes = function (bytes) {
  this.data += bytes;

  this._optimizeConstructedString(bytes.length);

  return this;
};
/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putString = function (str) {
  return this.putBytes(util.encodeUtf8(str));
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  var bytes = '';

  do {
    n -= 8;
    bytes += String.fromCharCode(i >> n & 0xFF);
  } while (n > 0);

  return this.putBytes(bytes);
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putSignedInt = function (i, n) {
  // putInt checks n
  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBuffer = function (buffer) {
  return this.putBytes(buffer.getBytes());
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.getByte = function () {
  return this.data.charCodeAt(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16 = function () {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24 = function () {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32 = function () {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer. Note that the resulting string is binary encoded (in node.js this
 * encoding is referred to as `binary`, it is *not* `utf8`).
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.ByteStringBuffer.prototype.getBytes = function (count) {
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.ByteStringBuffer.prototype.bytes = function (count) {
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.at = function (i) {
  return this.data.charCodeAt(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.setAt = function (i, b) {
  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.ByteStringBuffer.prototype.last = function () {
  return this.data.charCodeAt(this.data.length - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.ByteStringBuffer.prototype.copy = function () {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.compact = function () {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.clear = function () {
  this.data = '';
  this.read = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.truncate = function (count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.ByteStringBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */


util.ByteStringBuffer.prototype.toString = function () {
  return util.decodeUtf8(this.bytes());
};
/** End Buffer w/BinaryString backing */

/** Buffer w/UInt8Array backing */

/**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */


function DataBuffer(b, options) {
  // default options
  options = options || {}; // pointers for read from/write to buffer

  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);

  if (isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if (isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }

    this.write = 'writeOffset' in options ? options.writeOffset : this.data.byteLength;
    return;
  } // initialize to empty array buffer and add any given bytes using putBytes


  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if (b !== null && b !== undefined) {
    this.putBytes(b);
  }

  if ('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}

util.DataBuffer = DataBuffer;
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */

util.DataBuffer.prototype.length = function () {
  return this.write - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.DataBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */


util.DataBuffer.prototype.accommodate = function (amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }

  growSize = Math.max(growSize || this.growSize, amount); // grow buffer

  var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);
  return this;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putByte = function (b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.fillWithByte = function (b, n) {
  this.accommodate(n);

  for (var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }

  return this;
};
/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBytes = function (bytes, encoding) {
  if (util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if (util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  } // bytes is a util.DataBuffer or equivalent


  if (bytes instanceof util.DataBuffer || _typeof(bytes) === 'object' && typeof bytes.read === 'number' && typeof bytes.write === 'number' && util.isArrayBufferView(bytes.data)) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if (bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  } // string conversion


  encoding = encoding || 'binary';

  if (typeof bytes === 'string') {
    var view; // decode from string

    if (encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }

    if (encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    } // encode text as UTF-8 bytes


    if (encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    } // decode string as raw binary


    if (encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    } // encode text as UTF-16 bytes


    if (encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBuffer = function (buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};
/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putString = function (str) {
  return this.putBytes(str, 'utf16');
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16 = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24 = function (i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32 = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16Le = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24Le = function (i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32Le = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  do {
    n -= 8;
    this.data.setInt8(this.write++, i >> n & 0xFF);
  } while (n > 0);

  return this;
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putSignedInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.getByte = function () {
  return this.data.getInt8(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16 = function () {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24 = function () {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32 = function () {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16Le = function () {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24Le = function () {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32Le = function () {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.DataBuffer.prototype.getBytes = function (count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.DataBuffer.prototype.bytes = function (count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.at = function (i) {
  return this.data.getUint8(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.setAt = function (i, b) {
  this.data.setUint8(i, b);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.DataBuffer.prototype.last = function () {
  return this.data.getUint8(this.write - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.DataBuffer.prototype.copy = function () {
  return new util.DataBuffer(this);
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.compact = function () {
  if (this.read > 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.clear = function () {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.truncate = function (count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.DataBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */


util.DataBuffer.prototype.toString = function (encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8'; // encode to string

  if (encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }

  if (encoding === 'hex') {
    return util.binary.hex.encode(view);
  }

  if (encoding === 'base64') {
    return util.binary.base64.encode(view);
  } // decode to text


  if (encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }

  if (encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
};
/** End Buffer w/UInt8Array backing */

/**
 * Creates a buffer that stores bytes. A value may be given to populate the
 * buffer with data. This value can either be string of encoded bytes or a
 * regular string of characters. When passing a string of binary encoded
 * bytes, the encoding `raw` should be given. This is also the default. When
 * passing a string of characters, the encoding `utf8` should be given.
 *
 * @param [input] a string with encoded bytes to store in the buffer.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */


util.createBuffer = function (input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';

  if (input !== undefined && encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }

  return new util.ByteBuffer(input);
};
/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */


util.fillString = function (c, n) {
  var s = '';

  while (n > 0) {
    if (n & 1) {
      s += c;
    }

    n >>>= 1;

    if (n > 0) {
      c += c;
    }
  }

  return s;
};
/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */


util.xorBytes = function (s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;

  for (; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);

    if (c >= 10) {
      s3 += t;
      t = '';
      c = 0;
    }

    t += String.fromCharCode(b);
    ++c;
  }

  s3 += t;
  return s3;
};
/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */


util.hexToBytes = function (hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;

  if (hex.length & 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }

  return rval;
};
/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.bytesToHex = function (bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
};
/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */


util.int32ToBytes = function (i) {
  return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);
}; // base64 characters, reverse mapping


var _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var _base64Idx = [
/*43 -43 = 0*/

/*'+',  1,  2,  3,'/' */
62, -1, -1, -1, 63,
/*'0','1','2','3','4','5','6','7','8','9' */
52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
/*15, 16, 17,'=', 19, 20, 21 */
-1, -1, -1, 64, -1, -1, -1,
/*65 - 43 = 22*/

/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
/*91 - 43 = 48 */

/*48, 49, 50, 51, 52, 53 */
-1, -1, -1, -1, -1, -1,
/*97 - 43 = 54*/

/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]; // base58 characters (Bitcoin alphabet)

var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */

util.encode64 = function (input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++); // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */


util.decode64 = function (input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);

      if (enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }

  return output;
};
/**
 * Encodes the given string of characters (a standard JavaScript
 * string) as a binary encoded string where the bytes represent
 * a UTF-8 encoded string of characters. Non-ASCII characters will be
 * encoded as multiple bytes according to UTF-8.
 *
 * @param str a standard string of characters to encode.
 *
 * @return the binary encoded string.
 */


util.encodeUtf8 = function (str) {
  return unescape(encodeURIComponent(str));
};
/**
 * Decodes a binary encoded string that contains bytes that
 * represent a UTF-8 encoded string of characters -- into a
 * string of characters (a standard JavaScript string).
 *
 * @param str the binary encoded string to decode.
 *
 * @return the resulting standard string of characters.
 */


util.decodeUtf8 = function (str) {
  return decodeURIComponent(escape(str));
}; // binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */

util.binary.raw.encode = function (bytes) {
  return String.fromCharCode.apply(null, bytes);
};
/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.raw.decode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.binary.hex.encode = util.bytesToHex;
/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.binary.hex.decode = function (hex, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }

  offset = offset || 0;
  var i = 0,
      j = offset;

  if (hex.length & 1) {
    // odd number of characters, convert first character alone
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }

  return output ? j - offset : out;
};
/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */


util.binary.base64.encode = function (input, maxline) {
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++]; // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.base64.decode = function (input, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  } // remove all non-base64 characters


  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0,
      j = offset;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    out[j++] = enc1 << 2 | enc2 >> 4;

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      out[j++] = (enc2 & 15) << 4 | enc3 >> 2;

      if (enc4 !== 64) {
        // decoded 3 bytes
        out[j++] = (enc3 & 3) << 6 | enc4;
      }
    }
  } // make sure result is the exact decoded length


  return output ? j - offset : out.subarray(0, j);
}; // add support for base58 encoding/decoding with Bitcoin alphabet


util.binary.base58.encode = function (input, maxline) {
  return util.binary.baseN.encode(input, _base58, maxline);
};

util.binary.base58.decode = function (input, maxline) {
  return util.binary.baseN.decode(input, _base58, maxline);
}; // text encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.text = {
  utf8: {},
  utf16: {}
};
/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.text.utf8.encode = function (str, output, offset) {
  str = util.encodeUtf8(str);
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf8.decode = function (bytes) {
  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
};
/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.text.utf16.encode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length * 2);
  }

  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;

  for (var i = 0; i < str.length; ++i) {
    view[k++] = str.charCodeAt(i);
    j += 2;
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf16.decode = function (bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};
/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */


util.deflate = function (api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval); // strip zlib header and trailer if necessary

  if (raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);

    if (flg & 0x20) {
      start = 6;
    } // zlib trailer is 4 bytes of adler-32


    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
};
/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */


util.inflate = function (api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return rval === null ? null : util.decode64(rval);
};
/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */


var _setStorageObject = function (api, id, obj) {
  if (!api) {
    throw new Error('WebStorage not available.');
  }

  var rval;

  if (obj === null) {
    rval = api.removeItem(id);
  } else {
    // json-encode and base64-encode object
    obj = util.encode64(JSON.stringify(obj));
    rval = api.setItem(id, obj);
  } // handle potential flash error


  if (typeof rval !== 'undefined' && rval.rval !== true) {
    var error = new Error(rval.error.message);
    error.id = rval.error.id;
    error.name = rval.error.name;
    throw error;
  }
};
/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */


var _getStorageObject = function (api, id) {
  if (!api) {
    throw new Error('WebStorage not available.');
  } // get the existing entry


  var rval = api.getItem(id);
  /* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */
  // flash returns item wrapped in an object, handle special case

  if (api.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      } // no error, but also no item


      rval = null;
    } else {
      rval = rval.rval;
    }
  } // handle decoding


  if (rval !== null) {
    // base64-decode and json-decode data
    rval = JSON.parse(util.decode64(rval));
  }

  return rval;
};
/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */


var _setItem = function (api, id, key, data) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj === null) {
    // create a new storage object
    obj = {};
  } // update key


  obj[key] = data; // set storage object

  _setStorageObject(api, id, obj);
};
/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */


var _getItem = function (api, id, key) {
  // get storage object
  var rval = _getStorageObject(api, id);

  if (rval !== null) {
    // return data at key
    rval = key in rval ? rval[key] : null;
  }

  return rval;
};
/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */


var _removeItem = function (api, id, key) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj !== null && key in obj) {
    // remove key
    delete obj[key]; // see if entry has no keys remaining

    var empty = true;

    for (var prop in obj) {
      empty = false;
      break;
    }

    if (empty) {
      // remove entry entirely if no keys are left
      obj = null;
    } // set storage object


    _setStorageObject(api, id, obj);
  }
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */


var _clearItems = function (api, id) {
  _setStorageObject(api, id, null);
};
/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */


var _callStorageFunction = function (func, args, location) {
  var rval = null; // default storage types

  if (typeof location === 'undefined') {
    location = ['web', 'flash'];
  } // apply storage types in order of preference


  var type;
  var done = false;
  var exception = null;

  for (var idx in location) {
    type = location[idx];

    try {
      if (type === 'flash' || type === 'both') {
        if (args[0] === null) {
          throw new Error('Flash local storage not available.');
        }

        rval = func.apply(this, args);
        done = type === 'flash';
      }

      if (type === 'web' || type === 'both') {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }

    if (done) {
      break;
    }
  }

  if (!done) {
    throw exception;
  }

  return rval;
};
/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */


util.setItem = function (api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
};
/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */


util.getItem = function (api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
};
/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */


util.removeItem = function (api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */


util.clearItems = function (api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
};
/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */


util.parseUrl = function (str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = m === null ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };

  if (url) {
    url.fullHost = url.host;

    if (url.port) {
      if (url.port !== 80 && url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if (url.port !== 443 && url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if (url.scheme === 'http') {
      url.port = 80;
    } else if (url.scheme === 'https') {
      url.port = 443;
    }

    url.full = url.scheme + '://' + url.fullHost;
  }

  return url;
};
/* Storage for query variables */


var _queryVariables = null;
/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */

util.getQueryVariables = function (query) {
  var parse = function (q) {
    var rval = {};
    var kvpairs = q.split('&');

    for (var i = 0; i < kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;

      if (pos > 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }

      if (!(key in rval)) {
        rval[key] = [];
      } // disallow overriding object prototype keys


      if (!(key in Object.prototype) && val !== null) {
        rval[key].push(unescape(val));
      }
    }

    return rval;
  };

  var rval;

  if (typeof query === 'undefined') {
    // set cached variables if needed
    if (_queryVariables === null) {
      if (typeof window !== 'undefined' && window.location && window.location.search) {
        // parse window search query
        _queryVariables = parse(window.location.search.substring(1));
      } else {
        // no query variables available
        _queryVariables = {};
      }
    }

    rval = _queryVariables;
  } else {
    // parse given query
    rval = parse(query);
  }

  return rval;
};
/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */


util.parseFragment = function (fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = ''; // split into path and query if possible at the first '?'

  var pos = fragment.indexOf('?');

  if (pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  } // split path based on '/' and ignore first element if empty


  var path = fp.split('/');

  if (path.length > 0 && path[0] === '') {
    path.shift();
  } // convert query into object


  var query = fq === '' ? {} : util.getQueryVariables(fq);
  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
};
/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */


util.makeRequest = function (reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,

    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
    getPath: function (i) {
      return typeof i === 'undefined' ? frag.path : frag.path[i];
    },

    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function (k, i) {
      var rval;

      if (typeof k === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];

        if (rval && typeof i !== 'undefined') {
          rval = rval[i];
        }
      }

      return rval;
    },
    getQueryLast: function (k, _default) {
      var rval;
      var vals = req.getQuery(k);

      if (vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }

      return rval;
    }
  };
  return req;
};
/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */


util.makeLink = function (path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;
  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path + (qstr.length > 0 ? '?' + qstr : '') + (fragment.length > 0 ? '#' + fragment : '');
};
/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */


util.isEmpty = function (obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
};
/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */


util.format = function (format) {
  var re = /%./g; // current match

  var match; // current part

  var part; // current arg index

  var argi = 0; // collected parts to recombine later

  var parts = []; // last index found

  var last = 0; // loop while matches remain

  while (match = re.exec(format)) {
    part = format.substring(last, re.lastIndex - 2); // don't add empty strings (ie, parts between %s%s)

    if (part.length > 0) {
      parts.push(part);
    }

    last = re.lastIndex; // switch on % code

    var code = match[0][1];

    switch (code) {
      case 's':
      case 'o':
        // check if enough arguments were given
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push('<?>');
        }

        break;
      // FIXME: do proper formating for numbers, etc
      //case 'f':
      //case 'd':

      case '%':
        parts.push('%');
        break;

      default:
        parts.push('<%' + code + '?>');
    }
  } // add trailing part of format string


  parts.push(format.substring(last));
  return parts.join('');
};
/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */


util.formatNumber = function (number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57
  var n = number,
      c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ? '.' : thousands_sep,
      s = n < 0 ? '-' : '';
  var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + '';
  var j = i.length > 3 ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};
/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */


util.formatSize = function (size) {
  if (size >= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if (size >= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if (size >= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }

  return size;
};
/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */


util.bytesFromIP = function (ip) {
  if (ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }

  if (ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }

  return null;
};
/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv4 = function (ip) {
  ip = ip.split('.');

  if (ip.length !== 4) {
    return null;
  }

  var b = util.createBuffer();

  for (var i = 0; i < ip.length; ++i) {
    var num = parseInt(ip[i], 10);

    if (isNaN(num)) {
      return null;
    }

    b.putByte(num);
  }

  return b.getBytes();
};
/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv6 = function (ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function (e) {
    if (e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();

  for (var i = 0; i < 8; ++i) {
    if (!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }

    var bytes = util.hexToBytes(ip[i]);

    if (bytes.length < 2) {
      b.putByte(0);
    }

    b.putBytes(bytes);
  }

  return b.getBytes();
};
/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */


util.bytesToIP = function (bytes) {
  if (bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }

  if (bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }

  return null;
};
/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv4 = function (bytes) {
  if (bytes.length !== 4) {
    return null;
  }

  var ip = [];

  for (var i = 0; i < bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }

  return ip.join('.');
};
/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv6 = function (bytes) {
  if (bytes.length !== 16) {
    return null;
  }

  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;

  for (var i = 0; i < bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]); // canonicalize zero representation

    while (hex[0] === '0' && hex !== '0') {
      hex = hex.substr(1);
    }

    if (hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;

      if (!last || idx !== last.end + 1) {
        zeroGroups.push({
          start: idx,
          end: idx
        });
      } else {
        last.end = idx;

        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }

    ip.push(hex);
  }

  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup]; // only shorten group of length > 0

    if (group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, '');

      if (group.start === 0) {
        ip.unshift('');
      }

      if (group.end === 7) {
        ip.push('');
      }
    }
  }

  return ip.join(':');
};
/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */


util.estimateCores = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if ('cores' in util && !options.update) {
    return callback(null, util.cores);
  }

  if (typeof navigator !== 'undefined' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }

  if (typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }

  if (typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  } // create worker concurrency estimation code as blob


  var blobUrl = URL.createObjectURL(new Blob(['(', function () {
    self.addEventListener('message', function (e) {
      // run worker for 4 ms
      var st = Date.now();
      var et = st + 4;

      while (Date.now() < et) {
        ;
      }

      self.postMessage({
        st: st,
        et: et
      });
    });
  }.toString(), ')()'], {
    type: 'application/javascript'
  })); // take 5 samples using 16 workers

  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function (avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }

    map(numWorkers, function (err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];

    for (var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function (e) {
        results.push(e.data);

        if (results.length === numWorkers) {
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].terminate();
          }

          callback(null, results);
        }
      });
      workers.push(worker);
    }

    for (var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];

    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];

      for (var i = 0; i < numWorkers; ++i) {
        if (n === i) {
          continue;
        }

        var r2 = results[i];

        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i);
        }
      }
    } // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway


    return overlaps.reduce(function (max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./baseN":"node_modules/node-forge/lib/baseN.js","process":"node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/node-forge/lib/oids.js":[function(require,module,exports) {
/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = require('./forge');

forge.pki = forge.pki || {};
var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {}; // set id to name mapping and name to id mapping

function _IN(id, name) {
  oids[id] = name;
  oids[name] = id;
} // set id to name mapping only


function _I_(id, name) {
  oids[id] = name;
} // algorithm OIDs


_IN('1.2.840.113549.1.1.1', 'rsaEncryption'); // Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');


_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');

_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');

_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');

_IN('1.2.840.113549.1.1.8', 'mgf1');

_IN('1.2.840.113549.1.1.9', 'pSpecified');

_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');

_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');

_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');

_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption'); // Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519


_IN('1.3.101.112', 'EdDSA25519');

_IN('1.2.840.10040.4.3', 'dsa-with-sha1');

_IN('1.3.14.3.2.7', 'desCBC');

_IN('1.3.14.3.2.26', 'sha1');

_IN('2.16.840.1.101.3.4.2.1', 'sha256');

_IN('2.16.840.1.101.3.4.2.2', 'sha384');

_IN('2.16.840.1.101.3.4.2.3', 'sha512');

_IN('1.2.840.113549.2.5', 'md5'); // pkcs#7 content types


_IN('1.2.840.113549.1.7.1', 'data');

_IN('1.2.840.113549.1.7.2', 'signedData');

_IN('1.2.840.113549.1.7.3', 'envelopedData');

_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');

_IN('1.2.840.113549.1.7.5', 'digestedData');

_IN('1.2.840.113549.1.7.6', 'encryptedData'); // pkcs#9 oids


_IN('1.2.840.113549.1.9.1', 'emailAddress');

_IN('1.2.840.113549.1.9.2', 'unstructuredName');

_IN('1.2.840.113549.1.9.3', 'contentType');

_IN('1.2.840.113549.1.9.4', 'messageDigest');

_IN('1.2.840.113549.1.9.5', 'signingTime');

_IN('1.2.840.113549.1.9.6', 'counterSignature');

_IN('1.2.840.113549.1.9.7', 'challengePassword');

_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');

_IN('1.2.840.113549.1.9.14', 'extensionRequest');

_IN('1.2.840.113549.1.9.20', 'friendlyName');

_IN('1.2.840.113549.1.9.21', 'localKeyId');

_IN('1.2.840.113549.1.9.22.1', 'x509Certificate'); // pkcs#12 safe bags


_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');

_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');

_IN('1.2.840.113549.1.12.10.1.3', 'certBag');

_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');

_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');

_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag'); // password-based-encryption for pkcs#12


_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');

_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');

_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');

_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');

_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');

_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');

_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');

_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC'); // hmac OIDs


_IN('1.2.840.113549.2.7', 'hmacWithSHA1');

_IN('1.2.840.113549.2.8', 'hmacWithSHA224');

_IN('1.2.840.113549.2.9', 'hmacWithSHA256');

_IN('1.2.840.113549.2.10', 'hmacWithSHA384');

_IN('1.2.840.113549.2.11', 'hmacWithSHA512'); // symmetric key algorithm oids


_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');

_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');

_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');

_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC'); // certificate issuer/subject OIDs


_IN('2.5.4.3', 'commonName');

_IN('2.5.4.5', 'serialName');

_IN('2.5.4.6', 'countryName');

_IN('2.5.4.7', 'localityName');

_IN('2.5.4.8', 'stateOrProvinceName');

_IN('2.5.4.9', 'streetAddress');

_IN('2.5.4.10', 'organizationName');

_IN('2.5.4.11', 'organizationalUnitName');

_IN('2.5.4.13', 'description');

_IN('2.5.4.15', 'businessCategory');

_IN('2.5.4.17', 'postalCode');

_IN('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName');

_IN('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName'); // X.509 extension OIDs


_IN('2.16.840.1.113730.1.1', 'nsCertType');

_IN('2.16.840.1.113730.1.13', 'nsComment'); // deprecated in theory; still widely used


_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35


_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15


_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32


_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15


_I_('2.5.29.5', 'policyMapping'); // deprecated use .33


_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30


_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17


_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18


_I_('2.5.29.9', 'subjectDirectoryAttributes');

_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19


_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30


_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36


_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19


_IN('2.5.29.14', 'subjectKeyIdentifier');

_IN('2.5.29.15', 'keyUsage');

_I_('2.5.29.16', 'privateKeyUsagePeriod');

_IN('2.5.29.17', 'subjectAltName');

_IN('2.5.29.18', 'issuerAltName');

_IN('2.5.29.19', 'basicConstraints');

_I_('2.5.29.20', 'cRLNumber');

_I_('2.5.29.21', 'cRLReason');

_I_('2.5.29.22', 'expirationDate');

_I_('2.5.29.23', 'instructionCode');

_I_('2.5.29.24', 'invalidityDate');

_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31


_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28


_I_('2.5.29.27', 'deltaCRLIndicator');

_I_('2.5.29.28', 'issuingDistributionPoint');

_I_('2.5.29.29', 'certificateIssuer');

_I_('2.5.29.30', 'nameConstraints');

_IN('2.5.29.31', 'cRLDistributionPoints');

_IN('2.5.29.32', 'certificatePolicies');

_I_('2.5.29.33', 'policyMappings');

_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36


_IN('2.5.29.35', 'authorityKeyIdentifier');

_I_('2.5.29.36', 'policyConstraints');

_IN('2.5.29.37', 'extKeyUsage');

_I_('2.5.29.46', 'freshestCRL');

_I_('2.5.29.54', 'inhibitAnyPolicy'); // extKeyUsage purposes


_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');

_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');

_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');

_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');

_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');

_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');

_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');
},{"./forge":"node_modules/node-forge/lib/forge.js"}],"node_modules/node-forge/lib/asn1.js":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */
var forge = require('./forge');

require('./util');

require('./oids');
/* ASN.1 API */


var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
/**
 * ASN.1 classes.
 */

asn1.Class = {
  UNIVERSAL: 0x00,
  APPLICATION: 0x40,
  CONTEXT_SPECIFIC: 0x80,
  PRIVATE: 0xC0
};
/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */

asn1.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */

asn1.create = function (tagClass, type, constructed, value, options) {
  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */
  // remove undefined values
  if (forge.util.isArray(value)) {
    var tmp = [];

    for (var i = 0; i < value.length; ++i) {
      if (value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }

    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };

  if (options && 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents; // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes

    obj.original = asn1.copy(obj);
  }

  return obj;
};
/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */


asn1.copy = function (obj, options) {
  var copy;

  if (forge.util.isArray(obj)) {
    copy = [];

    for (var i = 0; i < obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }

    return copy;
  }

  if (typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };

  if (options && !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }

  return copy;
};
/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */


asn1.equals = function (obj1, obj2, options) {
  if (forge.util.isArray(obj1)) {
    if (!forge.util.isArray(obj2)) {
      return false;
    }

    if (obj1.length !== obj2.length) {
      return false;
    }

    for (var i = 0; i < obj1.length; ++i) {
      if (!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
    }

    return true;
  }

  if (_typeof(obj1) !== _typeof(obj2)) {
    return false;
  }

  if (typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);

  if (options && options.includeBitStringContents) {
    equal = equal && obj1.bitStringContents === obj2.bitStringContents;
  }

  return equal;
};
/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */


asn1.getBerValueLength = function (b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();

  if (b2 === 0x80) {
    return undefined;
  } // see if the length is "short form" or "long form" (bit 8 set)


  var length;
  var longForm = b2 & 0x80;

  if (!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 & 0x7F) << 3);
  }

  return length;
};
/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */


function _checkBufferLength(bytes, remaining, n) {
  if (n > remaining) {
    var error = new Error('Too few bytes to parse DER.');
    error.available = bytes.length();
    error.remaining = remaining;
    error.requested = n;
    throw error;
  }
}
/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */


var _getValueLength = function (bytes, remaining) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  // fromDer already checked that this byte exists
  var b2 = bytes.getByte();
  remaining--;

  if (b2 === 0x80) {
    return undefined;
  } // see if the length is "short form" or "long form" (bit 8 set)


  var length;
  var longForm = b2 & 0x80;

  if (!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    var longFormBytes = b2 & 0x7F;

    _checkBufferLength(bytes, remaining, longFormBytes);

    length = bytes.getInt(longFormBytes << 3);
  } // FIXME: this will only happen for 32 bit getInt with high bit set


  if (length < 0) {
    throw new Error('Negative length: ' + length);
  }

  return length;
};
/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */


asn1.fromDer = function (bytes, options) {
  if (options === undefined) {
    options = {
      strict: true,
      decodeBitStrings: true
    };
  }

  if (typeof options === 'boolean') {
    options = {
      strict: options,
      decodeBitStrings: true
    };
  }

  if (!('strict' in options)) {
    options.strict = true;
  }

  if (!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  } // wrap in buffer if needed


  if (typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  return _fromDer(bytes, bytes.length(), 0, options);
};
/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */


function _fromDer(bytes, remaining, depth, options) {
  // temporary storage for consumption calculations
  var start; // minimum length for ASN.1 DER structure is 2

  _checkBufferLength(bytes, remaining, 2); // get the first byte


  var b1 = bytes.getByte(); // consumed one byte

  remaining--; // get the tag class

  var tagClass = b1 & 0xC0; // get the type (bits 1-5)

  var type = b1 & 0x1F; // get the variable value length and adjust remaining bytes

  start = bytes.length();

  var length = _getValueLength(bytes, remaining);

  remaining -= start - bytes.length(); // ensure there are enough bytes to get the value

  if (length !== undefined && length > remaining) {
    if (options.strict) {
      var error = new Error('Too few bytes to read ASN.1 value.');
      error.available = bytes.length();
      error.remaining = remaining;
      error.requested = length;
      throw error;
    } // Note: be lenient with truncated values and use remaining state bytes


    length = remaining;
  } // value storage


  var value; // possible BIT STRING contents storage

  var bitStringContents; // constructed flag is bit 6 (32 = 0x20) of the first byte

  var constructed = (b1 & 0x20) === 0x20;

  if (constructed) {
    // parse child asn1 objects from the value
    value = [];

    if (length === undefined) {
      // asn1 object of indefinite length, read until end tag
      for (;;) {
        _checkBufferLength(bytes, remaining, 2);

        if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
          bytes.getBytes(2);
          remaining -= 2;
          break;
        }

        start = bytes.length();
        value.push(_fromDer(bytes, remaining, depth + 1, options));
        remaining -= start - bytes.length();
      }
    } else {
      // parsing asn1 object of definite length
      while (length > 0) {
        start = bytes.length();
        value.push(_fromDer(bytes, length, depth + 1, options));
        remaining -= start - bytes.length();
        length -= start - bytes.length();
      }
    }
  } // if a BIT STRING, save the contents including padding


  if (value === undefined && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
    bitStringContents = bytes.bytes(length);
  } // determine if a non-constructed value should be decoded as a composed
  // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
  // can be used this way.


  if (value === undefined && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING
  /*|| type === asn1.Type.OCTETSTRING*/
  && length > 1) {
    // save read position
    var savedRead = bytes.read;
    var savedRemaining = remaining;
    var unused = 0;

    if (type === asn1.Type.BITSTRING) {
      /* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").
         The second and following octets give the value of the bit string
        converted to an octet string. */
      _checkBufferLength(bytes, remaining, 1);

      unused = bytes.getByte();
      remaining--;
    } // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs


    if (unused === 0) {
      try {
        // attempt to parse child asn1 object from the value
        // (stored in array to signal composed value)
        start = bytes.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          verbose: options.verbose,
          strict: true,
          decodeBitStrings: true
        };

        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);

        var used = start - bytes.length();
        remaining -= used;

        if (type == asn1.Type.BITSTRING) {
          used++;
        } // if the data all decoded and the class indicates UNIVERSAL or
        // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object


        var tc = composed.tagClass;

        if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch (ex) {}
    }

    if (value === undefined) {
      // restore read position
      bytes.read = savedRead;
      remaining = savedRemaining;
    }
  }

  if (value === undefined) {
    // asn1 not constructed or composed, get raw value
    // TODO: do DER to OID conversion and vice-versa in .toDer?
    if (length === undefined) {
      if (options.strict) {
        throw new Error('Non-constructed ASN.1 object of indefinite length.');
      } // be lenient and use remaining state bytes


      length = remaining;
    }

    if (type === asn1.Type.BMPSTRING) {
      value = '';

      for (; length > 0; length -= 2) {
        _checkBufferLength(bytes, remaining, 2);

        value += String.fromCharCode(bytes.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes.getBytes(length);
    }
  } // add BIT STRING contents if available


  var asn1Options = bitStringContents === undefined ? null : {
    bitStringContents: bitStringContents
  }; // create and return asn1 object

  return asn1.create(tagClass, type, constructed, value, asn1Options);
}
/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */


asn1.toDer = function (obj) {
  var bytes = forge.util.createBuffer(); // build the first byte

  var b1 = obj.tagClass | obj.type; // for storing the ASN.1 value

  var value = forge.util.createBuffer(); // use BIT STRING contents if available and data not changed

  var useBitStringContents = false;

  if ('bitStringContents' in obj) {
    useBitStringContents = true;

    if (obj.original) {
      useBitStringContents = asn1.equals(obj, obj.original);
    }
  }

  if (useBitStringContents) {
    value.putBytes(obj.bitStringContents);
  } else if (obj.composed) {
    // if composed, use each child asn1 object's DER bytes as value
    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
    // from other asn1 objects
    if (obj.constructed) {
      b1 |= 0x20;
    } else {
      // type is a bit string, add unused bits of 0x00
      value.putByte(0x00);
    } // add all of the child DER bytes together


    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== undefined) {
        value.putBuffer(asn1.toDer(obj.value[i]));
      }
    }
  } else {
    // use asn1.value directly
    if (obj.type === asn1.Type.BMPSTRING) {
      for (var i = 0; i < obj.value.length; ++i) {
        value.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      // ensure integer is minimally-encoded
      // TODO: should all leading bytes be stripped vs just one?
      // .. ex '00 00 01' => '01'?
      if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 0x80) === 0 || obj.value.charCodeAt(0) === 0xFF && (obj.value.charCodeAt(1) & 0x80) === 0x80)) {
        value.putBytes(obj.value.substr(1));
      } else {
        value.putBytes(obj.value);
      }
    }
  } // add tag byte


  bytes.putByte(b1); // use "short form" encoding

  if (value.length() <= 127) {
    // one byte describes the length
    // bit 8 = 0 and bits 7-1 = length
    bytes.putByte(value.length() & 0x7F);
  } else {
    // use "long form" encoding
    // 2 to 127 bytes describe the length
    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
    // other bytes: length in base 256, big-endian
    var len = value.length();
    var lenBytes = '';

    do {
      lenBytes += String.fromCharCode(len & 0xFF);
      len = len >>> 8;
    } while (len > 0); // set first byte to # bytes used to store the length and turn on
    // bit 8 to indicate long-form length is used


    bytes.putByte(lenBytes.length | 0x80); // concatenate length bytes in reverse since they were generated
    // little endian and we need big endian

    for (var i = lenBytes.length - 1; i >= 0; --i) {
      bytes.putByte(lenBytes.charCodeAt(i));
    }
  } // concatenate value bytes


  bytes.putBuffer(value);
  return bytes;
};
/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */


asn1.oidToDer = function (oid) {
  // split OID into individual values
  var values = oid.split('.');
  var bytes = forge.util.createBuffer(); // first byte is 40 * value1 + value2

  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10)); // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value

  var last, valueBytes, value, b;

  for (var i = 2; i < values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);

    do {
      b = value & 0x7F;
      value = value >>> 7; // if value is not last, then turn on 8th bit

      if (!last) {
        b |= 0x80;
      }

      valueBytes.push(b);
      last = false;
    } while (value > 0); // add value bytes in reverse (needs to be in big endian)


    for (var n = valueBytes.length - 1; n >= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
};
/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */


asn1.derToOid = function (bytes) {
  var oid; // wrap in buffer if needed

  if (typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  } // first byte is 40 * value1 + value2


  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + b % 40; // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value

  var value = 0;

  while (bytes.length() > 0) {
    b = bytes.getByte();
    value = value << 7; // not the last byte for the value

    if (b & 0x80) {
      value += b & 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);
      value = 0;
    }
  }

  return oid;
};
/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */


asn1.utcTimeToDate = function (utc) {
  /* The following formats can be used:
     YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'
     Where:
     YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date(); // if YY >= 50 use 19xx, if YY < 50 use 20xx

  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2000 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month

  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0; // not just YYMMDDhhmmZ

  if (utc.length > 11) {
    // get character after minutes
    var c = utc.charAt(10);
    var end = 10; // see if seconds are present

    if (c !== '+' && c !== '-') {
      // get seconds
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  } // update date


  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);

  if (end) {
    // get +/- after end of time
    c = utc.charAt(end);

    if (c === '+' || c === '-') {
      // get hours+minutes offset
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10); // calculate offset in milliseconds

      var offset = hhoffset * 60 + mmoffset;
      offset *= 60000; // apply offset

      if (c === '+') {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }

  return date;
};
/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */


asn1.generalizedTimeToDate = function (gentime) {
  /* The following formats can be used:
     YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'
     Where:
     YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month

  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;

  if (gentime.charAt(gentime.length - 1) === 'Z') {
    isUTC = true;
  }

  var end = gentime.length - 5,
      c = gentime.charAt(end);

  if (c === '+' || c === '-') {
    // get hours+minutes offset
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10); // calculate offset in milliseconds

    offset = hhoffset * 60 + mmoffset;
    offset *= 60000; // apply offset

    if (c === '+') {
      offset *= -1;
    }

    isUTC = true;
  } // check for second fraction


  if (gentime.charAt(14) === '.') {
    fff = parseFloat(gentime.substr(14), 10) * 1000;
  }

  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff); // apply offset

    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }

  return date;
};
/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */


asn1.dateToUtcTime = function (date) {
  // TODO: validate; currently assumes proper format
  if (typeof date === 'string') {
    return date;
  }

  var rval = ''; // create format YYMMDDhhmmssZ

  var format = [];
  format.push(('' + date.getUTCFullYear()).substr(2));
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds()); // ensure 2 digits are used for each format entry

  for (var i = 0; i < format.length; ++i) {
    if (format[i].length < 2) {
      rval += '0';
    }

    rval += format[i];
  }

  rval += 'Z';
  return rval;
};
/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */


asn1.dateToGeneralizedTime = function (date) {
  // TODO: validate; currently assumes proper format
  if (typeof date === 'string') {
    return date;
  }

  var rval = ''; // create format YYYYMMDDHHMMSSZ

  var format = [];
  format.push('' + date.getUTCFullYear());
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds()); // ensure 2 digits are used for each format entry

  for (var i = 0; i < format.length; ++i) {
    if (format[i].length < 2) {
      rval += '0';
    }

    rval += format[i];
  }

  rval += 'Z';
  return rval;
};
/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */


asn1.integerToDer = function (x) {
  var rval = forge.util.createBuffer();

  if (x >= -0x80 && x < 0x80) {
    return rval.putSignedInt(x, 8);
  }

  if (x >= -0x8000 && x < 0x8000) {
    return rval.putSignedInt(x, 16);
  }

  if (x >= -0x800000 && x < 0x800000) {
    return rval.putSignedInt(x, 24);
  }

  if (x >= -0x80000000 && x < 0x80000000) {
    return rval.putSignedInt(x, 32);
  }

  var error = new Error('Integer too large; max is 32-bits.');
  error.integer = x;
  throw error;
};
/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */


asn1.derToInteger = function (bytes) {
  // wrap in buffer if needed
  if (typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var n = bytes.length() * 8;

  if (n > 32) {
    throw new Error('Integer too large; max is 32-bits.');
  }

  return bytes.getSignedInt(n);
};
/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */


asn1.validate = function (obj, v, capture, errors) {
  var rval = false; // ensure tag class and type are the same if specified

  if ((obj.tagClass === v.tagClass || typeof v.tagClass === 'undefined') && (obj.type === v.type || typeof v.type === 'undefined')) {
    // ensure constructed flag is the same if specified
    if (obj.constructed === v.constructed || typeof v.constructed === 'undefined') {
      rval = true; // handle sub values

      if (v.value && forge.util.isArray(v.value)) {
        var j = 0;

        for (var i = 0; rval && i < v.value.length; ++i) {
          rval = v.value[i].optional || false;

          if (obj.value[j]) {
            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);

            if (rval) {
              ++j;
            } else if (v.value[i].optional) {
              rval = true;
            }
          }

          if (!rval && errors) {
            errors.push('[' + v.name + '] ' + 'Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
          }
        }
      }

      if (rval && capture) {
        if (v.capture) {
          capture[v.capture] = obj.value;
        }

        if (v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }

        if (v.captureBitStringContents && 'bitStringContents' in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }

        if (v.captureBitStringValue && 'bitStringContents' in obj) {
          var value;

          if (obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = '';
          } else {
            // FIXME: support unused bits with data shifting
            var unused = obj.bitStringContents.charCodeAt(0);

            if (unused !== 0) {
              throw new Error('captureBitStringValue only supported for zero unused bits');
            }

            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors) {
      errors.push('[' + v.name + '] ' + 'Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
    }
  } else if (errors) {
    if (obj.tagClass !== v.tagClass) {
      errors.push('[' + v.name + '] ' + 'Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
    }

    if (obj.type !== v.type) {
      errors.push('[' + v.name + '] ' + 'Expected type "' + v.type + '", got "' + obj.type + '"');
    }
  }

  return rval;
}; // regex for testing for non-latin characters


var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */

asn1.prettyPrint = function (obj, level, indentation) {
  var rval = ''; // set default level and indentation

  level = level || 0;
  indentation = indentation || 2; // start new line for deep levels

  if (level > 0) {
    rval += '\n';
  } // create indent


  var indent = '';

  for (var i = 0; i < level * indentation; ++i) {
    indent += ' ';
  } // print class:type


  rval += indent + 'Tag: ';

  switch (obj.tagClass) {
    case asn1.Class.UNIVERSAL:
      rval += 'Universal:';
      break;

    case asn1.Class.APPLICATION:
      rval += 'Application:';
      break;

    case asn1.Class.CONTEXT_SPECIFIC:
      rval += 'Context-Specific:';
      break;

    case asn1.Class.PRIVATE:
      rval += 'Private:';
      break;
  }

  if (obj.tagClass === asn1.Class.UNIVERSAL) {
    rval += obj.type; // known types

    switch (obj.type) {
      case asn1.Type.NONE:
        rval += ' (None)';
        break;

      case asn1.Type.BOOLEAN:
        rval += ' (Boolean)';
        break;

      case asn1.Type.INTEGER:
        rval += ' (Integer)';
        break;

      case asn1.Type.BITSTRING:
        rval += ' (Bit string)';
        break;

      case asn1.Type.OCTETSTRING:
        rval += ' (Octet string)';
        break;

      case asn1.Type.NULL:
        rval += ' (Null)';
        break;

      case asn1.Type.OID:
        rval += ' (Object Identifier)';
        break;

      case asn1.Type.ODESC:
        rval += ' (Object Descriptor)';
        break;

      case asn1.Type.EXTERNAL:
        rval += ' (External or Instance of)';
        break;

      case asn1.Type.REAL:
        rval += ' (Real)';
        break;

      case asn1.Type.ENUMERATED:
        rval += ' (Enumerated)';
        break;

      case asn1.Type.EMBEDDED:
        rval += ' (Embedded PDV)';
        break;

      case asn1.Type.UTF8:
        rval += ' (UTF8)';
        break;

      case asn1.Type.ROID:
        rval += ' (Relative Object Identifier)';
        break;

      case asn1.Type.SEQUENCE:
        rval += ' (Sequence)';
        break;

      case asn1.Type.SET:
        rval += ' (Set)';
        break;

      case asn1.Type.PRINTABLESTRING:
        rval += ' (Printable String)';
        break;

      case asn1.Type.IA5String:
        rval += ' (IA5String (ASCII))';
        break;

      case asn1.Type.UTCTIME:
        rval += ' (UTC time)';
        break;

      case asn1.Type.GENERALIZEDTIME:
        rval += ' (Generalized time)';
        break;

      case asn1.Type.BMPSTRING:
        rval += ' (BMP String)';
        break;
    }
  } else {
    rval += obj.type;
  }

  rval += '\n';
  rval += indent + 'Constructed: ' + obj.constructed + '\n';

  if (obj.composed) {
    var subvalues = 0;
    var sub = '';

    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== undefined) {
        subvalues += 1;
        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);

        if (i + 1 < obj.value.length) {
          sub += ',';
        }
      }
    }

    rval += indent + 'Sub values: ' + subvalues + sub;
  } else {
    rval += indent + 'Value: ';

    if (obj.type === asn1.Type.OID) {
      var oid = asn1.derToOid(obj.value);
      rval += oid;

      if (forge.pki && forge.pki.oids) {
        if (oid in forge.pki.oids) {
          rval += ' (' + forge.pki.oids[oid] + ') ';
        }
      }
    }

    if (obj.type === asn1.Type.INTEGER) {
      try {
        rval += asn1.derToInteger(obj.value);
      } catch (ex) {
        rval += '0x' + forge.util.bytesToHex(obj.value);
      }
    } else if (obj.type === asn1.Type.BITSTRING) {
      // TODO: shift bits as needed to display without padding
      if (obj.value.length > 1) {
        // remove unused bits field
        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += '(none)';
      } // show unused bit count


      if (obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);

        if (unused == 1) {
          rval += ' (1 unused bit shown)';
        } else if (unused > 1) {
          rval += ' (' + unused + ' unused bits shown)';
        }
      }
    } else if (obj.type === asn1.Type.OCTETSTRING) {
      if (!_nonLatinRegex.test(obj.value)) {
        rval += '(' + obj.value + ') ';
      }

      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if (obj.type === asn1.Type.UTF8) {
      rval += forge.util.decodeUtf8(obj.value);
    } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
      rval += obj.value;
    } else if (_nonLatinRegex.test(obj.value)) {
      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if (obj.value.length === 0) {
      rval += '[null]';
    } else {
      rval += obj.value;
    }
  }

  return rval;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js","./oids":"node_modules/node-forge/lib/oids.js"}],"node_modules/node-forge/lib/cipher.js":[function(require,module,exports) {
/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

module.exports = forge.cipher = forge.cipher || {}; // registered algorithms

forge.cipher.algorithms = forge.cipher.algorithms || {};
/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */

forge.cipher.createCipher = function (algorithm, key) {
  var api = algorithm;

  if (typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);

    if (api) {
      api = api();
    }
  }

  if (!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  } // assume block cipher


  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: false
  });
};
/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */


forge.cipher.createDecipher = function (algorithm, key) {
  var api = algorithm;

  if (typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);

    if (api) {
      api = api();
    }
  }

  if (!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  } // assume block cipher


  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: true
  });
};
/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */


forge.cipher.registerAlgorithm = function (name, algorithm) {
  name = name.toUpperCase();
  forge.cipher.algorithms[name] = algorithm;
};
/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */


forge.cipher.getAlgorithm = function (name) {
  name = name.toUpperCase();

  if (name in forge.cipher.algorithms) {
    return forge.cipher.algorithms[name];
  }

  return null;
};

var BlockCipher = forge.cipher.BlockCipher = function (options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};
/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */


BlockCipher.prototype.start = function (options) {
  options = options || {};
  var opts = {};

  for (var key in options) {
    opts[key] = options[key];
  }

  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge.util.createBuffer();
  this.output = options.output || forge.util.createBuffer();
  this.mode.start(opts);
};
/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */


BlockCipher.prototype.update = function (input) {
  if (input) {
    // input given, so empty it into the input buffer
    this._input.putBuffer(input);
  } // do cipher operation until it needs more input and not finished


  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {} // free consumed memory from input buffer


  this._input.compact();
};
/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */


BlockCipher.prototype.finish = function (pad) {
  // backwards-compatibility w/deprecated padding API
  // Note: will overwrite padding functions even after another start() call
  if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
    this.mode.pad = function (input) {
      return pad(this.blockSize, input, false);
    };

    this.mode.unpad = function (output) {
      return pad(this.blockSize, output, true);
    };
  } // build options for padding and afterFinish functions


  var options = {};
  options.decrypt = this._decrypt; // get # of bytes that won't fill a block

  options.overflow = this._input.length() % this.blockSize;

  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options)) {
      return false;
    }
  } // do final update


  this._finish = true;
  this.update();

  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }

  return true;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/cipherModes.js":[function(require,module,exports) {
/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

forge.cipher = forge.cipher || {}; // supported cipher modes

var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
/** Electronic codebook (ECB) (Don't use this; it's not secure) **/

modes.ecb = function (options) {
  options = options || {};
  this.name = 'ECB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.ecb.prototype.start = function (options) {};

modes.ecb.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  } // get next block


  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  } // encrypt block


  this.cipher.encrypt(this._inBlock, this._outBlock); // write output

  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.decrypt = function (input, output, finish) {
  // not enough input to decrypt
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  } // get next block


  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  } // decrypt block


  this.cipher.decrypt(this._inBlock, this._outBlock); // write output

  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.pad = function (input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};

modes.ecb.prototype.unpad = function (output, options) {
  // check for error: input data not a multiple of blockSize
  if (options.overflow > 0) {
    return false;
  } // ensure padding byte count is valid


  var len = output.length();
  var count = output.at(len - 1);

  if (count > this.blockSize << 2) {
    return false;
  } // trim off padding bytes


  output.truncate(count);
  return true;
};
/** Cipher-block Chaining (CBC) **/


modes.cbc = function (options) {
  options = options || {};
  this.name = 'CBC';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.cbc.prototype.start = function (options) {
  // Note: legacy support for using IV residue (has security flaws)
  // if IV is null, reuse block from previous processing
  if (options.iv === null) {
    // must have a previous block
    if (!this._prev) {
      throw new Error('Invalid IV parameter.');
    }

    this._iv = this._prev.slice(0);
  } else if (!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } else {
    // save IV as "previous" block
    this._iv = transformIV(options.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};

modes.cbc.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  } // get next block
  // CBC XOR's IV (or previous block) with plaintext


  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  } // encrypt block


  this.cipher.encrypt(this._inBlock, this._outBlock); // write output, save previous block

  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }

  this._prev = this._outBlock;
};

modes.cbc.prototype.decrypt = function (input, output, finish) {
  // not enough input to decrypt
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  } // get next block


  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  } // decrypt block


  this.cipher.decrypt(this._inBlock, this._outBlock); // write output, save previous ciphered block
  // CBC XOR's IV (or previous block) with ciphertext

  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }

  this._prev = this._inBlock.slice(0);
};

modes.cbc.prototype.pad = function (input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};

modes.cbc.prototype.unpad = function (output, options) {
  // check for error: input data not a multiple of blockSize
  if (options.overflow > 0) {
    return false;
  } // ensure padding byte count is valid


  var len = output.length();
  var count = output.at(len - 1);

  if (count > this.blockSize << 2) {
    return false;
  } // trim off padding bytes


  output.truncate(count);
  return true;
};
/** Cipher feedback (CFB) **/


modes.cfb = function (options) {
  options = options || {};
  this.name = 'CFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.cfb.prototype.start = function (options) {
  if (!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } // use IV as first input


  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.cfb.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();

  if (inputLength === 0) {
    return true;
  } // encrypt block


  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block

  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }

    return;
  } // handle partial block


  var partialBytes = (this.blockSize - inputLength) % this.blockSize;

  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  } // XOR input with output, write input as partial output


  this._partialOutput.clear();

  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];

    this._partialOutput.putInt32(this._partialBlock[i]);
  }

  if (partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  } // skip any previous partial bytes


  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.cfb.prototype.decrypt = function (input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();

  if (inputLength === 0) {
    return true;
  } // encrypt block (CFB always uses encryption mode)


  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block

  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }

    return;
  } // handle partial block


  var partialBytes = (this.blockSize - inputLength) % this.blockSize;

  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  } // XOR input with output, write input as partial output


  this._partialOutput.clear();

  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();

    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }

  if (partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  } // skip any previous partial bytes


  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
/** Output feedback (OFB) **/


modes.ofb = function (options) {
  options = options || {};
  this.name = 'OFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ofb.prototype.start = function (options) {
  if (!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } // use IV as first input


  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ofb.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();

  if (input.length() === 0) {
    return true;
  } // encrypt block (OFB always uses encryption mode)


  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block

  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output and update next input
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }

    return;
  } // handle partial block


  var partialBytes = (this.blockSize - inputLength) % this.blockSize;

  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  } // XOR input with output


  this._partialOutput.clear();

  for (var i = 0; i < this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }

  if (partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  } // skip any previous partial bytes


  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
/** Counter (CTR) **/

modes.ctr = function (options) {
  options = options || {};
  this.name = 'CTR';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ctr.prototype.start = function (options) {
  if (!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } // use IV as first input


  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ctr.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();

  if (inputLength === 0) {
    return true;
  } // encrypt block (CTR always uses encryption mode)


  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block

  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;

    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    } // XOR input with output


    this._partialOutput.clear();

    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if (partialBytes > 0) {
      // block still incomplete, restore input buffer
      input.read -= this.blockSize;
    } // skip any previous partial bytes


    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  } // block complete, increment counter (input block)


  inc32(this._inBlock);
};

modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
/** Galois/Counter Mode (GCM) **/

modes.gcm = function (options) {
  options = options || {};
  this.name = 'GCM';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0; // R is actually this value concatenated with 120 more zero bits, but
  // we only XOR against R so the other zeros have no effect -- we just
  // apply this value to the first integer in a block

  this._R = 0xE1000000;
};

modes.gcm.prototype.start = function (options) {
  if (!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } // ensure IV is a byte buffer


  var iv = forge.util.createBuffer(options.iv); // no ciphered data processed yet

  this._cipherLength = 0; // default additional data is none

  var additionalData;

  if ('additionalData' in options) {
    additionalData = forge.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge.util.createBuffer();
  } // default tag length is 128 bits


  if ('tagLength' in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  } // if tag is given, ensure tag matches tag length


  this._tag = null;

  if (options.decrypt) {
    // save tag to check later
    this._tag = forge.util.createBuffer(options.tag).getBytes();

    if (this._tag.length !== this._tagLength / 8) {
      throw new Error('Authentication tag does not match tag length.');
    }
  } // create tmp storage for hash calculation


  this._hashBlock = new Array(this._ints); // no tag generated yet

  this.tag = null; // generate hash subkey
  // (apply block cipher to "zero" block)

  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey); // generate table M
  // use 4-bit tables (32 component decomposition of a 16 byte value)
  // 8-bit tables take more space and are known to have security
  // vulnerabilities (in native implementations)

  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits); // Note: support IV length different from 96 bits? (only supporting
  // 96 bits is recommended by NIST SP-800-38D)
  // generate J_0

  var ivLength = iv.length();

  if (ivLength === 12) {
    // 96-bit IV
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    // IV is NOT 96-bits
    this._j0 = [0, 0, 0, 0];

    while (iv.length() > 0) {
      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }

    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
  } // generate ICB (initial counter block)


  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0; // consume authentication data

  additionalData = forge.util.createBuffer(additionalData); // save additional data length as a BE 64-bit number

  this._aDataLength = from64To32(additionalData.length() * 8); // pad additional data to 128 bit (16 byte) block size

  var overflow = additionalData.length() % this.blockSize;

  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }

  this._s = [0, 0, 0, 0];

  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
  }
};

modes.gcm.prototype.encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();

  if (inputLength === 0) {
    return true;
  } // encrypt block


  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block

  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }

    this._cipherLength += this.blockSize;
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;

    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    } // XOR input with output


    this._partialOutput.clear();

    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if (partialBytes <= 0 || finish) {
      // handle overflow prior to hashing
      if (finish) {
        // get block overflow
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow; // truncate for hash function

        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      } // get output block for hashing


      for (var i = 0; i < this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }

      this._partialOutput.read -= this.blockSize;
    } // skip any previous partial bytes


    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if (partialBytes > 0 && !finish) {
      // block still incomplete, restore input buffer, get partial output,
      // and return early
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  } // update hash block S


  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock); // increment counter (input block)

  inc32(this._inBlock);
};

modes.gcm.prototype.decrypt = function (input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();

  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
    return true;
  } // encrypt block (GCM always uses encryption mode)


  this.cipher.encrypt(this._inBlock, this._outBlock); // increment counter (input block)

  inc32(this._inBlock); // update hash block S

  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock); // XOR hash input with output

  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  } // increment cipher data length


  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};

modes.gcm.prototype.afterFinish = function (output, options) {
  var rval = true; // handle overflow

  if (options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  } // handle authentication tag


  this.tag = forge.util.createBuffer(); // concatenate additional data length with cipher length

  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8)); // include lengths in hash


  this._s = this.ghash(this._hashSubkey, this._s, lengths); // do GCTR(J_0, S)

  var tag = [];
  this.cipher.encrypt(this._j0, tag);

  for (var i = 0; i < this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  } // trim tag to length


  this.tag.truncate(this.tag.length() % (this._tagLength / 8)); // check authentication tag

  if (options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }

  return rval;
};
/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */


modes.gcm.prototype.multiply = function (x, y) {
  var z_i = [0, 0, 0, 0];
  var v_i = y.slice(0); // calculate Z_128 (block has 128 bits)

  for (var i = 0; i < 128; ++i) {
    // if x_i is 0, Z_{i+1} = Z_i (unchanged)
    // else Z_{i+1} = Z_i ^ V_i
    // get x_i by finding 32-bit int position, then left shift 1 by remainder
    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;

    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    } // if LSB(V_i) is 1, V_i = V_i >> 1
    // else V_i = (V_i >> 1) ^ R


    this.pow(v_i, v_i);
  }

  return z_i;
};

modes.gcm.prototype.pow = function (x, out) {
  // if LSB(x) is 1, x = x >>> 1
  // else x = (x >>> 1) ^ R
  var lsb = x[3] & 1; // always do x >>> 1:
  // starting with the rightmost integer, shift each integer to the right
  // one bit, pulling in the bit from the integer to the left as its top
  // most bit (do this for the last 3 integers)

  for (var i = 3; i > 0; --i) {
    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
  } // shift the first integer normally


  out[0] = x[0] >>> 1; // if lsb was not set, then polynomial had a degree of 127 and doesn't
  // need to divided; otherwise, XOR with R to find the remainder; we only
  // need to XOR the first integer since R technically ends w/120 zero bits

  if (lsb) {
    out[0] ^= this._R;
  }
};

modes.gcm.prototype.tableMultiply = function (x) {
  // assumes 4-bit tables are used
  var z = [0, 0, 0, 0];

  for (var i = 0; i < 32; ++i) {
    var idx = i / 8 | 0;
    var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;
    var ah = this._m[i][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }

  return z;
};
/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */


modes.gcm.prototype.ghash = function (h, y, x) {
  y[0] ^= x[0];
  y[1] ^= x[1];
  y[2] ^= x[2];
  y[3] ^= x[3];
  return this.tableMultiply(y); //return this.multiply(y, h);
};
/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */


modes.gcm.prototype.generateHashTable = function (h, bits) {
  // TODO: There are further optimizations that would use only the
  // first table M_0 (or some variant) along with a remainder table;
  // this can be explored in the future
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m = new Array(size);

  for (var i = 0; i < size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = i / perInt | 0;
    var shft = (perInt - 1 - i % perInt) * bits;
    tmp[idx] = 1 << bits - 1 << shft;
    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
  }

  return m;
};
/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */


modes.gcm.prototype.generateSubHashTable = function (mid, bits) {
  // compute the table quickly by minimizing the number of
  // POW operations -- they only need to be performed for powers of 2,
  // all other entries can be composed from those powers using XOR
  var size = 1 << bits;
  var half = size >>> 1;
  var m = new Array(size);
  m[half] = mid.slice(0);
  var i = half >>> 1;

  while (i > 0) {
    // raise m0[2 * i] and store in m0[i]
    this.pow(m[2 * i], m[i] = []);
    i >>= 1;
  }

  i = 2;

  while (i < half) {
    for (var j = 1; j < i; ++j) {
      var m_i = m[i];
      var m_j = m[j];
      m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
    }

    i *= 2;
  }

  m[0] = [0, 0, 0, 0];
  /* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */

  for (i = half + 1; i < size; ++i) {
    var c = m[i ^ half];
    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }

  return m;
};
/** Utility functions */


function transformIV(iv, blockSize) {
  if (typeof iv === 'string') {
    // convert iv string into byte buffer
    iv = forge.util.createBuffer(iv);
  }

  if (forge.util.isArray(iv) && iv.length > 4) {
    // convert iv byte array into byte buffer
    var tmp = iv;
    iv = forge.util.createBuffer();

    for (var i = 0; i < tmp.length; ++i) {
      iv.putByte(tmp[i]);
    }
  }

  if (iv.length() < blockSize) {
    throw new Error('Invalid IV length; got ' + iv.length() + ' bytes and expected ' + blockSize + ' bytes.');
  }

  if (!forge.util.isArray(iv)) {
    // convert iv byte buffer into 32-bit integer array
    var ints = [];
    var blocks = blockSize / 4;

    for (var i = 0; i < blocks; ++i) {
      ints.push(iv.getInt32());
    }

    iv = ints;
  }

  return iv;
}

function inc32(block) {
  // increment last 32 bits of block only
  block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;
}

function from64To32(num) {
  // convert 64-bit number to two BE Int32s
  return [num / 0x100000000 | 0, num & 0xFFFFFFFF];
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/aes.js":[function(require,module,exports) {
/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./cipher');

require('./cipherModes');

require('./util');
/* AES API */


module.exports = forge.aes = forge.aes || {};
/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */

forge.aes.startEncrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode
  });

  cipher.start(iv);
  return cipher;
};
/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


forge.aes.createEncryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};
/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


forge.aes.startDecrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode
  });

  cipher.start(iv);
  return cipher;
};
/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


forge.aes.createDecryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};
/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */


forge.aes.Algorithm = function (name, mode) {
  if (!init) {
    initialize();
  }

  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function (inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function (inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};
/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */


forge.aes.Algorithm.prototype.initialize = function (options) {
  if (this._init) {
    return;
  }

  var key = options.key;
  var tmp;
  /* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */

  if (typeof key === 'string' && (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key string into byte buffer
    key = forge.util.createBuffer(key);
  } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key integer array into byte buffer
    tmp = key;
    key = forge.util.createBuffer();

    for (var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  } // convert key byte buffer into 32-bit integer array


  if (!forge.util.isArray(key)) {
    tmp = key;
    key = []; // key lengths of 16, 24, 32 bytes allowed

    var len = tmp.length();

    if (len === 16 || len === 24 || len === 32) {
      len = len >>> 2;

      for (var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  } // key must be an array of 32-bit integers by now


  if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error('Invalid key parameter.');
  } // encryption operation is always used for these modes


  var mode = this.mode.name;
  var encryptOp = ['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1; // do key expansion

  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};
/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */


forge.aes._expandKey = function (key, decrypt) {
  if (!init) {
    initialize();
  }

  return _expandKey(key, decrypt);
};
/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */


forge.aes._updateBlock = _updateBlock;
/** Register AES algorithms **/

registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function () {
    return new forge.aes.Algorithm(name, mode);
  };

  forge.cipher.registerAlgorithm(name, factory);
}
/** AES implementation **/


var init = false; // not yet initialized

var Nb = 4; // number of words comprising the state (AES = 4)

var sbox; // non-linear substitution table used in key expansion

var isbox; // inversion of sbox

var rcon; // round constant word array

var mix; // mix-columns table

var imix; // inverse mix-columns table

/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */

function initialize() {
  init = true;
  /* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.
     rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36
     We only store the first byte because it is the only one used.
  */

  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]; // compute xtime table which maps i onto GF(i, 0x02)

  var xtime = new Array(256);

  for (var i = 0; i < 128; ++i) {
    xtime[i] = i << 1;
    xtime[i + 128] = i + 128 << 1 ^ 0x11B;
  } // compute all other tables


  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);

  for (var i = 0; i < 4; ++i) {
    mix[i] = new Array(256);
    imix[i] = new Array(256);
  }

  var e = 0,
      ei = 0,
      e2,
      e4,
      e8,
      sx,
      sx2,
      me,
      ime;

  for (var i = 0; i < 256; ++i) {
    /* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:
       bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.
       It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.
       On each iteration we can determine the multiplicative inverse for
      the current element.
       Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.
       In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:
       s = 01000001
      x = 01000001
       iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63
       This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.
       At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */
    // apply affine transformation
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 0x63; // update tables

    sbox[e] = sx;
    isbox[sx] = e;
    /* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:
       [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]
       r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:
       r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c
       As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.
       To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.
       Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.
       There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.
       When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */
    // calculate mix and imix table values

    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2); // 3

    ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
    (e ^ e8) << 16 ^ // 9
    (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8); // B (11)
    // produce each of the mix tables by rotating the 2,1,1,3 value

    for (var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime; // cycle the right most byte to the left most position
      // ie: 2,1,1,3 becomes 3,2,1,1

      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    } // get next element and inverse


    if (e === 0) {
      // 1 is the inverse of 1
      e = ei = 1;
    } else {
      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0 <= i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */


function _expandKey(key, decrypt) {
  // copy the key's words to initialize the key schedule
  var w = key.slice(0);
  /* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).
     We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */
  // go through the rounds expanding the key

  var temp,
      iNk = 1;
  var Nk = w.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;

  for (var i = Nk; i < end; ++i) {
    temp = w[i - 1];

    if (i % Nk === 0) {
      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i % Nk === 4) {
      // temp = SubWord(temp)
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
    }

    w[i] = w[i - Nk] ^ temp;
  }
  /* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:
      1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.
      We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.
      The second case requires a little work.
      The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.
      To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.
      This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.
      We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */


  if (decrypt) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w.slice(0);
    end = w.length;

    for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      // do not sub the first or last round key (round keys are Nb
      // words) as no column mixing is performed before they are added,
      // but do change the key order
      if (i === 0 || i === end - Nb) {
        wnew[i] = w[wi];
        wnew[i + 1] = w[wi + 3];
        wnew[i + 2] = w[wi + 2];
        wnew[i + 3] = w[wi + 1];
      } else {
        // substitute each round key byte because the inverse-mix
        // table will inverse-substitute it (effectively cancel the
        // substitution because round key bytes aren't sub'd in
        // decryption mode) and swap indexes 3 and 1
        for (var n = 0; n < Nb; ++n) {
          tmp = w[wi + n];
          wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
        }
      }
    }

    w = wnew;
  }

  return w;
}
/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */


function _updateBlock(w, input, output, decrypt) {
  /*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr-1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end
   InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */
  // Encrypt: AddRoundKey(state, w[0, Nb-1])
  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;

  if (decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }

  var a, b, c, d, a2, b2, c2;
  a = input[0] ^ w[0];
  b = input[decrypt ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt ? 1 : 3] ^ w[3];
  var i = 3;
  /* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */

  for (var round = 1; round < Nr; ++round) {
    /* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:
                m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0
       So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:
       m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]
       Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
       However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.
       s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.
       This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:
       r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]
       We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):
       c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)
       Therefore:
       c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3
       c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0
       ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.
       When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:
       c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0
       If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.
       If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:
       r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c
       If we did the same in decryption mode we would get:
       r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a
       If instead we swap d and b (set b=c3 and d=c1), then we get:
       r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a
       Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */
    a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
    b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
    c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
    d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
    a = a2;
    b = b2;
    c = c2;
  }
  /*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
     Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */
  // Note: rows are shifted inline


  output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
  output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
  output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
  output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
}
/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'AES-' + mode;
  var cipher;

  if (options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  } // backwards compatible start API


  var start = cipher.start;

  cipher.start = function (iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;

    if (options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }

    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./cipher":"node_modules/node-forge/lib/cipher.js","./cipherModes":"node_modules/node-forge/lib/cipherModes.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/des.js":[function(require,module,exports) {
/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by
 * Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./cipher');

require('./cipherModes');

require('./util');
/* DES API */


module.exports = forge.des = forge.des || {};
/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */

forge.des.startEncrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });

  cipher.start(iv);
  return cipher;
};
/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


forge.des.createEncryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};
/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */


forge.des.startDecrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });

  cipher.start(iv);
  return cipher;
};
/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


forge.des.createDecryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};
/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */


forge.des.Algorithm = function (name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function (inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function (inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};
/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */


forge.des.Algorithm.prototype.initialize = function (options) {
  if (this._init) {
    return;
  }

  var key = forge.util.createBuffer(options.key);

  if (this.name.indexOf('3DES') === 0) {
    if (key.length() !== 24) {
      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
    }
  } // do key expansion to 16 or 48 subkeys (single or triple DES)


  this._keys = _createKeys(key);
  this._init = true;
};
/** Register DES algorithms **/


registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);

function registerAlgorithm(name, mode) {
  var factory = function () {
    return new forge.des.Algorithm(name, mode);
  };

  forge.cipher.registerAlgorithm(name, factory);
}
/** DES implementation **/


var spfunction1 = [0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004];
var spfunction2 = [-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000];
var spfunction3 = [0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200];
var spfunction4 = [0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080];
var spfunction5 = [0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100];
var spfunction6 = [0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010];
var spfunction7 = [0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002];
var spfunction8 = [0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000];
/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */

function _createKeys(key) {
  var pc2bytes0 = [0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204],
      pc2bytes1 = [0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101],
      pc2bytes2 = [0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808],
      pc2bytes3 = [0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000],
      pc2bytes4 = [0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010],
      pc2bytes5 = [0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420],
      pc2bytes6 = [0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002],
      pc2bytes7 = [0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800],
      pc2bytes8 = [0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002],
      pc2bytes9 = [0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408],
      pc2bytes10 = [0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020],
      pc2bytes11 = [0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200],
      pc2bytes12 = [0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010],
      pc2bytes13 = [0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105]; // how many iterations (1 for des, 3 for triple des)
  // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys

  var iterations = key.length() > 8 ? 3 : 1; // stores the return keys

  var keys = []; // now define the left shifts which need to be done

  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n = 0,
      tmp;

  for (var j = 0; j < iterations; j++) {
    var left = key.getInt32();
    var right = key.getInt32();
    tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 0x33333333;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 0x55555555;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 0x00ff00ff;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 0x55555555;
    right ^= tmp;
    left ^= tmp << 1; // right needs to be shifted and OR'd with last four bits of left

    tmp = left << 8 | right >>> 20 & 0x000000f0; // left needs to be put upside down

    left = right << 24 | right << 8 & 0xff0000 | right >>> 8 & 0xff00 | right >>> 24 & 0xf0;
    right = tmp; // now go through and perform these shifts on the left and right keys

    for (var i = 0; i < shifts.length; ++i) {
      //shift the keys either one or two bits to the left
      if (shifts[i]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }

      left &= -0xf;
      right &= -0xf; // now apply PC-2, in such a way that E is easier when encrypting or
      // decrypting this conversion will look like PC-2 except only the last 6
      // bits of each byte are used rather than 48 consecutive bits and the
      // order of lines will be according to how the S selection functions will
      // be applied: S2, S4, S6, S8, S1, S3, S5, S7

      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 0xf] | pc2bytes2[left >>> 20 & 0xf] | pc2bytes3[left >>> 16 & 0xf] | pc2bytes4[left >>> 12 & 0xf] | pc2bytes5[left >>> 8 & 0xf] | pc2bytes6[left >>> 4 & 0xf];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 0xf] | pc2bytes9[right >>> 20 & 0xf] | pc2bytes10[right >>> 16 & 0xf] | pc2bytes11[right >>> 12 & 0xf] | pc2bytes12[right >>> 8 & 0xf] | pc2bytes13[right >>> 4 & 0xf];
      tmp = (righttmp >>> 16 ^ lefttmp) & 0x0000ffff;
      keys[n++] = lefttmp ^ tmp;
      keys[n++] = righttmp ^ tmp << 16;
    }
  }

  return keys;
}
/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */


function _updateBlock(keys, input, output, decrypt) {
  // set up loops for single or triple DES
  var iterations = keys.length === 32 ? 3 : 9;
  var looping;

  if (iterations === 3) {
    looping = decrypt ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }

  var tmp;
  var left = input[0];
  var right = input[1]; // first each 64 bit chunk of the message must be permuted according to IP

  tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 0x33333333;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 0x55555555;
  right ^= tmp;
  left ^= tmp << 1; // rotate left 1 bit

  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;

  for (var j = 0; j < iterations; j += 3) {
    var endloop = looping[j + 1];
    var loopinc = looping[j + 2]; // now go through and perform the encryption or decryption

    for (var i = looping[j]; i != endloop; i += loopinc) {
      var right1 = right ^ keys[i];
      var right2 = (right >>> 4 | right << 28) ^ keys[i + 1]; // passing these bytes through the S selection functions

      tmp = left;
      left = right;
      right = tmp ^ (spfunction2[right1 >>> 24 & 0x3f] | spfunction4[right1 >>> 16 & 0x3f] | spfunction6[right1 >>> 8 & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[right2 >>> 24 & 0x3f] | spfunction3[right2 >>> 16 & 0x3f] | spfunction5[right2 >>> 8 & 0x3f] | spfunction7[right2 & 0x3f]);
    } // unreverse left and right


    tmp = left;
    left = right;
    right = tmp;
  } // rotate right 1 bit


  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31; // now perform IP-1, which is IP in the opposite direction

  tmp = (left >>> 1 ^ right) & 0x55555555;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 0x33333333;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */


function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'DES-' + mode;
  var cipher;

  if (options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  } // backwards compatible start API


  var start = cipher.start;

  cipher.start = function (iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;

    if (options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }

    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./cipher":"node_modules/node-forge/lib/cipher.js","./cipherModes":"node_modules/node-forge/lib/cipherModes.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/md.js":[function(require,module,exports) {
/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */
var forge = require('./forge');

module.exports = forge.md = forge.md || {};
forge.md.algorithms = forge.md.algorithms || {};
},{"./forge":"node_modules/node-forge/lib/forge.js"}],"node_modules/node-forge/lib/hmac.js":[function(require,module,exports) {
/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */
var forge = require('./forge');

require('./md');

require('./util');
/* HMAC API */


var hmac = module.exports = forge.hmac = forge.hmac || {};
/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */

hmac.create = function () {
  // the hmac key to use
  var _key = null; // the message digest to use

  var _md = null; // the inner padding

  var _ipadding = null; // the outer padding

  var _opadding = null; // hmac context

  var ctx = {};
  /**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */

  ctx.start = function (md, key) {
    if (md !== null) {
      if (typeof md === 'string') {
        // create builtin message digest
        md = md.toLowerCase();

        if (md in forge.md.algorithms) {
          _md = forge.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        // store message digest
        _md = md;
      }
    }

    if (key === null) {
      // reuse previous key
      key = _key;
    } else {
      if (typeof key === 'string') {
        // convert string into byte buffer
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key)) {
        // convert byte array into byte buffer
        var tmp = key;
        key = forge.util.createBuffer();

        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      } // if key is longer than blocksize, hash it


      var keylen = key.length();

      if (keylen > _md.blockLength) {
        _md.start();

        _md.update(key.bytes());

        key = _md.digest();
      } // mix key into inner and outer padding
      // ipadding = [0x36 * blocksize] ^ key
      // opadding = [0x5C * blocksize] ^ key


      _ipadding = forge.util.createBuffer();
      _opadding = forge.util.createBuffer();
      keylen = key.length();

      for (var i = 0; i < keylen; ++i) {
        var tmp = key.at(i);

        _ipadding.putByte(0x36 ^ tmp);

        _opadding.putByte(0x5C ^ tmp);
      } // if key is shorter than blocksize, add additional padding


      if (keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;

        for (var i = 0; i < tmp; ++i) {
          _ipadding.putByte(0x36);

          _opadding.putByte(0x5C);
        }
      }

      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    } // digest is done like so: hash(opadding | hash(ipadding | message))
    // prepare to do inner hash
    // hash(ipadding | message)


    _md.start();

    _md.update(_ipadding);
  };
  /**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */


  ctx.update = function (bytes) {
    _md.update(bytes);
  };
  /**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */


  ctx.getMac = function () {
    // digest is done like so: hash(opadding | hash(ipadding | message))
    // here we do the outer hashing
    var inner = _md.digest().bytes();

    _md.start();

    _md.update(_opadding);

    _md.update(inner);

    return _md.digest();
  }; // alias for getMac


  ctx.digest = ctx.getMac;
  return ctx;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./md":"node_modules/node-forge/lib/md.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/pbkdf2.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./hmac');

require('./md');

require('./util');

var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
var crypto;

if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
  crypto = require('crypto');
}
/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */


module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function (p, s, c, dkLen, md, callback) {
  if (typeof md === 'function') {
    callback = md;
    md = null;
  } // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed


  if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || _typeof(md) !== 'object') && (crypto.pbkdf2Sync.length > 4 || !md || md === 'sha1')) {
    if (typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }

    p = Buffer.from(p, 'binary');
    s = Buffer.from(s, 'binary');

    if (!callback) {
      if (crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }

      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }

    if (crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function (err, key) {
        if (err) {
          return callback(err);
        }

        callback(null, key.toString('binary'));
      });
    }

    return crypto.pbkdf2(p, s, c, dkLen, md, function (err, key) {
      if (err) {
        return callback(err);
      }

      callback(null, key.toString('binary'));
    });
  }

  if (typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }

  if (typeof md === 'string') {
    if (!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }

    md = forge.md[md].create();
  }

  var hLen = md.digestLength;
  /* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */

  if (dkLen > 0xFFFFFFFF * hLen) {
    var err = new Error('Derived key is too long.');

    if (callback) {
      return callback(err);
    }

    throw err;
  }
  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:
     len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */


  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;
  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:
     T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),
     where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:
     F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c
     where
     u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).
     Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */

  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1; // sync version

  if (!callback) {
    for (var i = 1; i <= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes(); // PRF(P, u_{c-1}) (other iterations)

      for (var j = 2; j <= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes(); // F(p, s, c, i)

        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }
      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:
         DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */


      dk += i < len ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */


    return dk;
  } // async version


  var i = 1,
      j;

  function outer() {
    if (i > len) {
      // done
      return callback(null, dk);
    } // PRF(P, S || INT(i)) (first iteration)


    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes(); // PRF(P, u_{c-1}) (other iterations)

    j = 2;
    inner();
  }

  function inner() {
    if (j <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes(); // F(p, s, c, i)

      xor = forge.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j;
      return forge.util.setImmediate(inner);
    }
    /* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:
       DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */


    dk += i < len ? xor : xor.substr(0, r);
    ++i;
    outer();
  }

  outer();
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./hmac":"node_modules/node-forge/lib/hmac.js","./md":"node_modules/node-forge/lib/md.js","./util":"node_modules/node-forge/lib/util.js","crypto":"node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/node-forge/lib/pem.js":[function(require,module,exports) {
/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */
var forge = require('./forge');

require('./util'); // shortcut for pem API


var pem = module.exports = forge.pem = forge.pem || {};
/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */

pem.encode = function (msg, options) {
  options = options || {};
  var rval = '-----BEGIN ' + msg.type + '-----\r\n'; // encode special headers

  var header;

  if (msg.procType) {
    header = {
      name: 'Proc-Type',
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header);
  }

  if (msg.contentDomain) {
    header = {
      name: 'Content-Domain',
      values: [msg.contentDomain]
    };
    rval += foldHeader(header);
  }

  if (msg.dekInfo) {
    header = {
      name: 'DEK-Info',
      values: [msg.dekInfo.algorithm]
    };

    if (msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }

    rval += foldHeader(header);
  }

  if (msg.headers) {
    // encode all other headers
    for (var i = 0; i < msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  } // terminate header


  if (msg.procType) {
    rval += '\r\n';
  } // add body


  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';
  rval += '-----END ' + msg.type + '-----\r\n';
  return rval;
};
/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */


pem.decode = function (str) {
  var rval = []; // split string into PEM messages (be lenient w/EOF on BEGIN line)

  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;

  while (true) {
    match = rMessage.exec(str);

    if (!match) {
      break;
    }

    var msg = {
      type: match[1],
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    };
    rval.push(msg); // no headers

    if (!match[2]) {
      continue;
    } // parse headers


    var lines = match[2].split(rCRLF);
    var li = 0;

    while (match && li < lines.length) {
      // get line, trim any rhs whitespace
      var line = lines[li].replace(/\s+$/, ''); // RFC2822 unfold any following folded lines

      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];

        if (!/\s/.test(next[0])) {
          break;
        }

        line += next;
        li = nl;
      } // parse header


      match = line.match(rHeader);

      if (match) {
        var header = {
          name: match[1],
          values: []
        };
        var values = match[2].split(',');

        for (var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        } // Proc-Type must be the first header


        if (!msg.procType) {
          if (header.name !== 'Proc-Type') {
            throw new Error('Invalid PEM formatted message. The first ' + 'encapsulated header must be "Proc-Type".');
          } else if (header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' + 'header must have two subfields.');
          }

          msg.procType = {
            version: values[0],
            type: values[1]
          };
        } else if (!msg.contentDomain && header.name === 'Content-Domain') {
          // special-case Content-Domain
          msg.contentDomain = values[0] || '';
        } else if (!msg.dekInfo && header.name === 'DEK-Info') {
          // special-case DEK-Info
          if (header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must have at least one subfield.');
          }

          msg.dekInfo = {
            algorithm: values[0],
            parameters: values[1] || null
          };
        } else {
          msg.headers.push(header);
        }
      }

      ++li;
    }

    if (msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }

  if (rval.length === 0) {
    throw new Error('Invalid PEM formatted message.');
  }

  return rval;
};

function foldHeader(header) {
  var rval = header.name + ': '; // ensure values with CRLF are folded

  var values = [];

  var insertSpace = function (match, $1) {
    return ' ' + $1;
  };

  for (var i = 0; i < header.values.length; ++i) {
    values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
  }

  rval += values.join(',') + '\r\n'; // do folding

  var length = 0;
  var candidate = -1;

  for (var i = 0; i < rval.length; ++i, ++length) {
    if (length > 65 && candidate !== -1) {
      var insert = rval[candidate];

      if (insert === ',') {
        ++candidate;
        rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + '\r\n' + insert + rval.substr(candidate + 1);
      }

      length = i - candidate - 1;
      candidate = -1;
      ++i;
    } else if (rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
      candidate = i;
    }
  }

  return rval;
}

function ltrim(str) {
  return str.replace(/^\s+/, '');
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/sha256.js":[function(require,module,exports) {
/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */

sha256.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-256 state contains eight 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(64); // message digest object


  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };

  return md;
}; // sha-256 padding bytes not initialized yet


var _padding = null;
var _initialized = false; // table of constants

var _k = null;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // create K table for SHA-256

  _k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 64 32-bit words according to SHA-256
    for (i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32();
    }

    for (; i < 64; ++i) {
      // XOR word 2 words ago rot right 17, rot right 19, shft right 10
      t1 = w[i - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10; // XOR word 15 words ago rot right 7, rot right 18, shft right 3

      t2 = w[i - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3; // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32

      w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
    } // initialize hash value for this chunk


    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;
    f = s.h5;
    g = s.h6;
    h = s.h7; // round function

    for (i = 0; i < 64; ++i) {
      // Sum1(e)
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7); // Ch(e, f, g) (optimized the same way as SHA-1)

      ch = g ^ e & (f ^ g); // Sum0(a)

      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10); // Maj(a, b, c) (optimized the same way as SHA-1)

      maj = a & b | c & (a ^ b); // main algorithm

      t1 = h + s1 + ch + _k[i] + w[i];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      e = d + t1 >>> 0;
      d = c;
      c = b;
      b = a; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      a = t1 + t2 >>> 0;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    s.h5 = s.h5 + f | 0;
    s.h6 = s.h6 + g | 0;
    s.h7 = s.h7 + h | 0;
    len -= 64;
  }
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./md":"node_modules/node-forge/lib/md.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/prng.js":[function(require,module,exports) {
var process = require("process");
/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

var _crypto = null;

if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions['node-webkit']) {
  _crypto = require('crypto');
}
/* PRNG API */


var prng = module.exports = forge.prng = forge.prng || {};
/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */

prng.create = function (plugin) {
  var ctx = {
    plugin: plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ''
  }; // create 32 entropy pools (each is a message digest)

  var md = plugin.md;
  var pools = new Array(32);

  for (var i = 0; i < 32; ++i) {
    pools[i] = md.create();
  }

  ctx.pools = pools; // entropy pools are written to cyclically, starting at index 0

  ctx.pool = 0;
  /**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */

  ctx.generate = function (count, callback) {
    // do synchronously
    if (!callback) {
      return ctx.generateSync(count);
    } // simple generator using counter-based CBC


    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge.util.createBuffer(); // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generate` call

    ctx.key = null;
    generate();

    function generate(err) {
      if (err) {
        return callback(err);
      } // sufficient bytes generated


      if (b.length() >= count) {
        return callback(null, b.getBytes(count));
      } // if amount of data generated is greater than 1 MiB, trigger reseed


      if (ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if (ctx.key === null) {
        // prevent stack overflow
        return forge.util.nextTick(function () {
          _reseed(generate);
        });
      } // generate the random bytes


      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes); // generate bytes for a new key and seed

      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge.util.setImmediate(generate);
    }
  };
  /**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */


  ctx.generateSync = function (count) {
    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed; // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generateSync` call

    ctx.key = null;
    var b = forge.util.createBuffer();

    while (b.length() < count) {
      // if amount of data generated is greater than 1 MiB, trigger reseed
      if (ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if (ctx.key === null) {
        _reseedSync();
      } // generate the random bytes


      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes); // generate bytes for a new key and seed

      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }

    return b.getBytes(count);
  };
  /**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */


  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();

      return callback();
    } // not enough seed data...


    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function (err, bytes) {
      if (err) {
        return callback(err);
      }

      ctx.collect(bytes);

      _seed();

      callback();
    });
  }
  /**
   * Private function that synchronously reseeds a generator.
   */


  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    } // not enough seed data...


    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));

    _seed();
  }
  /**
   * Private function that seeds a generator once enough bytes are available.
   */


  function _seed() {
    // update reseed count
    ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1; // goal is to update `key` via:
    // key = hash(key + s)
    //   where 's' is all collected entropy from selected pools, then...
    // create a plugin-based message digest

    var md = ctx.plugin.md.create(); // consume current key bytes

    md.update(ctx.keyBytes); // digest the entropy of pools whose index k meet the
    // condition 'n mod 2^k == 0' where n is the number of reseeds

    var _2powK = 1;

    for (var k = 0; k < 32; ++k) {
      if (ctx.reseeds % _2powK === 0) {
        md.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }

      _2powK = _2powK << 1;
    } // get digest for key bytes


    ctx.keyBytes = md.digest().getBytes(); // paranoid deviation from Fortuna:
    // update `seed` via `seed = hash(key)`
    // instead of initializing to zero once and only
    // ever incrementing it

    md.start();
    md.update(ctx.keyBytes);
    var seedBytes = md.digest().getBytes(); // update state

    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  /**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */


  function defaultSeedFile(needed) {
    // use window.crypto.getRandomValues strong source of entropy if available
    var getRandomValues = null;
    var globalScope = forge.util.globalScope;

    var _crypto = globalScope.crypto || globalScope.msCrypto;

    if (_crypto && _crypto.getRandomValues) {
      getRandomValues = function (arr) {
        return _crypto.getRandomValues(arr);
      };
    }

    var b = forge.util.createBuffer();

    if (getRandomValues) {
      while (b.length() < needed) {
        // max byte length is 65536 before QuotaExceededError is thrown
        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));

        try {
          getRandomValues(entropy);

          for (var i = 0; i < entropy.length; ++i) {
            b.putInt32(entropy[i]);
          }
        } catch (e) {
          /* only ignore QuotaExceededError */
          if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    } // be sad and add some weak random data


    if (b.length() < needed) {
      /* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 0x010000);

      while (b.length() < needed) {
        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);
        lo += (hi & 0x7FFF) << 16;
        lo += hi >> 15;
        lo = (lo & 0x7FFFFFFF) + (lo >> 31);
        seed = lo & 0xFFFFFFFF; // consume lower 3 bytes of seed

        for (var i = 0; i < 3; ++i) {
          // throw in more pseudo random
          next = seed >>> (i << 3);
          next ^= Math.floor(Math.random() * 0x0100);
          b.putByte(String.fromCharCode(next & 0xFF));
        }
      }
    }

    return b.getBytes(needed);
  } // initialize seed file APIs


  if (_crypto) {
    // use nodejs async API
    ctx.seedFile = function (needed, callback) {
      _crypto.randomBytes(needed, function (err, bytes) {
        if (err) {
          return callback(err);
        }

        callback(null, bytes.toString());
      });
    }; // use nodejs sync API


    ctx.seedFileSync = function (needed) {
      return _crypto.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function (needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e) {
        callback(e);
      }
    };

    ctx.seedFileSync = defaultSeedFile;
  }
  /**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */


  ctx.collect = function (bytes) {
    // iterate over pools distributing entropy cyclically
    var count = bytes.length;

    for (var i = 0; i < count; ++i) {
      ctx.pools[ctx.pool].update(bytes.substr(i, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  /**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */


  ctx.collectInt = function (i, n) {
    var bytes = '';

    for (var x = 0; x < n; x += 8) {
      bytes += String.fromCharCode(i >> x & 0xFF);
    }

    ctx.collect(bytes);
  };
  /**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */


  ctx.registerWorker = function (worker) {
    // worker receives random bytes
    if (worker === self) {
      ctx.seedFile = function (needed, callback) {
        function listener(e) {
          var data = e.data;

          if (data.forge && data.forge.prng) {
            self.removeEventListener('message', listener);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }

        self.addEventListener('message', listener);
        self.postMessage({
          forge: {
            prng: {
              needed: needed
            }
          }
        });
      };
    } else {
      // main thread sends random bytes upon request
      var listener = function (e) {
        var data = e.data;

        if (data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function (err, bytes) {
            worker.postMessage({
              forge: {
                prng: {
                  err: err,
                  bytes: bytes
                }
              }
            });
          });
        }
      }; // TODO: do we need to remove the event listener when the worker dies?


      worker.addEventListener('message', listener);
    }
  };

  return ctx;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js","crypto":"node_modules/parcel-bundler/src/builtins/_empty.js","process":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/node-forge/lib/random.js":[function(require,module,exports) {
/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./aes');

require('./sha256');

require('./prng');

require('./util');

(function () {
  // forge.random already defined
  if (forge.random && forge.random.getBytes) {
    module.exports = forge.random;
    return;
  }

  (function (jQuery) {
    // the default prng plugin, uses AES-128
    var prng_aes = {};

    var _prng_aes_output = new Array(4);

    var _prng_aes_buffer = forge.util.createBuffer();

    prng_aes.formatKey = function (key) {
      // convert the key into 32-bit integers
      var tmp = forge.util.createBuffer(key);
      key = new Array(4);
      key[0] = tmp.getInt32();
      key[1] = tmp.getInt32();
      key[2] = tmp.getInt32();
      key[3] = tmp.getInt32(); // return the expanded key

      return forge.aes._expandKey(key, false);
    };

    prng_aes.formatSeed = function (seed) {
      // convert seed into 32-bit integers
      var tmp = forge.util.createBuffer(seed);
      seed = new Array(4);
      seed[0] = tmp.getInt32();
      seed[1] = tmp.getInt32();
      seed[2] = tmp.getInt32();
      seed[3] = tmp.getInt32();
      return seed;
    };

    prng_aes.cipher = function (key, seed) {
      forge.aes._updateBlock(key, seed, _prng_aes_output, false);

      _prng_aes_buffer.putInt32(_prng_aes_output[0]);

      _prng_aes_buffer.putInt32(_prng_aes_output[1]);

      _prng_aes_buffer.putInt32(_prng_aes_output[2]);

      _prng_aes_buffer.putInt32(_prng_aes_output[3]);

      return _prng_aes_buffer.getBytes();
    };

    prng_aes.increment = function (seed) {
      // FIXME: do we care about carry or signed issues?
      ++seed[3];
      return seed;
    };

    prng_aes.md = forge.md.sha256;
    /**
     * Creates a new PRNG.
     */

    function spawnPrng() {
      var ctx = forge.prng.create(prng_aes);
      /**
       * Gets random bytes. If a native secure crypto API is unavailable, this
       * method tries to make the bytes more unpredictable by drawing from data that
       * can be collected from the user of the browser, eg: mouse movement.
       *
       * If a callback is given, this method will be called asynchronously.
       *
       * @param count the number of random bytes to get.
       * @param [callback(err, bytes)] called once the operation completes.
       *
       * @return the random bytes in a string.
       */

      ctx.getBytes = function (count, callback) {
        return ctx.generate(count, callback);
      };
      /**
       * Gets random bytes asynchronously. If a native secure crypto API is
       * unavailable, this method tries to make the bytes more unpredictable by
       * drawing from data that can be collected from the user of the browser,
       * eg: mouse movement.
       *
       * @param count the number of random bytes to get.
       *
       * @return the random bytes in a string.
       */


      ctx.getBytesSync = function (count) {
        return ctx.generate(count);
      };

      return ctx;
    } // create default prng context


    var _ctx = spawnPrng(); // add other sources of entropy only if window.crypto.getRandomValues is not
    // available -- otherwise this source will be automatically used by the prng


    var getRandomValues = null;
    var globalScope = forge.util.globalScope;

    var _crypto = globalScope.crypto || globalScope.msCrypto;

    if (_crypto && _crypto.getRandomValues) {
      getRandomValues = function (arr) {
        return _crypto.getRandomValues(arr);
      };
    }

    if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
      // if this is a web worker, do not use weak entropy, instead register to
      // receive strong entropy asynchronously from the main thread
      if (typeof window === 'undefined' || window.document === undefined) {// FIXME:
      } // get load time entropy


      _ctx.collectInt(+new Date(), 32); // add some entropy from navigator object


      if (typeof navigator !== 'undefined') {
        var _navBytes = '';

        for (var key in navigator) {
          try {
            if (typeof navigator[key] == 'string') {
              _navBytes += navigator[key];
            }
          } catch (e) {
            /* Some navigator keys might not be accessible, e.g. the geolocation
              attribute throws an exception if touched in Mozilla chrome://
              context.
               Silently ignore this and just don't use this as a source of
              entropy. */
          }
        }

        _ctx.collect(_navBytes);

        _navBytes = null;
      } // add mouse and keyboard collectors if jquery is available


      if (jQuery) {
        // set up mouse entropy capture
        jQuery().mousemove(function (e) {
          // add mouse coords
          _ctx.collectInt(e.clientX, 16);

          _ctx.collectInt(e.clientY, 16);
        }); // set up keyboard entropy capture

        jQuery().keypress(function (e) {
          _ctx.collectInt(e.charCode, 8);
        });
      }
    }
    /* Random API */


    if (!forge.random) {
      forge.random = _ctx;
    } else {
      // extend forge.random with _ctx
      for (var key in _ctx) {
        forge.random[key] = _ctx[key];
      }
    } // expose spawn PRNG


    forge.random.createInstance = spawnPrng;
    module.exports = forge.random;
  })(typeof jQuery !== 'undefined' ? jQuery : null);
})();
},{"./forge":"node_modules/node-forge/lib/forge.js","./aes":"node_modules/node-forge/lib/aes.js","./sha256":"node_modules/node-forge/lib/sha256.js","./prng":"node_modules/node-forge/lib/prng.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/rc2.js":[function(require,module,exports) {
/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */
var forge = require('./forge');

require('./util');

var piTable = [0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d, 0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2, 0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32, 0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82, 0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc, 0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26, 0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03, 0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7, 0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a, 0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec, 0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39, 0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31, 0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9, 0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9, 0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e, 0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad];
var s = [1, 2, 3, 5];
/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */

var rol = function (word, bits) {
  return word << bits & 0xffff | (word & 0xffff) >> 16 - bits;
};
/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */


var ror = function (word, bits) {
  return (word & 0xffff) >> bits | word << 16 - bits & 0xffff;
};
/* RC2 API */


module.exports = forge.rc2 = forge.rc2 || {};
/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */

forge.rc2.expandKey = function (key, effKeyBits) {
  if (typeof key === 'string') {
    key = forge.util.createBuffer(key);
  }

  effKeyBits = effKeyBits || 128;
  /* introduce variables that match the names used in RFC #2268 */

  var L = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 0xff >> (T1 & 0x07);
  var i;

  for (i = T; i < 128; i++) {
    L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 0xff]);
  }

  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);

  for (i = 127 - T8; i >= 0; i--) {
    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
  }

  return L;
};
/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */


var createCipher = function (key, bits, encrypt) {
  var _finish = false,
      _input = null,
      _output = null,
      _iv = null;
  var mixRound, mashRound;
  var i,
      j,
      K = [];
  /* Expand key and fill into K[] Array */

  key = forge.rc2.expandKey(key, bits);

  for (i = 0; i < 64; i++) {
    K.push(key.getInt16Le());
  }

  if (encrypt) {
    /**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function (R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        R[i] = rol(R[i], s[i]);
        j++;
      }
    };
    /**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */


    mashRound = function (R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[R[(i + 3) % 4] & 63];
      }
    };
  } else {
    /**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function (R) {
      for (i = 3; i >= 0; i--) {
        R[i] = ror(R[i], s[i]);
        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        j--;
      }
    };
    /**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */


    mashRound = function (R) {
      for (i = 3; i >= 0; i--) {
        R[i] -= K[R[(i + 3) % 4] & 63];
      }
    };
  }
  /**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */


  var runPlan = function (plan) {
    var R = [];
    /* Get data from input buffer and fill the four words into R */

    for (i = 0; i < 4; i++) {
      var val = _input.getInt16Le();

      if (_iv !== null) {
        if (encrypt) {
          /* We're encrypting, apply the IV first. */
          val ^= _iv.getInt16Le();
        } else {
          /* We're decryption, keep cipher text for next block. */
          _iv.putInt16Le(val);
        }
      }

      R.push(val & 0xffff);
    }
    /* Reset global "j" variable as per spec. */


    j = encrypt ? 0 : 63;
    /* Run execution plan. */

    for (var ptr = 0; ptr < plan.length; ptr++) {
      for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R);
      }
    }
    /* Write back result to output buffer. */


    for (i = 0; i < 4; i++) {
      if (_iv !== null) {
        if (encrypt) {
          /* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */
          _iv.putInt16Le(R[i]);
        } else {
          R[i] ^= _iv.getInt16Le();
        }
      }

      _output.putInt16Le(R[i]);
    }
  };
  /* Create cipher object */


  var cipher = null;
  cipher = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function (iv, output) {
      if (iv) {
        /* CBC mode */
        if (typeof iv === 'string') {
          iv = forge.util.createBuffer(iv);
        }
      }

      _finish = false;
      _input = forge.util.createBuffer();
      _output = output || new forge.util.createBuffer();
      _iv = iv;
      cipher.output = _output;
    },

    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function (input) {
      if (!_finish) {
        // not finishing, so fill the input buffer with more input
        _input.putBuffer(input);
      }

      while (_input.length() >= 8) {
        runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
      }
    },

    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function (pad) {
      var rval = true;

      if (encrypt) {
        if (pad) {
          rval = pad(8, _input, !encrypt);
        } else {
          // add PKCS#7 padding to block (each pad byte is the
          // value of the number of pad bytes)
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();

          _input.fillWithByte(padding, padding);
        }
      }

      if (rval) {
        // do final update
        _finish = true;
        cipher.update();
      }

      if (!encrypt) {
        // check for error: input data not a multiple of block size
        rval = _input.length() === 0;

        if (rval) {
          if (pad) {
            rval = pad(8, _output, !encrypt);
          } else {
            // ensure padding byte count is valid
            var len = _output.length();

            var count = _output.at(len - 1);

            if (count > len) {
              rval = false;
            } else {
              // trim off padding bytes
              _output.truncate(count);
            }
          }
        }
      }

      return rval;
    }
  };
  return cipher;
};
/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */


forge.rc2.startEncrypting = function (key, iv, output) {
  var cipher = forge.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */


forge.rc2.createEncryptionCipher = function (key, bits) {
  return createCipher(key, bits, true);
};
/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */


forge.rc2.startDecrypting = function (key, iv, output) {
  var cipher = forge.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */


forge.rc2.createDecryptionCipher = function (key, bits) {
  return createCipher(key, bits, false);
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/jsbn.js":[function(require,module,exports) {
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.

/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/

/*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */

/*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/
var forge = require('./forge');

module.exports = forge.jsbn = forge.jsbn || {}; // Bits per digit

var dbits; // JavaScript engine analysis

var canary = 0xdeadbeefcafe;
var j_lm = (canary & 0xffffff) == 0xefcafe; // (public) Constructor

function BigInteger(a, b, c) {
  this.data = [];
  if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);else if (b == null && "string" != typeof a) this.fromString(a, 256);else this.fromString(a, b);
}

forge.jsbn.BigInteger = BigInteger; // return new, unset BigInteger

function nbi() {
  return new BigInteger(null);
} // am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)


function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this.data[i++] + w.data[j] + c;
    c = Math.floor(v / 0x4000000);
    w.data[j++] = v & 0x3ffffff;
  }

  return c;
} // am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)


function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
      xh = x >> 15;

  while (--n >= 0) {
    var l = this.data[i] & 0x7fff;
    var h = this.data[i++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w.data[j++] = l & 0x3fffffff;
  }

  return c;
} // Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.


function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
      xh = x >> 14;

  while (--n >= 0) {
    var l = this.data[i] & 0x3fff;
    var h = this.data[i++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w.data[j++] = l & 0xfffffff;
  }

  return c;
} // node.js (no browser)


if (typeof navigator === 'undefined') {
  BigInteger.prototype.am = am3;
  dbits = 28;
} else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if (j_lm && navigator.appName != "Netscape") {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else {
  // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP; // Digit conversions

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);

for (vv = 0; vv <= 9; ++vv) {
  BI_RC[rr++] = vv;
}

rr = "a".charCodeAt(0);

for (vv = 10; vv < 36; ++vv) {
  BI_RC[rr++] = vv;
}

rr = "A".charCodeAt(0);

for (vv = 10; vv < 36; ++vv) {
  BI_RC[rr++] = vv;
}

function int2char(n) {
  return BI_RM.charAt(n);
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
} // (protected) copy this to r


function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) {
    r.data[i] = this.data[i];
  }

  r.t = this.t;
  r.s = this.s;
} // (protected) set from integer value x, -DV <= x < DV


function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0) this.data[0] = x;else if (x < -1) this.data[0] = x + this.DV;else this.t = 0;
} // return bigint initialized to value


function nbv(i) {
  var r = nbi();
  r.fromInt(i);
  return r;
} // (protected) set from string and radix


function bnpFromString(s, b) {
  var k;
  if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s.length,
      mi = false,
      sh = 0;

  while (--i >= 0) {
    var x = k == 8 ? s[i] & 0xff : intAt(s, i);

    if (x < 0) {
      if (s.charAt(i) == "-") mi = true;
      continue;
    }

    mi = false;
    if (sh == 0) this.data[this.t++] = x;else if (sh + k > this.DB) {
      this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this.data[this.t++] = x >> this.DB - sh;
    } else this.data[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB) sh -= this.DB;
  }

  if (k == 8 && (s[0] & 0x80) != 0) {
    this.s = -1;
    if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }

  this.clamp();
  if (mi) BigInteger.ZERO.subTo(this, this);
} // (protected) clamp off excess high words


function bnpClamp() {
  var c = this.s & this.DM;

  while (this.t > 0 && this.data[this.t - 1] == c) {
    --this.t;
  }
} // (public) return string representation in given radix


function bnToString(b) {
  if (this.s < 0) return "-" + this.negate().toString(b);
  var k;
  if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else return this.toRadix(b);
  var km = (1 << k) - 1,
      d,
      m = false,
      r = "",
      i = this.t;
  var p = this.DB - i * this.DB % k;

  if (i-- > 0) {
    if (p < this.DB && (d = this.data[i] >> p) > 0) {
      m = true;
      r = int2char(d);
    }

    while (i >= 0) {
      if (p < k) {
        d = (this.data[i] & (1 << p) - 1) << k - p;
        d |= this.data[--i] >> (p += this.DB - k);
      } else {
        d = this.data[i] >> (p -= k) & km;

        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }

      if (d > 0) m = true;
      if (m) r += int2char(d);
    }
  }

  return m ? r : "0";
} // (public) -this


function bnNegate() {
  var r = nbi();
  BigInteger.ZERO.subTo(this, r);
  return r;
} // (public) |this|


function bnAbs() {
  return this.s < 0 ? this.negate() : this;
} // (public) return + if this > a, - if this < a, 0 if equal


function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0) return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0) return this.s < 0 ? -r : r;

  while (--i >= 0) {
    if ((r = this.data[i] - a.data[i]) != 0) return r;
  }

  return 0;
} // returns bit length of the integer x


function nbits(x) {
  var r = 1,
      t;

  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }

  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }

  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }

  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }

  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }

  return r;
} // (public) return the number of bits in "this"


function bnBitLength() {
  if (this.t <= 0) return 0;
  return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
} // (protected) r = this << n*DB


function bnpDLShiftTo(n, r) {
  var i;

  for (i = this.t - 1; i >= 0; --i) {
    r.data[i + n] = this.data[i];
  }

  for (i = n - 1; i >= 0; --i) {
    r.data[i] = 0;
  }

  r.t = this.t + n;
  r.s = this.s;
} // (protected) r = this >> n*DB


function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) {
    r.data[i - n] = this.data[i];
  }

  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
} // (protected) r = this << n


function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB),
      c = this.s << bs & this.DM,
      i;

  for (i = this.t - 1; i >= 0; --i) {
    r.data[i + ds + 1] = this.data[i] >> cbs | c;
    c = (this.data[i] & bm) << bs;
  }

  for (i = ds - 1; i >= 0; --i) {
    r.data[i] = 0;
  }

  r.data[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
} // (protected) r = this >> n


function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);

  if (ds >= this.t) {
    r.t = 0;
    return;
  }

  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r.data[0] = this.data[ds] >> bs;

  for (var i = ds + 1; i < this.t; ++i) {
    r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
    r.data[i - ds] = this.data[i] >> bs;
  }

  if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
} // (protected) r = this - a


function bnpSubTo(a, r) {
  var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);

  while (i < m) {
    c += this.data[i] - a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }

  if (a.t < this.t) {
    c -= a.s;

    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }

    c += this.s;
  } else {
    c += this.s;

    while (i < a.t) {
      c -= a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }

    c -= a.s;
  }

  r.s = c < 0 ? -1 : 0;
  if (c < -1) r.data[i++] = this.DV + c;else if (c > 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
} // (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.


function bnpMultiplyTo(a, r) {
  var x = this.abs(),
      y = a.abs();
  var i = x.t;
  r.t = i + y.t;

  while (--i >= 0) {
    r.data[i] = 0;
  }

  for (i = 0; i < y.t; ++i) {
    r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
  }

  r.s = 0;
  r.clamp();
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
} // (protected) r = this^2, r != this (HAC 14.16)


function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;

  while (--i >= 0) {
    r.data[i] = 0;
  }

  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x.data[i], r, 2 * i, 0, 1);

    if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r.data[i + x.t] -= x.DV;
      r.data[i + x.t + 1] = 1;
    }
  }

  if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
} // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.


function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0) return;
  var pt = this.abs();

  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0);
    if (r != null) this.copyTo(r);
    return;
  }

  if (r == null) r = nbi();
  var y = nbi(),
      ts = this.s,
      ms = m.s;
  var nsh = this.DB - nbits(pm.data[pm.t - 1]); // normalize modulus

  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }

  var ys = y.t;
  var y0 = y.data[ys - 1];
  if (y0 == 0) return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt,
      d2 = (1 << this.F1) / yt,
      e = 1 << this.F2;
  var i = r.t,
      j = i - ys,
      t = q == null ? nbi() : q;
  y.dlShiftTo(j, t);

  if (r.compareTo(t) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t, r);
  }

  BigInteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y); // "negative" y so we can replace sub with am later

  while (y.t < ys) {
    y.data[y.t++] = 0;
  }

  while (--j >= 0) {
    // Estimate quotient digit
    var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);

    if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      // Try it out
      y.dlShiftTo(j, t);
      r.subTo(t, r);

      while (r.data[i] < --qd) {
        r.subTo(t, r);
      }
    }
  }

  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms) BigInteger.ZERO.subTo(q, q);
  }

  r.t = ys;
  r.clamp();
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder

  if (ts < 0) BigInteger.ZERO.subTo(r, r);
} // (public) this mod a


function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
  return r;
} // Modular reduction using "classic" algorithm


function Classic(m) {
  this.m = m;
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);else return x;
}

function cRevert(x) {
  return x;
}

function cReduce(x) {
  x.divRemTo(this.m, null, x);
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}

function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo; // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.

function bnpInvDigit() {
  if (this.t < 1) return 0;
  var x = this.data[0];
  if ((x & 1) == 0) return 0;
  var y = x & 3; // y == 1/x mod 2^2

  y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4

  y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8

  y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints

  y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV

  return y > 0 ? this.DV - y : -y;
} // Montgomery reduction


function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 0x7fff;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
} // xR mod m


function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
  return r;
} // x/R mod m


function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
} // x = x/R mod m (HAC 14.32)


function montReduce(x) {
  while (x.t <= this.mt2) {
    // pad x so am has enough room later
    x.data[x.t++] = 0;
  }

  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x.data[i]*mp mod DV
    var j = x.data[i] & 0x7fff;
    var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM; // use am to combine the multiply-shift-add into one call

    j = i + this.m.t;
    x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t); // propagate carry

    while (x.data[j] >= x.DV) {
      x.data[j] -= x.DV;
      x.data[++j]++;
    }
  }

  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
} // r = "x^2/R mod m"; x != r


function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
} // r = "xy/R mod m"; x,y != r


function montMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo; // (protected) true iff this is even

function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
} // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)


function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
  g.copyTo(r);

  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0) z.mulTo(r2, g, r);else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }

  return z.revert(r);
} // (public) this^e % m, 0 <= e < 2^32


function bnModPowInt(e, m) {
  var z;
  if (e < 256 || m.isEven()) z = new Classic(m);else z = new Montgomery(m);
  return this.exp(e, z);
} // protected


BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp; // public

BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt; // "constants"

BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1); // jsbn2 lib
//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).
//Extended JavaScript BN functions, required for RSA private ops.
//Version 1.1: new BigInteger("0", 10) returns "proper" zero
//(public)

function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
} //(public) return value as integer


function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this.data[0] - this.DV;else if (this.t == 0) return -1;
  } else if (this.t == 1) return this.data[0];else if (this.t == 0) return 0; // assumes 16 < DB < 32


  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
} //(public) return value as byte


function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
} //(public) return value as short (assumes DB>=16)


function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
} //(protected) return x s.t. r^x < DV


function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
} //(public) 0 if this == 0, 1 if this > 0


function bnSigNum() {
  if (this.s < 0) return -1;else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;else return 1;
} //(protected) convert to radix string


function bnpToRadix(b) {
  if (b == null) b = 10;
  if (this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
  this.divRemTo(d, y, z);

  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }

  return z.intValue().toString(b) + r;
} //(protected) convert from radix string


function bnpFromRadix(s, b) {
  this.fromInt(0);
  if (b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b, cs),
      mi = false,
      j = 0,
      w = 0;

  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i);

    if (x < 0) {
      if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }

    w = b * w + x;

    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }

  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }

  if (mi) BigInteger.ZERO.subTo(this, this);
} //(protected) alternate constructor


function bnpFromNumber(a, b, c) {
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) this.fromInt(1);else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1)) // force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven()) this.dAddOffset(1, 0); // force odd

      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
        t = a & 7;
    x.length = (a >> 3) + 1;
    b.nextBytes(x);
    if (t > 0) x[0] &= (1 << t) - 1;else x[0] = 0;
    this.fromString(x, 256);
  }
} //(public) convert to bigendian byte array


function bnToByteArray() {
  var i = this.t,
      r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8,
      d,
      k = 0;

  if (i-- > 0) {
    if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;

    while (i >= 0) {
      if (p < 8) {
        d = (this.data[i] & (1 << p) - 1) << 8 - p;
        d |= this.data[--i] >> (p += this.DB - 8);
      } else {
        d = this.data[i] >> (p -= 8) & 0xff;

        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }

      if ((d & 0x80) != 0) d |= -256;
      if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
      if (k > 0 || d != this.s) r[k++] = d;
    }
  }

  return r;
}

function bnEquals(a) {
  return this.compareTo(a) == 0;
}

function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}

function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
} //(protected) r = this op a (bitwise)


function bnpBitwiseTo(a, op, r) {
  var i,
      f,
      m = Math.min(a.t, this.t);

  for (i = 0; i < m; ++i) {
    r.data[i] = op(this.data[i], a.data[i]);
  }

  if (a.t < this.t) {
    f = a.s & this.DM;

    for (i = m; i < this.t; ++i) {
      r.data[i] = op(this.data[i], f);
    }

    r.t = this.t;
  } else {
    f = this.s & this.DM;

    for (i = m; i < a.t; ++i) {
      r.data[i] = op(f, a.data[i]);
    }

    r.t = a.t;
  }

  r.s = op(this.s, a.s);
  r.clamp();
} //(public) this & a


function op_and(x, y) {
  return x & y;
}

function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
} //(public) this | a


function op_or(x, y) {
  return x | y;
}

function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
} //(public) this ^ a


function op_xor(x, y) {
  return x ^ y;
}

function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
} //(public) this & ~a


function op_andnot(x, y) {
  return x & ~y;
}

function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
} //(public) ~this


function bnNot() {
  var r = nbi();

  for (var i = 0; i < this.t; ++i) {
    r.data[i] = this.DM & ~this.data[i];
  }

  r.t = this.t;
  r.s = ~this.s;
  return r;
} //(public) this << n


function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0) this.rShiftTo(-n, r);else this.lShiftTo(n, r);
  return r;
} //(public) this >> n


function bnShiftRight(n) {
  var r = nbi();
  if (n < 0) this.lShiftTo(-n, r);else this.rShiftTo(n, r);
  return r;
} //return index of lowest 1-bit in x, x < 2^31


function lbit(x) {
  if (x == 0) return -1;
  var r = 0;

  if ((x & 0xffff) == 0) {
    x >>= 16;
    r += 16;
  }

  if ((x & 0xff) == 0) {
    x >>= 8;
    r += 8;
  }

  if ((x & 0xf) == 0) {
    x >>= 4;
    r += 4;
  }

  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }

  if ((x & 1) == 0) ++r;
  return r;
} //(public) returns index of lowest 1-bit (or -1 if none)


function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i) {
    if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
  }

  if (this.s < 0) return this.t * this.DB;
  return -1;
} //return number of 1 bits in x


function cbit(x) {
  var r = 0;

  while (x != 0) {
    x &= x - 1;
    ++r;
  }

  return r;
} //(public) return number of set bits


function bnBitCount() {
  var r = 0,
      x = this.s & this.DM;

  for (var i = 0; i < this.t; ++i) {
    r += cbit(this.data[i] ^ x);
  }

  return r;
} //(public) true iff nth bit is set


function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t) return this.s != 0;
  return (this.data[j] & 1 << n % this.DB) != 0;
} //(protected) this op (1<<n)


function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
} //(public) this | (1<<n)


function bnSetBit(n) {
  return this.changeBit(n, op_or);
} //(public) this & ~(1<<n)


function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
} //(public) this ^ (1<<n)


function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
} //(protected) r = this + a


function bnpAddTo(a, r) {
  var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);

  while (i < m) {
    c += this.data[i] + a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }

  if (a.t < this.t) {
    c += a.s;

    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }

    c += this.s;
  } else {
    c += this.s;

    while (i < a.t) {
      c += a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }

    c += a.s;
  }

  r.s = c < 0 ? -1 : 0;
  if (c > 0) r.data[i++] = c;else if (c < -1) r.data[i++] = this.DV + c;
  r.t = i;
  r.clamp();
} //(public) this + a


function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
} //(public) this - a


function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
} //(public) this * a


function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
} //(public) this / a


function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
} //(public) this % a


function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
} //(public) [this/a,this%a]


function bnDivideAndRemainder(a) {
  var q = nbi(),
      r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
} //(protected) this *= n, this >= 0, 1 < n < DV


function bnpDMultiply(n) {
  this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
} //(protected) this += n << w words, this >= 0


function bnpDAddOffset(n, w) {
  if (n == 0) return;

  while (this.t <= w) {
    this.data[this.t++] = 0;
  }

  this.data[w] += n;

  while (this.data[w] >= this.DV) {
    this.data[w] -= this.DV;
    if (++w >= this.t) this.data[this.t++] = 0;
    ++this.data[w];
  }
} //A "null" reducer


function NullExp() {}

function nNop(x) {
  return x;
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r);
}

function nSqrTo(x, r) {
  x.squareTo(r);
}

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo; //(public) this^e

function bnPow(e) {
  return this.exp(e, new NullExp());
} //(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.


function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0; // assumes a,this >= 0

  r.t = i;

  while (i > 0) {
    r.data[--i] = 0;
  }

  var j;

  for (j = r.t - this.t; i < j; ++i) {
    r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
  }

  for (j = Math.min(a.t, n); i < j; ++i) {
    this.am(0, a.data[i], r, i, 0, n - i);
  }

  r.clamp();
} //(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.


function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0; // assumes a,this >= 0

  while (--i >= 0) {
    r.data[i] = 0;
  }

  for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
    r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
  }

  r.clamp();
  r.drShiftTo(1, r);
} //Barrett modular reduction


function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);else if (x.compareTo(this.m) < 0) return x;else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}

function barrettRevert(x) {
  return x;
} //x = x mod m (HAC 14.42)


function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);

  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }

  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);

  while (x.compareTo(this.r2) < 0) {
    x.dAddOffset(1, this.m.t + 1);
  }

  x.subTo(this.r2, x);

  while (x.compareTo(this.m) >= 0) {
    x.subTo(this.m, x);
  }
} //r = x^2 mod m; x != r


function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
} //r = x*y mod m; x,y != r


function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo; //(public) this^e % m (HAC 14.85)

function bnModPow(e, m) {
  var i = e.bitLength(),
      k,
      r = nbv(1),
      z;
  if (i <= 0) return r;else if (i < 18) k = 1;else if (i < 48) k = 3;else if (i < 144) k = 4;else if (i < 768) k = 5;else k = 6;
  if (i < 8) z = new Classic(m);else if (m.isEven()) z = new Barrett(m);else z = new Montgomery(m); // precomputation

  var g = new Array(),
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
  g[1] = z.convert(this);

  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);

    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }

  var j = e.t - 1,
      w,
      is1 = true,
      r2 = nbi(),
      t;
  i = nbits(e.data[j]) - 1;

  while (j >= 0) {
    if (i >= k1) w = e.data[j] >> i - k1 & km;else {
      w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
    }
    n = k;

    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }

    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }

    if (is1) {
      // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }

      if (n > 0) z.sqrTo(r, r2);else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }

    while (j >= 0 && (e.data[j] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;

      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }

  return z.revert(r);
} //(public) gcd(this,a) (HAC 14.54)


function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();

  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }

  var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
  if (g < 0) return x;
  if (i < g) g = i;

  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }

  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);

    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }

  if (g > 0) y.lShiftTo(g, y);
  return y;
} //(protected) this % n, n < 2^26


function bnpModInt(n) {
  if (n <= 0) return 0;
  var d = this.DV % n,
      r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0) if (d == 0) r = this.data[0] % n;else for (var i = this.t - 1; i >= 0; --i) {
    r = (d * r + this.data[i]) % n;
  }
  return r;
} //(public) 1/this % m (HAC 14.61)


function bnModInverse(m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(),
      v = this.clone();
  var a = nbv(1),
      b = nbv(0),
      c = nbv(0),
      d = nbv(1);

  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);

      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }

        a.rShiftTo(1, a);
      } else if (!b.isEven()) b.subTo(m, b);

      b.rShiftTo(1, b);
    }

    while (v.isEven()) {
      v.rShiftTo(1, v);

      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }

        c.rShiftTo(1, c);
      } else if (!d.isEven()) d.subTo(m, d);

      d.rShiftTo(1, d);
    }

    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac) a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      if (ac) c.subTo(a, c);
      d.subTo(b, d);
    }
  }

  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if (d.compareTo(m) >= 0) return d.subtract(m);
  if (d.signum() < 0) d.addTo(m, d);else return d;
  if (d.signum() < 0) return d.add(m);else return d;
}

var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; //(public) test primality with certainty >= 1-.5^t

function bnIsProbablePrime(t) {
  var i,
      x = this.abs();

  if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i) {
      if (x.data[0] == lowprimes[i]) return true;
    }

    return false;
  }

  if (x.isEven()) return false;
  i = 1;

  while (i < lowprimes.length) {
    var m = lowprimes[i],
        j = i + 1;

    while (j < lowprimes.length && m < lplim) {
      m *= lowprimes[j++];
    }

    m = x.modInt(m);

    while (i < j) {
      if (m % lowprimes[i++] == 0) return false;
    }
  }

  return x.millerRabin(t);
} //(protected) true if probably prime (HAC 4.24, Miller-Rabin)


function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0) return false;
  var r = n1.shiftRight(k);
  var prng = bnGetPrng();
  var a;

  for (var i = 0; i < t; ++i) {
    // select witness 'a' at random from between 1 and n1
    do {
      a = new BigInteger(this.bitLength(), prng);
    } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);

    var y = a.modPow(r, this);

    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;

      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(BigInteger.ONE) == 0) return false;
      }

      if (y.compareTo(n1) != 0) return false;
    }
  }

  return true;
} // get pseudo random number generator


function bnGetPrng() {
  // create prng with api that matches BigInteger secure random
  return {
    // x is an array to fill with bytes
    nextBytes: function (x) {
      for (var i = 0; i < x.length; ++i) {
        x[i] = Math.floor(Math.random() * 0x0100);
      }
    }
  };
} //protected


BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin; //public

BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime; //BigInteger interfaces not implemented in jsbn:
//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)
},{"./forge":"node_modules/node-forge/lib/forge.js"}],"node_modules/node-forge/lib/sha1.js":[function(require,module,exports) {
/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */

sha1.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-1 state contains five 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(80); // message digest object


  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };

  return md;
}; // sha-1 padding bytes not initialized yet


var _padding = null;
var _initialized = false;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, e, f, i;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 80 32-bit words according to SHA-1 algorithm
    // and for 32-79 using Max Locktyukhin's optimization
    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4; // round 1

    for (i = 0; i < 16; ++i) {
      t = bytes.getInt32();
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 20; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 2


    for (; i < 32; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 40; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 3


    for (; i < 60; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b & c | d & (b ^ c);
      t = (a << 5 | a >>> 27) + f + e + 0x8F1BBCDC + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 4


    for (; i < 80; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0xCA62C1D6 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    len -= 64;
  }
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./md":"node_modules/node-forge/lib/md.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/pkcs1.js":[function(require,module,exports) {
/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

require('./random');

require('./sha1'); // shortcut for PKCS#1 API


var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */

pkcs1.encode_rsa_oaep = function (key, message, options) {
  // parse arguments
  var label;
  var seed;
  var md;
  var mgf1Md; // legacy args (label, seed, md)

  if (typeof options === 'string') {
    label = options;
    seed = arguments[3] || undefined;
    md = arguments[4] || undefined;
  } else if (options) {
    label = options.label || undefined;
    seed = options.seed || undefined;
    md = options.md || undefined;

    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  } // default OAEP to SHA-1 message digest


  if (!md) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  } // default MGF-1 to same as OAEP


  if (!mgf1Md) {
    mgf1Md = md;
  } // compute length in bytes and check output


  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;

  if (message.length > maxLength) {
    var error = new Error('RSAES-OAEP input message length is too long.');
    error.length = message.length;
    error.maxLength = maxLength;
    throw error;
  }

  if (!label) {
    label = '';
  }

  md.update(label, 'raw');
  var lHash = md.digest();
  var PS = '';
  var PS_length = maxLength - message.length;

  for (var i = 0; i < PS_length; i++) {
    PS += '\x00';
  }

  var DB = lHash.getBytes() + PS + '\x01' + message;

  if (!seed) {
    seed = forge.random.getBytes(md.digestLength);
  } else if (seed.length !== md.digestLength) {
    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' + 'match the digest length.');
    error.seedLength = seed.length;
    error.digestLength = md.digestLength;
    throw error;
  }

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length); // return encoded message

  return '\x00' + maskedSeed + maskedDB;
};
/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */


pkcs1.decode_rsa_oaep = function (key, em, options) {
  // parse args
  var label;
  var md;
  var mgf1Md; // legacy args

  if (typeof options === 'string') {
    label = options;
    md = arguments[3] || undefined;
  } else if (options) {
    label = options.label || undefined;
    md = options.md || undefined;

    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  } // compute length in bytes


  var keyLength = Math.ceil(key.n.bitLength() / 8);

  if (em.length !== keyLength) {
    var error = new Error('RSAES-OAEP encoded message length is invalid.');
    error.length = em.length;
    error.expectedLength = keyLength;
    throw error;
  } // default OAEP to SHA-1 message digest


  if (md === undefined) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  } // default MGF-1 to same as OAEP


  if (!mgf1Md) {
    mgf1Md = md;
  }

  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error('RSAES-OAEP key is too short for the hash function.');
  }

  if (!label) {
    label = '';
  }

  md.update(label, 'raw');
  var lHash = md.digest().getBytes(); // split the message into its parts

  var y = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength); // constant time check that all values match what is expected

  var error = y !== '\x00'; // constant time check lHash vs lHashPrime

  for (var i = 0; i < md.digestLength; ++i) {
    error |= lHash.charAt(i) !== lHashPrime.charAt(i);
  } // "constant time" find the 0x1 byte separating the padding (zeros) from the
  // message
  // TODO: It must be possible to do this in a better/smarter way?


  var in_ps = 1;
  var index = md.digestLength;

  for (var j = md.digestLength; j < db.length; j++) {
    var code = db.charCodeAt(j);
    var is_0 = code & 0x1 ^ 0x1; // non-zero if not 0 or 1 in the ps section

    var error_mask = in_ps ? 0xfffe : 0x0000;
    error |= code & error_mask; // latch in_ps to zero after we find 0x1

    in_ps = in_ps & is_0;
    index += in_ps;
  }

  if (error || db.charCodeAt(index) !== 0x1) {
    throw new Error('Invalid RSAES-OAEP padding.');
  }

  return db.substring(index + 1);
};

function rsa_mgf1(seed, maskLength, hash) {
  // default to SHA-1 message digest
  if (!hash) {
    hash = forge.md.sha1.create();
  }

  var t = '';
  var count = Math.ceil(maskLength / hash.digestLength);

  for (var i = 0; i < count; ++i) {
    var c = String.fromCharCode(i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF);
    hash.start();
    hash.update(seed + c);
    t += hash.digest().getBytes();
  }

  return t.substring(0, maskLength);
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js","./random":"node_modules/node-forge/lib/random.js","./sha1":"node_modules/node-forge/lib/sha1.js"}],"node_modules/node-forge/lib/prime.js":[function(require,module,exports) {
/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

require('./jsbn');

require('./random');

(function () {
  // forge.prime already defined
  if (forge.prime) {
    module.exports = forge.prime;
    return;
  }
  /* PRIME API */


  var prime = module.exports = forge.prime = forge.prime || {};
  var BigInteger = forge.jsbn.BigInteger; // primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29

  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger(null);
  THIRTY.fromInt(30);

  var op_or = function (x, y) {
    return x | y;
  };
  /**
   * Generates a random probable prime with the given number of bits.
   *
   * Alternative algorithms can be specified by name as a string or as an
   * object with custom options like so:
   *
   * {
   *   name: 'PRIMEINC',
   *   options: {
   *     maxBlockTime: <the maximum amount of time to block the main
   *       thread before allowing I/O other JS to run>,
   *     millerRabinTests: <the number of miller-rabin tests to run>,
   *     workerScript: <the worker script URL>,
   *     workers: <the number of web workers (if supported) to use,
   *       -1 to use estimated cores minus one>.
   *     workLoad: the size of the work load, ie: number of possible prime
   *       numbers for each web worker to check per work assignment,
   *       (default: 100).
   *   }
   * }
   *
   * @param bits the number of bits for the prime number.
   * @param options the options to use.
   *          [algorithm] the algorithm to use (default: 'PRIMEINC').
   *          [prng] a custom crypto-secure pseudo-random number generator to use,
   *            that must define "getBytesSync".
   *
   * @return callback(err, num) called once the operation completes.
   */


  prime.generateProbablePrime = function (bits, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = options || {}; // default to PRIMEINC algorithm

    var algorithm = options.algorithm || 'PRIMEINC';

    if (typeof algorithm === 'string') {
      algorithm = {
        name: algorithm
      };
    }

    algorithm.options = algorithm.options || {}; // create prng with api that matches BigInteger secure random

    var prng = options.prng || forge.random;
    var rng = {
      // x is an array to fill with bytes
      nextBytes: function (x) {
        var b = prng.getBytesSync(x.length);

        for (var i = 0; i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };

    if (algorithm.name === 'PRIMEINC') {
      return primeincFindPrime(bits, rng, algorithm.options, callback);
    }

    throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
  };

  function primeincFindPrime(bits, rng, options, callback) {
    if ('workers' in options) {
      return primeincFindPrimeWithWorkers(bits, rng, options, callback);
    }

    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }

  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
    // initialize random number
    var num = generateRandom(bits, rng);
    /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
    number we are given is always aligned at 30k + 1. Each time the number is
    determined not to be prime we add to get to the next 'i', eg: if the number
    was at 30k + 1 we add 6. */

    var deltaIdx = 0; // get required number of MR tests

    var mrTests = getMillerRabinTests(num.bitLength());

    if ('millerRabinTests' in options) {
      mrTests = options.millerRabinTests;
    } // find prime nearest to 'num' for maxBlockTime ms
    // 10 ms gives 5ms of leeway for other calculations before dropping
    // below 60fps (1000/60 == 16.67), but in reality, the number will
    // likely be higher due to an 'atomic' big int modPow


    var maxBlockTime = 10;

    if ('maxBlockTime' in options) {
      maxBlockTime = options.maxBlockTime;
    }

    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  }

  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +new Date();

    do {
      // overflow, regenerate random number
      if (num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      } // do primality test


      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      } // get next potential prime


      num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime); // keep trying later


    forge.util.setImmediate(function () {
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    });
  } // NOTE: This algorithm is indeterminate in nature because workers
  // run in parallel looking at different segments of numbers. Even if this
  // algorithm is run twice with the same input from a predictable RNG, it
  // may produce different outputs.


  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
    // web workers unavailable
    if (typeof Worker === 'undefined') {
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    } // initialize random number


    var num = generateRandom(bits, rng); // use web workers to generate keys

    var numWorkers = options.workers;
    var workLoad = options.workLoad || 100;
    var range = workLoad * 30 / 8;
    var workerScript = options.workerScript || 'forge/prime.worker.js';

    if (numWorkers === -1) {
      return forge.util.estimateCores(function (err, cores) {
        if (err) {
          // default to 2
          cores = 2;
        }

        numWorkers = cores - 1;
        generate();
      });
    }

    generate();

    function generate() {
      // require at least 1 worker
      numWorkers = Math.max(1, numWorkers); // TODO: consider optimizing by starting workers outside getPrime() ...
      // note that in order to clean up they will have to be made internally
      // asynchronous which may actually be slower
      // start workers immediately

      var workers = [];

      for (var i = 0; i < numWorkers; ++i) {
        // FIXME: fix path or use blob URLs
        workers[i] = new Worker(workerScript);
      }

      var running = numWorkers; // listen for requests from workers and assign ranges to find prime

      for (var i = 0; i < numWorkers; ++i) {
        workers[i].addEventListener('message', workerMessage);
      }
      /* Note: The distribution of random numbers is unknown. Therefore, each
      web worker is continuously allocated a range of numbers to check for a
      random number until one is found.
       Every 30 numbers will be checked just 8 times, because prime numbers
      have the form:
       30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)
       Therefore, if we want a web worker to run N checks before asking for
      a new range of numbers, each range must contain N*30/8 numbers.
       For 100 checks (workLoad), this is a range of 375. */


      var found = false;

      function workerMessage(e) {
        // ignore message, prime already found
        if (found) {
          return;
        }

        --running;
        var data = e.data;

        if (data.found) {
          // terminate all workers
          for (var i = 0; i < workers.length; ++i) {
            workers[i].terminate();
          }

          found = true;
          return callback(null, new BigInteger(data.prime, 16));
        } // overflow, regenerate random number


        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        } // assign new range to check


        var hex = num.toString(16); // start prime search

        e.target.postMessage({
          hex: hex,
          workLoad: workLoad
        });
        num.dAddOffset(range, 0);
      }
    }
  }
  /**
   * Generates a random number using the given number of bits and RNG.
   *
   * @param bits the number of bits for the number.
   * @param rng the random number generator to use.
   *
   * @return the random number.
   */


  function generateRandom(bits, rng) {
    var num = new BigInteger(bits, rng); // force MSB set

    var bits1 = bits - 1;

    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
    } // align number on 30k+1 boundary


    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  /**
   * Returns the required number of Miller-Rabin tests to generate a
   * prime with an error probability of (1/2)^80.
   *
   * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
   *
   * @param bits the bit size.
   *
   * @return the required number of iterations.
   */


  function getMillerRabinTests(bits) {
    if (bits <= 100) return 27;
    if (bits <= 150) return 18;
    if (bits <= 200) return 15;
    if (bits <= 250) return 12;
    if (bits <= 300) return 9;
    if (bits <= 350) return 8;
    if (bits <= 400) return 7;
    if (bits <= 500) return 6;
    if (bits <= 600) return 5;
    if (bits <= 800) return 4;
    if (bits <= 1250) return 3;
    return 2;
  }
})();
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js","./jsbn":"node_modules/node-forge/lib/jsbn.js","./random":"node_modules/node-forge/lib/random.js"}],"node_modules/node-forge/lib/rsa.js":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */
var forge = require('./forge');

require('./asn1');

require('./jsbn');

require('./oids');

require('./pkcs1');

require('./prime');

require('./random');

require('./util');

if (typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

var _crypto = forge.util.isNodejs ? require('crypto') : null; // shortcut for asn.1 API


var asn1 = forge.asn1; // shortcut for util API

var util = forge.util;
/*
 * RSA encryption and decryption, see RFC 2313.
 */

forge.pki = forge.pki || {};
module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
var pki = forge.pki; // for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29

var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2]; // validator for a PrivateKeyInfo structure

var privateKeyValidator = {
  // PrivateKeyInfo
  name: 'PrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'PrivateKeyInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // privateKeyAlgorithm
    name: 'PrivateKeyInfo.privateKeyAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'privateKeyOid'
    }]
  }, {
    // PrivateKey
    name: 'PrivateKeyInfo',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'privateKey'
  }]
}; // validator for an RSA private key

var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: 'RSAPrivateKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'RSAPrivateKey.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // modulus (n)
    name: 'RSAPrivateKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPrivateKey.publicExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPublicExponent'
  }, {
    // privateExponent (d)
    name: 'RSAPrivateKey.privateExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrivateExponent'
  }, {
    // prime1 (p)
    name: 'RSAPrivateKey.prime1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime1'
  }, {
    // prime2 (q)
    name: 'RSAPrivateKey.prime2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime2'
  }, {
    // exponent1 (d mod (p-1))
    name: 'RSAPrivateKey.exponent1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent1'
  }, {
    // exponent2 (d mod (q-1))
    name: 'RSAPrivateKey.exponent2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent2'
  }, {
    // coefficient ((inverse of q) mod p)
    name: 'RSAPrivateKey.coefficient',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyCoefficient'
  }]
}; // validator for an RSA public key

var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: 'RSAPublicKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: 'RSAPublicKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPublicKey.exponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyExponent'
  }]
}; // validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key

var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
  name: 'SubjectPublicKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'subjectPublicKeyInfo',
  value: [{
    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'publicKeyOid'
    }]
  }, {
    // subjectPublicKey
    name: 'SubjectPublicKeyInfo.subjectPublicKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: 'rsaPublicKey'
    }]
  }]
};
/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */

var emsaPkcs1v15encode = function (md) {
  // get the oid for the algorithm
  var oid;

  if (md.algorithm in pki.oids) {
    oid = pki.oids[md.algorithm];
  } else {
    var error = new Error('Unknown message digest algorithm.');
    error.algorithm = md.algorithm;
    throw error;
  }

  var oidBytes = asn1.oidToDer(oid).getBytes(); // create the digest info

  var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
  digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));
  var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest); // encode digest info

  return asn1.toDer(digestInfo).getBytes();
};
/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */


var _modPow = function (x, key, pub) {
  if (pub) {
    return x.modPow(key.e, key.n);
  }

  if (!key.p || !key.q) {
    // allow calculation without CRT params (slow)
    return x.modPow(key.d, key.n);
  } // pre-compute dP, dQ, and qInv if necessary


  if (!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
  }

  if (!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
  }

  if (!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }
  /* Chinese remainder theorem (CRT) states:
     Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):
     x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk
     This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.
     The single simultaneous solution x can be solved with the following
    equation:
     x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.
     Where x is less than n, xi = x mod ni.
     For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:
     y = x^d mod n
     Given the above:
     x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q
     So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n
     According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:
     A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:
     y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n
     Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let
     xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:
     y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n
     This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:
     y = (qInv*(xp - xq) mod p) * q + xq
     However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */
  // cryptographic blinding


  var r;

  do {
    r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
  } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));

  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n); // calculate xp and xq

  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q); // xp must be larger than xq to avoid signed bit usage

  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  } // do last step


  var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq); // remove effect of random for cryptographic blinding

  y = y.multiply(r.modInverse(key.n)).mod(key.n);
  return y;
};
/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */


pki.rsa.encrypt = function (m, key, bt) {
  var pub = bt;
  var eb; // get the length of the modulus in bytes

  var k = Math.ceil(key.n.bitLength() / 8);

  if (bt !== false && bt !== true) {
    // legacy, default to PKCS#1 v1.5 padding
    pub = bt === 0x02;
    eb = _encodePkcs1_v1_5(m, key, bt);
  } else {
    eb = forge.util.createBuffer();
    eb.putBytes(m);
  } // load encryption block as big integer 'x'
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings


  var x = new BigInteger(eb.toHex(), 16); // do RSA encryption

  var y = _modPow(x, key, pub); // convert y into the encrypted data byte string, if y is shorter in
  // bytes than k, then prepend zero bytes to fill up ed
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings


  var yhex = y.toString(16);
  var ed = forge.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);

  while (zeros > 0) {
    ed.putByte(0x00);
    --zeros;
  }

  ed.putBytes(forge.util.hexToBytes(yhex));
  return ed.getBytes();
};
/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */


pki.rsa.decrypt = function (ed, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8); // error if the length of the encrypted data ED is not k

  if (ed.length !== k) {
    var error = new Error('Encrypted message length is invalid.');
    error.length = ed.length;
    error.expected = k;
    throw error;
  } // convert encrypted data into a big integer
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings


  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16); // y must be less than the modulus or it wasn't the result of
  // a previous mod operation (encryption) using that modulus

  if (y.compareTo(key.n) >= 0) {
    throw new Error('Encrypted message is invalid.');
  } // do RSA decryption


  var x = _modPow(y, key, pub); // create the encryption block, if x is shorter in bytes than k, then
  // prepend zero bytes to fill up eb
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings


  var xhex = x.toString(16);
  var eb = forge.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);

  while (zeros > 0) {
    eb.putByte(0x00);
    --zeros;
  }

  eb.putBytes(forge.util.hexToBytes(xhex));

  if (ml !== false) {
    // legacy, default to PKCS#1 v1.5 padding
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  } // return message


  return eb.getBytes();
};
/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */


pki.rsa.createKeyPairGenerationState = function (bits, e, options) {
  // TODO: migrate step-based prime generation code to forge.prime
  // set default bits
  if (typeof bits === 'string') {
    bits = parseInt(bits, 10);
  }

  bits = bits || 2048; // create prng with api that matches BigInteger secure random

  options = options || {};
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function (x) {
      var b = prng.getBytesSync(x.length);

      for (var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };
  var algorithm = options.algorithm || 'PRIMEINC'; // create PRIMEINC algorithm state

  var rval;

  if (algorithm === 'PRIMEINC') {
    rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error('Invalid key generation algorithm: ' + algorithm);
  }

  return rval;
};
/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */


pki.rsa.stepKeyPairGenerationState = function (state, n) {
  // set default algorithm if not set
  if (!('algorithm' in state)) {
    state.algorithm = 'PRIMEINC';
  } // TODO: migrate step-based prime generation code to forge.prime
  // TODO: abstract as PRIMEINC algorithm
  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
  // with some minor optimizations and designed to run in steps
  // local state vars


  var THIRTY = new BigInteger(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;

  var op_or = function (x, y) {
    return x | y;
  }; // keep stepping until time limit is reached or done


  var t1 = +new Date();
  var t2;
  var total = 0;

  while (state.keys === null && (n <= 0 || total < n)) {
    // generate p or q
    if (state.state === 0) {
      /* Note: All primes are of the form:
         30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i
         When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */
      var bits = state.p === null ? state.pBits : state.qBits;
      var bits1 = bits - 1; // get a random number

      if (state.pqState === 0) {
        state.num = new BigInteger(bits, state.rng); // force MSB set

        if (!state.num.testBit(bits1)) {
          state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
        } // align number on 30k+1 boundary


        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state.pqState;
      } else if (state.pqState === 1) {
        // try to make the number a prime
        if (state.num.bitLength() > bits) {
          // overflow, try again
          state.pqState = 0; // do primality test
        } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          // get next potential prime
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if (state.pqState === 2) {
        // ensure number is coprime with e
        state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
      } else if (state.pqState === 3) {
        // store p or q
        state.pqState = 0;

        if (state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        } // advance state if both p and q are ready


        if (state.p !== null && state.q !== null) {
          ++state.state;
        }

        state.num = null;
      }
    } else if (state.state === 1) {
      // ensure p is larger than q (swap them if not)
      if (state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }

      ++state.state;
    } else if (state.state === 2) {
      // compute phi: (p - 1)(q - 1) (Euler's totient function)
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if (state.state === 3) {
      // ensure e and phi are coprime
      if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
        // phi and e are coprime, advance
        ++state.state;
      } else {
        // phi and e aren't coprime, so generate a new p and q
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 4) {
      // create n, ensure n is has the right number of bits
      state.n = state.p.multiply(state.q); // ensure n is right number of bits

      if (state.n.bitLength() === state.bits) {
        // success, advance
        ++state.state;
      } else {
        // failed, get new q
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 5) {
      // set keys
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      };
    } // update timing


    t2 = +new Date();
    total += t2 - t1;
    t1 = t2;
  }

  return state.keys !== null;
};
/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *            and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync". Disables use of native APIs.
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */


pki.rsa.generateKeyPair = function (bits, e, options, callback) {
  // (bits), (options), (callback)
  if (arguments.length === 1) {
    if (_typeof(bits) === 'object') {
      options = bits;
      bits = undefined;
    } else if (typeof bits === 'function') {
      callback = bits;
      bits = undefined;
    }
  } else if (arguments.length === 2) {
    // (bits, e), (bits, options), (bits, callback), (options, callback)
    if (typeof bits === 'number') {
      if (typeof e === 'function') {
        callback = e;
        e = undefined;
      } else if (typeof e !== 'number') {
        options = e;
        e = undefined;
      }
    } else {
      options = bits;
      callback = e;
      bits = undefined;
      e = undefined;
    }
  } else if (arguments.length === 3) {
    // (bits, e, options), (bits, e, callback), (bits, options, callback)
    if (typeof e === 'number') {
      if (typeof options === 'function') {
        callback = options;
        options = undefined;
      }
    } else {
      callback = options;
      options = e;
      e = undefined;
    }
  }

  options = options || {};

  if (bits === undefined) {
    bits = options.bits || 2048;
  }

  if (e === undefined) {
    e = options.e || 0x10001;
  } // use native code if permitted, available, and parameters are acceptable


  if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {
    if (callback) {
      // try native async
      if (_detectNodeCrypto('generateKeyPair')) {
        return _crypto.generateKeyPair('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        }, function (err, pub, priv) {
          if (err) {
            return callback(err);
          }

          callback(null, {
            privateKey: pki.privateKeyFromPem(priv),
            publicKey: pki.publicKeyFromPem(pub)
          });
        });
      }

      if (_detectSubtleCrypto('generateKey') && _detectSubtleCrypto('exportKey')) {
        // use standard native generateKey
        return util.globalScope.crypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {
            name: 'SHA-256'
          }
        }, true
        /* key can be exported*/
        , ['sign', 'verify']).then(function (pair) {
          return util.globalScope.crypto.subtle.exportKey('pkcs8', pair.privateKey); // avoiding catch(function(err) {...}) to support IE <= 8
        }).then(undefined, function (err) {
          callback(err);
        }).then(function (pkcs8) {
          if (pkcs8) {
            var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }

      if (_detectSubtleMsCrypto('generateKey') && _detectSubtleMsCrypto('exportKey')) {
        var genOp = util.globalScope.msCrypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {
            name: 'SHA-256'
          }
        }, true
        /* key can be exported*/
        , ['sign', 'verify']);

        genOp.oncomplete = function (e) {
          var pair = e.target.result;
          var exportOp = util.globalScope.msCrypto.subtle.exportKey('pkcs8', pair.privateKey);

          exportOp.oncomplete = function (e) {
            var pkcs8 = e.target.result;
            var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };

          exportOp.onerror = function (err) {
            callback(err);
          };
        };

        genOp.onerror = function (err) {
          callback(err);
        };

        return;
      }
    } else {
      // try native sync
      if (_detectNodeCrypto('generateKeyPairSync')) {
        var keypair = _crypto.generateKeyPairSync('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        });

        return {
          privateKey: pki.privateKeyFromPem(keypair.privateKey),
          publicKey: pki.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  } // use JavaScript implementation


  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);

  if (!callback) {
    pki.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }

  _generateKeyPair(state, options, callback);
};
/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */


pki.setRsaPublicKey = pki.rsa.setPublicKey = function (n, e) {
  var key = {
    n: n,
    e: e
  };
  /**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */

  key.encrypt = function (data, scheme, schemeOptions) {
    if (typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if (scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    if (scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        encode: function (m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
        }
      };
    } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        encode: function (m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };
    } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {
        encode: function (e) {
          return e;
        }
      };
    } else if (typeof scheme === 'string') {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    } // do scheme-based encoding then rsa encryption


    var e = scheme.encode(data, key, true);
    return pki.rsa.encrypt(e, key, true);
  };
  /**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */


  key.verify = function (digest, signature, scheme) {
    if (typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if (scheme === undefined) {
      scheme = 'RSASSA-PKCS1-V1_5';
    }

    if (scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {
        verify: function (digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true); // d is ASN.1 BER-encoded DigestInfo

          var obj = asn1.fromDer(d); // compare the given digest to the decrypted one

          return digest === obj.value[1].value;
        }
      };
    } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {
        verify: function (digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true);
          return digest === d;
        }
      };
    } // do rsa decryption w/o any decoding, then verify -- which does decoding


    var d = pki.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest, d, key.n.bitLength());
  };

  return key;
};
/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */


pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function (n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n: n,
    e: e,
    d: d,
    p: p,
    q: q,
    dP: dP,
    dQ: dQ,
    qInv: qInv
  };
  /**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */

  key.decrypt = function (data, scheme, schemeOptions) {
    if (typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if (scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    } // do rsa decryption w/o any decoding


    var d = pki.rsa.decrypt(data, key, false, false);

    if (scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        decode: _decodePkcs1_v1_5
      };
    } else if (scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        decode: function (d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };
    } else if (['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {
        decode: function (d) {
          return d;
        }
      };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    } // decode according to scheme


    return scheme.decode(d, key, false);
  };
  /**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */


  key.sign = function (md, scheme) {
    /* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */
    // private key operation
    var bt = false;

    if (typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    }

    if (scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {
        encode: emsaPkcs1v15encode
      };
      bt = 0x01;
    } else if (scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {
        encode: function () {
          return md;
        }
      };
      bt = 0x01;
    } // encode and then encrypt


    var d = scheme.encode(md, key.n.bitLength());
    return pki.rsa.encrypt(d, key, bt);
  };

  return key;
};
/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */


pki.wrapRsaPrivateKey = function (rsaKey) {
  // PrivateKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version (0)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), // privateKeyAlgorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // PrivateKey
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())]);
};
/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */


pki.privateKeyFromAsn1 = function (obj) {
  // get PrivateKeyInfo
  var capture = {};
  var errors = [];

  if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
  } // get RSAPrivateKey


  capture = {};
  errors = [];

  if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read private key. ' + 'ASN.1 object does not contain an RSAPrivateKey.');
    error.errors = errors;
    throw error;
  } // Note: Version is currently ignored.
  // capture.privateKeyVersion
  // FIXME: inefficient, get a BigInteger that uses byte strings


  var n, e, d, p, q, dP, dQ, qInv;
  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex(); // set private key

  return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
};
/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */


pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function (key) {
  // RSAPrivateKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version (0 = only 2 primes, 1 multiple primes)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), // modulus (n)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), // publicExponent (e)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)), // privateExponent (d)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)), // privateKeyPrime1 (p)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)), // privateKeyPrime2 (q)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)), // privateKeyExponent1 (dP)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)), // privateKeyExponent2 (dQ)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)), // coefficient (qInv)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))]);
};
/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */


pki.publicKeyFromAsn1 = function (obj) {
  // get SubjectPublicKeyInfo
  var capture = {};
  var errors = [];

  if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
    // get oid
    var oid = asn1.derToOid(capture.publicKeyOid);

    if (oid !== pki.oids.rsaEncryption) {
      var error = new Error('Cannot read public key. Unknown OID.');
      error.oid = oid;
      throw error;
    }

    obj = capture.rsaPublicKey;
  } // get RSA params


  errors = [];

  if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
    var error = new Error('Cannot read public key. ' + 'ASN.1 object does not contain an RSAPublicKey.');
    error.errors = errors;
    throw error;
  } // FIXME: inefficient, get a BigInteger that uses byte strings


  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex(); // set public key

  return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
};
/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */


pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function (key) {
  // SubjectPublicKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AlgorithmIdentifier
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), // parameters (null)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // subjectPublicKey
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]);
};
/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */


pki.publicKeyToRSAPublicKey = function (key) {
  // RSAPublicKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// modulus (n)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), // publicExponent (e)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]);
};
/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */


function _encodePkcs1_v1_5(m, key, bt) {
  var eb = forge.util.createBuffer(); // get the length of the modulus in bytes

  var k = Math.ceil(key.n.bitLength() / 8);
  /* use PKCS#1 v1.5 padding */

  if (m.length > k - 11) {
    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
    error.length = m.length;
    error.max = k - 11;
    throw error;
  }
  /* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:
     EB = 00 || BT || PS || 00 || D
     The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.
     The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */
  // build the encryption block


  eb.putByte(0x00);
  eb.putByte(bt); // create the padding

  var padNum = k - 3 - m.length;
  var padByte; // private key op

  if (bt === 0x00 || bt === 0x01) {
    padByte = bt === 0x00 ? 0x00 : 0xFF;

    for (var i = 0; i < padNum; ++i) {
      eb.putByte(padByte);
    }
  } else {
    // public key op
    // pad with random non-zero values
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge.random.getBytes(padNum);

      for (var i = 0; i < padNum; ++i) {
        padByte = padBytes.charCodeAt(i);

        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }

      padNum = numZeros;
    }
  } // zero followed by message


  eb.putByte(0x00);
  eb.putBytes(m);
  return eb;
}
/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */


function _decodePkcs1_v1_5(em, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);
  /* It is an error if any of the following conditions occurs:
     1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */
  // parse the encryption block

  var eb = forge.util.createBuffer(em);
  var first = eb.getByte();
  var bt = eb.getByte();

  if (first !== 0x00 || pub && bt !== 0x00 && bt !== 0x01 || !pub && bt != 0x02 || pub && bt === 0x00 && typeof ml === 'undefined') {
    throw new Error('Encryption block is invalid.');
  }

  var padNum = 0;

  if (bt === 0x00) {
    // check all padding bytes for 0x00
    padNum = k - 3 - ml;

    for (var i = 0; i < padNum; ++i) {
      if (eb.getByte() !== 0x00) {
        throw new Error('Encryption block is invalid.');
      }
    }
  } else if (bt === 0x01) {
    // find the first byte that isn't 0xFF, should be after all padding
    padNum = 0;

    while (eb.length() > 1) {
      if (eb.getByte() !== 0xFF) {
        --eb.read;
        break;
      }

      ++padNum;
    }
  } else if (bt === 0x02) {
    // look for 0x00 byte
    padNum = 0;

    while (eb.length() > 1) {
      if (eb.getByte() === 0x00) {
        --eb.read;
        break;
      }

      ++padNum;
    }
  } // zero must be 0x00 and padNum must be (k - 3 - message length)


  var zero = eb.getByte();

  if (zero !== 0x00 || padNum !== k - 3 - eb.length()) {
    throw new Error('Encryption block is invalid.');
  }

  return eb.getBytes();
}
/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */


function _generateKeyPair(state, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};
  var opts = {
    algorithm: {
      name: options.algorithm || 'PRIMEINC',
      options: {
        workers: options.workers || 2,
        workLoad: options.workLoad || 100,
        workerScript: options.workerScript
      }
    }
  };

  if ('prng' in options) {
    opts.prng = options.prng;
  }

  generate();

  function generate() {
    // find p and then q (done in series to simplify)
    getPrime(state.pBits, function (err, num) {
      if (err) {
        return callback(err);
      }

      state.p = num;

      if (state.q !== null) {
        return finish(err, state.q);
      }

      getPrime(state.qBits, finish);
    });
  }

  function getPrime(bits, callback) {
    forge.prime.generateProbablePrime(bits, opts, callback);
  }

  function finish(err, num) {
    if (err) {
      return callback(err);
    } // set q


    state.q = num; // ensure p is larger than q (swap them if not)

    if (state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    } // ensure p is coprime with e


    if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
      state.p = null;
      generate();
      return;
    } // ensure q is coprime with e


    if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    } // compute phi: (p - 1)(q - 1) (Euler's totient function)


    state.p1 = state.p.subtract(BigInteger.ONE);
    state.q1 = state.q.subtract(BigInteger.ONE);
    state.phi = state.p1.multiply(state.q1); // ensure e and phi are coprime

    if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
      // phi and e aren't coprime, so generate a new p and q
      state.p = state.q = null;
      generate();
      return;
    } // create n, ensure n is has the right number of bits


    state.n = state.p.multiply(state.q);

    if (state.n.bitLength() !== state.bits) {
      // failed, get new q
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    } // set keys


    var d = state.e.modInverse(state.phi);
    state.keys = {
      privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
      publicKey: pki.rsa.setPublicKey(state.n, state.e)
    };
    callback(null, state.keys);
  }
}
/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */


function _bnToBytes(b) {
  // prepend 0x00 if first byte >= 0x80
  var hex = b.toString(16);

  if (hex[0] >= '8') {
    hex = '00' + hex;
  }

  var bytes = forge.util.hexToBytes(hex); // ensure integer is minimally-encoded

  if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 0x80) === 0 || bytes.charCodeAt(0) === 0xFF && (bytes.charCodeAt(1) & 0x80) === 0x80)) {
    return bytes.substr(1);
  }

  return bytes;
}
/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */


function _getMillerRabinTests(bits) {
  if (bits <= 100) return 27;
  if (bits <= 150) return 18;
  if (bits <= 200) return 15;
  if (bits <= 250) return 12;
  if (bits <= 300) return 9;
  if (bits <= 350) return 8;
  if (bits <= 400) return 7;
  if (bits <= 500) return 6;
  if (bits <= 600) return 5;
  if (bits <= 800) return 4;
  if (bits <= 1250) return 3;
  return 2;
}
/**
 * Performs feature detection on the Node crypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */


function _detectNodeCrypto(fn) {
  return forge.util.isNodejs && typeof _crypto[fn] === 'function';
}
/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */


function _detectSubtleCrypto(fn) {
  return typeof util.globalScope !== 'undefined' && _typeof(util.globalScope.crypto) === 'object' && _typeof(util.globalScope.crypto.subtle) === 'object' && typeof util.globalScope.crypto.subtle[fn] === 'function';
}
/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */


function _detectSubtleMsCrypto(fn) {
  return typeof util.globalScope !== 'undefined' && _typeof(util.globalScope.msCrypto) === 'object' && _typeof(util.globalScope.msCrypto.subtle) === 'object' && typeof util.globalScope.msCrypto.subtle[fn] === 'function';
}

function _intToUint8Array(x) {
  var bytes = forge.util.hexToBytes(x.toString(16));
  var buffer = new Uint8Array(bytes.length);

  for (var i = 0; i < bytes.length; ++i) {
    buffer[i] = bytes.charCodeAt(i);
  }

  return buffer;
}

function _privateKeyFromJwk(jwk) {
  if (jwk.kty !== 'RSA') {
    throw new Error('Unsupported key algorithm "' + jwk.kty + '"; algorithm must be "RSA".');
  }

  return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e), _base64ToBigInt(jwk.d), _base64ToBigInt(jwk.p), _base64ToBigInt(jwk.q), _base64ToBigInt(jwk.dp), _base64ToBigInt(jwk.dq), _base64ToBigInt(jwk.qi));
}

function _publicKeyFromJwk(jwk) {
  if (jwk.kty !== 'RSA') {
    throw new Error('Key algorithm must be "RSA".');
  }

  return pki.setRsaPublicKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e));
}

function _base64ToBigInt(b64) {
  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./asn1":"node_modules/node-forge/lib/asn1.js","./jsbn":"node_modules/node-forge/lib/jsbn.js","./oids":"node_modules/node-forge/lib/oids.js","./pkcs1":"node_modules/node-forge/lib/pkcs1.js","./prime":"node_modules/node-forge/lib/prime.js","./random":"node_modules/node-forge/lib/random.js","./util":"node_modules/node-forge/lib/util.js","crypto":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/node-forge/lib/pbe.js":[function(require,module,exports) {
/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */
var forge = require('./forge');

require('./aes');

require('./asn1');

require('./des');

require('./md');

require('./oids');

require('./pbkdf2');

require('./pem');

require('./random');

require('./rc2');

require('./rsa');

require('./util');

if (typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
} // shortcut for asn.1 API


var asn1 = forge.asn1;
/* Password-based encryption implementation. */

var pki = forge.pki = forge.pki || {};
module.exports = pki.pbe = forge.pbe = forge.pbe || {};
var oids = pki.oids; // validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params

var encryptedPrivateKeyValidator = {
  name: 'EncryptedPrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encryptionOid'
    }, {
      name: 'AlgorithmIdentifier.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'encryptionParams'
    }]
  }, {
    // encryptedData
    name: 'EncryptedPrivateKeyInfo.encryptedData',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encryptedData'
  }]
}; // validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes

var PBES2AlgorithmsValidator = {
  name: 'PBES2Algorithms',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'PBES2Algorithms.keyDerivationFunc',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.keyDerivationFunc.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'kdfOid'
    }, {
      name: 'PBES2Algorithms.params',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PBES2Algorithms.params.salt',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'kdfSalt'
      }, {
        name: 'PBES2Algorithms.params.iterationCount',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'kdfIterationCount'
      }, {
        name: 'PBES2Algorithms.params.keyLength',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: 'keyLength'
      }, {
        // prf
        name: 'PBES2Algorithms.params.prf',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: 'PBES2Algorithms.params.prf.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'prfOid'
        }]
      }]
    }]
  }, {
    name: 'PBES2Algorithms.encryptionScheme',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.encryptionScheme.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encOid'
    }, {
      name: 'PBES2Algorithms.encryptionScheme.iv',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: 'encIv'
    }]
  }]
};
var pkcs12PbeParamsValidator = {
  name: 'pkcs-12PbeParams',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'pkcs-12PbeParams.salt',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'salt'
  }, {
    name: 'pkcs-12PbeParams.iterations',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'iterations'
  }]
};
/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */

pki.encryptPrivateKeyInfo = function (obj, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || 'aes128';
  options.prfAlgorithm = options.prfAlgorithm || 'sha1'; // generate PBE params

  var salt = forge.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;

  if (options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
    // do PBES2
    var ivLen, encOid, cipherFn;

    switch (options.algorithm) {
      case 'aes128':
        dkLen = 16;
        ivLen = 16;
        encOid = oids['aes128-CBC'];
        cipherFn = forge.aes.createEncryptionCipher;
        break;

      case 'aes192':
        dkLen = 24;
        ivLen = 16;
        encOid = oids['aes192-CBC'];
        cipherFn = forge.aes.createEncryptionCipher;
        break;

      case 'aes256':
        dkLen = 32;
        ivLen = 16;
        encOid = oids['aes256-CBC'];
        cipherFn = forge.aes.createEncryptionCipher;
        break;

      case 'des':
        dkLen = 8;
        ivLen = 8;
        encOid = oids['desCBC'];
        cipherFn = forge.des.createEncryptionCipher;
        break;

      default:
        var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
        error.algorithm = options.algorithm;
        throw error;
    } // get PRF message digest


    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm); // encrypt private key using pbe SHA-1 and AES/DES

    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes(); // get PBKDF2-params

    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
    encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBES2']).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// keyDerivationFunc
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()), // PBKDF2-params
    params]), // encryptionScheme
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), // iv
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]);
  } else if (options.algorithm === '3des') {
    // Do PKCS12 PBE
    dkLen = 24;
    var saltBytes = new forge.util.ByteBuffer(salt);
    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()), // pkcs-12PbeParams
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// salt
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), // iteration count
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]);
  } else {
    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
    error.algorithm = options.algorithm;
    throw error;
  } // EncryptedPrivateKeyInfo


  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// encryptionAlgorithm
  encryptionAlgorithm, // encryptedData
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]);
  return rval;
};
/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */


pki.decryptPrivateKeyInfo = function (obj, password) {
  var rval = null; // get PBE params

  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read encrypted private key. ' + 'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  } // get cipher


  var oid = asn1.derToOid(capture.encryptionOid);
  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password); // get encrypted data

  var encrypted = forge.util.createBuffer(capture.encryptedData);
  cipher.update(encrypted);

  if (cipher.finish()) {
    rval = asn1.fromDer(cipher.output);
  }

  return rval;
};
/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */


pki.encryptedPrivateKeyToPem = function (epki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'ENCRYPTED PRIVATE KEY',
    body: asn1.toDer(epki).getBytes()
  };
  return forge.pem.encode(msg, {
    maxline: maxline
  });
};
/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */


pki.encryptedPrivateKeyFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'ENCRYPTED PRIVATE KEY') {
    var error = new Error('Could not convert encrypted private key from PEM; ' + 'PEM header type is "ENCRYPTED PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert encrypted private key from PEM; ' + 'PEM is encrypted.');
  } // convert DER to ASN.1 object


  return asn1.fromDer(msg.body);
};
/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */


pki.encryptRsaPrivateKey = function (rsaKey, password, options) {
  // standard PKCS#8
  options = options || {};

  if (!options.legacy) {
    // encrypt PrivateKeyInfo
    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
    rval = pki.encryptPrivateKeyInfo(rval, password, options);
    return pki.encryptedPrivateKeyToPem(rval);
  } // legacy non-PKCS#8


  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;

  switch (options.algorithm) {
    case 'aes128':
      algorithm = 'AES-128-CBC';
      dkLen = 16;
      iv = forge.random.getBytesSync(16);
      cipherFn = forge.aes.createEncryptionCipher;
      break;

    case 'aes192':
      algorithm = 'AES-192-CBC';
      dkLen = 24;
      iv = forge.random.getBytesSync(16);
      cipherFn = forge.aes.createEncryptionCipher;
      break;

    case 'aes256':
      algorithm = 'AES-256-CBC';
      dkLen = 32;
      iv = forge.random.getBytesSync(16);
      cipherFn = forge.aes.createEncryptionCipher;
      break;

    case '3des':
      algorithm = 'DES-EDE3-CBC';
      dkLen = 24;
      iv = forge.random.getBytesSync(8);
      cipherFn = forge.des.createEncryptionCipher;
      break;

    case 'des':
      algorithm = 'DES-CBC';
      dkLen = 8;
      iv = forge.random.getBytesSync(8);
      cipherFn = forge.des.createEncryptionCipher;
      break;

    default:
      var error = new Error('Could not encrypt RSA private key; unsupported ' + 'encryption algorithm "' + options.algorithm + '".');
      error.algorithm = options.algorithm;
      throw error;
  } // encrypt private key using OpenSSL legacy key derivation


  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
  cipher.finish();
  var msg = {
    type: 'RSA PRIVATE KEY',
    procType: {
      version: '4',
      type: 'ENCRYPTED'
    },
    dekInfo: {
      algorithm: algorithm,
      parameters: forge.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge.pem.encode(msg);
};
/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */


pki.decryptRsaPrivateKey = function (pem, password) {
  var rval = null;
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'ENCRYPTED PRIVATE KEY' && msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM header type ' + 'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error.headerType = error;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    var dkLen;
    var cipherFn;

    switch (msg.dekInfo.algorithm) {
      case 'DES-CBC':
        dkLen = 8;
        cipherFn = forge.des.createDecryptionCipher;
        break;

      case 'DES-EDE3-CBC':
        dkLen = 24;
        cipherFn = forge.des.createDecryptionCipher;
        break;

      case 'AES-128-CBC':
        dkLen = 16;
        cipherFn = forge.aes.createDecryptionCipher;
        break;

      case 'AES-192-CBC':
        dkLen = 24;
        cipherFn = forge.aes.createDecryptionCipher;
        break;

      case 'AES-256-CBC':
        dkLen = 32;
        cipherFn = forge.aes.createDecryptionCipher;
        break;

      case 'RC2-40-CBC':
        dkLen = 5;

        cipherFn = function (key) {
          return forge.rc2.createDecryptionCipher(key, 40);
        };

        break;

      case 'RC2-64-CBC':
        dkLen = 8;

        cipherFn = function (key) {
          return forge.rc2.createDecryptionCipher(key, 64);
        };

        break;

      case 'RC2-128-CBC':
        dkLen = 16;

        cipherFn = function (key) {
          return forge.rc2.createDecryptionCipher(key, 128);
        };

        break;

      default:
        var error = new Error('Could not decrypt private key; unsupported ' + 'encryption algorithm "' + msg.dekInfo.algorithm + '".');
        error.algorithm = msg.dekInfo.algorithm;
        throw error;
    } // use OpenSSL legacy key derivation


    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge.util.createBuffer(msg.body));

    if (cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }

  if (msg.type === 'ENCRYPTED PRIVATE KEY') {
    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
  } else {
    // decryption already performed above
    rval = asn1.fromDer(rval);
  }

  if (rval !== null) {
    rval = pki.privateKeyFromAsn1(rval);
  }

  return rval;
};
/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */


pki.pbe.generatePkcs12Key = function (password, salt, id, iter, n, md) {
  var j, l;

  if (typeof md === 'undefined' || md === null) {
    if (!('sha1' in forge.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }

    md = forge.md.sha1.create();
  }

  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge.util.ByteBuffer();
  /* Convert password to Unicode byte buffer + trailing 0-byte. */

  var passBuf = new forge.util.ByteBuffer();

  if (password !== null && password !== undefined) {
    for (l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }

    passBuf.putInt16(0);
  }
  /* Length of salt and password in BYTES. */


  var p = passBuf.length();
  var s = salt.length();
  /* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */

  var D = new forge.util.ByteBuffer();
  D.fillWithByte(id, v);
  /* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */

  var Slen = v * Math.ceil(s / v);
  var S = new forge.util.ByteBuffer();

  for (l = 0; l < Slen; l++) {
    S.putByte(salt.at(l % s));
  }
  /* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */


  var Plen = v * Math.ceil(p / v);
  var P = new forge.util.ByteBuffer();

  for (l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }
  /* 4. Set I=S||P to be the concatenation of S and P. */


  var I = S;
  I.putBuffer(P);
  /* 5. Set c=ceil(n / u). */

  var c = Math.ceil(n / u);
  /* 6. For i=1, 2, ..., c, do the following: */

  for (var i = 1; i <= c; i++) {
    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */
    var buf = new forge.util.ByteBuffer();
    buf.putBytes(D.bytes());
    buf.putBytes(I.bytes());

    for (var round = 0; round < iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }
    /* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */


    var B = new forge.util.ByteBuffer();

    for (l = 0; l < v; l++) {
      B.putByte(buf.at(l % u));
    }
    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */


    var k = Math.ceil(s / v) + Math.ceil(p / v);
    var Inew = new forge.util.ByteBuffer();

    for (j = 0; j < k; j++) {
      var chunk = new forge.util.ByteBuffer(I.getBytes(v));
      var x = 0x1ff;

      for (l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 0xff);
      }

      Inew.putBuffer(chunk);
    }

    I = Inew;
    /* Add Ai to A. */

    result.putBuffer(buf);
  }

  result.truncate(result.length() - n);
  return result;
};
/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */


pki.pbe.getCipher = function (oid, params, password) {
  switch (oid) {
    case pki.oids['pkcs5PBES2']:
      return pki.pbe.getCipherForPBES2(oid, params, password);

    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
      return pki.pbe.getCipherForPKCS12PBE(oid, params, password);

    default:
      var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
      error.oid = oid;
      error.supportedOids = ['pkcs5PBES2', 'pbeWithSHAAnd3-KeyTripleDES-CBC', 'pbewithSHAAnd40BitRC2-CBC'];
      throw error;
  }
};
/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */


pki.pbe.getCipherForPBES2 = function (oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];

  if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  } // check oids


  oid = asn1.derToOid(capture.kdfOid);

  if (oid !== pki.oids['pkcs5PBKDF2']) {
    var error = new Error('Cannot read encrypted private key. ' + 'Unsupported key derivation function OID.');
    error.oid = oid;
    error.supportedOids = ['pkcs5PBKDF2'];
    throw error;
  }

  oid = asn1.derToOid(capture.encOid);

  if (oid !== pki.oids['aes128-CBC'] && oid !== pki.oids['aes192-CBC'] && oid !== pki.oids['aes256-CBC'] && oid !== pki.oids['des-EDE3-CBC'] && oid !== pki.oids['desCBC']) {
    var error = new Error('Cannot read encrypted private key. ' + 'Unsupported encryption scheme OID.');
    error.oid = oid;
    error.supportedOids = ['aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
    throw error;
  } // set PBE params


  var salt = capture.kdfSalt;
  var count = forge.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;

  switch (pki.oids[oid]) {
    case 'aes128-CBC':
      dkLen = 16;
      cipherFn = forge.aes.createDecryptionCipher;
      break;

    case 'aes192-CBC':
      dkLen = 24;
      cipherFn = forge.aes.createDecryptionCipher;
      break;

    case 'aes256-CBC':
      dkLen = 32;
      cipherFn = forge.aes.createDecryptionCipher;
      break;

    case 'des-EDE3-CBC':
      dkLen = 24;
      cipherFn = forge.des.createDecryptionCipher;
      break;

    case 'desCBC':
      dkLen = 8;
      cipherFn = forge.des.createDecryptionCipher;
      break;
  } // get PRF message digest


  var md = prfOidToMessageDigest(capture.prfOid); // decrypt private key using pbe with chosen PRF and AES/DES

  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);
  return cipher;
};
/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */


pki.pbe.getCipherForPKCS12PBE = function (oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];

  if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' + 'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  var salt = forge.util.createBuffer(capture.salt);
  var count = forge.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);
  var dkLen, dIvLen, cipherFn;

  switch (oid) {
    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge.des.startDecrypting;
      break;

    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
      dkLen = 5;
      dIvLen = 8;

      cipherFn = function (key, iv) {
        var cipher = forge.rc2.createDecryptionCipher(key, 40);
        cipher.start(iv, null);
        return cipher;
      };

      break;

    default:
      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
      error.oid = oid;
      throw error;
  } // get PRF message digest


  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
  return cipherFn(key, iv);
};
/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */


pki.pbe.opensslDeriveBytes = function (password, salt, dkLen, md) {
  if (typeof md === 'undefined' || md === null) {
    if (!('md5' in forge.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }

    md = forge.md.md5.create();
  }

  if (salt === null) {
    salt = '';
  }

  var digests = [hash(md, password + salt)];

  for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }

  return digests.join('').substr(0, dkLen);
};

function hash(md, bytes) {
  return md.start().update(bytes).digest().getBytes();
}

function prfOidToMessageDigest(prfOid) {
  // get PRF algorithm, default to SHA-1
  var prfAlgorithm;

  if (!prfOid) {
    prfAlgorithm = 'hmacWithSHA1';
  } else {
    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];

    if (!prfAlgorithm) {
      var error = new Error('Unsupported PRF OID.');
      error.oid = prfOid;
      error.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512'];
      throw error;
    }
  }

  return prfAlgorithmToMessageDigest(prfAlgorithm);
}

function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory = forge.md;

  switch (prfAlgorithm) {
    case 'hmacWithSHA224':
      factory = forge.md.sha512;

    case 'hmacWithSHA1':
    case 'hmacWithSHA256':
    case 'hmacWithSHA384':
    case 'hmacWithSHA512':
      prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
      break;

    default:
      var error = new Error('Unsupported PRF algorithm.');
      error.algorithm = prfAlgorithm;
      error.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512'];
      throw error;
  }

  if (!factory || !(prfAlgorithm in factory)) {
    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);
  }

  return factory[prfAlgorithm].create();
}

function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// salt
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), // iteration count
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())]); // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm

  if (prfAlgorithm !== 'hmacWithSHA1') {
    params.value.push( // key length
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]));
  }

  return params;
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./aes":"node_modules/node-forge/lib/aes.js","./asn1":"node_modules/node-forge/lib/asn1.js","./des":"node_modules/node-forge/lib/des.js","./md":"node_modules/node-forge/lib/md.js","./oids":"node_modules/node-forge/lib/oids.js","./pbkdf2":"node_modules/node-forge/lib/pbkdf2.js","./pem":"node_modules/node-forge/lib/pem.js","./random":"node_modules/node-forge/lib/random.js","./rc2":"node_modules/node-forge/lib/rc2.js","./rsa":"node_modules/node-forge/lib/rsa.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/multiformats/cjs/src/bases/identity.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');
var bytes = require('../bytes.js');

const identity = base.from({
  prefix: '\0',
  name: 'identity',
  encode: buf => bytes.toString(buf),
  decode: str => bytes.fromString(str)
});

exports.identity = identity;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js","../bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/multiformats/cjs/src/bases/base2.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base2 = base.rfc4648({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
});

exports.base2 = base2;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/bases/base8.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base8 = base.rfc4648({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
});

exports.base8 = base8;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/bases/base10.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');

const base10 = base.baseX({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
});

exports.base10 = base10;

},{"./base.js":"node_modules/multiformats/cjs/src/bases/base.js"}],"node_modules/multiformats/cjs/src/hashes/hasher.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var digest = require('./digest.js');

const from = ({name, code, encode}) => new Hasher(name, code, encode);
class Hasher {
  constructor(name, code, encode) {
    this.name = name;
    this.code = code;
    this.encode = encode;
  }
  async digest(input) {
    if (input instanceof Uint8Array) {
      const digest$1 = await this.encode(input);
      return digest.create(this.code, digest$1);
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}

exports.Hasher = Hasher;
exports.from = from;

},{"./digest.js":"node_modules/multiformats/cjs/src/hashes/digest.js"}],"node_modules/multiformats/cjs/src/hashes/sha2-browser.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hasher = require('./hasher.js');

const sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));
const sha256 = hasher.from({
  name: 'sha2-256',
  code: 18,
  encode: sha('SHA-256')
});
const sha512 = hasher.from({
  name: 'sha2-512',
  code: 19,
  encode: sha('SHA-512')
});

exports.sha256 = sha256;
exports.sha512 = sha512;

},{"./hasher.js":"node_modules/multiformats/cjs/src/hashes/hasher.js"}],"node_modules/multiformats/cjs/src/hashes/identity.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hasher = require('./hasher.js');
var bytes = require('../bytes.js');

const identity = hasher.from({
  name: 'identity',
  code: 0,
  encode: input => bytes.coerce(input)
});

exports.identity = identity;

},{"./hasher.js":"node_modules/multiformats/cjs/src/hashes/hasher.js","../bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/multiformats/cjs/src/codecs/raw.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bytes = require('../bytes.js');

const raw = bytes$1 => bytes.coerce(bytes$1);
const {name, code, encode, decode} = {
  name: 'raw',
  code: 85,
  decode: raw,
  encode: raw
};

exports.code = code;
exports.decode = decode;
exports.encode = encode;
exports.name = name;

},{"../bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/multiformats/cjs/src/codecs/json.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const {name, code, encode, decode} = {
  name: 'json',
  code: 512,
  encode: json => new TextEncoder().encode(JSON.stringify(json)),
  decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
};

exports.code = code;
exports.decode = decode;
exports.encode = encode;
exports.name = name;

},{}],"node_modules/multiformats/cjs/src/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('./cid.js');
var varint = require('./varint.js');
var bytes = require('./bytes.js');
var hasher = require('./hashes/hasher.js');
var digest = require('./hashes/digest.js');



exports.CID = cid.CID;
exports.varint = varint;
exports.bytes = bytes;
exports.hasher = hasher;
exports.digest = digest;

},{"./cid.js":"node_modules/multiformats/cjs/src/cid.js","./varint.js":"node_modules/multiformats/cjs/src/varint.js","./bytes.js":"node_modules/multiformats/cjs/src/bytes.js","./hashes/hasher.js":"node_modules/multiformats/cjs/src/hashes/hasher.js","./hashes/digest.js":"node_modules/multiformats/cjs/src/hashes/digest.js"}],"node_modules/multiformats/cjs/src/basics.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var identity = require('./bases/identity.js');
var base2 = require('./bases/base2.js');
var base8 = require('./bases/base8.js');
var base10 = require('./bases/base10.js');
var base16 = require('./bases/base16.js');
var base32 = require('./bases/base32.js');
var base36 = require('./bases/base36.js');
var base58 = require('./bases/base58.js');
var base64 = require('./bases/base64.js');
var sha2 = require('./hashes/sha2.js');
var identity$1 = require('./hashes/identity.js');
var raw = require('./codecs/raw.js');
var json = require('./codecs/json.js');
require('./index.js');
var cid = require('./cid.js');
var hasher = require('./hashes/hasher.js');
var digest = require('./hashes/digest.js');
var varint = require('./varint.js');
var bytes = require('./bytes.js');

const bases = {
  ...identity,
  ...base2,
  ...base8,
  ...base10,
  ...base16,
  ...base32,
  ...base36,
  ...base58,
  ...base64
};
const hashes = {
  ...sha2,
  ...identity$1
};
const codecs = {
  raw,
  json
};

exports.CID = cid.CID;
exports.hasher = hasher;
exports.digest = digest;
exports.varint = varint;
exports.bytes = bytes;
exports.bases = bases;
exports.codecs = codecs;
exports.hashes = hashes;

},{"./bases/identity.js":"node_modules/multiformats/cjs/src/bases/identity.js","./bases/base2.js":"node_modules/multiformats/cjs/src/bases/base2.js","./bases/base8.js":"node_modules/multiformats/cjs/src/bases/base8.js","./bases/base10.js":"node_modules/multiformats/cjs/src/bases/base10.js","./bases/base16.js":"node_modules/multiformats/cjs/src/bases/base16.js","./bases/base32.js":"node_modules/multiformats/cjs/src/bases/base32.js","./bases/base36.js":"node_modules/multiformats/cjs/src/bases/base36.js","./bases/base58.js":"node_modules/multiformats/cjs/src/bases/base58.js","./bases/base64.js":"node_modules/multiformats/cjs/src/bases/base64.js","./hashes/sha2.js":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","./hashes/identity.js":"node_modules/multiformats/cjs/src/hashes/identity.js","./codecs/raw.js":"node_modules/multiformats/cjs/src/codecs/raw.js","./codecs/json.js":"node_modules/multiformats/cjs/src/codecs/json.js","./index.js":"node_modules/multiformats/cjs/src/index.js","./cid.js":"node_modules/multiformats/cjs/src/cid.js","./hashes/hasher.js":"node_modules/multiformats/cjs/src/hashes/hasher.js","./hashes/digest.js":"node_modules/multiformats/cjs/src/hashes/digest.js","./varint.js":"node_modules/multiformats/cjs/src/varint.js","./bytes.js":"node_modules/multiformats/cjs/src/bytes.js"}],"node_modules/uint8arrays/util/bases.js":[function(require,module,exports) {
  'use strict'

const { bases } = require('multiformats/basics')

/**
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 */

/**
 * @param {string} name
 * @param {string} prefix
 * @param {(buf: Uint8Array) => string} encode
 * @param {(str: string) => Uint8Array} decode
 * @returns {MultibaseCodec}
 */
function createCodec (name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: {
      decode
    }
  }
}

const string = createCodec('utf8', 'u', (buf) => {
  const decoder = new TextDecoder('utf8')
  return 'u' + decoder.decode(buf)
}, (str) => {
  const encoder = new TextEncoder()
  return encoder.encode(str.substring(1))
})

const ascii = createCodec('ascii', 'a', (buf) => {
  let string = 'a'

  for (let i = 0; i < buf.length; i++) {
    string += String.fromCharCode(buf[i])
  }
  return string
}, (str) => {
  str = str.substring(1)
  const buf = new Uint8Array(str.length)

  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i)
  }

  return buf
})

/**
 * @typedef {'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof bases } SupportedEncodings
 */

/**
 * @type {Record<SupportedEncodings, MultibaseCodec>}
 */
const BASES = {
  'utf8': string,
  'utf-8': string,
  'hex': bases.base16,
  'latin1': ascii,
  'ascii': ascii,
  'binary': ascii,

  ...bases
}

module.exports = BASES

},{"multiformats/basics":"node_modules/multiformats/cjs/src/basics.js"}],"node_modules/uint8arrays/from-string.js":[function(require,module,exports) {
'use strict'

const bases = require('./util/bases')

/**
 * @typedef {import('./util/bases').SupportedEncodings} SupportedEncodings
 */

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {string} string
 * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 */
function fromString (string, encoding = 'utf8') {
  const base = bases[encoding]

  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`)
  }

  // add multibase prefix
  return base.decoder.decode(`${base.prefix}${string}`)
}

module.exports = fromString

},{"./util/bases":"node_modules/uint8arrays/util/bases.js"}],"node_modules/uint8arrays/concat.js":[function(require,module,exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {number} [length]
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

},{}],"node_modules/libp2p-crypto/src/webcrypto.js":[function(require,module,exports) {
/* eslint-env browser */
'use strict'; // Check native crypto exists and is enabled (In insecure context `self.crypto`
// exists but `self.crypto.subtle` does not).

exports.get = function () {
  var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : self;
  var nativeCrypto = win.crypto || win.msCrypto;

  if (!nativeCrypto || !nativeCrypto.subtle) {
    throw Object.assign(new Error('Missing Web Crypto API. ' + 'The most likely cause of this error is that this page is being accessed ' + 'from an insecure context (i.e. not HTTPS). For more information and ' + 'possible resolutions see ' + 'https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api'), {
      code: 'ERR_MISSING_WEB_CRYPTO'
    });
  }

  return nativeCrypto;
};
},{}],"node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var concat = require('uint8arrays/concat');

var fromString = require('uint8arrays/from-string');

var webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples

/**
 *
 * @param {object} [options]
 * @param {string} [options.algorithm=AES-GCM]
 * @param {number} [options.nonceLength=12]
 * @param {number} [options.keyLength=16]
 * @param {string} [options.digest=sha256]
 * @param {number} [options.saltLength=16]
 * @param {number} [options.iterations=32767]
 * @returns {*}
 */


function create() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$algorithm = _ref.algorithm,
      algorithm = _ref$algorithm === void 0 ? 'AES-GCM' : _ref$algorithm,
      _ref$nonceLength = _ref.nonceLength,
      nonceLength = _ref$nonceLength === void 0 ? 12 : _ref$nonceLength,
      _ref$keyLength = _ref.keyLength,
      keyLength = _ref$keyLength === void 0 ? 16 : _ref$keyLength,
      _ref$digest = _ref.digest,
      digest = _ref$digest === void 0 ? 'SHA-256' : _ref$digest,
      _ref$saltLength = _ref.saltLength,
      saltLength = _ref$saltLength === void 0 ? 16 : _ref$saltLength,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? 32767 : _ref$iterations;

  var crypto = webcrypto.get();
  keyLength *= 8; // Browser crypto uses bits instead of bytes

  /**
   * Uses the provided password to derive a pbkdf2 key. The key
   * will then be used to encrypt the data.
   *
   * @param {Uint8Array} data - The data to decrypt
   * @param {string} password - A plain password
   * @returns {Promise<Uint8Array>}
   */

  function encrypt(_x, _x2) {
    return _encrypt.apply(this, arguments);
  }
  /**
   * Uses the provided password to derive a pbkdf2 key. The key
   * will then be used to decrypt the data. The options used to create
   * this decryption cipher must be the same as those used to create
   * the encryption cipher.
   *
   * @param {Uint8Array} data - The data to decrypt
   * @param {string} password - A plain password
   * @returns {Promise<Uint8Array>}
   */


  function _encrypt() {
    _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, password) {
      var salt, nonce, aesGcm, deriveParams, rawKey, cryptoKey, ciphertext;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // eslint-disable-line require-await
              salt = crypto.getRandomValues(new Uint8Array(saltLength));
              nonce = crypto.getRandomValues(new Uint8Array(nonceLength));
              aesGcm = {
                name: algorithm,
                iv: nonce
              }; // Derive a key using PBKDF2.

              deriveParams = {
                name: 'PBKDF2',
                salt: salt,
                iterations: iterations,
                hash: {
                  name: digest
                }
              };
              _context.next = 6;
              return crypto.subtle.importKey('raw', fromString(password), {
                name: 'PBKDF2'
              }, false, ['deriveKey', 'deriveBits']);

            case 6:
              rawKey = _context.sent;
              _context.next = 9;
              return crypto.subtle.deriveKey(deriveParams, rawKey, {
                name: algorithm,
                length: keyLength
              }, true, ['encrypt']);

            case 9:
              cryptoKey = _context.sent;
              _context.next = 12;
              return crypto.subtle.encrypt(aesGcm, cryptoKey, data);

            case 12:
              ciphertext = _context.sent;
              return _context.abrupt("return", concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]));

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _encrypt.apply(this, arguments);
  }

  function decrypt(_x3, _x4) {
    return _decrypt.apply(this, arguments);
  }

  function _decrypt() {
    _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data, password) {
      var salt, nonce, ciphertext, aesGcm, deriveParams, rawKey, cryptoKey, plaintext;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              salt = data.slice(0, saltLength);
              nonce = data.slice(saltLength, saltLength + nonceLength);
              ciphertext = data.slice(saltLength + nonceLength);
              aesGcm = {
                name: algorithm,
                iv: nonce
              }; // Derive the key using PBKDF2.

              deriveParams = {
                name: 'PBKDF2',
                salt: salt,
                iterations: iterations,
                hash: {
                  name: digest
                }
              };
              _context2.next = 7;
              return crypto.subtle.importKey('raw', fromString(password), {
                name: 'PBKDF2'
              }, false, ['deriveKey', 'deriveBits']);

            case 7:
              rawKey = _context2.sent;
              _context2.next = 10;
              return crypto.subtle.deriveKey(deriveParams, rawKey, {
                name: algorithm,
                length: keyLength
              }, true, ['decrypt']);

            case 10:
              cryptoKey = _context2.sent;
              _context2.next = 13;
              return crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);

            case 13:
              plaintext = _context2.sent;
              return _context2.abrupt("return", new Uint8Array(plaintext));

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _decrypt.apply(this, arguments);
  }

  return {
    encrypt: encrypt,
    decrypt: decrypt
  };
}

module.exports = {
  create: create
};
},{"uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","../webcrypto":"node_modules/libp2p-crypto/src/webcrypto.js"}],"node_modules/libp2p-crypto/src/keys/importer.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/bases/base64'),
    base64 = _require.base64;

var ciphers = require('../ciphers/aes-gcm');

module.exports = {
  /**
   * Attempts to decrypt a base64 encoded PrivateKey string
   * with the given password. The privateKey must have been exported
   * using the same password and underlying cipher (aes-gcm)
   *
   * @param {string} privateKey - A base64 encoded encrypted key
   * @param {string} password
   * @returns {Promise<Uint8Array>} The private key protobuf
   */
  import: function () {
    var _import2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(privateKey, password) {
      var encryptedKey, cipher;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              encryptedKey = base64.decode(privateKey);
              cipher = ciphers.create();
              _context.next = 4;
              return cipher.decrypt(encryptedKey, password);

            case 4:
              return _context.abrupt("return", _context.sent);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function _import(_x, _x2) {
      return _import2.apply(this, arguments);
    }

    return _import;
  }()
};
},{"multiformats/bases/base64":"node_modules/multiformats/cjs/src/bases/base64.js","../ciphers/aes-gcm":"node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"}],"node_modules/uint8arrays/equals.js":[function(require,module,exports) {
'use strict'

/**
 * Returns true if the two passed Uint8Arrays have the same content
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */
function equals (a, b) {
  if (a === b) {
    return true
  }

  if (a.byteLength !== b.byteLength) {
    return false
  }

  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false
    }
  }

  return true
}

module.exports = equals

},{}],"node_modules/uint8arrays/to-string.js":[function(require,module,exports) {
'use strict'

const bases = require('./util/bases')

/**
 * @typedef {import('./util/bases').SupportedEncodings} SupportedEncodings
 */

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array - The array to turn into a string
 * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
 * @returns {string}
 */
function toString (array, encoding = 'utf8') {
  const base = bases[encoding]

  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`)
  }

  // strip multibase prefix
  return base.encoder.encode(array).substring(1)
}

module.exports = toString

},{"./util/bases":"node_modules/uint8arrays/util/bases.js"}],"node_modules/node-forge/lib/sha512.js":[function(require,module,exports) {
/**
 * Secure Hash Algorithm with a 1024-bit block size implementation.
 *
 * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For
 * SHA-256 (block size 512 bits), see sha256.js.
 *
 * See FIPS 180-4 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha512 = module.exports = forge.sha512 = forge.sha512 || {}; // SHA-512

forge.md.sha512 = forge.md.algorithms.sha512 = sha512; // SHA-384

var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};

sha384.create = function () {
  return sha512.create('SHA-384');
};

forge.md.sha384 = forge.md.algorithms.sha384 = sha384; // SHA-512/256

forge.sha512.sha256 = forge.sha512.sha256 || {
  create: function () {
    return sha512.create('SHA-512/256');
  }
};
forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] = forge.sha512.sha256; // SHA-512/224

forge.sha512.sha224 = forge.sha512.sha224 || {
  create: function () {
    return sha512.create('SHA-512/224');
  }
};
forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] = forge.sha512.sha224;
/**
 * Creates a SHA-2 message digest object.
 *
 * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,
 *          SHA-512/256).
 *
 * @return a message digest object.
 */

sha512.create = function (algorithm) {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  }

  if (typeof algorithm === 'undefined') {
    algorithm = 'SHA-512';
  }

  if (!(algorithm in _states)) {
    throw new Error('Invalid SHA-512 algorithm: ' + algorithm);
  } // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)


  var _state = _states[algorithm];
  var _h = null; // input buffer

  var _input = forge.util.createBuffer(); // used for 64-bit word storage


  var _w = new Array(80);

  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  } // determine digest length by algorithm name (default)


  var digestLength = 64;

  switch (algorithm) {
    case 'SHA-384':
      digestLength = 48;
      break;

    case 'SHA-512/256':
      digestLength = 32;
      break;

    case 'SHA-512/224':
      digestLength = 28;
      break;
  } // message digest object


  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace('-', '').toLowerCase(),
    blockLength: 128,
    digestLength: digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength128 for backwards-compatibility)

    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _h = new Array(_state.length);

    for (var i = 0; i < _state.length; ++i) {
      _h[i] = _state[i].slice(0);
    }

    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_h, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-512 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 896 mod 1024. In other words,
    the data to be digested must be a multiple of 1024 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 16 bytes (128
    bits), that means that the last segment of the data must have 112 bytes
    (896 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 896 mod 1024 because
    1024 - 128 = 896.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 896 mod 1024, then 1024 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var h = new Array(_h.length);

    for (var i = 0; i < _h.length; ++i) {
      h[i] = _h[i].slice(0);
    }

    _update(h, _w, finalBlock);

    var rval = forge.util.createBuffer();
    var hlen;

    if (algorithm === 'SHA-512') {
      hlen = h.length;
    } else if (algorithm === 'SHA-384') {
      hlen = h.length - 2;
    } else {
      hlen = h.length - 4;
    }

    for (var i = 0; i < hlen; ++i) {
      rval.putInt32(h[i][0]);

      if (i !== hlen - 1 || algorithm !== 'SHA-512/224') {
        rval.putInt32(h[i][1]);
      }
    }

    return rval;
  };

  return md;
}; // sha-512 padding bytes not initialized yet


var _padding = null;
var _initialized = false; // table of constants

var _k = null; // initial hash states

var _states = null;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 128); // create K table for SHA-512

  _k = [[0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe], [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65], [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725], [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b], [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53], [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec], [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6], [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]]; // initial hash states

  _states = {};
  _states['SHA-512'] = [[0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1], [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]];
  _states['SHA-384'] = [[0xcbbb9d5d, 0xc1059ed8], [0x629a292a, 0x367cd507], [0x9159015a, 0x3070dd17], [0x152fecd8, 0xf70e5939], [0x67332667, 0xffc00b31], [0x8eb44a87, 0x68581511], [0xdb0c2e0d, 0x64f98fa7], [0x47b5481d, 0xbefa4fa4]];
  _states['SHA-512/256'] = [[0x22312194, 0xFC2BF72C], [0x9F555FA3, 0xC84C64C2], [0x2393B86B, 0x6F53B151], [0x96387719, 0x5940EABD], [0x96283EE2, 0xA88EFFE3], [0xBE5E1E25, 0x53863992], [0x2B0199FC, 0x2C85B8AA], [0x0EB72DDC, 0x81C52CA2]];
  _states['SHA-512/224'] = [[0x8C3D37C8, 0x19544DA2], [0x73E19966, 0x89DCD4D6], [0x1DFAB7AE, 0x32FF9C82], [0x679DD514, 0x582F9FCF], [0x0F6D2B69, 0x7BD44DA8], [0x77E36F73, 0x04C48942], [0x3F9D85A8, 0x6A1D36C8], [0x1112E6AD, 0x91D692A1]]; // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-512 state with the given byte buffer.
 *
 * @param s the SHA-512 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (128 byte) chunks
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i, hi, lo, w2, w7, w15, w16;
  var len = bytes.length();

  while (len >= 128) {
    // the w array will be populated with sixteen 64-bit big-endian words
    // and then extended into 64 64-bit words according to SHA-512
    for (i = 0; i < 16; ++i) {
      w[i][0] = bytes.getInt32() >>> 0;
      w[i][1] = bytes.getInt32() >>> 0;
    }

    for (; i < 80; ++i) {
      // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)
      w2 = w[i - 2];
      hi = w2[0];
      lo = w2[1]; // high bits

      t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0; // SHR 6
      // low bits

      t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0; // SHR 6
      // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)

      w15 = w[i - 15];
      hi = w15[0];
      lo = w15[1]; // high bits

      t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0; // SHR 7
      // low bits

      t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0; // SHR 7
      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)

      w7 = w[i - 7];
      w16 = w[i - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 0x100000000 >>> 0) >>> 0;
      w[i][1] = lo >>> 0;
    } // initialize hash value for this chunk


    a_hi = s[0][0];
    a_lo = s[0][1];
    b_hi = s[1][0];
    b_lo = s[1][1];
    c_hi = s[2][0];
    c_lo = s[2][1];
    d_hi = s[3][0];
    d_lo = s[3][1];
    e_hi = s[4][0];
    e_lo = s[4][1];
    f_hi = s[5][0];
    f_lo = s[5][1];
    g_hi = s[6][0];
    g_lo = s[6][1];
    h_hi = s[7][0];
    h_lo = s[7][1]; // round function

    for (i = 0; i < 80; ++i) {
      // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0; // ROTR 41/(swap + ROTR 9)

      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0; // ROTR 41/(swap + ROTR 9)
      // Ch(e, f, g) (optimized the same way as SHA-1)

      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0; // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)

      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0; // ROTR 39/(swap + ROTR 7)

      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0; // ROTR 39/(swap + ROTR 7)
      // Maj(a, b, c) (optimized the same way as SHA-1)

      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0; // main algorithm
      // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)

      lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 0x100000000 >>> 0) >>> 0;
      t1_lo = lo >>> 0; // t2 = s0 + maj modulo 2^64 (carry lo overflow)

      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 0x100000000 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo; // e = (d + t1) modulo 2^64 (carry lo overflow)

      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 0x100000000 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo; // a = (t1 + t2) modulo 2^64 (carry lo overflow)

      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 0x100000000 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    } // update hash state (additional modulo 2^64)


    lo = s[0][1] + a_lo;
    s[0][0] = s[0][0] + a_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[0][1] = lo >>> 0;
    lo = s[1][1] + b_lo;
    s[1][0] = s[1][0] + b_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[1][1] = lo >>> 0;
    lo = s[2][1] + c_lo;
    s[2][0] = s[2][0] + c_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[2][1] = lo >>> 0;
    lo = s[3][1] + d_lo;
    s[3][0] = s[3][0] + d_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[3][1] = lo >>> 0;
    lo = s[4][1] + e_lo;
    s[4][0] = s[4][0] + e_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[4][1] = lo >>> 0;
    lo = s[5][1] + f_lo;
    s[5][0] = s[5][0] + f_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[5][1] = lo >>> 0;
    lo = s[6][1] + g_lo;
    s[6][0] = s[6][0] + g_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[6][1] = lo >>> 0;
    lo = s[7][1] + h_lo;
    s[7][0] = s[7][0] + h_hi + (lo / 0x100000000 >>> 0) >>> 0;
    s[7][1] = lo >>> 0;
    len -= 128;
  }
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./md":"node_modules/node-forge/lib/md.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/asn1-validator.js":[function(require,module,exports) {
/**
 * Copyright (c) 2019 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./asn1');

var asn1 = forge.asn1;
exports.privateKeyValidator = {
  // PrivateKeyInfo
  name: 'PrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'PrivateKeyInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // privateKeyAlgorithm
    name: 'PrivateKeyInfo.privateKeyAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'privateKeyOid'
    }]
  }, {
    // PrivateKey
    name: 'PrivateKeyInfo',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'privateKey'
  }]
};
exports.publicKeyValidator = {
  name: 'SubjectPublicKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'subjectPublicKeyInfo',
  value: [{
    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'publicKeyOid'
    }]
  }, // capture group for ed25519PublicKey
  {
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    composed: true,
    captureBitStringValue: 'ed25519PublicKey'
  } // FIXME: this is capture group for rsaPublicKey, use it in this API or
  // discard?

  /* {
    // subjectPublicKey
    name: 'SubjectPublicKeyInfo.subjectPublicKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: 'rsaPublicKey'
    }]
  } */
  ]
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./asn1":"node_modules/node-forge/lib/asn1.js"}],"node_modules/node-forge/lib/ed25519.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
/**
 * JavaScript implementation of Ed25519.
 *
 * Copyright (c) 2017-2019 Digital Bazaar, Inc.
 *
 * This implementation is based on the most excellent TweetNaCl which is
 * in the public domain. Many thanks to its contributors:
 *
 * https://github.com/dchest/tweetnacl-js
 */
var forge = require('./forge');

require('./jsbn');

require('./random');

require('./sha512');

require('./util');

var asn1Validator = require('./asn1-validator');

var publicKeyValidator = asn1Validator.publicKeyValidator;
var privateKeyValidator = asn1Validator.privateKeyValidator;

if (typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

var ByteBuffer = forge.util.ByteBuffer;
var NativeBuffer = typeof Buffer === 'undefined' ? Uint8Array : Buffer;
/*
 * Ed25519 algorithms, see RFC 8032:
 * https://tools.ietf.org/html/rfc8032
 */

forge.pki = forge.pki || {};
module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
var ed25519 = forge.ed25519;
ed25519.constants = {};
ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519.constants.SEED_BYTE_LENGTH = 32;
ed25519.constants.SIGN_BYTE_LENGTH = 64;
ed25519.constants.HASH_BYTE_LENGTH = 64;

ed25519.generateKeyPair = function (options) {
  options = options || {};
  var seed = options.seed;

  if (seed === undefined) {
    // generate seed
    seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
  } else if (typeof seed === 'string') {
    if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
      throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + ' bytes in length.');
    }
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
  }

  seed = messageToNativeBuffer({
    message: seed,
    encoding: 'binary'
  });
  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);

  for (var i = 0; i < 32; ++i) {
    sk[i] = seed[i];
  }

  crypto_sign_keypair(pk, sk);
  return {
    publicKey: pk,
    privateKey: sk
  };
};
/**
 * Converts a private key from a RFC8410 ASN.1 encoding.
 *
 * @param obj - The asn1 representation of a private key.
 *
 * @returns {Object} keyInfo - The key information.
 * @returns {Buffer|Uint8Array} keyInfo.privateKeyBytes - 32 private key bytes.
 */


ed25519.privateKeyFromAsn1 = function (obj) {
  var capture = {};
  var errors = [];
  var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);

  if (!valid) {
    var error = new Error('Invalid Key.');
    error.errors = errors;
    throw error;
  }

  var oid = forge.asn1.derToOid(capture.privateKeyOid);
  var ed25519Oid = forge.oids.EdDSA25519;

  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }

  var privateKey = capture.privateKey; // manually extract the private key bytes from nested octet string, see FIXME:
  // https://github.com/digitalbazaar/forge/blob/master/lib/asn1.js#L542

  var privateKeyBytes = messageToNativeBuffer({
    message: forge.asn1.fromDer(privateKey).value,
    encoding: 'binary'
  }); // TODO: RFC8410 specifies a format for encoding the public key bytes along
  // with the private key bytes. `publicKeyBytes` can be returned in the
  // future. https://tools.ietf.org/html/rfc8410#section-10.3

  return {
    privateKeyBytes: privateKeyBytes
  };
};
/**
 * Converts a public key from a RFC8410 ASN.1 encoding.
 *
 * @param obj - The asn1 representation of a public key.
 *
 * @return {Buffer|Uint8Array} - 32 public key bytes.
 */


ed25519.publicKeyFromAsn1 = function (obj) {
  // get SubjectPublicKeyInfo
  var capture = {};
  var errors = [];
  var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);

  if (!valid) {
    var error = new Error('Invalid Key.');
    error.errors = errors;
    throw error;
  }

  var oid = forge.asn1.derToOid(capture.publicKeyOid);
  var ed25519Oid = forge.oids.EdDSA25519;

  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }

  var publicKeyBytes = capture.ed25519PublicKey;

  if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new Error('Key length is invalid.');
  }

  return messageToNativeBuffer({
    message: publicKeyBytes,
    encoding: 'binary'
  });
};

ed25519.publicKeyFromPrivateKey = function (options) {
  options = options || {};
  var privateKey = messageToNativeBuffer({
    message: options.privateKey,
    encoding: 'binary'
  });

  if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
  }

  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);

  for (var i = 0; i < pk.length; ++i) {
    pk[i] = privateKey[32 + i];
  }

  return pk;
};

ed25519.sign = function (options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);
  var privateKey = messageToNativeBuffer({
    message: options.privateKey,
    encoding: 'binary'
  });

  if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
    var keyPair = ed25519.generateKeyPair({
      seed: privateKey
    });
    privateKey = keyPair.privateKey;
  } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + ' or ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
  }

  var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  crypto_sign(signedMsg, msg, msg.length, privateKey);
  var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);

  for (var i = 0; i < sig.length; ++i) {
    sig[i] = signedMsg[i];
  }

  return sig;
};

ed25519.verify = function (options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);

  if (options.signature === undefined) {
    throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ' + 'ByteBuffer, or a binary string.');
  }

  var sig = messageToNativeBuffer({
    message: options.signature,
    encoding: 'binary'
  });

  if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
    throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
  }

  var publicKey = messageToNativeBuffer({
    message: options.publicKey,
    encoding: 'binary'
  });

  if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  }

  var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var i;

  for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
    sm[i] = sig[i];
  }

  for (i = 0; i < msg.length; ++i) {
    sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
  }

  return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
};

function messageToNativeBuffer(options) {
  var message = options.message;

  if (message instanceof Uint8Array || message instanceof NativeBuffer) {
    return message;
  }

  var encoding = options.encoding;

  if (message === undefined) {
    if (options.md) {
      // TODO: more rigorous validation that `md` is a MessageDigest
      message = options.md.digest().getBytes();
      encoding = 'binary';
    } else {
      throw new TypeError('"options.message" or "options.md" not specified.');
    }
  }

  if (typeof message === 'string' && !encoding) {
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  }

  if (typeof message === 'string') {
    if (typeof Buffer !== 'undefined') {
      return Buffer.from(message, encoding);
    }

    message = new ByteBuffer(message, encoding);
  } else if (!(message instanceof ByteBuffer)) {
    throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ' + 'ByteBuffer, or a string with "options.encoding" specifying its ' + 'encoding.');
  } // convert to native buffer


  var buffer = new NativeBuffer(message.length());

  for (var i = 0; i < buffer.length; ++i) {
    buffer[i] = message.at(i);
  }

  return buffer;
}

var gf0 = gf();
var gf1 = gf([1]);
var D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]);
var D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]);
var X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]);
var Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]);
var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
var I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]); // TODO: update forge buffer implementation to use `Buffer` or `Uint8Array`,
// whichever is available, to improve performance

function sha512(msg, msgLen) {
  // Note: `out` and `msg` are NativeBuffer
  var md = forge.md.sha512.create();
  var buffer = new ByteBuffer(msg);
  md.update(buffer.getBytes(msgLen), 'binary');
  var hash = md.digest().getBytes();

  if (typeof Buffer !== 'undefined') {
    return Buffer.from(hash, 'binary');
  }

  var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);

  for (var i = 0; i < 64; ++i) {
    out[i] = hash.charCodeAt(i);
  }

  return out;
}

function crypto_sign_keypair(pk, sk) {
  var p = [gf(), gf(), gf(), gf()];
  var i;
  var d = sha512(sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; ++i) {
    sk[i + 32] = pk[i];
  }

  return 0;
} // Note: difference from C - smlen returned, not passed as argument.


function crypto_sign(sm, m, n, sk) {
  var i,
      j,
      x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var d = sha512(sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  var smlen = n + 64;

  for (i = 0; i < n; ++i) {
    sm[64 + i] = m[i];
  }

  for (i = 0; i < 32; ++i) {
    sm[32 + i] = d[32 + i];
  }

  var r = sha512(sm.subarray(32), n + 32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; ++i) {
    sm[i] = sk[i];
  }

  var h = sha512(sm, n + 64);
  reduce(h);

  for (i = 32; i < 64; ++i) {
    x[i] = 0;
  }

  for (i = 0; i < 32; ++i) {
    x[i] = r[i];
  }

  for (i = 0; i < 32; ++i) {
    for (j = 0; j < 32; j++) {
      x[i + j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new NativeBuffer(32);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];
  mlen = -1;

  if (n < 64) {
    return -1;
  }

  if (unpackneg(q, pk)) {
    return -1;
  }

  for (i = 0; i < n; ++i) {
    m[i] = sm[i];
  }

  for (i = 0; i < 32; ++i) {
    m[i + 32] = pk[i];
  }

  var h = sha512(m, n);
  reduce(h);
  scalarmult(p, q, h);
  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);
  n -= 64;

  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; ++i) {
      m[i] = 0;
    }

    return -1;
  }

  for (i = 0; i < n; ++i) {
    m[i] = sm[i + 64];
  }

  mlen = n;
  return mlen;
}

function modL(r, x) {
  var carry, i, j, k;

  for (i = 63; i >= 32; --i) {
    carry = 0;

    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = x[j] + 128 >> 8;
      x[j] -= carry * 256;
    }

    x[j] += carry;
    x[i] = 0;
  }

  carry = 0;

  for (j = 0; j < 32; ++j) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }

  for (j = 0; j < 32; ++j) {
    x[j] -= carry * L[j];
  }

  for (i = 0; i < 32; ++i) {
    x[i + 1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64);

  for (var i = 0; i < 64; ++i) {
    x[i] = r[i];
    r[i] = 0;
  }

  modL(r, x);
}

function add(p, q) {
  var a = gf(),
      b = gf(),
      c = gf(),
      d = gf(),
      e = gf(),
      f = gf(),
      g = gf(),
      h = gf(),
      t = gf();
  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);
  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  for (var i = 0; i < 4; ++i) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(),
      ty = gf(),
      zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(),
      t = gf();

  for (i = 0; i < 16; ++i) {
    t[i] = n[i];
  }

  car25519(t);
  car25519(t);
  car25519(t);

  for (j = 0; j < 2; ++j) {
    m[0] = t[0] - 0xffed;

    for (i = 1; i < 15; ++i) {
      m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
      m[i - 1] &= 0xffff;
    }

    m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
    b = m[15] >> 16 & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1 - b);
  }

  for (i = 0; i < 16; i++) {
    o[2 * i] = t[i] & 0xff;
    o[2 * i + 1] = t[i] >> 8;
  }
}

function unpackneg(r, p) {
  var t = gf(),
      chk = gf(),
      num = gf(),
      den = gf(),
      den2 = gf(),
      den4 = gf(),
      den6 = gf();
  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);
  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);
  S(chk, r[0]);
  M(chk, chk, den);

  if (neq25519(chk, num)) {
    M(r[0], r[0], I);
  }

  S(chk, r[0]);
  M(chk, chk, den);

  if (neq25519(chk, num)) {
    return -1;
  }

  if (par25519(r[0]) === p[31] >> 7) {
    Z(r[0], gf0, r[0]);
  }

  M(r[3], r[0], r[1]);
  return 0;
}

function unpack25519(o, n) {
  var i;

  for (i = 0; i < 16; ++i) {
    o[i] = n[2 * i] + (n[2 * i + 1] << 8);
  }

  o[15] &= 0x7fff;
}

function pow2523(o, i) {
  var c = gf();
  var a;

  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }

  for (a = 250; a >= 0; --a) {
    S(c, c);

    if (a !== 1) {
      M(c, c, i);
    }
  }

  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}

function neq25519(a, b) {
  var c = new NativeBuffer(32);
  var d = new NativeBuffer(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x, xi, y, yi, 32);
}

function vn(x, xi, y, yi, n) {
  var i,
      d = 0;

  for (i = 0; i < n; ++i) {
    d |= x[xi + i] ^ y[yi + i];
  }

  return (1 & d - 1 >>> 8) - 1;
}

function par25519(a) {
  var d = new NativeBuffer(32);
  pack25519(d, a);
  return d[0] & 1;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);

  for (i = 255; i >= 0; --i) {
    b = s[i / 8 | 0] >> (i & 7) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function set25519(r, a) {
  var i;

  for (i = 0; i < 16; i++) {
    r[i] = a[i] | 0;
  }
}

function inv25519(o, i) {
  var c = gf();
  var a;

  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }

  for (a = 253; a >= 0; --a) {
    S(c, c);

    if (a !== 2 && a !== 4) {
      M(c, c, i);
    }
  }

  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}

function car25519(o) {
  var i,
      v,
      c = 1;

  for (i = 0; i < 16; ++i) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }

  o[0] += c - 1 + 37 * (c - 1);
}

function sel25519(p, q, b) {
  var t,
      c = ~(b - 1);

  for (var i = 0; i < 16; ++i) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function gf(init) {
  var i,
      r = new Float64Array(16);

  if (init) {
    for (i = 0; i < init.length; ++i) {
      r[i] = init[i];
    }
  }

  return r;
}

function A(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] + b[i];
  }
}

function Z(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] - b[i];
  }
}

function S(o, a) {
  M(o, a, a);
}

function M(o, a, b) {
  var v,
      c,
      t0 = 0,
      t1 = 0,
      t2 = 0,
      t3 = 0,
      t4 = 0,
      t5 = 0,
      t6 = 0,
      t7 = 0,
      t8 = 0,
      t9 = 0,
      t10 = 0,
      t11 = 0,
      t12 = 0,
      t13 = 0,
      t14 = 0,
      t15 = 0,
      t16 = 0,
      t17 = 0,
      t18 = 0,
      t19 = 0,
      t20 = 0,
      t21 = 0,
      t22 = 0,
      t23 = 0,
      t24 = 0,
      t25 = 0,
      t26 = 0,
      t27 = 0,
      t28 = 0,
      t29 = 0,
      t30 = 0,
      b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11],
      b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30; // t15 left as is
  // first car

  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1); // second car

  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./jsbn":"node_modules/node-forge/lib/jsbn.js","./random":"node_modules/node-forge/lib/random.js","./sha512":"node_modules/node-forge/lib/sha512.js","./util":"node_modules/node-forge/lib/util.js","./asn1-validator":"node_modules/node-forge/lib/asn1-validator.js","buffer":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/iso-random-stream/src/random.browser.js":[function(require,module,exports) {
'use strict'; // limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues

var MAX_BYTES = 65536;
/**
 * @param {number} size
 */

function randomBytes(size) {
  var bytes = new Uint8Array(size);
  var generated = 0;

  if (size > 0) {
    // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) {
      while (generated < size) {
        if (generated + MAX_BYTES > size) {
          crypto.getRandomValues(bytes.subarray(generated, generated + (size - generated)));
          generated += size - generated;
        } else {
          crypto.getRandomValues(bytes.subarray(generated, generated + MAX_BYTES));
          generated += MAX_BYTES;
        }
      }
    } else {
      crypto.getRandomValues(bytes);
    }
  }

  return bytes;
}

module.exports = randomBytes;
},{}],"node_modules/libp2p-crypto/src/random-bytes.js":[function(require,module,exports) {
'use strict';

var randomBytes = require('iso-random-stream/src/random');

var errcode = require('err-code');

module.exports = function (length) {
  if (isNaN(length) || length <= 0) {
    throw errcode(new Error('random bytes length must be a Number bigger than 0'), 'ERR_INVALID_LENGTH');
  }

  return randomBytes(length);
};
},{"iso-random-stream/src/random":"node_modules/iso-random-stream/src/random.browser.js","err-code":"node_modules/err-code/index.js"}],"node_modules/libp2p-crypto/src/util.js":[function(require,module,exports) {
'use strict';

require('node-forge/lib/util');

require('node-forge/lib/jsbn');

var forge = require('node-forge/lib/forge');

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayConcat = require('uint8arrays/concat');

exports.bigIntegerToUintBase64url = function (num, len) {
  // Call `.abs()` to convert to unsigned
  var buf = Uint8Array.from(num.abs().toByteArray()); // toByteArray converts to big endian
  // toByteArray() gives us back a signed array, which will include a leading 0
  // byte if the most significant bit of the number is 1:
  // https://docs.microsoft.com/en-us/windows/win32/seccertenroll/about-integer
  // Our number will always be positive so we should remove the leading padding.

  buf = buf[0] === 0 ? buf.slice(1) : buf;

  if (len != null) {
    if (buf.length > len) throw new Error('byte array longer than desired length');
    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
  }

  return uint8ArrayToString(buf, 'base64url');
}; // Convert a base64url encoded string to a BigInteger


exports.base64urlToBigInteger = function (str) {
  var buf = exports.base64urlToBuffer(str);
  return new forge.jsbn.BigInteger(uint8ArrayToString(buf, 'base16'), 16);
};

exports.base64urlToBuffer = function (str, len) {
  var buf = uint8ArrayFromString(str, 'base64urlpad');

  if (len != null) {
    if (buf.length > len) throw new Error('byte array longer than desired length');
    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
  }

  return buf;
};
},{"node-forge/lib/util":"node_modules/node-forge/lib/util.js","node-forge/lib/jsbn":"node_modules/node-forge/lib/jsbn.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js"}],"node_modules/libp2p-crypto/src/keys/rsa-utils.js":[function(require,module,exports) {
'use strict';

require('node-forge/lib/asn1');

require('node-forge/lib/rsa');

var forge = require('node-forge/lib/forge');

var _require = require('./../util'),
    bigIntegerToUintBase64url = _require.bigIntegerToUintBase64url,
    base64urlToBigInteger = _require.base64urlToBigInteger;

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string'); // Convert a PKCS#1 in ASN1 DER format to a JWK key


exports.pkcs1ToJwk = function (bytes) {
  var asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, 'ascii'));
  var privateKey = forge.pki.privateKeyFromAsn1(asn1); // https://tools.ietf.org/html/rfc7518#section-6.3.1

  return {
    kty: 'RSA',
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: 'RS256',
    kid: '2011-04-29'
  };
}; // Convert a JWK key into PKCS#1 in ASN1 DER format


exports.jwkToPkcs1 = function (jwk) {
  var asn1 = forge.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), 'ascii');
}; // Convert a PKCIX in ASN1 DER format to a JWK key


exports.pkixToJwk = function (bytes) {
  var asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, 'ascii'));
  var publicKey = forge.pki.publicKeyFromAsn1(asn1);
  return {
    kty: 'RSA',
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e),
    alg: 'RS256',
    kid: '2011-04-29'
  };
}; // Convert a JWK key to PKCIX in ASN1 DER format


exports.jwkToPkix = function (jwk) {
  var asn1 = forge.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), 'ascii');
};
},{"node-forge/lib/asn1":"node_modules/node-forge/lib/asn1.js","node-forge/lib/rsa":"node_modules/node-forge/lib/rsa.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","./../util":"node_modules/libp2p-crypto/src/util.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js"}],"node_modules/libp2p-crypto/src/keys/jwk2pem.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

require('node-forge/lib/rsa');

var forge = require('node-forge/lib/forge');

var _require = require('../util'),
    base64urlToBigInteger = _require.base64urlToBigInteger;

function convert(key, types) {
  return types.map(function (t) {
    return base64urlToBigInteger(key[t]);
  });
}

function jwk2priv(key) {
  var _forge$pki;

  return (_forge$pki = forge.pki).setRsaPrivateKey.apply(_forge$pki, _toConsumableArray(convert(key, ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi'])));
}

function jwk2pub(key) {
  var _forge$pki2;

  return (_forge$pki2 = forge.pki).setRsaPublicKey.apply(_forge$pki2, _toConsumableArray(convert(key, ['n', 'e'])));
}

module.exports = {
  jwk2pub: jwk2pub,
  jwk2priv: jwk2priv
};
},{"node-forge/lib/rsa":"node_modules/node-forge/lib/rsa.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","../util":"node_modules/libp2p-crypto/src/util.js"}],"node_modules/libp2p-crypto/src/keys/rsa-browser.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var webcrypto = require('../webcrypto');

var randomBytes = require('../random-bytes');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayFromString = require('uint8arrays/from-string');

exports.utils = require('./rsa-utils');

exports.generateKey = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(bits) {
    var pair, keys;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return webcrypto.get().subtle.generateKey({
              name: 'RSASSA-PKCS1-v1_5',
              modulusLength: bits,
              publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
              hash: {
                name: 'SHA-256'
              }
            }, true, ['sign', 'verify']);

          case 2:
            pair = _context.sent;
            _context.next = 5;
            return exportKey(pair);

          case 5:
            keys = _context.sent;
            return _context.abrupt("return", {
              privateKey: keys[0],
              publicKey: keys[1]
            });

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}(); // Takes a jwk key


exports.unmarshalPrivateKey = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
    var privateKey, pair, keys;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return webcrypto.get().subtle.importKey('jwk', key, {
              name: 'RSASSA-PKCS1-v1_5',
              hash: {
                name: 'SHA-256'
              }
            }, true, ['sign']);

          case 2:
            privateKey = _context2.sent;
            _context2.t0 = privateKey;
            _context2.next = 6;
            return derivePublicFromPrivate(key);

          case 6:
            _context2.t1 = _context2.sent;
            pair = [_context2.t0, _context2.t1];
            _context2.next = 10;
            return exportKey({
              privateKey: pair[0],
              publicKey: pair[1]
            });

          case 10:
            keys = _context2.sent;
            return _context2.abrupt("return", {
              privateKey: keys[0],
              publicKey: keys[1]
            });

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports.getRandomValues = randomBytes;

exports.hashAndSign = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, msg) {
    var privateKey, sig;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return webcrypto.get().subtle.importKey('jwk', key, {
              name: 'RSASSA-PKCS1-v1_5',
              hash: {
                name: 'SHA-256'
              }
            }, false, ['sign']);

          case 2:
            privateKey = _context3.sent;
            _context3.next = 5;
            return webcrypto.get().subtle.sign({
              name: 'RSASSA-PKCS1-v1_5'
            }, privateKey, Uint8Array.from(msg));

          case 5:
            sig = _context3.sent;
            return _context3.abrupt("return", new Uint8Array(sig, sig.byteOffset, sig.byteLength));

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();

exports.hashAndVerify = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key, sig, msg) {
    var publicKey;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return webcrypto.get().subtle.importKey('jwk', key, {
              name: 'RSASSA-PKCS1-v1_5',
              hash: {
                name: 'SHA-256'
              }
            }, false, ['verify']);

          case 2:
            publicKey = _context4.sent;
            return _context4.abrupt("return", webcrypto.get().subtle.verify({
              name: 'RSASSA-PKCS1-v1_5'
            }, publicKey, sig, msg));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x5, _x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();

function exportKey(pair) {
  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);
}

function derivePublicFromPrivate(jwKey) {
  return webcrypto.get().subtle.importKey('jwk', {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: 'RSASSA-PKCS1-v1_5',
    hash: {
      name: 'SHA-256'
    }
  }, true, ['verify']);
}
/*

RSA encryption/decryption for the browser with webcrypto workarround
"bloody dark magic. webcrypto's why."

Explanation:
  - Convert JWK to nodeForge
  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a "binary-string backed buffer", so let's make our Uint8Array a binary string
  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array

*/


var _require = require('./jwk2pem'),
    jwk2pub = _require.jwk2pub,
    jwk2priv = _require.jwk2priv;

function convertKey(key, pub, msg, handle) {
  var fkey = pub ? jwk2pub(key) : jwk2priv(key);
  var fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii');
  var fomsg = handle(fmsg, fkey);
  return uint8ArrayFromString(fomsg, 'ascii');
}

exports.encrypt = function (key, msg) {
  return convertKey(key, true, msg, function (msg, key) {
    return key.encrypt(msg);
  });
};

exports.decrypt = function (key, msg) {
  return convertKey(key, false, msg, function (msg, key) {
    return key.decrypt(msg);
  });
};
},{"../webcrypto":"node_modules/libp2p-crypto/src/webcrypto.js","../random-bytes":"node_modules/libp2p-crypto/src/random-bytes.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","./rsa-utils":"node_modules/libp2p-crypto/src/keys/rsa-utils.js","./jwk2pem":"node_modules/libp2p-crypto/src/keys/jwk2pem.js"}],"node_modules/libp2p-crypto/src/keys/exporter.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/bases/base64'),
    base64 = _require.base64;

var ciphers = require('../ciphers/aes-gcm');

module.exports = {
  /**
   * Exports the given PrivateKey as a base64 encoded string.
   * The PrivateKey is encrypted via a password derived PBKDF2 key
   * leveraging the aes-gcm cipher algorithm.
   *
   * @param {Uint8Array} privateKey - The PrivateKey protobuf
   * @param {string} password
   * @returns {Promise<string>} A base64 encoded string
   */
  export: function () {
    var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(privateKey, password) {
      var cipher, encryptedKey;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cipher = ciphers.create();
              _context.next = 3;
              return cipher.encrypt(privateKey, password);

            case 3:
              encryptedKey = _context.sent;
              return _context.abrupt("return", base64.encode(encryptedKey));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function _export(_x, _x2) {
      return _export2.apply(this, arguments);
    }

    return _export;
  }()
};
},{"multiformats/bases/base64":"node_modules/multiformats/cjs/src/bases/base64.js","../ciphers/aes-gcm":"node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"}],"node_modules/libp2p-crypto/src/keys/rsa-class.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var errcode = require('err-code');

var uint8ArrayEquals = require('uint8arrays/equals');

var uint8ArrayToString = require('uint8arrays/to-string');

require('node-forge/lib/sha512');

require('node-forge/lib/ed25519');

var forge = require('node-forge/lib/forge');

var crypto = require('./rsa');

var pbm = require('./keys');

var exporter = require('./exporter');

var RsaPublicKey = /*#__PURE__*/function () {
  function RsaPublicKey(key) {
    _classCallCheck(this, RsaPublicKey);

    this._key = key;
  }

  _createClass(RsaPublicKey, [{
    key: "verify",
    value: function () {
      var _verify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, sig) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", crypto.hashAndVerify(this._key, sig, data));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function verify(_x, _x2) {
        return _verify.apply(this, arguments);
      }

      return verify;
    }()
  }, {
    key: "marshal",
    value: function marshal() {
      return crypto.utils.jwkToPkix(this._key);
    }
  }, {
    key: "bytes",
    get: function get() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      }).finish();
    }
  }, {
    key: "encrypt",
    value: function encrypt(bytes) {
      return crypto.encrypt(this._key, bytes);
    }
  }, {
    key: "equals",
    value: function equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
  }, {
    key: "hash",
    value: function () {
      var _hash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _yield$sha256$digest, bytes;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return sha256.digest(this.bytes);

              case 2:
                _yield$sha256$digest = _context2.sent;
                bytes = _yield$sha256$digest.bytes;
                return _context2.abrupt("return", bytes);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function hash() {
        return _hash.apply(this, arguments);
      }

      return hash;
    }()
  }]);

  return RsaPublicKey;
}();

var RsaPrivateKey = /*#__PURE__*/function () {
  // key       - Object of the jwk format
  // publicKey - Uint8Array of the spki format
  function RsaPrivateKey(key, publicKey) {
    _classCallCheck(this, RsaPrivateKey);

    this._key = key;
    this._publicKey = publicKey;
  }

  _createClass(RsaPrivateKey, [{
    key: "genSecret",
    value: function genSecret() {
      return crypto.getRandomValues(16);
    }
  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(message) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", crypto.hashAndSign(this._key, message));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sign(_x3) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }, {
    key: "public",
    get: function get() {
      if (!this._publicKey) {
        throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');
      }

      return new RsaPublicKey(this._publicKey);
    }
  }, {
    key: "decrypt",
    value: function decrypt(bytes) {
      return crypto.decrypt(this._key, bytes);
    }
  }, {
    key: "marshal",
    value: function marshal() {
      return crypto.utils.jwkToPkcs1(this._key);
    }
  }, {
    key: "bytes",
    get: function get() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      }).finish();
    }
  }, {
    key: "equals",
    value: function equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
  }, {
    key: "hash",
    value: function () {
      var _hash2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _yield$sha256$digest2, bytes;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return sha256.digest(this.bytes);

              case 2:
                _yield$sha256$digest2 = _context4.sent;
                bytes = _yield$sha256$digest2.bytes;
                return _context4.abrupt("return", bytes);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function hash() {
        return _hash2.apply(this, arguments);
      }

      return hash;
    }()
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the SHA-256 multihash of its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     *
     * @returns {Promise<string>}
     */

  }, {
    key: "id",
    value: function () {
      var _id = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var hash;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.public.hash();

              case 2:
                hash = _context5.sent;
                return _context5.abrupt("return", uint8ArrayToString(hash, 'base58btc'));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function id() {
        return _id.apply(this, arguments);
      }

      return id;
    }()
    /**
     * Exports the key into a password protected PEM format
     *
     * @param {string} password - The password to read the encrypted PEM
     * @param {string} [format=pkcs-8] - The format in which to export as
     */

  }, {
    key: "export",
    value: function () {
      var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(password) {
        var format,
            buffer,
            asn1,
            privateKey,
            options,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                format = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'pkcs-8';

                if (!(format === 'pkcs-8')) {
                  _context6.next = 9;
                  break;
                }

                buffer = new forge.util.ByteBuffer(this.marshal());
                asn1 = forge.asn1.fromDer(buffer);
                privateKey = forge.pki.privateKeyFromAsn1(asn1);
                options = {
                  algorithm: 'aes256',
                  count: 10000,
                  saltSize: 128 / 8,
                  prfAlgorithm: 'sha512'
                };
                return _context6.abrupt("return", forge.pki.encryptRsaPrivateKey(privateKey, password, options));

              case 9:
                if (!(format === 'libp2p-key')) {
                  _context6.next = 13;
                  break;
                }

                return _context6.abrupt("return", exporter.export(this.bytes, password));

              case 13:
                throw errcode(new Error("export format '".concat(format, "' is not supported")), 'ERR_INVALID_EXPORT_FORMAT');

              case 14:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _export(_x4) {
        return _export2.apply(this, arguments);
      }

      return _export;
    }()
  }]);

  return RsaPrivateKey;
}();

function unmarshalRsaPrivateKey(_x5) {
  return _unmarshalRsaPrivateKey.apply(this, arguments);
}

function _unmarshalRsaPrivateKey() {
  _unmarshalRsaPrivateKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(bytes) {
    var jwk, keys;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            jwk = crypto.utils.pkcs1ToJwk(bytes);
            _context7.next = 3;
            return crypto.unmarshalPrivateKey(jwk);

          case 3:
            keys = _context7.sent;
            return _context7.abrupt("return", new RsaPrivateKey(keys.privateKey, keys.publicKey));

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _unmarshalRsaPrivateKey.apply(this, arguments);
}

function unmarshalRsaPublicKey(bytes) {
  var jwk = crypto.utils.pkixToJwk(bytes);
  return new RsaPublicKey(jwk);
}

function fromJwk(_x6) {
  return _fromJwk.apply(this, arguments);
}

function _fromJwk() {
  _fromJwk = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(jwk) {
    var keys;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return crypto.unmarshalPrivateKey(jwk);

          case 2:
            keys = _context8.sent;
            return _context8.abrupt("return", new RsaPrivateKey(keys.privateKey, keys.publicKey));

          case 4:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _fromJwk.apply(this, arguments);
}

function generateKeyPair(_x7) {
  return _generateKeyPair.apply(this, arguments);
}

function _generateKeyPair() {
  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(bits) {
    var keys;
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return crypto.generateKey(bits);

          case 2:
            keys = _context9.sent;
            return _context9.abrupt("return", new RsaPrivateKey(keys.privateKey, keys.publicKey));

          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _generateKeyPair.apply(this, arguments);
}

module.exports = {
  RsaPublicKey: RsaPublicKey,
  RsaPrivateKey: RsaPrivateKey,
  unmarshalRsaPublicKey: unmarshalRsaPublicKey,
  unmarshalRsaPrivateKey: unmarshalRsaPrivateKey,
  generateKeyPair: generateKeyPair,
  fromJwk: fromJwk
};
},{"multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","err-code":"node_modules/err-code/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","node-forge/lib/sha512":"node_modules/node-forge/lib/sha512.js","node-forge/lib/ed25519":"node_modules/node-forge/lib/ed25519.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","./rsa":"node_modules/libp2p-crypto/src/keys/rsa-browser.js","./keys":"node_modules/libp2p-crypto/src/keys/keys.js","./exporter":"node_modules/libp2p-crypto/src/keys/exporter.js"}],"node_modules/libp2p-crypto/src/keys/ed25519.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

require('node-forge/lib/ed25519');

var forge = require('node-forge/lib/forge');

exports.publicKeyLength = forge.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
exports.privateKeyLength = forge.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
exports.generateKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", forge.pki.ed25519.generateKeyPair());

        case 1:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
})); // seed should be a 32 byte uint8array

exports.generateKeyFromSeed = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(seed) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", forge.pki.ed25519.generateKeyPair({
              seed: seed
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports.hashAndSign = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, msg) {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", forge.pki.ed25519.sign({
              message: msg,
              privateKey: key
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();

exports.hashAndVerify = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key, sig, msg) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", forge.pki.ed25519.verify({
              signature: sig,
              message: msg,
              publicKey: key
            }));

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x4, _x5, _x6) {
    return _ref4.apply(this, arguments);
  };
}();
},{"node-forge/lib/ed25519":"node_modules/node-forge/lib/ed25519.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js"}],"node_modules/libp2p-crypto/src/keys/ed25519-class.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var errcode = require('err-code');

var uint8ArrayEquals = require('uint8arrays/equals');

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var _require2 = require('multiformats/bases/base58'),
    base58btc = _require2.base58btc;

var _require3 = require('multiformats/hashes/identity'),
    identity = _require3.identity;

var crypto = require('./ed25519');

var pbm = require('./keys');

var exporter = require('./exporter');

var Ed25519PublicKey = /*#__PURE__*/function () {
  function Ed25519PublicKey(key) {
    _classCallCheck(this, Ed25519PublicKey);

    this._key = ensureKey(key, crypto.publicKeyLength);
  }

  _createClass(Ed25519PublicKey, [{
    key: "verify",
    value: function () {
      var _verify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, sig) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", crypto.hashAndVerify(this._key, sig, data));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function verify(_x, _x2) {
        return _verify.apply(this, arguments);
      }

      return verify;
    }()
  }, {
    key: "marshal",
    value: function marshal() {
      return this._key;
    }
  }, {
    key: "bytes",
    get: function get() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      }).finish();
    }
  }, {
    key: "equals",
    value: function equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
  }, {
    key: "hash",
    value: function () {
      var _hash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _yield$sha256$digest, bytes;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return sha256.digest(this.bytes);

              case 2:
                _yield$sha256$digest = _context2.sent;
                bytes = _yield$sha256$digest.bytes;
                return _context2.abrupt("return", bytes);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function hash() {
        return _hash.apply(this, arguments);
      }

      return hash;
    }()
  }]);

  return Ed25519PublicKey;
}();

var Ed25519PrivateKey = /*#__PURE__*/function () {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  function Ed25519PrivateKey(key, publicKey) {
    _classCallCheck(this, Ed25519PrivateKey);

    this._key = ensureKey(key, crypto.privateKeyLength);
    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);
  }

  _createClass(Ed25519PrivateKey, [{
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(message) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", crypto.hashAndSign(this._key, message));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sign(_x3) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }, {
    key: "public",
    get: function get() {
      return new Ed25519PublicKey(this._publicKey);
    }
  }, {
    key: "marshal",
    value: function marshal() {
      return this._key;
    }
  }, {
    key: "bytes",
    get: function get() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      }).finish();
    }
  }, {
    key: "equals",
    value: function equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
  }, {
    key: "hash",
    value: function () {
      var _hash2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _yield$sha256$digest2, bytes;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return sha256.digest(this.bytes);

              case 2:
                _yield$sha256$digest2 = _context4.sent;
                bytes = _yield$sha256$digest2.bytes;
                return _context4.abrupt("return", bytes);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function hash() {
        return _hash2.apply(this, arguments);
      }

      return hash;
    }()
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the identity multihash containing its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     *
     * @returns {Promise<string>}
     */

  }, {
    key: "id",
    value: function () {
      var _id = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var encoding;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return identity.digest(this.public.bytes);

              case 2:
                encoding = _context5.sent;
                return _context5.abrupt("return", base58btc.encode(encoding.bytes).substring(1));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function id() {
        return _id.apply(this, arguments);
      }

      return id;
    }()
    /**
     * Exports the key into a password protected `format`
     *
     * @param {string} password - The password to encrypt the key
     * @param {string} [format=libp2p-key] - The format in which to export as
     * @returns {Promise<Uint8Array>} The encrypted private key
     */

  }, {
    key: "export",
    value: function () {
      var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(password) {
        var format,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                format = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'libp2p-key';

                if (!(format === 'libp2p-key')) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt("return", exporter.export(this.bytes, password));

              case 5:
                throw errcode(new Error("export format '".concat(format, "' is not supported")), 'ERR_INVALID_EXPORT_FORMAT');

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _export(_x4) {
        return _export2.apply(this, arguments);
      }

      return _export;
    }()
  }]);

  return Ed25519PrivateKey;
}();

function unmarshalEd25519PrivateKey(bytes) {
  // Try the old, redundant public key version
  if (bytes.length > crypto.privateKeyLength) {
    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);

    var _privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);

    var _publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);

    return new Ed25519PrivateKey(_privateKeyBytes, _publicKeyBytes);
  }

  bytes = ensureKey(bytes, crypto.privateKeyLength);
  var privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);
  var publicKeyBytes = bytes.slice(crypto.publicKeyLength);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}

function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureKey(bytes, crypto.publicKeyLength);
  return new Ed25519PublicKey(bytes);
}

function generateKeyPair() {
  return _generateKeyPair.apply(this, arguments);
}

function _generateKeyPair() {
  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
    var _yield$crypto$generat, privateKey, publicKey;

    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return crypto.generateKey();

          case 2:
            _yield$crypto$generat = _context7.sent;
            privateKey = _yield$crypto$generat.privateKey;
            publicKey = _yield$crypto$generat.publicKey;
            return _context7.abrupt("return", new Ed25519PrivateKey(privateKey, publicKey));

          case 6:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _generateKeyPair.apply(this, arguments);
}

function generateKeyPairFromSeed(_x5) {
  return _generateKeyPairFromSeed.apply(this, arguments);
}

function _generateKeyPairFromSeed() {
  _generateKeyPairFromSeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(seed) {
    var _yield$crypto$generat2, privateKey, publicKey;

    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return crypto.generateKeyFromSeed(seed);

          case 2:
            _yield$crypto$generat2 = _context8.sent;
            privateKey = _yield$crypto$generat2.privateKey;
            publicKey = _yield$crypto$generat2.publicKey;
            return _context8.abrupt("return", new Ed25519PrivateKey(privateKey, publicKey));

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _generateKeyPairFromSeed.apply(this, arguments);
}

function ensureKey(key, length) {
  key = Uint8Array.from(key || []);

  if (key.length !== length) {
    throw errcode(new Error("Key must be a Uint8Array of length ".concat(length, ", got ").concat(key.length)), 'ERR_INVALID_KEY_TYPE');
  }

  return key;
}

module.exports = {
  Ed25519PublicKey: Ed25519PublicKey,
  Ed25519PrivateKey: Ed25519PrivateKey,
  unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: unmarshalEd25519PublicKey,
  generateKeyPair: generateKeyPair,
  generateKeyPairFromSeed: generateKeyPairFromSeed
};
},{"err-code":"node_modules/err-code/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","multiformats/hashes/identity":"node_modules/multiformats/cjs/src/hashes/identity.js","./ed25519":"node_modules/libp2p-crypto/src/keys/ed25519.js","./keys":"node_modules/libp2p-crypto/src/keys/keys.js","./exporter":"node_modules/libp2p-crypto/src/keys/exporter.js"}],"node_modules/secp256k1/lib/index.js":[function(require,module,exports) {
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
};

function assert(cond, msg) {
  if (!cond) throw new Error(msg);
}

function isUint8Array(name, value, length) {
  assert(value instanceof Uint8Array, "Expected ".concat(name, " to be an Uint8Array"));

  if (length !== undefined) {
    if (Array.isArray(length)) {
      var numbers = length.join(', ');
      var msg = "Expected ".concat(name, " to be an Uint8Array with length [").concat(numbers, "]");
      assert(length.includes(value.length), msg);
    } else {
      var _msg = "Expected ".concat(name, " to be an Uint8Array with length ").concat(length);

      assert(value.length === length, _msg);
    }
  }
}

function isCompressed(value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
}

function getAssertedOutput() {
  var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (len) {
    return new Uint8Array(len);
  };
  var length = arguments.length > 1 ? arguments[1] : undefined;
  if (typeof output === 'function') output = output(length);
  isUint8Array('output', output, length);
  return output;
}

function toTypeString(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}

module.exports = function (secp256k1) {
  return {
    contextRandomize: function contextRandomize(seed) {
      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');
      if (seed !== null) isUint8Array('seed', seed, 32);

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
      }
    },
    privateKeyVerify: function privateKeyVerify(seckey) {
      isUint8Array('private key', seckey, 32);
      return secp256k1.privateKeyVerify(seckey) === 0;
    },
    privateKeyNegate: function privateKeyNegate(seckey) {
      isUint8Array('private key', seckey, 32);

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey;

        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
      isUint8Array('private key', seckey, 32);
      isUint8Array('tweak', tweak, 32);

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey;

        case 1:
          throw new Error(errors.TWEAK_ADD);
      }
    },
    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
      isUint8Array('private key', seckey, 32);
      isUint8Array('tweak', tweak, 32);

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey;

        case 1:
          throw new Error(errors.TWEAK_MUL);
      }
    },
    publicKeyVerify: function publicKeyVerify(pubkey) {
      isUint8Array('public key', pubkey, [33, 65]);
      return secp256k1.publicKeyVerify(pubkey) === 0;
    },
    publicKeyCreate: function publicKeyCreate(seckey) {
      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : undefined;
      isUint8Array('private key', seckey, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.SECKEY_INVALID);

        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyConvert: function publicKeyConvert(pubkey) {
      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : undefined;
      isUint8Array('public key', pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyNegate: function publicKeyNegate(pubkey) {
      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : undefined;
      isUint8Array('public key', pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);

        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyCombine: function publicKeyCombine(pubkeys) {
      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : undefined;
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');

      var _iterator = _createForOfIteratorHelper(pubkeys),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pubkey = _step.value;
          isUint8Array('public key', pubkey, [33, 65]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.PUBKEY_COMBINE);

        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    },
    publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {
      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var output = arguments.length > 3 ? arguments[3] : undefined;
      isUint8Array('public key', pubkey, [33, 65]);
      isUint8Array('tweak', tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.TWEAK_ADD);
      }
    },
    publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {
      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var output = arguments.length > 3 ? arguments[3] : undefined;
      isUint8Array('public key', pubkey, [33, 65]);
      isUint8Array('tweak', tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.TWEAK_MUL);
      }
    },
    signatureNormalize: function signatureNormalize(sig) {
      isUint8Array('signature', sig, 64);

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig;

        case 1:
          throw new Error(errors.SIG_PARSE);
      }
    },
    signatureExport: function signatureExport(sig, output) {
      isUint8Array('signature', sig, 64);
      output = getAssertedOutput(output, 72);
      var obj = {
        output: output,
        outputlen: 72
      };

      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen);

        case 1:
          throw new Error(errors.SIG_PARSE);

        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    signatureImport: function signatureImport(sig, output) {
      isUint8Array('signature', sig);
      output = getAssertedOutput(output, 64);

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.SIG_PARSE);

        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdsaSign: function ecdsaSign(msg32, seckey) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var output = arguments.length > 3 ? arguments[3] : undefined;
      isUint8Array('message', msg32, 32);
      isUint8Array('private key', seckey, 32);
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
      if (options.data !== undefined) isUint8Array('options.data', options.data);
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
      output = getAssertedOutput(output, 64);
      var obj = {
        signature: output,
        recid: null
      };

      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj;

        case 1:
          throw new Error(errors.SIGN);

        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64);
      isUint8Array('message', msg32, 32);
      isUint8Array('public key', pubkey, [33, 65]);

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true;

        case 3:
          return false;

        case 1:
          throw new Error(errors.SIG_PARSE);

        case 2:
          throw new Error(errors.PUBKEY_PARSE);
      }
    },
    ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {
      var compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var output = arguments.length > 4 ? arguments[4] : undefined;
      isUint8Array('signature', sig, 64);
      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');
      isUint8Array('message', msg32, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.SIG_PARSE);

        case 2:
          throw new Error(errors.RECOVER);

        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    },
    ecdh: function ecdh(pubkey, seckey) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var output = arguments.length > 3 ? arguments[3] : undefined;
      isUint8Array('public key', pubkey, [33, 65]);
      isUint8Array('private key', seckey, 32);
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
      if (options.data !== undefined) isUint8Array('options.data', options.data);

      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
        isUint8Array('output', output);
      } else {
        output = getAssertedOutput(output, 32);
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output;

        case 1:
          throw new Error(errors.PUBKEY_PARSE);

        case 2:
          throw new Error(errors.ECDH);
      }
    }
  };
};
},{}],"node_modules/elliptic/package.json":[function(require,module,exports) {
module.exports = {
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}
;
},{}],"node_modules/elliptic/node_modules/bn.js/lib/bn.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/minimalistic-assert/index.js":[function(require,module,exports) {
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],"node_modules/minimalistic-crypto-utils/lib/utils.js":[function(require,module,exports) {
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],"node_modules/elliptic/lib/elliptic/utils.js":[function(require,module,exports) {
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js","minimalistic-crypto-utils":"node_modules/minimalistic-crypto-utils/lib/utils.js"}],"node_modules/brorand/index.js":[function(require,module,exports) {
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/elliptic/lib/elliptic/curve/base.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/elliptic/lib/elliptic/curve/short.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":"node_modules/elliptic/lib/elliptic/utils.js","bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","inherits":"node_modules/inherits/inherits_browser.js","./base":"node_modules/elliptic/lib/elliptic/curve/base.js"}],"node_modules/elliptic/lib/elliptic/curve/mont.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","inherits":"node_modules/inherits/inherits_browser.js","./base":"node_modules/elliptic/lib/elliptic/curve/base.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/elliptic/lib/elliptic/curve/edwards.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":"node_modules/elliptic/lib/elliptic/utils.js","bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","inherits":"node_modules/inherits/inherits_browser.js","./base":"node_modules/elliptic/lib/elliptic/curve/base.js"}],"node_modules/elliptic/lib/elliptic/curve/index.js":[function(require,module,exports) {
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":"node_modules/elliptic/lib/elliptic/curve/base.js","./short":"node_modules/elliptic/lib/elliptic/curve/short.js","./mont":"node_modules/elliptic/lib/elliptic/curve/mont.js","./edwards":"node_modules/elliptic/lib/elliptic/curve/edwards.js"}],"node_modules/hash.js/lib/hash/utils.js":[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"minimalistic-assert":"node_modules/minimalistic-assert/index.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/hash.js/lib/hash/common.js":[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":"node_modules/hash.js/lib/hash/utils.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js"}],"node_modules/hash.js/lib/hash/sha/common.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":"node_modules/hash.js/lib/hash/utils.js"}],"node_modules/hash.js/lib/hash/sha/1.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../utils":"node_modules/hash.js/lib/hash/utils.js","../common":"node_modules/hash.js/lib/hash/common.js","./common":"node_modules/hash.js/lib/hash/sha/common.js"}],"node_modules/hash.js/lib/hash/sha/256.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../utils":"node_modules/hash.js/lib/hash/utils.js","../common":"node_modules/hash.js/lib/hash/common.js","./common":"node_modules/hash.js/lib/hash/sha/common.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js"}],"node_modules/hash.js/lib/hash/sha/224.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":"node_modules/hash.js/lib/hash/utils.js","./256":"node_modules/hash.js/lib/hash/sha/256.js"}],"node_modules/hash.js/lib/hash/sha/512.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../utils":"node_modules/hash.js/lib/hash/utils.js","../common":"node_modules/hash.js/lib/hash/common.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js"}],"node_modules/hash.js/lib/hash/sha/384.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":"node_modules/hash.js/lib/hash/utils.js","./512":"node_modules/hash.js/lib/hash/sha/512.js"}],"node_modules/hash.js/lib/hash/sha.js":[function(require,module,exports) {
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":"node_modules/hash.js/lib/hash/sha/1.js","./sha/224":"node_modules/hash.js/lib/hash/sha/224.js","./sha/256":"node_modules/hash.js/lib/hash/sha/256.js","./sha/384":"node_modules/hash.js/lib/hash/sha/384.js","./sha/512":"node_modules/hash.js/lib/hash/sha/512.js"}],"node_modules/hash.js/lib/hash/ripemd.js":[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./utils":"node_modules/hash.js/lib/hash/utils.js","./common":"node_modules/hash.js/lib/hash/common.js"}],"node_modules/hash.js/lib/hash/hmac.js":[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":"node_modules/hash.js/lib/hash/utils.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js"}],"node_modules/hash.js/lib/hash.js":[function(require,module,exports) {
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/utils":"node_modules/hash.js/lib/hash/utils.js","./hash/common":"node_modules/hash.js/lib/hash/common.js","./hash/sha":"node_modules/hash.js/lib/hash/sha.js","./hash/ripemd":"node_modules/hash.js/lib/hash/ripemd.js","./hash/hmac":"node_modules/hash.js/lib/hash/hmac.js"}],"node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":[function(require,module,exports) {
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],"node_modules/elliptic/lib/elliptic/curves.js":[function(require,module,exports) {
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"hash.js":"node_modules/hash.js/lib/hash.js","./curve":"node_modules/elliptic/lib/elliptic/curve/index.js","./utils":"node_modules/elliptic/lib/elliptic/utils.js","./precomputed/secp256k1":"node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"}],"node_modules/hmac-drbg/lib/hmac-drbg.js":[function(require,module,exports) {
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":"node_modules/hash.js/lib/hash.js","minimalistic-crypto-utils":"node_modules/minimalistic-crypto-utils/lib/utils.js","minimalistic-assert":"node_modules/minimalistic-assert/index.js"}],"node_modules/elliptic/lib/elliptic/ec/key.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/elliptic/lib/elliptic/ec/signature.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/elliptic/lib/elliptic/ec/index.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","hmac-drbg":"node_modules/hmac-drbg/lib/hmac-drbg.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js","../curves":"node_modules/elliptic/lib/elliptic/curves.js","brorand":"node_modules/brorand/index.js","./key":"node_modules/elliptic/lib/elliptic/ec/key.js","./signature":"node_modules/elliptic/lib/elliptic/ec/signature.js"}],"node_modules/elliptic/lib/elliptic/eddsa/key.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/elliptic/lib/elliptic/eddsa/signature.js":[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"bn.js":"node_modules/elliptic/node_modules/bn.js/lib/bn.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js"}],"node_modules/elliptic/lib/elliptic/eddsa/index.js":[function(require,module,exports) {
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"hash.js":"node_modules/hash.js/lib/hash.js","../curves":"node_modules/elliptic/lib/elliptic/curves.js","../utils":"node_modules/elliptic/lib/elliptic/utils.js","./key":"node_modules/elliptic/lib/elliptic/eddsa/key.js","./signature":"node_modules/elliptic/lib/elliptic/eddsa/signature.js"}],"node_modules/elliptic/lib/elliptic.js":[function(require,module,exports) {
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":"node_modules/elliptic/package.json","./elliptic/utils":"node_modules/elliptic/lib/elliptic/utils.js","brorand":"node_modules/brorand/index.js","./elliptic/curve":"node_modules/elliptic/lib/elliptic/curve/index.js","./elliptic/curves":"node_modules/elliptic/lib/elliptic/curves.js","./elliptic/ec":"node_modules/elliptic/lib/elliptic/ec/index.js","./elliptic/eddsa":"node_modules/elliptic/lib/elliptic/eddsa/index.js"}],"node_modules/secp256k1/lib/elliptic.js":[function(require,module,exports) {
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve; // Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758

var BN = ecparams.n.constructor;

function loadCompressedPublicKey(first, xbuf) {
  var x = new BN(xbuf); // overflow

  if (x.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red); // compute corresponding Y

  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
  if (first === 0x03 !== y.isOdd()) y = y.redNeg();
  return ec.keyPair({
    pub: {
      x: x,
      y: y
    }
  });
}

function loadUncompressedPublicKey(first, xbuf, ybuf) {
  var x = new BN(xbuf);
  var y = new BN(ybuf); // overflow

  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red);
  y = y.toRed(ecparams.red); // is odd flag

  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + b = y*y

  var x3 = x.redSqr().redIMul(x);
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
  return ec.keyPair({
    pub: {
      x: x,
      y: y
    }
  });
}

function loadPublicKey(pubkey) {
  // length should be validated in interface
  var first = pubkey[0];

  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null;
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));

    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null;
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));

    default:
      return null;
  }
}

function savePublicKey(output, point) {
  var pubkey = point.encode(null, output.length === 33); // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))

  for (var i = 0; i < output.length; ++i) {
    output[i] = pubkey[i];
  }
}

module.exports = {
  contextRandomize: function contextRandomize() {
    return 0;
  },
  privateKeyVerify: function privateKeyVerify(seckey) {
    var bn = new BN(seckey);
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
  },
  privateKeyNegate: function privateKeyNegate(seckey) {
    var bn = new BN(seckey);
    var negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);
    seckey.set(negate);
    return 0;
  },
  privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
    var bn = new BN(tweak);
    if (bn.cmp(ecparams.n) >= 0) return 1;
    bn.iadd(new BN(seckey));
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
    if (bn.isZero()) return 1;
    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
    seckey.set(tweaked);
    return 0;
  },
  privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
    var bn = new BN(tweak);
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
    bn.imul(new BN(seckey));
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
    seckey.set(tweaked);
    return 0;
  },
  publicKeyVerify: function publicKeyVerify(pubkey) {
    var pair = loadPublicKey(pubkey);
    return pair === null ? 1 : 0;
  },
  publicKeyCreate: function publicKeyCreate(output, seckey) {
    var bn = new BN(seckey);
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
    var point = ec.keyFromPrivate(seckey).getPublic();
    savePublicKey(output, point);
    return 0;
  },
  publicKeyConvert: function publicKeyConvert(output, pubkey) {
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    var point = pair.getPublic();
    savePublicKey(output, point);
    return 0;
  },
  publicKeyNegate: function publicKeyNegate(output, pubkey) {
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    var point = pair.getPublic();
    point.y = point.y.redNeg();
    savePublicKey(output, point);
    return 0;
  },
  publicKeyCombine: function publicKeyCombine(output, pubkeys) {
    var pairs = new Array(pubkeys.length);

    for (var i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i]);
      if (pairs[i] === null) return 1;
    }

    var point = pairs[0].getPublic();

    for (var _i = 1; _i < pairs.length; ++_i) {
      point = point.add(pairs[_i].pub);
    }

    if (point.isInfinity()) return 2;
    savePublicKey(output, point);
    return 0;
  },
  publicKeyTweakAdd: function publicKeyTweakAdd(output, pubkey, tweak) {
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    tweak = new BN(tweak);
    if (tweak.cmp(ecparams.n) >= 0) return 2;
    var point = pair.getPublic().add(ecparams.g.mul(tweak));
    if (point.isInfinity()) return 2;
    savePublicKey(output, point);
    return 0;
  },
  publicKeyTweakMul: function publicKeyTweakMul(output, pubkey, tweak) {
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    tweak = new BN(tweak);
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
    var point = pair.getPublic().mul(tweak);
    savePublicKey(output, point);
    return 0;
  },
  signatureNormalize: function signatureNormalize(sig) {
    var r = new BN(sig.subarray(0, 32));
    var s = new BN(sig.subarray(32, 64));
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);
    }

    return 0;
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport: function signatureExport(obj, sig) {
    var sigR = sig.subarray(0, 32);
    var sigS = sig.subarray(32, 64);
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
    var output = obj.output; // Prepare R

    var r = output.subarray(4, 4 + 33);
    r[0] = 0x00;
    r.set(sigR, 1);
    var lenR = 33;
    var posR = 0;

    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR) {
      ;
    }

    r = r.subarray(posR);
    if (r[0] & 0x80) return 1;
    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1; // Prepare S

    var s = output.subarray(6 + 33, 6 + 33 + 33);
    s[0] = 0x00;
    s.set(sigS, 1);
    var lenS = 33;
    var posS = 0;

    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS) {
      ;
    }

    s = s.subarray(posS);
    if (s[0] & 0x80) return 1;
    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1; // Set output length for return

    obj.outputlen = 6 + lenR + lenS; // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]

    output[0] = 0x30;
    output[1] = obj.outputlen - 2;
    output[2] = 0x02;
    output[3] = r.length;
    output.set(r, 4);
    output[4 + lenR] = 0x02;
    output[5 + lenR] = s.length;
    output.set(s, 6 + lenR);
    return 0;
  },
  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport: function signatureImport(output, sig) {
    if (sig.length < 8) return 1;
    if (sig.length > 72) return 1;
    if (sig[0] !== 0x30) return 1;
    if (sig[1] !== sig.length - 2) return 1;
    if (sig[2] !== 0x02) return 1;
    var lenR = sig[3];
    if (lenR === 0) return 1;
    if (5 + lenR >= sig.length) return 1;
    if (sig[4 + lenR] !== 0x02) return 1;
    var lenS = sig[5 + lenR];
    if (lenS === 0) return 1;
    if (6 + lenR + lenS !== sig.length) return 1;
    if (sig[4] & 0x80) return 1;
    if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;
    if (sig[lenR + 6] & 0x80) return 1;
    if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;
    var sigR = sig.subarray(4, 4 + lenR);
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);
    if (sigR.length > 32) return 1;
    var sigS = sig.subarray(6 + lenR);
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);
    if (sigS.length > 32) throw new Error('S length is too long');
    var r = new BN(sigR);
    if (r.cmp(ecparams.n) >= 0) r = new BN(0);
    var s = new BN(sig.subarray(6 + lenR));
    if (s.cmp(ecparams.n) >= 0) s = new BN(0);
    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);
    return 0;
  },
  ecdsaSign: function ecdsaSign(obj, message, seckey, data, noncefn) {
    if (noncefn) {
      var _noncefn = noncefn;

      noncefn = function noncefn(counter) {
        var nonce = _noncefn(message, seckey, null, data, counter);

        var isValid = nonce instanceof Uint8Array && nonce.length === 32;
        if (!isValid) throw new Error('This is the way');
        return new BN(nonce);
      };
    }

    var d = new BN(seckey);
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
    var sig;

    try {
      sig = ec.sign(message, seckey, {
        canonical: true,
        k: noncefn,
        pers: data
      });
    } catch (err) {
      return 1;
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);
    obj.recid = sig.recoveryParam;
    return 0;
  },
  ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
    var sigObj = {
      r: sig.subarray(0, 32),
      s: sig.subarray(32, 64)
    };
    var sigr = new BN(sigObj.r);
    var sigs = new BN(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 2;
    var point = pair.getPublic();
    var isValid = ec.verify(msg32, sigObj, point);
    return isValid ? 0 : 3;
  },
  ecdsaRecover: function ecdsaRecover(output, sig, recid, msg32) {
    var sigObj = {
      r: sig.slice(0, 32),
      s: sig.slice(32, 64)
    };
    var sigr = new BN(sigObj.r);
    var sigs = new BN(sigObj.s);
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
    if (sigr.isZero() || sigs.isZero()) return 2; // Can throw `throw new Error('Unable to find sencond key candinate');`

    var point;

    try {
      point = ec.recoverPubKey(msg32, sigObj, recid);
    } catch (err) {
      return 2;
    }

    savePublicKey(output, point);
    return 0;
  },
  ecdh: function ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    var pair = loadPublicKey(pubkey);
    if (pair === null) return 1;
    var scalar = new BN(seckey);
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
    var point = pair.getPublic().mul(scalar);

    if (hashfn === undefined) {
      var _data = point.encode(null, true);

      var sha256 = ec.hash().update(_data).digest();

      for (var i = 0; i < 32; ++i) {
        output[i] = sha256[i];
      }
    } else {
      if (!xbuf) xbuf = new Uint8Array(32);
      var x = point.getX().toArray('be', 32);

      for (var _i2 = 0; _i2 < 32; ++_i2) {
        xbuf[_i2] = x[_i2];
      }

      if (!ybuf) ybuf = new Uint8Array(32);
      var y = point.getY().toArray('be', 32);

      for (var _i3 = 0; _i3 < 32; ++_i3) {
        ybuf[_i3] = y[_i3];
      }

      var hash = hashfn(xbuf, ybuf, data);
      var isValid = hash instanceof Uint8Array && hash.length === output.length;
      if (!isValid) return 2;
      output.set(hash);
    }

    return 0;
  }
};
},{"elliptic":"node_modules/elliptic/lib/elliptic.js"}],"node_modules/secp256k1/elliptic.js":[function(require,module,exports) {
module.exports = require('./lib')(require('./lib/elliptic'));
},{"./lib":"node_modules/secp256k1/lib/index.js","./lib/elliptic":"node_modules/secp256k1/lib/elliptic.js"}],"node_modules/libp2p-crypto/src/keys/secp256k1.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var secp256k1 = require('secp256k1');

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

module.exports = function (randomBytes) {
  var privateKeyLength = 32;

  function generateKey() {
    var privateKey;

    do {
      privateKey = randomBytes(32);
    } while (!secp256k1.privateKeyVerify(privateKey));

    return privateKey;
  }

  function hashAndSign(_x, _x2) {
    return _hashAndSign.apply(this, arguments);
  }

  function _hashAndSign() {
    _hashAndSign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, msg) {
      var _yield$sha256$digest, digest, sig;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return sha256.digest(msg);

            case 2:
              _yield$sha256$digest = _context.sent;
              digest = _yield$sha256$digest.digest;
              sig = secp256k1.ecdsaSign(digest, key);
              return _context.abrupt("return", secp256k1.signatureExport(sig.signature));

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _hashAndSign.apply(this, arguments);
  }

  function hashAndVerify(_x3, _x4, _x5) {
    return _hashAndVerify.apply(this, arguments);
  }

  function _hashAndVerify() {
    _hashAndVerify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key, sig, msg) {
      var _yield$sha256$digest2, digest;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return sha256.digest(msg);

            case 2:
              _yield$sha256$digest2 = _context2.sent;
              digest = _yield$sha256$digest2.digest;
              sig = secp256k1.signatureImport(sig);
              return _context2.abrupt("return", secp256k1.ecdsaVerify(sig, digest, key));

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _hashAndVerify.apply(this, arguments);
  }

  function compressPublicKey(key) {
    if (!secp256k1.publicKeyVerify(key)) {
      throw new Error('Invalid public key');
    }

    return secp256k1.publicKeyConvert(key, true);
  }

  function decompressPublicKey(key) {
    return secp256k1.publicKeyConvert(key, false);
  }

  function validatePrivateKey(key) {
    if (!secp256k1.privateKeyVerify(key)) {
      throw new Error('Invalid private key');
    }
  }

  function validatePublicKey(key) {
    if (!secp256k1.publicKeyVerify(key)) {
      throw new Error('Invalid public key');
    }
  }

  function computePublicKey(privateKey) {
    validatePrivateKey(privateKey);
    return secp256k1.publicKeyCreate(privateKey);
  }

  return {
    generateKey: generateKey,
    privateKeyLength: privateKeyLength,
    hashAndSign: hashAndSign,
    hashAndVerify: hashAndVerify,
    compressPublicKey: compressPublicKey,
    decompressPublicKey: decompressPublicKey,
    validatePrivateKey: validatePrivateKey,
    validatePublicKey: validatePublicKey,
    computePublicKey: computePublicKey
  };
};
},{"secp256k1":"node_modules/secp256k1/elliptic.js","multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js"}],"node_modules/libp2p-crypto/src/keys/secp256k1-class.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var errcode = require('err-code');

var uint8ArrayEquals = require('uint8arrays/equals');

var uint8ArrayToString = require('uint8arrays/to-string');

var exporter = require('./exporter');

module.exports = function (keysProtobuf, randomBytes, crypto) {
  crypto = crypto || require('./secp256k1')(randomBytes);

  var Secp256k1PublicKey = /*#__PURE__*/function () {
    function Secp256k1PublicKey(key) {
      _classCallCheck(this, Secp256k1PublicKey);

      crypto.validatePublicKey(key);
      this._key = key;
    }

    _createClass(Secp256k1PublicKey, [{
      key: "verify",
      value: function verify(data, sig) {
        return crypto.hashAndVerify(this._key, sig, data);
      }
    }, {
      key: "marshal",
      value: function marshal() {
        return crypto.compressPublicKey(this._key);
      }
    }, {
      key: "bytes",
      get: function get() {
        return keysProtobuf.PublicKey.encode({
          Type: keysProtobuf.KeyType.Secp256k1,
          Data: this.marshal()
        }).finish();
      }
    }, {
      key: "equals",
      value: function equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
    }, {
      key: "hash",
      value: function () {
        var _hash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _yield$sha256$digest, bytes;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return sha256.digest(this.bytes);

                case 2:
                  _yield$sha256$digest = _context.sent;
                  bytes = _yield$sha256$digest.bytes;
                  return _context.abrupt("return", bytes);

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function hash() {
          return _hash.apply(this, arguments);
        }

        return hash;
      }()
    }]);

    return Secp256k1PublicKey;
  }();

  var Secp256k1PrivateKey = /*#__PURE__*/function () {
    function Secp256k1PrivateKey(key, publicKey) {
      _classCallCheck(this, Secp256k1PrivateKey);

      this._key = key;
      this._publicKey = publicKey || crypto.computePublicKey(key);
      crypto.validatePrivateKey(this._key);
      crypto.validatePublicKey(this._publicKey);
    }

    _createClass(Secp256k1PrivateKey, [{
      key: "sign",
      value: function sign(message) {
        return crypto.hashAndSign(this._key, message);
      }
    }, {
      key: "public",
      get: function get() {
        return new Secp256k1PublicKey(this._publicKey);
      }
    }, {
      key: "marshal",
      value: function marshal() {
        return this._key;
      }
    }, {
      key: "bytes",
      get: function get() {
        return keysProtobuf.PrivateKey.encode({
          Type: keysProtobuf.KeyType.Secp256k1,
          Data: this.marshal()
        }).finish();
      }
    }, {
      key: "equals",
      value: function equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
    }, {
      key: "hash",
      value: function () {
        var _hash2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var _yield$sha256$digest2, bytes;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return sha256.digest(this.bytes);

                case 2:
                  _yield$sha256$digest2 = _context2.sent;
                  bytes = _yield$sha256$digest2.bytes;
                  return _context2.abrupt("return", bytes);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function hash() {
          return _hash2.apply(this, arguments);
        }

        return hash;
      }()
      /**
       * Gets the ID of the key.
       *
       * The key id is the base58 encoding of the SHA-256 multihash of its public key.
       * The public key is a protobuf encoding containing a type and the DER encoding
       * of the PKCS SubjectPublicKeyInfo.
       *
       * @returns {Promise<string>}
       */

    }, {
      key: "id",
      value: function () {
        var _id = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var hash;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return this.public.hash();

                case 2:
                  hash = _context3.sent;
                  return _context3.abrupt("return", uint8ArrayToString(hash, 'base58btc'));

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function id() {
          return _id.apply(this, arguments);
        }

        return id;
      }()
      /**
       * Exports the key into a password protected `format`
       *
       * @param {string} password - The password to encrypt the key
       * @param {string} [format=libp2p-key] - The format in which to export as
       * @returns {Promise<string>} The encrypted private key
       */

    }, {
      key: "export",
      value: function () {
        var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(password) {
          var format,
              _args4 = arguments;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  format = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 'libp2p-key';

                  if (!(format === 'libp2p-key')) {
                    _context4.next = 5;
                    break;
                  }

                  return _context4.abrupt("return", exporter.export(this.bytes, password));

                case 5:
                  throw errcode(new Error("export format '".concat(format, "' is not supported")), 'ERR_INVALID_EXPORT_FORMAT');

                case 6:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function _export(_x) {
          return _export2.apply(this, arguments);
        }

        return _export;
      }()
    }]);

    return Secp256k1PrivateKey;
  }();

  function unmarshalSecp256k1PrivateKey(bytes) {
    return new Secp256k1PrivateKey(bytes);
  }

  function unmarshalSecp256k1PublicKey(bytes) {
    return new Secp256k1PublicKey(bytes);
  }

  function generateKeyPair() {
    return _generateKeyPair.apply(this, arguments);
  }

  function _generateKeyPair() {
    _generateKeyPair = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var privateKeyBytes;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return crypto.generateKey();

            case 2:
              privateKeyBytes = _context5.sent;
              return _context5.abrupt("return", new Secp256k1PrivateKey(privateKeyBytes));

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _generateKeyPair.apply(this, arguments);
  }

  return {
    Secp256k1PublicKey: Secp256k1PublicKey,
    Secp256k1PrivateKey: Secp256k1PrivateKey,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey,
    generateKeyPair: generateKeyPair
  };
};
},{"multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","err-code":"node_modules/err-code/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","./exporter":"node_modules/libp2p-crypto/src/keys/exporter.js","./secp256k1":"node_modules/libp2p-crypto/src/keys/secp256k1.js"}],"node_modules/libp2p-crypto/src/hmac/lengths.js":[function(require,module,exports) {
'use strict';

module.exports = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};
},{}],"node_modules/libp2p-crypto/src/hmac/index-browser.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var webcrypto = require('../webcrypto');

var lengths = require('./lengths');

var hashTypes = {
  SHA1: 'SHA-1',
  SHA256: 'SHA-256',
  SHA512: 'SHA-512'
};

var sign = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, data) {
    var buf;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return webcrypto.get().subtle.sign({
              name: 'HMAC'
            }, key, data);

          case 2:
            buf = _context.sent;
            return _context.abrupt("return", new Uint8Array(buf, buf.byteOffset, buf.byteLength));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function sign(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.create = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(hashType, secret) {
    var hash, key;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            hash = hashTypes[hashType];
            _context3.next = 3;
            return webcrypto.get().subtle.importKey('raw', secret, {
              name: 'HMAC',
              hash: {
                name: hash
              }
            }, false, ['sign']);

          case 3:
            key = _context3.sent;
            return _context3.abrupt("return", {
              digest: function digest(data) {
                return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          return _context2.abrupt("return", sign(key, data));

                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }))();
              },
              length: lengths[hashType]
            });

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
},{"../webcrypto":"node_modules/libp2p-crypto/src/webcrypto.js","./lengths":"node_modules/libp2p-crypto/src/hmac/lengths.js"}],"node_modules/libp2p-crypto/src/keys/key-stretcher.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var errcode = require('err-code');

var uint8ArrayConcat = require('uint8arrays/concat');

var uint8ArrayFromString = require('uint8arrays/from-string');

var hmac = require('../hmac');

var cipherMap = {
  'AES-128': {
    ivSize: 16,
    keySize: 16
  },
  'AES-256': {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    cipherKeySize: 32
  }
}; // Generates a set of keys for each party by stretching the shared key.
// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)

module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cipherType, hash, secret) {
    var cipher, allowed, cipherKeySize, ivSize, hmacKeySize, seed, resultLength, m, a, result, j, b, todo, half, resultBuffer, r1, r2, createKey;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            cipher = cipherMap[cipherType];

            if (cipher) {
              _context.next = 4;
              break;
            }

            allowed = Object.keys(cipherMap).join(' / ');
            throw errcode(new Error("unknown cipher type '".concat(cipherType, "'. Must be ").concat(allowed)), 'ERR_INVALID_CIPHER_TYPE');

          case 4:
            if (hash) {
              _context.next = 6;
              break;
            }

            throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE');

          case 6:
            cipherKeySize = cipher.keySize;
            ivSize = cipher.ivSize;
            hmacKeySize = 20;
            seed = uint8ArrayFromString('key expansion');
            resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
            _context.next = 13;
            return hmac.create(hash, secret);

          case 13:
            m = _context.sent;
            _context.next = 16;
            return m.digest(seed);

          case 16:
            a = _context.sent;
            result = [];
            j = 0;

          case 19:
            if (!(j < resultLength)) {
              _context.next = 32;
              break;
            }

            _context.next = 22;
            return m.digest(uint8ArrayConcat([a, seed]));

          case 22:
            b = _context.sent;
            todo = b.length;

            if (j + todo > resultLength) {
              todo = resultLength - j;
            }

            result.push(b);
            j += todo;
            _context.next = 29;
            return m.digest(a);

          case 29:
            a = _context.sent;
            _context.next = 19;
            break;

          case 32:
            half = resultLength / 2;
            resultBuffer = uint8ArrayConcat(result);
            r1 = resultBuffer.slice(0, half);
            r2 = resultBuffer.slice(half, resultLength);

            createKey = function createKey(res) {
              return {
                iv: res.slice(0, ivSize),
                cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
                macKey: res.slice(ivSize + cipherKeySize)
              };
            };

            return _context.abrupt("return", {
              k1: createKey(r1),
              k2: createKey(r2)
            });

          case 38:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
},{"err-code":"node_modules/err-code/index.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","../hmac":"node_modules/libp2p-crypto/src/hmac/index-browser.js"}],"node_modules/libp2p-crypto/src/keys/validate-curve-type.js":[function(require,module,exports) {
'use strict';

var errcode = require('err-code');

module.exports = function (curveTypes, type) {
  if (!curveTypes.includes(type)) {
    var names = curveTypes.join(' / ');
    throw errcode(new Error("Unknown curve: ".concat(type, ". Must be ").concat(names)), 'ERR_INVALID_CURVE');
  }
};
},{"err-code":"node_modules/err-code/index.js"}],"node_modules/libp2p-crypto/src/keys/ecdh-browser.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var errcode = require('err-code');

var webcrypto = require('../webcrypto');

var _require = require('../util'),
    base64urlToBuffer = _require.base64urlToBuffer;

var validateCurveType = require('./validate-curve-type');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayConcat = require('uint8arrays/concat');

var uint8ArrayEquals = require('uint8arrays/equals');

var bits = {
  'P-256': 256,
  'P-384': 384,
  'P-521': 521
};

exports.generateEphmeralKeyPair = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(curve) {
    var pair, genSharedKey, publicKey;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            validateCurveType(Object.keys(bits), curve);
            _context2.next = 3;
            return webcrypto.get().subtle.generateKey({
              name: 'ECDH',
              namedCurve: curve
            }, true, ['deriveBits']);

          case 3:
            pair = _context2.sent;

            // forcePrivate is used for testing only
            genSharedKey = /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(theirPub, forcePrivate) {
                var privateKey, keys, buffer;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!forcePrivate) {
                          _context.next = 6;
                          break;
                        }

                        _context.next = 3;
                        return webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {
                          name: 'ECDH',
                          namedCurve: curve
                        }, false, ['deriveBits']);

                      case 3:
                        privateKey = _context.sent;
                        _context.next = 7;
                        break;

                      case 6:
                        privateKey = pair.privateKey;

                      case 7:
                        _context.next = 9;
                        return webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {
                          name: 'ECDH',
                          namedCurve: curve
                        }, false, []);

                      case 9:
                        _context.t0 = _context.sent;
                        _context.t1 = privateKey;
                        keys = [_context.t0, _context.t1];
                        _context.next = 14;
                        return webcrypto.get().subtle.deriveBits({
                          name: 'ECDH',
                          namedCurve: curve,
                          public: keys[0]
                        }, keys[1], bits[curve]);

                      case 14:
                        buffer = _context.sent;
                        return _context.abrupt("return", new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength));

                      case 16:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function genSharedKey(_x2, _x3) {
                return _ref2.apply(this, arguments);
              };
            }();

            _context2.next = 7;
            return webcrypto.get().subtle.exportKey('jwk', pair.publicKey);

          case 7:
            publicKey = _context2.sent;
            return _context2.abrupt("return", {
              key: marshalPublicKey(publicKey),
              genSharedKey: genSharedKey
            });

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

var curveLengths = {
  'P-256': 32,
  'P-384': 48,
  'P-521': 66
}; // Marshal converts a jwk encodec ECDH public key into the
// form specified in section 4.3.6 of ANSI X9.62. (This is the format
// go-ipfs uses)

function marshalPublicKey(jwk) {
  var byteLen = curveLengths[jwk.crv];
  return uint8ArrayConcat([Uint8Array.from([4]), // uncompressed point
  base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);
} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key


function unmarshalPublicKey(curve, key) {
  var byteLen = curveLengths[curve];

  if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT');
  }

  return {
    kty: 'EC',
    crv: curve,
    x: uint8ArrayToString(key.slice(1, byteLen + 1), 'base64url'),
    y: uint8ArrayToString(key.slice(1 + byteLen), 'base64url'),
    ext: true
  };
}

var unmarshalPrivateKey = function unmarshalPrivateKey(curve, key) {
  return _objectSpread(_objectSpread({}, unmarshalPublicKey(curve, key.public)), {}, {
    d: uint8ArrayToString(key.private, 'base64url')
  });
};
},{"err-code":"node_modules/err-code/index.js","../webcrypto":"node_modules/libp2p-crypto/src/webcrypto.js","../util":"node_modules/libp2p-crypto/src/util.js","./validate-curve-type":"node_modules/libp2p-crypto/src/keys/validate-curve-type.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js"}],"node_modules/libp2p-crypto/src/keys/ephemeral-keys.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var ecdh = require('./ecdh'); // Generates an ephemeral public key and returns a function that will compute
// the shared secret key.
//
// Focuses only on ECDH now, but can be made more general in the future.


module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(curve) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", ecdh.generateEphmeralKeyPair(curve));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}(); // eslint-disable-line require-await
},{"./ecdh":"node_modules/libp2p-crypto/src/keys/ecdh-browser.js"}],"node_modules/libp2p-crypto/src/keys/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var keysPBM = require('./keys');

require('node-forge/lib/asn1');

require('node-forge/lib/pbe');

var forge = require('node-forge/lib/forge');

var errcode = require('err-code');

var uint8ArrayFromString = require('uint8arrays/from-string');

var importer = require('./importer');

var supportedKeys = {
  rsa: require('./rsa-class'),
  ed25519: require('./ed25519-class'),
  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))
};
var ErrMissingSecp256K1 = {
  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',
  code: 'ERR_MISSING_PACKAGE'
};

function typeToKey(type) {
  var key = supportedKeys[type.toLowerCase()];

  if (!key) {
    var supported = Object.keys(supportedKeys).join(' / ');
    throw errcode(new Error("invalid or unsupported key type ".concat(type, ". Must be ").concat(supported)), 'ERR_UNSUPPORTED_KEY_TYPE');
  }

  return key;
} // Generates a keypair of the given type and bitsize


var generateKeyPair = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type, bits) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", typeToKey(type).generateKeyPair(bits));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function generateKeyPair(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}(); // Generates a keypair of the given type and bitsize
// seed is a 32 byte uint8array


var generateKeyPairFromSeed = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type, seed, bits) {
    var key;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // eslint-disable-line require-await
            key = typeToKey(type);

            if (!(type.toLowerCase() !== 'ed25519')) {
              _context2.next = 3;
              break;
            }

            throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');

          case 3:
            return _context2.abrupt("return", key.generateKeyPairFromSeed(seed, bits));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function generateKeyPairFromSeed(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}(); // Converts a protobuf serialized public key into its
// representative object


var unmarshalPublicKey = function unmarshalPublicKey(buf) {
  var decoded = keysPBM.PublicKey.decode(buf);
  var data = decoded.Data;

  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);

    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);

    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
      } else {
        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
      }

    default:
      typeToKey(decoded.Type);
    // throws because type is not supported
  }
}; // Converts a public key object into a protobuf serialized public key


var marshalPublicKey = function marshalPublicKey(key, type) {
  type = (type || 'rsa').toLowerCase();
  typeToKey(type); // check type

  return key.bytes;
}; // Converts a protobuf serialized private key into its
// representative object


var unmarshalPrivateKey = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(buf) {
    var decoded, data;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // eslint-disable-line require-await
            decoded = keysPBM.PrivateKey.decode(buf);
            data = decoded.Data;
            _context3.t0 = decoded.Type;
            _context3.next = _context3.t0 === keysPBM.KeyType.RSA ? 5 : _context3.t0 === keysPBM.KeyType.Ed25519 ? 6 : _context3.t0 === keysPBM.KeyType.Secp256k1 ? 7 : 12;
            break;

          case 5:
            return _context3.abrupt("return", supportedKeys.rsa.unmarshalRsaPrivateKey(data));

          case 6:
            return _context3.abrupt("return", supportedKeys.ed25519.unmarshalEd25519PrivateKey(data));

          case 7:
            if (!supportedKeys.secp256k1) {
              _context3.next = 11;
              break;
            }

            return _context3.abrupt("return", supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data));

          case 11:
            throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);

          case 12:
            typeToKey(decoded.Type);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function unmarshalPrivateKey(_x6) {
    return _ref3.apply(this, arguments);
  };
}(); // Converts a private key object into a protobuf serialized private key


var marshalPrivateKey = function marshalPrivateKey(key, type) {
  type = (type || 'rsa').toLowerCase();
  typeToKey(type); // check type

  return key.bytes;
};
/**
 *
 * @param {string} encryptedKey
 * @param {string} password
 */


var importKey = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(encryptedKey, password) {
    var _key, key, der;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return importer.import(encryptedKey, password);

          case 3:
            _key = _context4.sent;
            return _context4.abrupt("return", unmarshalPrivateKey(_key));

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);

          case 9:
            // Only rsa supports pem right now
            key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);

            if (!(key === null)) {
              _context4.next = 12;
              break;
            }

            throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM');

          case 12:
            der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
            der = uint8ArrayFromString(der.getBytes(), 'ascii');
            return _context4.abrupt("return", supportedKeys.rsa.unmarshalRsaPrivateKey(der));

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 7]]);
  }));

  return function importKey(_x7, _x8) {
    return _ref4.apply(this, arguments);
  };
}();

module.exports = {
  supportedKeys: supportedKeys,
  keysPBM: keysPBM,
  keyStretcher: require('./key-stretcher'),
  generateEphemeralKeyPair: require('./ephemeral-keys'),
  generateKeyPair: generateKeyPair,
  generateKeyPairFromSeed: generateKeyPairFromSeed,
  unmarshalPublicKey: unmarshalPublicKey,
  marshalPublicKey: marshalPublicKey,
  unmarshalPrivateKey: unmarshalPrivateKey,
  marshalPrivateKey: marshalPrivateKey,
  import: importKey
};
},{"./keys":"node_modules/libp2p-crypto/src/keys/keys.js","node-forge/lib/asn1":"node_modules/node-forge/lib/asn1.js","node-forge/lib/pbe":"node_modules/node-forge/lib/pbe.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","err-code":"node_modules/err-code/index.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","./importer":"node_modules/libp2p-crypto/src/keys/importer.js","./rsa-class":"node_modules/libp2p-crypto/src/keys/rsa-class.js","./ed25519-class":"node_modules/libp2p-crypto/src/keys/ed25519-class.js","./secp256k1-class":"node_modules/libp2p-crypto/src/keys/secp256k1-class.js","../random-bytes":"node_modules/libp2p-crypto/src/random-bytes.js","./key-stretcher":"node_modules/libp2p-crypto/src/keys/key-stretcher.js","./ephemeral-keys":"node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"}],"node_modules/class-is/index.js":[function(require,module,exports) {
'use strict';

function withIs(Class, { className, symbolName }) {
    const symbol = Symbol.for(symbolName);

    const ClassIsWrapper = {
        // The code below assigns the class wrapper to an object to trick
        // JavaScript engines to show the name of the extended class when
        // logging an instances.
        // We are assigning an anonymous class (class wrapper) to the object
        // with key `className` to keep the correct name.
        // If this is not supported it falls back to logging `ClassIsWrapper`.
        [className]: class extends Class {
            constructor(...args) {
                super(...args);
                Object.defineProperty(this, symbol, { value: true });
            }

            get [Symbol.toStringTag]() {
                return className;
            }
        },
    }[className];

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

function withIsProto(Class, { className, symbolName, withoutNew }) {
    const symbol = Symbol.for(symbolName);

    /* eslint-disable object-shorthand */
    const ClassIsWrapper = {
        [className]: function (...args) {
            if (withoutNew && !(this instanceof ClassIsWrapper)) {
                return new ClassIsWrapper(...args);
            }

            const _this = Class.call(this, ...args) || this;

            if (_this && !_this[symbol]) {
                Object.defineProperty(_this, symbol, { value: true });
            }

            return _this;
        },
    }[className];
    /* eslint-enable object-shorthand */

    ClassIsWrapper.prototype = Object.create(Class.prototype);
    ClassIsWrapper.prototype.constructor = ClassIsWrapper;

    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
            return className;
        },
    });

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

module.exports = withIs;
module.exports.proto = withIsProto;

},{}],"node_modules/peer-id/src/proto.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-peer-id"] || ($protobuf.roots["libp2p-peer-id"] = {});

$root.PeerIdProto = function () {
  /**
   * Properties of a PeerIdProto.
   * @exports IPeerIdProto
   * @interface IPeerIdProto
   * @property {Uint8Array} id PeerIdProto id
   * @property {Uint8Array|null} [pubKey] PeerIdProto pubKey
   * @property {Uint8Array|null} [privKey] PeerIdProto privKey
   */

  /**
   * Constructs a new PeerIdProto.
   * @exports PeerIdProto
   * @classdesc Represents a PeerIdProto.
   * @implements IPeerIdProto
   * @constructor
   * @param {IPeerIdProto=} [p] Properties to set
   */
  function PeerIdProto(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * PeerIdProto id.
   * @member {Uint8Array} id
   * @memberof PeerIdProto
   * @instance
   */


  PeerIdProto.prototype.id = $util.newBuffer([]);
  /**
   * PeerIdProto pubKey.
   * @member {Uint8Array} pubKey
   * @memberof PeerIdProto
   * @instance
   */

  PeerIdProto.prototype.pubKey = $util.newBuffer([]);
  /**
   * PeerIdProto privKey.
   * @member {Uint8Array} privKey
   * @memberof PeerIdProto
   * @instance
   */

  PeerIdProto.prototype.privKey = $util.newBuffer([]);
  /**
   * Encodes the specified PeerIdProto message. Does not implicitly {@link PeerIdProto.verify|verify} messages.
   * @function encode
   * @memberof PeerIdProto
   * @static
   * @param {IPeerIdProto} m PeerIdProto message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  PeerIdProto.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    w.uint32(10).bytes(m.id);
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey")) w.uint32(18).bytes(m.pubKey);
    if (m.privKey != null && Object.hasOwnProperty.call(m, "privKey")) w.uint32(26).bytes(m.privKey);
    return w;
  };
  /**
   * Decodes a PeerIdProto message from the specified reader or buffer.
   * @function decode
   * @memberof PeerIdProto
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {PeerIdProto} PeerIdProto
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  PeerIdProto.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.PeerIdProto();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.id = r.bytes();
          break;

        case 2:
          m.pubKey = r.bytes();
          break;

        case 3:
          m.privKey = r.bytes();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    if (!m.hasOwnProperty("id")) throw $util.ProtocolError("missing required 'id'", {
      instance: m
    });
    return m;
  };
  /**
   * Creates a PeerIdProto message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof PeerIdProto
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {PeerIdProto} PeerIdProto
   */


  PeerIdProto.fromObject = function fromObject(d) {
    if (d instanceof $root.PeerIdProto) return d;
    var m = new $root.PeerIdProto();

    if (d.id != null) {
      if (typeof d.id === "string") $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);else if (d.id.length) m.id = d.id;
    }

    if (d.pubKey != null) {
      if (typeof d.pubKey === "string") $util.base64.decode(d.pubKey, m.pubKey = $util.newBuffer($util.base64.length(d.pubKey)), 0);else if (d.pubKey.length) m.pubKey = d.pubKey;
    }

    if (d.privKey != null) {
      if (typeof d.privKey === "string") $util.base64.decode(d.privKey, m.privKey = $util.newBuffer($util.base64.length(d.privKey)), 0);else if (d.privKey.length) m.privKey = d.privKey;
    }

    return m;
  };
  /**
   * Creates a plain object from a PeerIdProto message. Also converts values to other types if specified.
   * @function toObject
   * @memberof PeerIdProto
   * @static
   * @param {PeerIdProto} m PeerIdProto
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  PeerIdProto.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      if (o.bytes === String) d.id = "";else {
        d.id = [];
        if (o.bytes !== Array) d.id = $util.newBuffer(d.id);
      }
      if (o.bytes === String) d.pubKey = "";else {
        d.pubKey = [];
        if (o.bytes !== Array) d.pubKey = $util.newBuffer(d.pubKey);
      }
      if (o.bytes === String) d.privKey = "";else {
        d.privKey = [];
        if (o.bytes !== Array) d.privKey = $util.newBuffer(d.privKey);
      }
    }

    if (m.id != null && m.hasOwnProperty("id")) {
      d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
    }

    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
    }

    if (m.privKey != null && m.hasOwnProperty("privKey")) {
      d.privKey = o.bytes === String ? $util.base64.encode(m.privKey, 0, m.privKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.privKey) : m.privKey;
    }

    return d;
  };
  /**
   * Converts this PeerIdProto to JSON.
   * @function toJSON
   * @memberof PeerIdProto
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  PeerIdProto.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return PeerIdProto;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/peer-id/src/index.js":[function(require,module,exports) {
/*
 * Id is an object representation of a peer Id. a peer Id is a multihash
 */
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('multiformats/cid'),
    CID = _require.CID;

var b32 = require('multiformats/bases/base32');

var b36 = require('multiformats/bases/base36');

var b58 = require('multiformats/bases/base58');

var b64 = require('multiformats/bases/base64');

var _require2 = require('multiformats/bases/base58'),
    base58btc = _require2.base58btc;

var _require3 = require('multiformats/bases/base32'),
    base32 = _require3.base32;

var _require4 = require('multiformats/bases/base16'),
    base16 = _require4.base16;

var Digest = require('multiformats/hashes/digest');

var cryptoKeys = require('libp2p-crypto/src/keys');

var withIs = require('class-is');

var _require5 = require('./proto'),
    PeerIdProto = _require5.PeerIdProto;

var uint8ArrayEquals = require('uint8arrays/equals');

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string');

var _require6 = require('multiformats/hashes/identity'),
    identity = _require6.identity;

var bases = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, b32), b36), b58), b64);

var baseDecoder = Object.keys(bases).reduce(function (acc, curr) {
  return acc.or(bases[curr]);
}, base32.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv

var DAG_PB_CODE = 0x70;
var LIBP2P_KEY_CODE = 0x72;

var PeerId = /*#__PURE__*/function () {
  function PeerId(id, privKey, pubKey) {
    _classCallCheck(this, PeerId);

    if (!(id instanceof Uint8Array)) {
      throw new Error('invalid id provided');
    }

    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {
      throw new Error('inconsistent arguments');
    }

    this._id = id;
    this._idB58String = base58btc.encode(this.id).substring(1);
    this._privKey = privKey;
    this._pubKey = pubKey;
  }

  _createClass(PeerId, [{
    key: "id",
    get: function get() {
      return this._id;
    },
    set: function set(val) {
      throw new Error('Id is immutable');
    }
  }, {
    key: "privKey",
    get: function get() {
      return this._privKey;
    },
    set: function set(privKey) {
      this._privKey = privKey;
    }
  }, {
    key: "pubKey",
    get: function get() {
      if (this._pubKey) {
        return this._pubKey;
      }

      if (this._privKey) {
        return this._privKey.public;
      }

      try {
        var decoded = Digest.decode(this.id);

        if (decoded.code === identity.code) {
          this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);
        }
      } catch (_) {// Ignore, there is no valid public key
      }

      return this._pubKey;
    },
    set: function set(pubKey) {
      this._pubKey = pubKey;
    } // Return the protobuf version of the public key, matching go ipfs formatting

  }, {
    key: "marshalPubKey",
    value: function marshalPubKey() {
      if (this.pubKey) {
        return cryptoKeys.marshalPublicKey(this.pubKey);
      }
    } // Return the protobuf version of the private key, matching go ipfs formatting

  }, {
    key: "marshalPrivKey",
    value: function marshalPrivKey() {
      if (this.privKey) {
        return cryptoKeys.marshalPrivateKey(this.privKey);
      }
    } // Return the protobuf version of the peer-id

  }, {
    key: "marshal",
    value: function marshal(excludePriv) {
      return PeerIdProto.encode({
        id: this.toBytes(),
        pubKey: this.marshalPubKey(),
        privKey: excludePriv ? null : this.marshalPrivKey()
      }).finish();
    }
  }, {
    key: "toPrint",
    value: function toPrint() {
      var pid = this.toB58String(); // All sha256 nodes start with Qm
      // We can skip the Qm to make the peer.ID more useful

      if (pid.startsWith('Qm')) {
        pid = pid.slice(2);
      }

      var maxRunes = 6;

      if (pid.length < maxRunes) {
        maxRunes = pid.length;
      }

      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';
    } // return the jsonified version of the key, matching the formatting
    // of go-ipfs for its config file

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        id: this.toB58String(),
        privKey: toB64Opt(this.marshalPrivKey()),
        pubKey: toB64Opt(this.marshalPubKey())
      };
    } // encode/decode functions

  }, {
    key: "toHexString",
    value: function toHexString() {
      return base16.encode(this.id).substring(1);
    }
  }, {
    key: "toBytes",
    value: function toBytes() {
      return this.id;
    }
  }, {
    key: "toB58String",
    value: function toB58String() {
      return this._idB58String;
    } // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209

  }, {
    key: "toString",
    value: function toString() {
      if (!this._idCIDString) {
        var cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id));
        Object.defineProperty(this, '_idCIDString', {
          value: cid.toString(),
          enumerable: false
        });
      }

      return this._idCIDString;
    }
    /**
     * Checks the equality of `this` peer against a given PeerId.
     *
     * @param {Uint8Array|PeerId} id
     * @returns {boolean}
     */

  }, {
    key: "equals",
    value: function equals(id) {
      if (id instanceof Uint8Array) {
        return uint8ArrayEquals(this.id, id);
      } else if (id.id) {
        return uint8ArrayEquals(this.id, id.id);
      } else {
        throw new Error('not valid Id');
      }
    }
    /**
     * Checks the equality of `this` peer against a given PeerId.
     *
     * @deprecated Use `.equals`
     * @param {Uint8Array|PeerId} id
     * @returns {boolean}
     */

  }, {
    key: "isEqual",
    value: function isEqual(id) {
      return this.equals(id);
    }
    /*
     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)
     */

  }, {
    key: "isValid",
    value: function isValid() {
      // TODO: needs better checking
      return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));
    }
    /**
     * Check if the PeerId has an inline public key.
     *
     * @returns {boolean}
     */

  }, {
    key: "hasInlinePublicKey",
    value: function hasInlinePublicKey() {
      try {
        var decoded = Digest.decode(this.id);

        if (decoded.code === identity.code) {
          return true;
        }
      } catch (_) {// Ignore, there is no valid public key
      }

      return false;
    }
  }]);

  return PeerId;
}();

var PeerIdWithIs = withIs(PeerId, {
  className: 'PeerId',
  symbolName: '@libp2p/js-peer-id/PeerId'
});
exports = module.exports = PeerIdWithIs;

var computeDigest = function computeDigest(pubKey) {
  if (pubKey.bytes.length <= 42) {
    return Digest.create(identity.code, pubKey.bytes).bytes;
  } else {
    return pubKey.hash();
  }
};

var computePeerId = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(privKey, pubKey) {
    var digest;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return computeDigest(pubKey);

          case 2:
            digest = _context.sent;
            return _context.abrupt("return", new PeerIdWithIs(digest, privKey, pubKey));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function computePeerId(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}(); // generation


exports.create = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(opts) {
    var key;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            opts = opts || {};
            opts.bits = opts.bits || 2048;
            opts.keyType = opts.keyType || 'RSA';
            _context2.next = 5;
            return cryptoKeys.generateKeyPair(opts.keyType, opts.bits);

          case 5:
            key = _context2.sent;
            return _context2.abrupt("return", computePeerId(key, key.public));

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x3) {
    return _ref2.apply(this, arguments);
  };
}();

exports.createFromHexString = function (str) {
  return new PeerIdWithIs(base16.decode('f' + str));
};

exports.createFromBytes = function (buf) {
  try {
    var cid = CID.decode(buf);

    if (!validMulticodec(cid)) {
      throw new Error('Supplied PeerID CID is invalid');
    }

    return exports.createFromCID(cid);
  } catch (_unused) {
    var digest = Digest.decode(buf);

    if (digest.code !== identity.code) {
      throw new Error('Supplied PeerID CID is invalid');
    }

    return new PeerIdWithIs(buf);
  }
};

exports.createFromB58String = function (str) {
  return exports.createFromBytes(base58btc.decode('z' + str));
};

var validMulticodec = function validMulticodec(cid) {
  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)
  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE;
};

exports.createFromCID = function (cid) {
  cid = CID.asCID(cid);

  if (!cid || !validMulticodec(cid)) {
    throw new Error('Supplied PeerID CID is invalid');
  }

  return new PeerIdWithIs(cid.multihash.bytes);
}; // Public Key input will be a Uint8Array


exports.createFromPubKey = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key) {
    var buf, pubKey;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            buf = key;

            if (typeof buf === 'string') {
              buf = uint8ArrayFromString(key, 'base64pad');
            }

            if (buf instanceof Uint8Array) {
              _context3.next = 4;
              break;
            }

            throw new Error('Supplied key is neither a base64 string nor a Uint8Array');

          case 4:
            _context3.next = 6;
            return cryptoKeys.unmarshalPublicKey(buf);

          case 6:
            pubKey = _context3.sent;
            return _context3.abrupt("return", computePeerId(undefined, pubKey));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x4) {
    return _ref3.apply(this, arguments);
  };
}(); // Private key input will be a string


exports.createFromPrivKey = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key) {
    var privKey;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (typeof key === 'string') {
              key = uint8ArrayFromString(key, 'base64pad');
            }

            if (key instanceof Uint8Array) {
              _context4.next = 3;
              break;
            }

            throw new Error('Supplied key is neither a base64 string nor a Uint8Array');

          case 3:
            _context4.next = 5;
            return cryptoKeys.unmarshalPrivateKey(key);

          case 5:
            privKey = _context4.sent;
            return _context4.abrupt("return", computePeerId(privKey, privKey.public));

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x5) {
    return _ref4.apply(this, arguments);
  };
}();

exports.createFromJSON = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(obj) {
    var id, rawPrivKey, rawPubKey, pub, privKey, privDigest, pubDigest;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            id = base58btc.decode('z' + obj.id);
            rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');
            rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');
            _context5.t0 = rawPubKey;

            if (!_context5.t0) {
              _context5.next = 8;
              break;
            }

            _context5.next = 7;
            return cryptoKeys.unmarshalPublicKey(rawPubKey);

          case 7:
            _context5.t0 = _context5.sent;

          case 8:
            pub = _context5.t0;

            if (rawPrivKey) {
              _context5.next = 11;
              break;
            }

            return _context5.abrupt("return", new PeerIdWithIs(id, undefined, pub));

          case 11:
            _context5.next = 13;
            return cryptoKeys.unmarshalPrivateKey(rawPrivKey);

          case 13:
            privKey = _context5.sent;
            _context5.next = 16;
            return computeDigest(privKey.public);

          case 16:
            privDigest = _context5.sent;

            if (!pub) {
              _context5.next = 21;
              break;
            }

            _context5.next = 20;
            return computeDigest(pub);

          case 20:
            pubDigest = _context5.sent;

          case 21:
            if (!(pub && !uint8ArrayEquals(privDigest, pubDigest))) {
              _context5.next = 23;
              break;
            }

            throw new Error('Public and private key do not match');

          case 23:
            if (!(id && !uint8ArrayEquals(privDigest, id))) {
              _context5.next = 25;
              break;
            }

            throw new Error('Id and private key do not match');

          case 25:
            return _context5.abrupt("return", new PeerIdWithIs(id, privKey, pub));

          case 26:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function (_x6) {
    return _ref5.apply(this, arguments);
  };
}();

exports.createFromProtobuf = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(buf) {
    var _PeerIdProto$decode, id, privKey, pubKey, pubDigest, privDigest;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (typeof buf === 'string') {
              buf = uint8ArrayFromString(buf, 'base16');
            }

            _PeerIdProto$decode = PeerIdProto.decode(buf), id = _PeerIdProto$decode.id, privKey = _PeerIdProto$decode.privKey, pubKey = _PeerIdProto$decode.pubKey;

            if (!privKey) {
              _context6.next = 8;
              break;
            }

            _context6.next = 5;
            return cryptoKeys.unmarshalPrivateKey(privKey);

          case 5:
            _context6.t0 = _context6.sent;
            _context6.next = 9;
            break;

          case 8:
            _context6.t0 = false;

          case 9:
            privKey = _context6.t0;

            if (!pubKey) {
              _context6.next = 16;
              break;
            }

            _context6.next = 13;
            return cryptoKeys.unmarshalPublicKey(pubKey);

          case 13:
            _context6.t1 = _context6.sent;
            _context6.next = 17;
            break;

          case 16:
            _context6.t1 = false;

          case 17:
            pubKey = _context6.t1;

            if (!privKey) {
              _context6.next = 22;
              break;
            }

            _context6.next = 21;
            return computeDigest(privKey.public);

          case 21:
            privDigest = _context6.sent;

          case 22:
            if (!pubKey) {
              _context6.next = 26;
              break;
            }

            _context6.next = 25;
            return computeDigest(pubKey);

          case 25:
            pubDigest = _context6.sent;

          case 26:
            if (!privKey) {
              _context6.next = 31;
              break;
            }

            if (!pubKey) {
              _context6.next = 30;
              break;
            }

            if (uint8ArrayEquals(privDigest, pubDigest)) {
              _context6.next = 30;
              break;
            }

            throw new Error('Public and private key do not match');

          case 30:
            return _context6.abrupt("return", new PeerIdWithIs(privDigest, privKey, privKey.public));

          case 31:
            if (!pubKey) {
              _context6.next = 33;
              break;
            }

            return _context6.abrupt("return", new PeerIdWithIs(pubDigest, undefined, pubKey));

          case 33:
            if (!id) {
              _context6.next = 35;
              break;
            }

            return _context6.abrupt("return", new PeerIdWithIs(id));

          case 35:
            throw new Error('Protobuf did not contain any usable key material');

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x7) {
    return _ref6.apply(this, arguments);
  };
}();

exports.parse = function (str) {
  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {
    // identity hash ed25519 key or sha2-256 hash of rsa public key
    // base58btc encoded either way
    str = "z".concat(str);
  }

  return exports.createFromBytes(baseDecoder.decode(str));
};

exports.isPeerId = function (peerId) {
  return Boolean(_typeof(peerId) === 'object' && peerId._id && peerId._idB58String);
};

function toB64Opt(val) {
  if (val) {
    return uint8ArrayToString(val, 'base64pad');
  }
}
},{"multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","multiformats/bases/base32":"node_modules/multiformats/cjs/src/bases/base32.js","multiformats/bases/base36":"node_modules/multiformats/cjs/src/bases/base36.js","multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","multiformats/bases/base64":"node_modules/multiformats/cjs/src/bases/base64.js","multiformats/bases/base16":"node_modules/multiformats/cjs/src/bases/base16.js","multiformats/hashes/digest":"node_modules/multiformats/cjs/src/hashes/digest.js","libp2p-crypto/src/keys":"node_modules/libp2p-crypto/src/keys/index.js","class-is":"node_modules/class-is/index.js","./proto":"node_modules/peer-id/src/proto.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","multiformats/hashes/identity":"node_modules/multiformats/cjs/src/hashes/identity.js"}],"node_modules/ip-regex/index.js":[function(require,module,exports) {
'use strict';

var word = '[a-fA-F\\d:]';

var b = function b(options) {
  return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : '';
};

var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
var v6seg = '[a-fA-F\\d]{1,4}';
var v6 = "\n(?:\n(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:").concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:").concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:").concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:").concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:").concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:").concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::").concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful

var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
var v4exact = new RegExp("^".concat(v4, "$"));
var v6exact = new RegExp("^".concat(v6, "$"));

var ip = function ip(options) {
  return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), 'g');
};

ip.v4 = function (options) {
  return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), 'g');
};

ip.v6 = function (options) {
  return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), 'g');
};

module.exports = ip;
},{}],"node_modules/is-ip/index.js":[function(require,module,exports) {
'use strict';

var ipRegex = require('ip-regex');

var isIp = function isIp(string) {
  return ipRegex({
    exact: true
  }).test(string);
};

isIp.v4 = function (string) {
  return ipRegex.v4({
    exact: true
  }).test(string);
};

isIp.v6 = function (string) {
  return ipRegex.v6({
    exact: true
  }).test(string);
};

isIp.version = function (string) {
  return isIp(string) ? isIp.v4(string) ? 4 : 6 : undefined;
};

module.exports = isIp;
},{"ip-regex":"node_modules/ip-regex/index.js"}],"node_modules/multiaddr/src/ip.js":[function(require,module,exports) {
'use strict'

const isIp = require('is-ip')
const uint8ArrayToString = require('uint8arrays/to-string')

const isIP = isIp
const isV4 = isIp.v4
const isV6 = isIp.v6

// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7
// @ts-ignore - this is copied from the link above better to keep it the same
const toBytes = function (ip, buff, offset) {
  offset = ~~offset

  let result

  if (isV4(ip)) {
    result = buff || new Uint8Array(offset + 4)
    // @ts-ignore
    // eslint-disable-next-line array-callback-return
    ip.split(/\./g).map(function (byte) {
      result[offset++] = parseInt(byte, 10) & 0xff
    })
  } else if (isV6(ip)) {
    const sections = ip.split(':', 8)

    let i
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i])
      let v4Buffer

      if (isv4) {
        v4Buffer = toBytes(sections[i])
        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0')
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0')
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      const argv = [i, '1']
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0')
      }
      sections.splice.apply(sections, argv)
    }

    result = buff || new Uint8Array(offset + 16)
    for (i = 0; i < sections.length; i++) {
      const word = parseInt(sections[i], 16)
      result[offset++] = (word >> 8) & 0xff
      result[offset++] = word & 0xff
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip)
  }

  return result
}

// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63
// @ts-ignore - this is copied from the link above better to keep it the same
const toString = function (buff, offset, length) {
  offset = ~~offset
  length = length || (buff.length - offset)

  const result = []
  let string
  const view = new DataView(buff.buffer)
  if (length === 4) {
    // IPv4
    for (let i = 0; i < length; i++) {
      result.push(buff[offset + i])
    }
    string = result.join('.')
  } else if (length === 16) {
    // IPv6
    for (let i = 0; i < length; i += 2) {
      result.push(view.getUint16(offset + i).toString(16))
    }
    string = result.join(':')
    string = string.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')
    string = string.replace(/:{3,4}/, '::')
  }

  return string
}

module.exports = {
  isIP,
  isV4,
  isV6,
  toBytes,
  toString
}

},{"is-ip":"node_modules/is-ip/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js"}],"node_modules/multiaddr/src/protocols-table.js":[function(require,module,exports) {
'use strict'
/** @typedef {import("./types").Protocol} Protocol */

/**
 * Protocols
 *
 * @param {number | string} proto
 * @returns {Protocol}
 */
function Protocols (proto) {
  if (typeof (proto) === 'number') {
    if (Protocols.codes[proto]) {
      return Protocols.codes[proto]
    }

    throw new Error('no protocol with code: ' + proto)
  } else if (typeof (proto) === 'string') {
    if (Protocols.names[proto]) {
      return Protocols.names[proto]
    }

    throw new Error('no protocol with name: ' + proto)
  }

  throw new Error('invalid protocol id type: ' + proto)
}

const V = -1
Protocols.lengthPrefixedVarSize = V
Protocols.V = V

/** @type {Array<[number, number, string, (string|boolean)?, string?]>} */
Protocols.table = [
  [4, 32, 'ip4'],
  [6, 16, 'tcp'],
  [33, 16, 'dccp'],
  [41, 128, 'ip6'],
  [42, V, 'ip6zone'],
  [53, V, 'dns', 'resolvable'],
  [54, V, 'dns4', 'resolvable'],
  [55, V, 'dns6', 'resolvable'],
  [56, V, 'dnsaddr', 'resolvable'],
  [132, 16, 'sctp'],
  [273, 16, 'udp'],
  [275, 0, 'p2p-webrtc-star'],
  [276, 0, 'p2p-webrtc-direct'],
  [277, 0, 'p2p-stardust'],
  [290, 0, 'p2p-circuit'],
  [301, 0, 'udt'],
  [302, 0, 'utp'],
  [400, V, 'unix', false, 'path'],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, 'ipfs'],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, 'p2p'],
  [443, 0, 'https'],
  [444, 96, 'onion'],
  [445, 296, 'onion3'],
  [446, V, 'garlic64'],
  [460, 0, 'quic'],
  [477, 0, 'ws'],
  [478, 0, 'wss'],
  [479, 0, 'p2p-websocket-star'],
  [480, 0, 'http'],
  [777, V, 'memory']
]
/** @type {Record<string,Protocol>} */
Protocols.names = {}
/** @type {Record<number,Protocol>} */
Protocols.codes = {}

// populate tables
Protocols.table.map(row => {
  const proto = p.apply(null, row)
  Protocols.codes[proto.code] = proto
  Protocols.names[proto.name] = proto
  return null
})

Protocols.object = p

/**
 *
 * Create a protocol
 *
 * @param {number} code
 * @param {number} size
 * @param {string} name
 * @param {any} [resolvable]
 * @param {any} [path]
 * @returns {Protocol}
 */
function p (code, size, name, resolvable, path) {
  return {
    code,
    size,
    name,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  }
}

module.exports = Protocols

},{}],"node_modules/varint/encode.js":[function(require,module,exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

},{}],"node_modules/varint/decode.js":[function(require,module,exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

},{}],"node_modules/varint/length.js":[function(require,module,exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

},{}],"node_modules/varint/index.js":[function(require,module,exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

},{"./encode.js":"node_modules/varint/encode.js","./decode.js":"node_modules/varint/decode.js","./length.js":"node_modules/varint/length.js"}],"node_modules/multiaddr/src/convert.js":[function(require,module,exports) {
'use strict'

const ip = require('./ip')
const protocols = require('./protocols-table')
const { CID } = require('multiformats/cid')
const { base32 } = require('multiformats/bases/base32')
const { base58btc } = require('multiformats/bases/base58')
const Digest = require('multiformats/hashes/digest')
const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')
const uint8ArrayConcat = require('uint8arrays/concat')

module.exports = Convert

// converts (serializes) addresses
/**
 * @param {string} proto
 * @param {string | Uint8Array} a
 */
function Convert (proto, a) {
  if (a instanceof Uint8Array) {
    return Convert.toString(proto, a)
  } else {
    return Convert.toBytes(proto, a)
  }
}

/**
 * Convert [code,Uint8Array] to string
 *
 * @param {number|string} proto
 * @param {Uint8Array} buf
 * @returns {string}
 */
Convert.toString = function convertToString (proto, buf) {
  const protocol = protocols(proto)
  switch (protocol.code) {
    case 4: // ipv4
    case 41: // ipv6
      return bytes2ip(buf)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return bytes2port(buf).toString()

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
    case 777: // memory
      return bytes2str(buf)

    case 421: // ipfs
      return bytes2mh(buf)
    case 444: // onion
      return bytes2onion(buf)
    case 445: // onion3
      return bytes2onion(buf)
    default:
      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex
  }
}

Convert.toBytes = function convertToBytes (/** @type {string | number } */ proto, /** @type {string} */ str) {
  const protocol = protocols(proto)
  switch (protocol.code) {
    case 4: // ipv4
      return ip2bytes(str)
    case 41: // ipv6
      return ip2bytes(str)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return port2bytes(parseInt(str, 10))

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
    case 777: // memory
      return str2bytes(str)

    case 421: // ipfs
      return mh2bytes(str)
    case 444: // onion
      return onion2bytes(str)
    case 445: // onion3
      return onion32bytes(str)
    default:
      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex
  }
}

/**
 * @param {string} ipString
 */
function ip2bytes (ipString) {
  if (!ip.isIP(ipString)) {
    throw new Error('invalid ip address')
  }
  return ip.toBytes(ipString)
}

/**
 * @param {Uint8Array} ipBuff
 */
function bytes2ip (ipBuff) {
  const ipString = ip.toString(ipBuff)
  if (!ipString || !ip.isIP(ipString)) {
    throw new Error('invalid ip address')
  }
  return ipString
}

/**
 * @param {number} port
 */
function port2bytes (port) {
  const buf = new ArrayBuffer(2)
  const view = new DataView(buf)
  view.setUint16(0, port)

  return new Uint8Array(buf)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2port (buf) {
  const view = new DataView(buf.buffer)
  return view.getUint16(buf.byteOffset)
}

/**
 * @param {string} str
 */
function str2bytes (str) {
  const buf = uint8ArrayFromString(str)
  const size = Uint8Array.from(varint.encode(buf.length))
  return uint8ArrayConcat([size, buf], size.length + buf.length)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2str (buf) {
  const size = varint.decode(buf)
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return uint8ArrayToString(buf)
}

/**
 * @param {string} hash - base58btc string
 */
function mh2bytes (hash) {
  let mh

  if (hash[0] === 'Q' || hash[0] === '1') {
    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes
  } else {
    mh = CID.parse(hash).multihash.bytes
  }

  // the address is a varint prefixed multihash string representation
  const size = Uint8Array.from(varint.encode(mh.length))
  return uint8ArrayConcat([size, mh], size.length + mh.length)
}

/**
 * Converts bytes to bas58btc string
 *
 * @param {Uint8Array} buf
 * @returns {string} base58btc string
 */
function bytes2mh (buf) {
  const size = varint.decode(buf)
  const address = buf.slice(varint.decode.bytes)

  if (address.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return uint8ArrayToString(address, 'base58btc')
}

/**
 * @param {string} str
 */
function onion2bytes (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 16) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.')
  }

  // onion addresses do not include the multibase prefix, add it before decoding
  const buf = base32.decode('b' + addr[0])

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2bytes(port)
  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)
}

/**
 * @param {string} str
 */
function onion32bytes (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 56) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.')
  }
  // onion addresses do not include the multibase prefix, add it before decoding
  const buf = base32.decode('b' + addr[0])

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2bytes(port)
  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2onion (buf) {
  const addrBytes = buf.slice(0, buf.length - 2)
  const portBytes = buf.slice(buf.length - 2)
  const addr = uint8ArrayToString(addrBytes, 'base32')
  const port = bytes2port(portBytes)
  return addr + ':' + port
}

},{"./ip":"node_modules/multiaddr/src/ip.js","./protocols-table":"node_modules/multiaddr/src/protocols-table.js","multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","multiformats/bases/base32":"node_modules/multiformats/cjs/src/bases/base32.js","multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","multiformats/hashes/digest":"node_modules/multiformats/cjs/src/hashes/digest.js","varint":"node_modules/varint/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js"}],"node_modules/multiaddr/src/codec.js":[function(require,module,exports) {
'use strict'

const convert = require('./convert')
const protocols = require('./protocols-table')
const varint = require('varint')
const uint8ArrayConcat = require('uint8arrays/concat')
const uint8ArrayToString = require('uint8arrays/to-string')

// export codec
module.exports = {
  stringToStringTuples,
  stringTuplesToString,

  tuplesToStringTuples,
  stringTuplesToTuples,

  bytesToTuples,
  tuplesToBytes,

  bytesToString,
  stringToBytes,

  fromString,
  fromBytes,
  validateBytes,
  isValidBytes,
  cleanPath,

  ParseError,
  protoFromTuple,

  sizeForAddr
}

// string -> [[str name, str addr]... ]
/**
 * @param {string} str
 */
function stringToStringTuples (str) {
  const tuples = []
  const parts = str.split('/').slice(1) // skip first empty elem
  if (parts.length === 1 && parts[0] === '') {
    return []
  }

  for (let p = 0; p < parts.length; p++) {
    const part = parts[p]
    const proto = protocols(part)

    if (proto.size === 0) {
      tuples.push([part])
      continue
    }

    p++ // advance addr part
    if (p >= parts.length) {
      throw ParseError('invalid address: ' + str)
    }

    // if it's a path proto, take the rest
    if (proto.path) {
      tuples.push([
        part,
        // TODO: should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join('/'))
      ])
      break
    }

    tuples.push([part, parts[p]])
  }

  return tuples
}

// [[str name, str addr]... ] -> string
/**
 * @param {[number, string?][]} tuples
 */
function stringTuplesToString (tuples) {
  /** @type {Array<string | undefined>} */
  const parts = []
  tuples.map((tup) => {
    const proto = protoFromTuple(tup)
    parts.push(proto.name)
    if (tup.length > 1) {
      parts.push(tup[1])
    }
    return null
  })

  return cleanPath(parts.join('/'))
}

// [[str name, str addr]... ] -> [[int code, Uint8Array]... ]
/**
 * @param {Array<string[] | string >} tuples
 * @returns {[number , Uint8Array?][]}
 */
function stringTuplesToTuples (tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup]
    }
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toBytes(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

/**
 * Convert tuples to string tuples
 *
 * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]
 *
 * @param {Array<[number, Uint8Array?]>} tuples
 * @returns {Array<[number, string?]>}
 */

function tuplesToStringTuples (tuples) {
  return tuples.map(tup => {
    const proto = protoFromTuple(tup)
    if (tup[1]) {
      return [proto.code, convert.toString(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Uint8Array ]... ] -> Uint8Array
/**
 * @param {[number, Uint8Array?][]} tuples
 */
function tuplesToBytes (tuples) {
  return fromBytes(uint8ArrayConcat(tuples.map((/** @type {any[]} */ tup) => {
    const proto = protoFromTuple(tup)
    let buf = Uint8Array.from(varint.encode(proto.code))

    if (tup.length > 1) {
      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer
    }

    return buf
  })))
}

/**
 * @param {import("./types").Protocol} p
 * @param {Uint8Array | number[]} addr
 */
function sizeForAddr (p, addr) {
  if (p.size > 0) {
    return p.size / 8
  } else if (p.size === 0) {
    return 0
  } else {
    const size = varint.decode(addr)
    return size + varint.decode.bytes
  }
}

/**
 *
 * @param {Uint8Array} buf
 * @returns {Array<[number, Uint8Array?]>}
 */
function bytesToTuples (buf) {
  /** @type {Array<[number, Uint8Array?]>} */
  const tuples = []
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)

    const size = sizeForAddr(p, buf.slice(i + n))

    if (size === 0) {
      tuples.push([code])
      i += n
      continue
    }

    const addr = buf.slice(i + n, i + n + size)

    i += (size + n)

    if (i > buf.length) { // did not end _exactly_ at buffer.length
      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))
    }

    // ok, tuple seems good.
    tuples.push([code, addr])
  }

  return tuples
}

// Uint8Array -> String
/**
 * @param {Uint8Array} buf
 */
function bytesToString (buf) {
  const a = bytesToTuples(buf)
  const b = tuplesToStringTuples(a)
  return stringTuplesToString(b)
}

// String -> Uint8Array
/**
 * @param {string} str
 */
function stringToBytes (str) {
  str = cleanPath(str)
  const a = stringToStringTuples(str)
  const b = stringTuplesToTuples(a)

  return tuplesToBytes(b)
}

// String -> Uint8Array
/**
 * @param {string} str
 */
function fromString (str) {
  return stringToBytes(str)
}

// Uint8Array -> Uint8Array
/**
 * @param {Uint8Array} buf
 */
function fromBytes (buf) {
  const err = validateBytes(buf)
  if (err) throw err
  return Uint8Array.from(buf) // copy
}

/**
 * @param {Uint8Array} buf
 */
function validateBytes (buf) {
  try {
    bytesToTuples(buf) // try to parse. will throw if breaks
  } catch (err) {
    return err
  }
}

/**
 * @param {Uint8Array} buf
 */
function isValidBytes (buf) {
  return validateBytes(buf) === undefined
}

/**
 * @param {string} str
 */
function cleanPath (str) {
  return '/' + str.trim().split('/').filter((/** @type {any} */ a) => a).join('/')
}

/**
 * @param {string} str
 */
function ParseError (str) {
  return new Error('Error parsing address: ' + str)
}

/**
 * @param {any[]} tup
 */
function protoFromTuple (tup) {
  const proto = protocols(tup[0])
  return proto
}

},{"./convert":"node_modules/multiaddr/src/convert.js","./protocols-table":"node_modules/multiaddr/src/protocols-table.js","varint":"node_modules/varint/index.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js"}],"node_modules/multiaddr/src/index.js":[function(require,module,exports) {
'use strict'

const codec = require('./codec')
const protocols = require('./protocols-table')
const varint = require('varint')
const { CID } = require('multiformats/cid')
const { base58btc } = require('multiformats/bases/base58')
const errCode = require('err-code')
const inspect = Symbol.for('nodejs.util.inspect.custom')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayEquals = require('uint8arrays/equals')

/**
 * @typedef {(addr: Multiaddr) => Promise<string[]>} Resolver
 * @typedef {string | Multiaddr | Uint8Array | null} MultiaddrInput
 * @typedef {import('./types').MultiaddrObject} MultiaddrObject
 * @typedef {import('./types').Protocol} Protocol
 */

/** @type {Map<string, Resolver>} */
const resolvers = new Map()
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')

/**
 * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from
 * a Uint8Array, String or another Multiaddr instance
 * public key.
 *
 */
class Multiaddr {
  /**
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * ```
   *
   * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
   */
  constructor (addr) {
    // default
    if (addr == null) {
      addr = ''
    }

    // Define symbol
    Object.defineProperty(this, symbol, { value: true })

    if (addr instanceof Uint8Array) {
      /** @type {Uint8Array} - The raw bytes representing this multiaddress */
      this.bytes = codec.fromBytes(addr)
    } else if (typeof addr === 'string') {
      if (addr.length > 0 && addr.charAt(0) !== '/') {
        throw new Error(`multiaddr "${addr}" must start with a "/"`)
      }
      this.bytes = codec.fromString(addr)
    } else if (Multiaddr.isMultiaddr(addr)) { // Multiaddr
      this.bytes = codec.fromBytes(addr.bytes) // validate + copy buffer
    } else {
      throw new Error('addr must be a string, Buffer, or another Multiaddr')
    }
  }

  /**
   * Returns Multiaddr as a String
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
   * // '/ip4/127.0.0.1/tcp/4001'
   * ```
   */
  toString () {
    return codec.bytesToString(this.bytes)
  }

  /**
   * Returns Multiaddr as a JSON encoded object
   *
   * @example
   * ```js
   * JSON.stringify(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // '/ip4/127.0.0.1/tcp/4001'
   * ```
   */
  toJSON () {
    return this.toString()
  }

  /**
   * Returns Multiaddr as a convinient options object to be used with net.createConnection
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }
   * ```
   */
  toOptions () {
    /** @type {MultiaddrObject} */
    const opts = {}
    const parsed = this.toString().split('/')
    opts.family = parsed[1] === 'ip4' ? 4 : 6
    opts.host = parsed[2]
    opts.transport = parsed[3]
    opts.port = parseInt(parsed[4])
    return opts
  }

  /**
   * Returns the protocols the Multiaddr is defined with, as an array of objects, in
   * left-to-right order. Each object contains the protocol code, protocol name,
   * and the size of its address space in bits.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
   * // [ { code: 4, size: 32, name: 'ip4' },
   * //   { code: 6, size: 16, name: 'tcp' } ]
   * ```
   *
   * @returns {Protocol[]} protocols - All the protocols the address is composed of
   */
  protos () {
    return this.protoCodes().map(code => Object.assign({}, protocols(code)))
  }

  /**
   * Returns the codes of the protocols in left-to-right order.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
   * // [ 4, 6 ]
   * ```
   *
   * @returns {number[]} protocol codes
   */
  protoCodes () {
    const codes = []
    const buf = this.bytes
    let i = 0
    while (i < buf.length) {
      const code = varint.decode(buf, i)
      const n = varint.decode.bytes

      const p = protocols(code)
      const size = codec.sizeForAddr(p, buf.slice(i + n))

      i += (size + n)
      codes.push(code)
    }

    return codes
  }

  /**
   * Returns the names of the protocols in left-to-right order.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
   * // [ 'ip4', 'tcp' ]
   * ```
   *
   * @returns {string[]} protocol names
   */
  protoNames () {
    return this.protos().map(proto => proto.name)
  }

  /**
   * Returns a tuple of parts
   *
   * @example
   * ```js
   * new Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
   * ```
   */
  tuples () {
    return codec.bytesToTuples(this.bytes)
  }

  /**
   * Returns a tuple of string/number parts
   * - tuples[][0] = code of protocol
   * - tuples[][1] = contents of address
   *
   * @example
   * ```js
   * new Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]
   * ```
   */
  stringTuples () {
    const t = codec.bytesToTuples(this.bytes)
    return codec.tuplesToStringTuples(t)
  }

  /**
   * Encapsulates a Multiaddr in another Multiaddr
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
   *
   * mh3.toString()
   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
   * ```
   *
   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr
   */
  encapsulate (addr) {
    addr = new Multiaddr(addr)
    return new Multiaddr(this.toString() + addr.toString())
  }

  /**
   * Decapsulates a Multiaddr from another Multiaddr
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
   *
   * mh3.decapsulate(mh2).toString()
   * // '/ip4/8.8.8.8/tcp/1080'
   * ```
   *
   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr
   * @returns {Multiaddr}
   */
  decapsulate (addr) {
    const addrString = addr.toString()
    const s = this.toString()
    const i = s.lastIndexOf(addrString)
    if (i < 0) {
      throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)
    }
    return new Multiaddr(s.slice(0, i))
  }

  /**
   * A more reliable version of `decapsulate` if you are targeting a
   * specific code, such as 421 (the `p2p` protocol code). The last index of the code
   * will be removed from the `Multiaddr`, and a new instance will be returned.
   * If the code is not present, the original `Multiaddr` is returned.
   *
   * @example
   * ```js
   * const addr = new Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')
   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>
   *
   * addr.decapsulateCode(421).toString()
   * // '/ip4/0.0.0.0/tcp/8080'
   *
   * new Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()
   * // '/ip4/127.0.0.1/tcp/8080'
   * ```
   *
   * @param {number} code - The code of the protocol to decapsulate from this Multiaddr
   * @returns {Multiaddr}
   */
  decapsulateCode (code) {
    const tuples = this.tuples()
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code) {
        return new Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)))
      }
    }
    return this
  }

  /**
   * Extract the peerId if the multiaddr contains one
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
   *
   * // should return QmValidBase58string or null if the id is missing or invalid
   * const peerId = mh1.getPeerId()
   * ```
   *
   * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma
   */
  getPeerId () {
    try {
      const tuples = this.stringTuples().filter((tuple) => {
        if (tuple[0] === protocols.names.ipfs.code) {
          return true
        }
        return false
      })

      // Get the last ipfs tuple ['ipfs', 'peerid string']
      const tuple = tuples.pop()
      if (tuple && tuple[1]) {
        const peerIdStr = tuple[1]

        // peer id is base58btc encoded string but not multibase encoded so add the `z`
        // prefix so we can validate that it is correctly encoded
        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')
        }

        // try to parse peer id as CID
        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')
      }

      return null
    } catch (e) {
      return null
    }
  }

  /**
   * Extract the path if the multiaddr contains one
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
   *
   * // should return utf8 string or null if the id is missing or invalid
   * const path = mh1.getPath()
   * ```js
   *
   * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present
   */
  getPath () {
    let path = null
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = protocols(tuple[0])
        if (proto.path) {
          return true
        }
        return false
      })[0][1]

      if (!path) {
        path = null
      }
    } catch (e) {
      path = null
    }
    return path
  }

  /**
   * Checks if two Multiaddrs are the same
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * mh1.equals(mh1)
   * // true
   *
   * mh1.equals(mh2)
   * // false
   * ```
   *
   * @param {Multiaddr} addr
   * @returns {boolean}
   */
  equals (addr) {
    return uint8ArrayEquals(this.bytes, addr.bytes)
  }

  /**
   * Resolve multiaddr if containing resolvable hostname.
   *
   * @example
   * ```js
   * Multiaddr.resolvers.set('dnsaddr', resolverFunction)
   * const mh1 = new Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')
   * const resolvedMultiaddrs = await mh1.resolve()
   * // [
   * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
   * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
   * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>
   * // ]
   * ```
   *
   * @returns {Promise<Array<Multiaddr>>}
   */
  async resolve () {
    const resolvableProto = this.protos().find((p) => p.resolvable)

    // Multiaddr is not resolvable?
    if (!resolvableProto) {
      return [this]
    }

    const resolver = resolvers.get(resolvableProto.name)
    if (!resolver) {
      throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
    }

    const addresses = await resolver(this)
    return addresses.map((a) => new Multiaddr(a))
  }

  /**
   * Gets a Multiaddrs node-friendly address object. Note that protocol information
   * is left out: in Node (and most network systems) the protocol is unknowable
   * given only the address.
   *
   * Has to be a ThinWaist Address, otherwise throws error
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
   * // {family: 4, address: '127.0.0.1', port: 4001}
   * ```
   *
   * @returns {{family: 4 | 6, address: string, port: number}}
   * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
   */
  nodeAddress () {
    const codes = this.protoCodes()
    const names = this.protoNames()
    const parts = this.toString().split('/').slice(1)

    if (parts.length < 4) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".')
    } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
      throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`)
    } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {
      throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
    }

    return {
      family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,
      address: parts[1],
      port: parseInt(parts[3]) // tcp or udp port
    }
  }

  /**
   * Returns if a Multiaddr is a Thin Waist address or not.
   *
   * Thin Waist is if a Multiaddr adheres to the standard combination of:
   *
   * `{IPv4, IPv6}/{TCP, UDP}`
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * const mh2 = new Multiaddr('/ip4/192.168.2.1/tcp/5001')
   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
   * const mh4 = new Multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')
   * // <Multiaddr 047f0000010607d0de039302a503221220d52ebb89d85b02a284948203a62ff28389c57c9f42beec4ec20db76a64835843 - /ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a>
   * mh1.isThinWaistAddress()
   * // true
   * mh2.isThinWaistAddress()
   * // true
   * mh3.isThinWaistAddress()
   * // false
   * mh4.isThinWaistAddress()
   * // false
   * ```
   *
   * @param {Multiaddr} [addr] - Defaults to using `this` instance
   */
  isThinWaistAddress (addr) {
    const protos = (addr || this).protos()

    if (protos.length !== 2) {
      return false
    }

    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false
    }
    return true
  }

  /**
   * Creates a Multiaddr from a node-friendly address object
   *
   * @example
   * ```js
   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * ```
   *
   * @param {{family: 4 | 6, address: string, port: number}} addr
   * @param {string} transport
   */
  static fromNodeAddress (addr, transport) {
    if (!addr) { throw new Error('requires node address object') }
    if (!transport) { throw new Error('requires transport protocol') }
    let ip
    switch (addr.family) {
      case 4:
        ip = 'ip4'
        break
      case 6:
        ip = 'ip6'
        break
      default:
        throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`)
    }
    return new Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))
  }

  /**
   * Returns if something is a Multiaddr that is a name
   *
   * @param {Multiaddr} addr
   * @returns {boolean} isName
   */
  static isName (addr) {
    if (!Multiaddr.isMultiaddr(addr)) {
      return false
    }

    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto) => proto.resolvable)
  }

  /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is Multiaddr}
   */
  static isMultiaddr (value) {
    return value instanceof Multiaddr || Boolean(value && value[symbol])
  }

  /**
   * Returns Multiaddr as a human-readable string.
   * For post Node.js v10.0.0.
   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
   *
   * @example
   * ```js
   * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
   * ```
   *
   * @returns {string}
   */
  [inspect] () {
    return '<Multiaddr ' +
    uint8ArrayToString(this.bytes, 'base16') + ' - ' +
    codec.bytesToString(this.bytes) + '>'
  }

  /**
   * Returns Multiaddr as a human-readable string.
   * Fallback for pre Node.js v10.0.0.
   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
   * ```
   *
   * @returns {string}
   */
  inspect () {
    return '<Multiaddr ' +
      uint8ArrayToString(this.bytes, 'base16') + ' - ' +
      codec.bytesToString(this.bytes) + '>'
  }
}

/**
 * Object containing table, names and codes of all supported protocols.
 * To get the protocol values from a Multiaddr, you can use
 * [`.protos()`](#multiaddrprotos),
 * [`.protoCodes()`](#multiaddrprotocodes) or
 * [`.protoNames()`](#multiaddrprotonames)
 *
 * @returns {{table: Array, names: Object, codes: Object}}
 */
Multiaddr.protocols = protocols

Multiaddr.resolvers = resolvers

/**
 * Static factory
 *
 * @param {MultiaddrInput} addr
 */
function multiaddr (addr) {
  return new Multiaddr(addr)
}

module.exports = { Multiaddr, multiaddr, protocols, resolvers }

},{"./codec":"node_modules/multiaddr/src/codec.js","./protocols-table":"node_modules/multiaddr/src/protocols-table.js","varint":"node_modules/varint/index.js","multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","err-code":"node_modules/err-code/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js"}],"node_modules/it-filter/index.js":[function(require,module,exports) {
'use strict'

/**
 * Filters the passed (async) iterable by using the filter function
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 * @param {function(T):boolean|Promise<boolean>} fn
 */
const filter = async function * (source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry
    }
  }
}

module.exports = filter

},{}],"node_modules/it-map/index.js":[function(require,module,exports) {
'use strict'

/**
 * Takes an (async) iterable and returns one with each item mapped by the passed
 * function.
 *
 * @template I,O
 * @param {AsyncIterable<I>|Iterable<I>} source
 * @param {function(I):O|Promise<O>} func
 * @returns {AsyncIterable<O>}
 */
const map = async function * (source, func) {
  for await (const val of source) {
    yield func(val)
  }
}

module.exports = map

},{}],"node_modules/it-take/index.js":[function(require,module,exports) {
'use strict'

/**
 * Stop iteration after n items have been received.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 * @param {number} limit
 * @returns {AsyncIterable<T>}
 */
const take = async function * (source, limit) {
  let items = 0

  if (limit < 1) {
    return
  }

  for await (const entry of source) {
    yield entry

    items++

    if (items === limit) {
      return
    }
  }
}

module.exports = take

},{}],"node_modules/libp2p/src/content-routing/utils.js":[function(require,module,exports) {
'use strict';

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var errCode = require('err-code');

var filter = require('it-filter');

var map = require('it-map');

var take = require('it-take');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * Store the multiaddrs from every peer in the passed peer store
 *
 * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source
 * @param {import('../peer-store')} peerStore
 */


function storeAddresses(source, peerStore) {
  return map(source, function (peer) {
    // ensure we have the addresses for a given peer
    peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
/**
 * Filter peers by unique peer id
 *
 * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source
 */


function uniquePeers(source) {
  /** @type Set<string> */
  var seen = new Set();
  return filter(source, function (peer) {
    // dedupe by peer id
    if (seen.has(peer.id.toString())) {
      return false;
    }

    seen.add(peer.id.toString());
    return true;
  });
}
/**
 * Require at least `min` peers to be yielded from `source`
 *
 * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source
 * @param {number} min
 */


function requirePeers(_x) {
  return _requirePeers.apply(this, arguments);
}
/**
 * If `max` is passed, only take that number of peers from the source
 * otherwise take all the peers
 *
 * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source
 * @param {number} [max]
 */


function _requirePeers() {
  _requirePeers = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(source) {
    var min,
        seen,
        _iteratorAbruptCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        peer,
        _args = arguments;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            min = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;
            seen = 0;
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = _asyncIterator(source);

          case 6:
            _context.next = 8;
            return _awaitAsyncGenerator(_iterator.next());

          case 8:
            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
              _context.next = 16;
              break;
            }

            peer = _step.value;
            seen++;
            _context.next = 13;
            return peer;

          case 13:
            _iteratorAbruptCompletion = false;
            _context.next = 6;
            break;

          case 16:
            _context.next = 22;
            break;

          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 22:
            _context.prev = 22;
            _context.prev = 23;

            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context.next = 27;
              break;
            }

            _context.next = 27;
            return _awaitAsyncGenerator(_iterator.return());

          case 27:
            _context.prev = 27;

            if (!_didIteratorError) {
              _context.next = 30;
              break;
            }

            throw _iteratorError;

          case 30:
            return _context.finish(27);

          case 31:
            return _context.finish(22);

          case 32:
            if (!(seen < min)) {
              _context.next = 34;
              break;
            }

            throw errCode(new Error('not found'), 'NOT_FOUND');

          case 34:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 18, 22, 32], [23,, 27, 31]]);
  }));
  return _requirePeers.apply(this, arguments);
}

function maybeLimitSource(source, max) {
  if (max) {
    return take(source, max);
  }

  return source;
}

module.exports = {
  storeAddresses: storeAddresses,
  uniquePeers: uniquePeers,
  requirePeers: requirePeers,
  maybeLimitSource: maybeLimitSource
};
},{"err-code":"node_modules/err-code/index.js","it-filter":"node_modules/it-filter/index.js","it-map":"node_modules/it-map/index.js","it-take":"node_modules/it-take/index.js"}],"node_modules/fast-fifo/fixed-size.js":[function(require,module,exports) {
module.exports = class FixedFIFO {
  constructor (hwm) {
    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')
    this.buffer = new Array(hwm)
    this.mask = hwm - 1
    this.top = 0
    this.btm = 0
    this.next = null
  }

  push (data) {
    if (this.buffer[this.top] !== undefined) return false
    this.buffer[this.top] = data
    this.top = (this.top + 1) & this.mask
    return true
  }

  shift () {
    const last = this.buffer[this.btm]
    if (last === undefined) return undefined
    this.buffer[this.btm] = undefined
    this.btm = (this.btm + 1) & this.mask
    return last
  }

  isEmpty () {
    return this.buffer[this.btm] === undefined
  }
}

},{}],"node_modules/fast-fifo/index.js":[function(require,module,exports) {
const FixedFIFO = require('./fixed-size')

module.exports = class FastFIFO {
  constructor (hwm) {
    this.hwm = hwm || 16
    this.head = new FixedFIFO(this.hwm)
    this.tail = this.head
  }

  push (val) {
    if (!this.head.push(val)) {
      const prev = this.head
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)
      this.head.push(val)
    }
  }

  shift () {
    const val = this.tail.shift()
    if (val === undefined && this.tail.next) {
      const next = this.tail.next
      this.tail.next = null
      this.tail = next
      return this.tail.shift()
    }
    return val
  }

  isEmpty () {
    return this.head.isEmpty()
  }
}

},{"./fixed-size":"node_modules/fast-fifo/fixed-size.js"}],"node_modules/it-pushable/index.js":[function(require,module,exports) {
const FIFO = require('fast-fifo')

module.exports = (options) => {
  options = options || {}
  let onEnd

  if (typeof options === 'function') {
    onEnd = options
    options = {}
  } else {
    onEnd = options.onEnd
  }

  let buffer = new FIFO()
  let pushable, onNext, ended

  const waitNext = () => {
    if (!buffer.isEmpty()) {
      if (options.writev) {
        let next
        const values = []
        while (!buffer.isEmpty()) {
          next = buffer.shift()
          if (next.error) throw next.error
          values.push(next.value)
        }
        return { done: next.done, value: values }
      }

      const next = buffer.shift()
      if (next.error) throw next.error
      return next
    }

    if (ended) return { done: true }

    return new Promise((resolve, reject) => {
      onNext = next => {
        onNext = null
        if (next.error) {
          reject(next.error)
        } else {
          if (options.writev && !next.done) {
            resolve({ done: next.done, value: [next.value] })
          } else {
            resolve(next)
          }
        }
        return pushable
      }
    })
  }

  const bufferNext = next => {
    if (onNext) return onNext(next)
    buffer.push(next)
    return pushable
  }

  const bufferError = err => {
    buffer = new FIFO()
    if (onNext) return onNext({ error: err })
    buffer.push({ error: err })
    return pushable
  }

  const push = value => {
    if (ended) return pushable
    return bufferNext({ done: false, value })
  }
  const end = err => {
    if (ended) return pushable
    ended = true
    return err ? bufferError(err) : bufferNext({ done: true })
  }
  const _return = () => {
    buffer = new FIFO()
    end()
    return { done: true }
  }
  const _throw = err => {
    end(err)
    return { done: true }
  }

  pushable = {
    [Symbol.asyncIterator] () { return this },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end
  }

  if (!onEnd) return pushable

  const _pushable = pushable

  pushable = {
    [Symbol.asyncIterator] () { return this },
    next () {
      return _pushable.next()
    },
    throw (err) {
      _pushable.throw(err)
      if (onEnd) {
        onEnd(err)
        onEnd = null
      }
      return { done: true }
    },
    return () {
      _pushable.return()
      if (onEnd) {
        onEnd()
        onEnd = null
      }
      return { done: true }
    },
    push,
    end (err) {
      _pushable.end(err)
      if (onEnd) {
        onEnd(err)
        onEnd = null
      }
      return pushable
    }
  }

  return pushable
}

},{"fast-fifo":"node_modules/fast-fifo/index.js"}],"node_modules/it-merge/index.js":[function(require,module,exports) {
'use strict'

const pushable = require('it-pushable')

/**
 * Treat one or more iterables as a single iterable.
 *
 * Nb. sources are iterated over in parallel so the
 * order of emitted items is not guaranteed.
 *
 * @template T
 * @param {...AsyncIterable<T>|Iterable<T>} sources
 * @returns {AsyncIterable<T>}
 */
const merge = async function * (...sources) {
  const output = pushable()

  setTimeout(async () => {
    try {
      await Promise.all(
        sources.map(async (source) => {
          for await (const item of source) {
            output.push(item)
          }
        })
      )

      output.end()
    } catch (err) {
      output.end(err)
    }
  }, 0)

  yield * output
}

module.exports = merge

},{"it-pushable":"node_modules/it-pushable/index.js"}],"node_modules/it-pipe/index.js":[function(require,module,exports) {
const rawPipe = (...fns) => {
  let res
  while (fns.length) {
    res = fns.shift()(res)
  }
  return res
}

const isIterable = obj => obj && (
  typeof obj[Symbol.asyncIterator] === 'function' ||
  typeof obj[Symbol.iterator] === 'function' ||
  typeof obj.next === 'function' // Probably, right?
)

const isDuplex = obj => obj && typeof obj.sink === 'function' && isIterable(obj.source)

const duplexPipelineFn = duplex => source => {
  duplex.sink(source) // TODO: error on sink side is unhandled rejection - this is the same as pull streams
  return duplex.source
}

const pipe = (...fns) => {
  // Duplex at start: wrap in function and return duplex source
  if (isDuplex(fns[0])) {
    const duplex = fns[0]
    fns[0] = () => duplex.source
  // Iterable at start: wrap in function
  } else if (isIterable(fns[0])) {
    const source = fns[0]
    fns[0] = () => source
  }

  if (fns.length > 1) {
    // Duplex at end: use duplex sink
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink
    }
  }

  if (fns.length > 2) {
    // Duplex in the middle, consume source with duplex sink and return duplex source
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i])
      }
    }
  }

  return rawPipe(...fns)
}

module.exports = pipe
module.exports.pipe = pipe
module.exports.rawPipe = rawPipe
module.exports.isIterable = isIterable
module.exports.isDuplex = isDuplex

},{}],"node_modules/it-first/index.js":[function(require,module,exports) {
'use strict'

/**
 * Returns the first result from an (async) iterable, unless empty, in which
 * case returns `undefined`.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */
const first = async (source) => {
  for await (const entry of source) { // eslint-disable-line no-unreachable-loop
    return entry
  }

  return undefined
}

module.exports = first

},{}],"node_modules/it-drain/index.js":[function(require,module,exports) {
'use strict'

/**
 * Drains an (async) iterable discarding its' content and does not return
 * anything.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 * @returns {Promise<void>}
 */
const drain = async (source) => {
  for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty
}

module.exports = drain

},{}],"node_modules/set-delayed-interval/src/index.js":[function(require,module,exports) {
'use strict'

const intervals = new Map()

const _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1000000)}`

/**
 * Run a given task each {interval} ms
 *
 * @param {() => Promise} task
 * @param {number} interval
 * @param {string} id
 */
async function _runPeriodically (task, interval, id) {
  while (intervals.get(id)) {
    try {
      await task()
    } catch (err) {
      // Throw global context error if handler throws
      setTimeout(() => { throw err }, 1)
      break
    }

    if (!intervals.get(id)) {
      break
    }

    await new Promise(resolve => {
      const _timeout = setTimeout(resolve, interval)

      intervals.set(id, _timeout)
    })
  }
}

/**
 * Asynchronous setInterval that is properly delayed using promises and can be delayed on boot.
 *
 * @param {() => Promise} task
 * @param {number} interval
 * @param {number} [delay = interval]
 * @returns {string}
 */
function setDelayedInterval (task, interval, delay) {
  delay = delay || interval

  const id = _generateId()
  const _timeout = setTimeout(() => {
    _runPeriodically(task, interval, id)
  }, delay)

  intervals.set(id, _timeout)

  return id
}

/**
 * Clear delayed interval.
 *
 * @param {string} id
 */
function clearDelayedInterval (id) {
  const _timeout = intervals.get(id)

  if (_timeout) {
    clearTimeout(_timeout)
    intervals.delete(id)
  }
}

module.exports = {
  setDelayedInterval,
  clearDelayedInterval
}

},{}],"node_modules/libp2p/src/peer-routing.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

function _asyncGeneratorDelegate(inner, awaitWrap) { var iter = {}, waiting = false; function pump(key, value) { waiting = true; value = new Promise(function (resolve) { resolve(inner[key](value)); }); return { done: false, value: awaitWrap(value) }; } ; iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; }; iter.next = function (value) { if (waiting) { waiting = false; return value; } return pump("next", value); }; if (typeof inner.throw === "function") { iter.throw = function (value) { if (waiting) { waiting = false; throw value; } return pump("throw", value); }; } if (typeof inner.return === "function") { iter.return = function (value) { if (waiting) { waiting = false; return value; } return pump("return", value); }; } return iter; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:peer-routing'), {
  error: debug('libp2p:peer-routing:err')
});

var errCode = require('err-code');

var _require = require('./content-routing/utils'),
    storeAddresses = _require.storeAddresses,
    uniquePeers = _require.uniquePeers,
    requirePeers = _require.requirePeers;

var merge = require('it-merge');

var _require2 = require('it-pipe'),
    pipe = _require2.pipe;

var first = require('it-first');

var drain = require('it-drain');

var filter = require('it-filter');

var _require3 = require('set-delayed-interval'),
    setDelayedInterval = _require3.setDelayedInterval,
    clearDelayedInterval = _require3.clearDelayedInterval;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule
 */

/**
 * @typedef {Object} RefreshManagerOptions
 * @property {boolean} [enabled = true] - Whether to enable the Refresh manager
 * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)
 * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)
 *
 * @typedef {Object} PeerRoutingOptions
 * @property {RefreshManagerOptions} [refreshManager]
 */


var PeerRouting = /*#__PURE__*/function () {
  /**
   * @class
   * @param {import('./')} libp2p
   */
  function PeerRouting(libp2p) {
    _classCallCheck(this, PeerRouting);

    this._peerId = libp2p.peerId;
    this._peerStore = libp2p.peerStore;
    /** @type {PeerRoutingModule[]} */

    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers

    if (libp2p._dht && libp2p._config.dht.enabled) {
      this._routers.push(libp2p._dht);
    }

    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  /**
   * Start peer routing service.
   */


  _createClass(PeerRouting, [{
    key: "start",
    value: function start() {
      if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {
        return;
      }

      this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);
    }
    /**
     * Recurrent task to find closest peers and add their addresses to the Address Book.
     */

  }, {
    key: "_findClosestPeersTask",
    value: function () {
      var _findClosestPeersTask2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return drain(this.getClosestPeers(this._peerId.id));

              case 3:
                _context.next = 8;
                break;

              case 5:
                _context.prev = 5;
                _context.t0 = _context["catch"](0);
                log.error(_context.t0);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 5]]);
      }));

      function _findClosestPeersTask() {
        return _findClosestPeersTask2.apply(this, arguments);
      }

      return _findClosestPeersTask;
    }()
    /**
     * Stop peer routing service.
     */

  }, {
    key: "stop",
    value: function stop() {
      clearDelayedInterval(this._timeoutId);
    }
    /**
     * Iterates over all peer routers in parallel to find the given peer.
     *
     * @param {PeerId} id - The id of the peer to find
     * @param {object} [options]
     * @param {number} [options.timeout] - How long the query should run
     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */

  }, {
    key: "findPeer",
    value: function () {
      var _findPeer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(id, options) {
        var _this2 = this;

        var output;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._routers.length) {
                  _context2.next = 2;
                  break;
                }

                throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');

              case 2:
                if (!(id.toB58String() === this._peerId.toB58String())) {
                  _context2.next = 4;
                  break;
                }

                throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF');

              case 4:
                _context2.next = 6;
                return pipe(merge.apply(void 0, _toConsumableArray(this._routers.map(function (router) {
                  return [router.findPeer(id, options)];
                }))), function (source) {
                  return filter(source, Boolean);
                }, // @ts-ignore findPeer resolves a Promise
                function (source) {
                  return storeAddresses(source, _this2._peerStore);
                }, function (source) {
                  return first(source);
                });

              case 6:
                output = _context2.sent;

                if (!output) {
                  _context2.next = 9;
                  break;
                }

                return _context2.abrupt("return", output);

              case 9:
                throw errCode(new Error('not found'), 'NOT_FOUND');

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function findPeer(_x, _x2) {
        return _findPeer.apply(this, arguments);
      }

      return findPeer;
    }()
    /**
     * Attempt to find the closest peers on the network to the given key.
     *
     * @param {Uint8Array} key - A CID like key
     * @param {Object} [options]
     * @param {number} [options.timeout=30e3] - How long the query can take.
     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */

  }, {
    key: "getClosestPeers",
    value: function getClosestPeers(key) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        timeout: 30e3
      };
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (_this._routers.length) {
                  _context3.next = 2;
                  break;
                }

                throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');

              case 2:
                return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(merge.apply(void 0, _toConsumableArray(_this._routers.map(function (router) {
                  return router.getClosestPeers(key, options);
                }))), function (source) {
                  return storeAddresses(source, _this._peerStore);
                }, function (source) {
                  return uniquePeers(source);
                }, function (source) {
                  return requirePeers(source);
                })), _awaitAsyncGenerator), "t0", 3);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  }]);

  return PeerRouting;
}();

module.exports = PeerRouting;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","./content-routing/utils":"node_modules/libp2p/src/content-routing/utils.js","it-merge":"node_modules/it-merge/index.js","it-pipe":"node_modules/it-pipe/index.js","it-first":"node_modules/it-first/index.js","it-drain":"node_modules/it-drain/index.js","it-filter":"node_modules/it-filter/index.js","set-delayed-interval":"node_modules/set-delayed-interval/src/index.js"}],"node_modules/libp2p/src/errors.js":[function(require,module,exports) {
'use strict';

exports.messages = {
  NOT_STARTED_YET: 'The libp2p node is not started yet',
  DHT_DISABLED: 'DHT is not available',
  CONN_ENCRYPTION_REQUIRED: 'At least one connection encryption module is required'
};
exports.codes = {
  DHT_DISABLED: 'ERR_DHT_DISABLED',
  PUBSUB_NOT_STARTED: 'ERR_PUBSUB_NOT_STARTED',
  DHT_NOT_STARTED: 'ERR_DHT_NOT_STARTED',
  CONN_ENCRYPTION_REQUIRED: 'ERR_CONN_ENCRYPTION_REQUIRED',
  ERR_INVALID_PROTOCOLS_FOR_STREAM: 'ERR_INVALID_PROTOCOLS_FOR_STREAM',
  ERR_CONNECTION_ENDED: 'ERR_CONNECTION_ENDED',
  ERR_CONNECTION_FAILED: 'ERR_CONNECTION_FAILED',
  ERR_NODE_NOT_STARTED: 'ERR_NODE_NOT_STARTED',
  ERR_ALREADY_ABORTED: 'ERR_ALREADY_ABORTED',
  ERR_TOO_MANY_ADDRESSES: 'ERR_TOO_MANY_ADDRESSES',
  ERR_NO_VALID_ADDRESSES: 'ERR_NO_VALID_ADDRESSES',
  ERR_RELAYED_DIAL: 'ERR_RELAYED_DIAL',
  ERR_DIALED_SELF: 'ERR_DIALED_SELF',
  ERR_DISCOVERED_SELF: 'ERR_DISCOVERED_SELF',
  ERR_DUPLICATE_TRANSPORT: 'ERR_DUPLICATE_TRANSPORT',
  ERR_ENCRYPTION_FAILED: 'ERR_ENCRYPTION_FAILED',
  ERR_HOP_REQUEST_FAILED: 'ERR_HOP_REQUEST_FAILED',
  ERR_INVALID_KEY: 'ERR_INVALID_KEY',
  ERR_INVALID_MESSAGE: 'ERR_INVALID_MESSAGE',
  ERR_INVALID_PARAMETERS: 'ERR_INVALID_PARAMETERS',
  ERR_INVALID_PEER: 'ERR_INVALID_PEER',
  ERR_MUXER_UNAVAILABLE: 'ERR_MUXER_UNAVAILABLE',
  ERR_TIMEOUT: 'ERR_TIMEOUT',
  ERR_TRANSPORT_UNAVAILABLE: 'ERR_TRANSPORT_UNAVAILABLE',
  ERR_TRANSPORT_DIAL_FAILED: 'ERR_TRANSPORT_DIAL_FAILED',
  ERR_UNSUPPORTED_PROTOCOL: 'ERR_UNSUPPORTED_PROTOCOL',
  ERR_INVALID_MULTIADDR: 'ERR_INVALID_MULTIADDR',
  ERR_SIGNATURE_NOT_VALID: 'ERR_SIGNATURE_NOT_VALID'
};
},{}],"node_modules/libp2p/src/content-routing/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

function _asyncGeneratorDelegate(inner, awaitWrap) { var iter = {}, waiting = false; function pump(key, value) { waiting = true; value = new Promise(function (resolve) { resolve(inner[key](value)); }); return { done: false, value: awaitWrap(value) }; } ; iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; }; iter.next = function (value) { if (waiting) { waiting = false; return value; } return pump("next", value); }; if (typeof inner.throw === "function") { iter.throw = function (value) { if (waiting) { waiting = false; throw value; } return pump("throw", value); }; } if (typeof inner.return === "function") { iter.return = function (value) { if (waiting) { waiting = false; return value; } return pump("return", value); }; } return iter; }

var errCode = require('err-code');

var _require = require('../errors'),
    messages = _require.messages,
    codes = _require.codes;

var _require2 = require('./utils'),
    storeAddresses = _require2.storeAddresses,
    uniquePeers = _require2.uniquePeers,
    requirePeers = _require2.requirePeers,
    maybeLimitSource = _require2.maybeLimitSource;

var merge = require('it-merge');

var _require3 = require('it-pipe'),
    pipe = _require3.pipe;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule
 */

/**
 * @typedef {Object} GetData
 * @property {PeerId} from
 * @property {Uint8Array} val
 */


var ContentRouting = /*#__PURE__*/function () {
  /**
   * @class
   * @param {import('..')} libp2p
   */
  function ContentRouting(libp2p) {
    _classCallCheck(this, ContentRouting);

    this.libp2p = libp2p;
    /** @type {ContentRoutingModule[]} */

    this.routers = libp2p._modules.contentRouting || [];
    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers

    if (this.dht && libp2p._config.dht.enabled) {
      this.routers.push(this.dht);
    }
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key.
   *
   * @param {CID} key - The CID key of the content to find
   * @param {object} [options]
   * @param {number} [options.timeout] - How long the query should run
   * @param {number} [options.maxNumProviders] - maximum number of providers to find
   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}
   */


  _createClass(ContentRouting, [{
    key: "findProviders",
    value: function findProviders(key) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (_this.routers.length) {
                  _context.next = 2;
                  break;
                }

                throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE');

              case 2:
                return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(merge.apply(void 0, _toConsumableArray(_this.routers.map(function (router) {
                  return router.findProviders(key, options);
                }))), function (source) {
                  return storeAddresses(source, _this.libp2p.peerStore);
                }, function (source) {
                  return uniquePeers(source);
                }, function (source) {
                  return maybeLimitSource(source, options.maxNumProviders);
                }, function (source) {
                  return requirePeers(source);
                })), _awaitAsyncGenerator), "t0", 3);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key.
     *
     * @param {CID} key - The CID key of the content to find
     * @returns {Promise<void>}
     */

  }, {
    key: "provide",
    value: function () {
      var _provide = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.routers.length) {
                  _context2.next = 2;
                  break;
                }

                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');

              case 2:
                _context2.next = 4;
                return Promise.all(this.routers.map(function (router) {
                  return router.provide(key);
                }));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function provide(_x) {
        return _provide.apply(this, arguments);
      }

      return provide;
    }()
    /**
     * Store the given key/value pair in the DHT.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {Object} [options] - put options
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put
     * @returns {Promise<void>}
     */

  }, {
    key: "put",
    value: function put(key, value, options) {
      if (!this.libp2p.isStarted() || !this.dht.isStarted) {
        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
      }

      return this.dht.put(key, value, options);
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     *
     * @param {Uint8Array} key
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     * @returns {Promise<GetData>}
     */

  }, {
    key: "get",
    value: function get(key, options) {
      if (!this.libp2p.isStarted() || !this.dht.isStarted) {
        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
      }

      return this.dht.get(key, options);
    }
    /**
     * Get the `n` values to the given key without sorting.
     *
     * @param {Uint8Array} key
     * @param {number} nVals
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     * @returns {Promise<GetData[]>}
     */

  }, {
    key: "getMany",
    value: function () {
      var _getMany = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, nVals, options) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!this.libp2p.isStarted() || !this.dht.isStarted)) {
                  _context3.next = 2;
                  break;
                }

                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);

              case 2:
                return _context3.abrupt("return", this.dht.getMany(key, nVals, options));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getMany(_x2, _x3, _x4) {
        return _getMany.apply(this, arguments);
      }

      return getMany;
    }()
  }]);

  return ContentRouting;
}();

module.exports = ContentRouting;
},{"err-code":"node_modules/err-code/index.js","../errors":"node_modules/libp2p/src/errors.js","./utils":"node_modules/libp2p/src/content-routing/utils.js","it-merge":"node_modules/it-merge/index.js","it-pipe":"node_modules/it-pipe/index.js"}],"node_modules/libp2p/src/get-peer.js":[function(require,module,exports) {
'use strict';

var PeerId = require('peer-id');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var errCode = require('err-code');

var _require2 = require('./errors'),
    codes = _require2.codes;
/**
 * Converts the given `peer` to a `Peer` object.
 * If a multiaddr is received, the addressBook is updated.
 *
 * @param {PeerId|Multiaddr|string} peer
 * @returns {{ id: PeerId, multiaddrs: Multiaddr[]|undefined }}
 */


function getPeer(peer) {
  if (typeof peer === 'string') {
    peer = new Multiaddr(peer);
  }

  var addr;

  if (Multiaddr.isMultiaddr(peer)) {
    addr = peer;
    var idStr = peer.getPeerId();

    if (!idStr) {
      throw errCode(new Error("".concat(peer, " does not have a valid peer type")), codes.ERR_INVALID_MULTIADDR);
    }

    try {
      peer = PeerId.createFromB58String(idStr);
    } catch (err) {
      throw errCode(new Error("".concat(peer, " is not a valid peer type")), codes.ERR_INVALID_MULTIADDR);
    }
  }

  return {
    id: peer,
    multiaddrs: addr ? [addr] : undefined
  };
}

module.exports = getPeer;
},{"peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","err-code":"node_modules/err-code/index.js","./errors":"node_modules/libp2p/src/errors.js"}],"node_modules/is-plain-obj/index.js":[function(require,module,exports) {
'use strict';

module.exports = function (value) {
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
},{}],"node_modules/merge-options/index.js":[function(require,module,exports) {
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var isOptionObject = require('is-plain-obj');

var hasOwnProperty = Object.prototype.hasOwnProperty;
var propertyIsEnumerable = Object.propertyIsEnumerable;

var defineProperty = function defineProperty(object, name, value) {
  return Object.defineProperty(object, name, {
    value: value,
    writable: true,
    enumerable: true,
    configurable: true
  });
};

var globalThis = this;
var defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};

var getEnumerableOwnPropertyKeys = function getEnumerableOwnPropertyKeys(value) {
  var keys = [];

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      keys.push(key);
    }
  }
  /* istanbul ignore else  */


  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(value);

    var _iterator = _createForOfIteratorHelper(symbols),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var symbol = _step.value;

        if (propertyIsEnumerable.call(value, symbol)) {
          keys.push(symbol);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return keys;
};

function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }

  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }

  return value;
}

function cloneArray(array) {
  var result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach(function (key) {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}

function cloneOptionObject(object) {
  var result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach(function (key) {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */


var mergeKeys = function mergeKeys(merged, source, keys, config) {
  keys.forEach(function (key) {
    if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
      return;
    } // Do not recurse into prototype chain of merged


    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge(merged[key], source[key], config));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */


var concatArrays = function concatArrays(merged, source, config) {
  var result = merged.slice(0, 0);
  var resultIndex = 0;
  [merged, source].forEach(function (array) {
    var indices = []; // `result.concat(array)` with cloning

    for (var k = 0; k < array.length; k++) {
      if (!hasOwnProperty.call(array, k)) {
        continue;
      }

      indices.push(String(k));

      if (array === merged) {
        // Already cloned
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    } // Merge non-index keys


    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(function (key) {
      return !indices.includes(key);
    }), config);
  });
  return result;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */


function merge(merged, source, config) {
  if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config);
  }

  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }

  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}

module.exports = function () {
  var config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);
  var merged = {
    _: {}
  };

  for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
    options[_key] = arguments[_key];
  }

  for (var _i = 0, _options = options; _i < _options.length; _i++) {
    var option = _options[_i];

    if (option === undefined) {
      continue;
    }

    if (!isOptionObject(option)) {
      throw new TypeError('`' + option + '` is not an Option Object');
    }

    merged = merge(merged, {
      _: option
    }, config);
  }

  return merged._;
};
},{"is-plain-obj":"node_modules/is-plain-obj/index.js"}],"node_modules/receptacle/index.js":[function(require,module,exports) {
'use strict'

module.exports = Receptacle
var toMS = require('ms')
var cache = Receptacle.prototype
var counter = new Date() % 1e9

function getUID () { return (Math.random() * 1e9 >>> 0) + (counter++) }

/**
 * Creates a cache with a maximum key size.
 *
 * @constructor
 * @param {Object} options
 * @param {Number} [options.max=Infinity] the maximum number of keys allowed in the cache (lru).
 * @param {Array} [options.items=[]] the default items in the cache.
 */
function Receptacle (options) {
  options = options || {}
  this.id = options.id || getUID()
  this.max = options.max || Infinity
  this.items = options.items || []
  this._lookup = {}
  this.size = this.items.length
  this.lastModified = new Date(options.lastModified || new Date())

  // Setup initial timers and indexes for the cache.
  for (var item, ttl, i = this.items.length; i--;) {
    item = this.items[i]
    ttl = new Date(item.expires) - new Date()
    this._lookup[item.key] = item
    if (ttl > 0) this.expire(item.key, ttl)
    else if (ttl <= 0) this.delete(item.key)
  }
}

/**
 * Tests if a key is currently in the cache.
 * Does not check if slot is empty.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {Boolean}
 */
cache.has = function (key) {
  return key in this._lookup
}

/**
 * Retrieves a key from the cache and marks it as recently used.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {*}
 */
cache.get = function (key) {
  if (!this.has(key)) return null
  var record = this._lookup[key]
  // Update expiry for "refresh" keys
  if (record.refresh) this.expire(key, record.refresh)
  // Move to front of the line.
  this.items.splice(this.items.indexOf(record), 1)
  this.items.push(record)
  return record.value
}

/**
 * Retrieves user meta data for a cached item.
 *
 * @param {String} key - the key to retrieve meta data from the cache.
 * @return {*}
 */
cache.meta = function (key) {
  if (!this.has(key)) return null
  var record = this._lookup[key]
  if (!('meta' in record)) return null
  return record.meta
}

/**
 * Puts a key into the cache with an optional expiry time.
 *
 * @param {String} key - the key for the value in the cache.
 * @param {*} value - the value to place at the key.
 * @param {Number} [options.ttl] - a time after which the key will be removed.
 * @return {Receptacle}
 */
cache.set = function (key, value, options) {
  var oldRecord = this._lookup[key]
  var record = this._lookup[key] = { key: key, value: value }
  // Mark cache as modified.
  this.lastModified = new Date()

  if (oldRecord) {
    // Replace an old key.
    clearTimeout(oldRecord.timeout)
    this.items.splice(this.items.indexOf(oldRecord), 1, record)
  } else {
    // Remove least used item if needed.
    if (this.size >= this.max) this.delete(this.items[0].key)
    // Add a new key.
    this.items.push(record)
    this.size++
  }

  if (options) {
    // Setup key expiry.
    if ('ttl' in options) this.expire(key, options.ttl)
    // Store user options in the record.
    if ('meta' in options) record.meta = options.meta
    // Mark a auto refresh key.
    if (options.refresh) record.refresh = options.ttl
  }

  return this
}

/**
 * Deletes an item from the cache.
 *
 * @param {String} key - the key to remove.
 * @return {Receptacle}
 */
cache.delete = function (key) {
  var record = this._lookup[key]
  if (!record) return false
  this.lastModified = new Date()
  this.items.splice(this.items.indexOf(record), 1)
  clearTimeout(record.timeout)
  delete this._lookup[key]
  this.size--
  return this
}

/**
 * Utility to register a key that will be removed after some time.
 *
 * @param {String} key - the key to remove.
 * @param {Number} [ms] - the timeout before removal.
 * @return {Receptacle}
 */
cache.expire = function (key, ttl) {
  var ms = ttl || 0
  var record = this._lookup[key]
  if (!record) return this
  if (typeof ms === 'string') ms = toMS(ttl)
  if (typeof ms !== 'number') throw new TypeError('Expiration time must be a string or number.')
  clearTimeout(record.timeout)
  record.timeout = setTimeout(this.delete.bind(this, record.key), ms)
  record.expires = Number(new Date()) + ms
  return this
}

/**
 * Deletes all items from the cache.
 * @return {Receptacle}
 */
cache.clear = function () {
  for (var i = this.items.length; i--;) this.delete(this.items[i].key)
  return this
}

/**
 * Fixes serialization issues in polyfilled environments.
 * Ensures non-cyclical serialized object.
 */
cache.toJSON = function () {
  var items = new Array(this.items.length)
  var item
  for (var i = items.length; i--;) {
    item = this.items[i]
    items[i] = {
      key: item.key,
      meta: item.meta,
      value: item.value,
      expires: item.expires,
      refresh: item.refresh
    }
  }

  return {
    id: this.id,
    max: isFinite(this.max) ? this.max : undefined,
    lastModified: this.lastModified,
    items: items
  }
}

},{"ms":"node_modules/ms/index.js"}],"node_modules/node-fetch/browser.js":[function(require,module,exports) {

"use strict"; // ref: https://github.com/tc39/proposal-global

var getGlobal = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  throw new Error('unable to locate global object');
};

var global = getGlobal();
module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

if (global.fetch) {
  exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;
},{}],"node_modules/native-fetch/src/index.js":[function(require,module,exports) {
'use strict'

if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
  module.exports = {
    default: globalThis.fetch,
    Headers: globalThis.Headers,
    Request: globalThis.Request,
    Response: globalThis.Response
  }
} else {
  module.exports = {
    default: require('node-fetch').default,
    Headers: require('node-fetch').Headers,
    Request: require('node-fetch').Request,
    Response: require('node-fetch').Response
  }
}

},{"node-fetch":"node_modules/node-fetch/browser.js"}],"node_modules/dns-over-http-resolver/src/utils.js":[function(require,module,exports) {
'use strict'

const { default: nativeFetch, Headers } = require('native-fetch')

/**
 * Build fetch resource for request.
 *
 * @param {object} properties
 * @param {string} properties.serverResolver
 * @param {string} properties.hostname
 * @param {string} properties.recordType
 * @returns {string}
 */
function buildResource ({ serverResolver, hostname, recordType }) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`
}

/**
 * Use fetch to find the record.
 *
 * @param {object} resource
 * @returns {Promise}
 */
function fetch (resource) {
  return nativeFetch(resource, {
    headers: new Headers({
      accept: 'application/dns-json'
    })
  })
}

/**
 * Creates cache key composed by recordType and hostname.
 *
 * @param {string} hostname
 * @param {string} recordType
 * @returns {string}
 */
function getCacheKey (hostname, recordType) {
  return `${recordType}_${hostname}`
}

module.exports = {
  buildResource,
  fetch,
  getCacheKey
}

},{"native-fetch":"node_modules/native-fetch/src/index.js"}],"node_modules/dns-over-http-resolver/src/index.js":[function(require,module,exports) {
'use strict'
const debug = require('debug')
const log = debug('dns-over-http-resolver')
log.error = debug('dns-over-http-resolver:error')

const Receptacle = require('receptacle')

const utils = require('./utils')

/**
 * DNS over HTTP resolver.
 * Uses a list of servers to resolve DNS records with HTTP requests.
 */
class Resolver {
  /**
   * @class
   * @param {object} [properties]
   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.
   */
  constructor ({ maxCache = 100 } = {}) {
    this._cache = new Receptacle({ max: maxCache })
    this._servers = [
      'https://cloudflare-dns.com/dns-query',
      'https://dns.google/resolve'
    ]
  }

  /**
   * Get an array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   *
   * @returns {Array<string>}
   */
  getServers () {
    return this._servers
  }

  /**
   * Get a shuffled array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   *
   * @returns {Array<string>}
   */
  _getShuffledServers () {
    const newServers = [].concat(this._servers)

    for (let i = newServers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * i)
      const temp = newServers[i]
      newServers[i] = newServers[j]
      newServers[j] = temp
    }

    return newServers
  }

  /**
   * Sets the IP address and port of servers to be used when performing DNS resolution.
   *
   * @param {Array<string>} servers - array of RFC 5952 formatted addresses.
   */
  setServers (servers) {
    this._servers = servers
  }

  /**
   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.
   *
   * @param {string} hostname - host name to resolve.
   * @param {string} [rrType = 'A'] - resource record type.
   * @returns {Promise<*>}
   */
  resolve (hostname, rrType = 'A') {
    switch (rrType) {
      case 'A':
        return this.resolve4(hostname)
      case 'AAAA':
        return this.resolve6(hostname)
      case 'TXT':
        return this.resolveTxt(hostname)
      default:
        throw new Error(`${rrType} is not supported`)
    }
  }

  /**
   * Uses the DNS protocol to resolve the given host name into IPv4 addresses.
   *
   * @param {string} hostname - host name to resolve.
   * @returns {Promise<Array<string>>}
   */
  async resolve4 (hostname) {
    const recordType = 'A'
    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))
    if (cached) {
      return cached
    }

    for (const server of this._getShuffledServers()) {
      try {
        const response = await utils.fetch(utils.buildResource({
          serverResolver: server,
          hostname,
          recordType
        }))

        const d = await response.json()
        const data = d.Answer.map(a => a.data)
        const ttl = Math.min(d.Answer.map(a => a.TTL))

        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })

        return data
      } catch (err) {
        log.error(`${server} could not resolve ${hostname} record ${recordType}`)
      }
    }

    throw new Error(`Could not resolve ${hostname} record ${recordType}`)
  }

  /**
   * Uses the DNS protocol to resolve the given host name into IPv6 addresses.
   *
   * @param {string} hostname - host name to resolve.
   * @returns {Promise<Array<string>>}
   */
  async resolve6 (hostname) {
    const recordType = 'AAAA'
    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))
    if (cached) {
      return cached
    }

    for (const server of this._getShuffledServers()) {
      try {
        const response = await utils.fetch(utils.buildResource({
          serverResolver: server,
          hostname,
          recordType
        }))

        const d = await response.json()
        const data = d.Answer.map(a => a.data)
        const ttl = Math.min(d.Answer.map(a => a.TTL))

        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })

        return data
      } catch (err) {
        log.error(`${server} could not resolve ${hostname} record ${recordType}`)
      }
    }

    throw new Error(`Could not resolve ${hostname} record ${recordType}`)
  }

  /**
   * Uses the DNS protocol to resolve the given host name into a Text record.
   *
   * @param {string} hostname - host name to resolve.
   * @returns {Promise<Array<Array<string>>>}
   */
  async resolveTxt (hostname) {
    const recordType = 'TXT'
    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))
    if (cached) {
      return cached
    }

    for (const server of this._getShuffledServers()) {
      try {
        const response = await utils.fetch(utils.buildResource({
          serverResolver: server,
          hostname,
          recordType
        }))

        const d = await response.json()
        const data = d.Answer.map(a => [a.data.replace(/['"]+/g, '')])
        const ttl = Math.min(d.Answer.map(a => a.TTL))

        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })

        return data
      } catch (err) {
        log.error(`${server} could not resolve ${hostname} record ${recordType}`)
      }
    }

    throw new Error(`Could not resolve ${hostname} record ${recordType}`)
  }
}

Resolver.Resolver = Resolver
module.exports = Resolver

},{"debug":"node_modules/debug/src/browser.js","receptacle":"node_modules/receptacle/index.js","./utils":"node_modules/dns-over-http-resolver/src/utils.js"}],"node_modules/multiaddr/src/resolvers/dns.browser.js":[function(require,module,exports) {
'use strict'

/** @type {import('dns').promises.Resolver} */
// @ts-ignore - has no types
const dns = require('dns-over-http-resolver')

module.exports = dns

},{"dns-over-http-resolver":"node_modules/dns-over-http-resolver/src/index.js"}],"node_modules/multiaddr/src/resolvers/index.js":[function(require,module,exports) {
'use strict'

const protocols = require('../protocols-table')

const { code: dnsaddrCode } = protocols('dnsaddr')

/**
 * @typedef {import('..').Multiaddr} Multiaddr
 */

/**
 * Resolver for dnsaddr addresses.
 *
 * @param {Multiaddr} addr
 * @returns {Promise<string[]>}
 */
async function dnsaddrResolver (addr) {
  const Resolver = require('./dns')
  const resolver = new Resolver()

  const peerId = addr.getPeerId()
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) || []

  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`)
  let addresses = records.flat().map((a) => a.split('=')[1])

  if (peerId) {
    addresses = addresses.filter((entry) => entry.includes(peerId))
  }

  return addresses
}

module.exports = {
  dnsaddrResolver
}

},{"../protocols-table":"node_modules/multiaddr/src/protocols-table.js","./dns":"node_modules/multiaddr/src/resolvers/dns.browser.js"}],"node_modules/libp2p/src/constants.js":[function(require,module,exports) {
'use strict';

module.exports = {
  DIAL_TIMEOUT: 30e3,
  // How long in ms a dial attempt is allowed to take
  MAX_PARALLEL_DIALS: 100,
  // Maximum allowed concurrent dials
  MAX_PER_PEER_DIALS: 4,
  // Allowed parallel dials per DialRequest
  MAX_ADDRS_TO_DIAL: 25,
  // Maximum number of allowed addresses to attempt to dial
  METRICS: {
    computeThrottleMaxQueueSize: 1000,
    computeThrottleTimeout: 2000,
    movingAverageIntervals: [60 * 1000, // 1 minute
    5 * 60 * 1000, // 5 minutes
    15 * 60 * 1000 // 15 minutes
    ],
    maxOldPeersRetention: 50
  }
};
},{}],"node_modules/libp2p/package.json":[function(require,module,exports) {
module.exports = {
  "name": "libp2p",
  "version": "0.32.2",
  "description": "JavaScript implementation of libp2p, a modular peer to peer network stack",
  "leadMaintainer": "Jacob Heun <jacobheun@gmail.com>",
  "main": "src/index.js",
  "types": "dist/src/index.d.ts",
  "typesVersions": {
    "*": {
      "src/*": ["dist/src/*", "dist/src/*/index"]
    }
  },
  "files": ["dist", "src"],
  "scripts": {
    "lint": "aegir lint",
    "build": "aegir build",
    "build:proto": "npm run build:proto:circuit && npm run build:proto:identify && npm run build:proto:plaintext && npm run build:proto:address-book && npm run build:proto:proto-book && npm run build:proto:peer-record && npm run build:proto:envelope",
    "build:proto:circuit": "pbjs -t static-module -w commonjs -r libp2p-circuit --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/circuit/protocol/index.js ./src/circuit/protocol/index.proto",
    "build:proto:identify": "pbjs -t static-module -w commonjs -r libp2p-identify --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/identify/message.js ./src/identify/message.proto",
    "build:proto:plaintext": "pbjs -t static-module -w commonjs -r libp2p-plaintext --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/insecure/proto.js ./src/insecure/proto.proto",
    "build:proto:address-book": "pbjs -t static-module -w commonjs -r libp2p-address-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/address-book.js ./src/peer-store/persistent/pb/address-book.proto",
    "build:proto:proto-book": "pbjs -t static-module -w commonjs -r libp2p-proto-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/proto-book.js ./src/peer-store/persistent/pb/proto-book.proto",
    "build:proto:peer-record": "pbjs -t static-module -w commonjs -r libp2p-peer-record --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/peer-record/peer-record.js ./src/record/peer-record/peer-record.proto",
    "build:proto:envelope": "pbjs -t static-module -w commonjs -r libp2p-envelope --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/envelope/envelope.js ./src/record/envelope/envelope.proto",
    "build:proto-types": "npm run build:proto-types:circuit && npm run build:proto-types:identify && npm run build:proto-types:plaintext && npm run build:proto-types:address-book && npm run build:proto-types:proto-book && npm run build:proto-types:peer-record && npm run build:proto-types:envelope",
    "build:proto-types:circuit": "pbts -o src/circuit/protocol/index.d.ts src/circuit/protocol/index.js",
    "build:proto-types:identify": "pbts -o src/identify/message.d.ts src/identify/message.js",
    "build:proto-types:plaintext": "pbts -o src/insecure/proto.d.ts src/insecure/proto.js",
    "build:proto-types:address-book": "pbts -o src/peer-store/persistent/pb/address-book.d.ts src/peer-store/persistent/pb/address-book.js",
    "build:proto-types:proto-book": "pbts -o src/peer-store/persistent/pb/proto-book.d.ts src/peer-store/persistent/pb/proto-book.js",
    "build:proto-types:peer-record": "pbts -o src/record/peer-record/peer-record.d.ts src/record/peer-record/peer-record.js",
    "build:proto-types:envelope": "pbts -o src/record/envelope/envelope.d.ts src/record/envelope/envelope.js",
    "test": "aegir test",
    "test:ts": "aegir build --no-bundle && npm run test --prefix test/ts-use",
    "test:node": "aegir test -t node -f \"./test/**/*.{node,spec}.js\"",
    "test:browser": "aegir test -t browser",
    "test:examples": "cd examples && npm run test:all",
    "prepare": "aegir build --no-bundle",
    "release": "aegir release -t node -t browser",
    "release-minor": "aegir release --type minor -t node -t browser",
    "release-major": "aegir release --type major -t node -t browser",
    "coverage": "nyc --reporter=text --reporter=lcov npm run test:node"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/libp2p/js-libp2p.git"
  },
  "keywords": ["libp2p", "network", "p2p", "peer", "peer-to-peer", "IPFS"],
  "bugs": {
    "url": "https://github.com/libp2p/js-libp2p/issues"
  },
  "homepage": "https://libp2p.io",
  "license": "MIT",
  "engines": {
    "node": ">=14.0.0"
  },
  "browser": {
    "@motrix/nat-api": false
  },
  "eslintConfig": {
    "extends": "ipfs",
    "ignorePatterns": ["!.aegir.js", "test/ts-use"]
  },
  "dependencies": {
    "@motrix/nat-api": "^0.3.1",
    "@vascosantos/moving-average": "^1.1.0",
    "abort-controller": "^3.0.0",
    "aggregate-error": "^3.1.0",
    "any-signal": "^2.1.1",
    "bignumber.js": "^9.0.1",
    "class-is": "^1.1.0",
    "debug": "^4.3.1",
    "err-code": "^3.0.0",
    "es6-promisify": "^6.1.1",
    "events": "^3.3.0",
    "hashlru": "^2.3.0",
    "interface-datastore": "^5.1.1",
    "it-all": "^1.0.4",
    "it-buffer": "^0.1.2",
    "it-drain": "^1.0.3",
    "it-filter": "^1.0.1",
    "it-first": "^1.0.4",
    "it-handshake": "^2.0.0",
    "it-length-prefixed": "^5.0.2",
    "it-map": "^1.0.4",
    "it-merge": "^1.0.0",
    "it-pipe": "^1.1.0",
    "it-take": "^1.0.0",
    "libp2p-crypto": "^0.19.4",
    "libp2p-interfaces": "^1.0.0",
    "libp2p-utils": "^0.4.0",
    "mafmt": "^10.0.0",
    "merge-options": "^3.0.4",
    "multiaddr": "^10.0.0",
    "multiformats": "^9.0.0",
    "multistream-select": "^2.0.0",
    "mutable-proxy": "^1.0.0",
    "node-forge": "^0.10.0",
    "p-any": "^3.0.0",
    "p-fifo": "^1.0.0",
    "p-retry": "^4.4.0",
    "p-settle": "^4.1.1",
    "peer-id": "^0.15.0",
    "private-ip": "^2.1.0",
    "protobufjs": "^6.10.2",
    "retimer": "^3.0.0",
    "sanitize-filename": "^1.6.3",
    "set-delayed-interval": "^1.0.0",
    "streaming-iterables": "^6.0.0",
    "timeout-abort-controller": "^1.1.1",
    "varint": "^6.0.0",
    "wherearewe": "^1.0.0",
    "xsalsa20": "^1.1.0"
  },
  "devDependencies": {
    "@nodeutils/defaults-deep": "^1.1.0",
    "@types/es6-promisify": "^6.0.0",
    "@types/node": "^16.0.1",
    "@types/node-forge": "^0.10.1",
    "@types/varint": "^6.0.0",
    "abortable-iterator": "^3.0.0",
    "aegir": "^33.1.1",
    "buffer": "^6.0.3",
    "delay": "^5.0.0",
    "interop-libp2p": "^0.4.0",
    "into-stream": "^6.0.0",
    "ipfs-http-client": "^50.1.1",
    "it-concat": "^2.0.0",
    "it-pair": "^1.0.0",
    "it-pushable": "^1.4.0",
    "libp2p": ".",
    "libp2p-bootstrap": "^0.13.0",
    "libp2p-delegated-content-routing": "^0.11.0",
    "libp2p-delegated-peer-routing": "^0.10.0",
    "libp2p-floodsub": "^0.27.0",
    "libp2p-gossipsub": "^0.10.0",
    "libp2p-interfaces-compliance-tests": "^1.0.0",
    "libp2p-kad-dht": "^0.23.0",
    "libp2p-mdns": "^0.17.0",
    "libp2p-mplex": "^0.10.1",
    "libp2p-noise": "^4.0.0",
    "libp2p-tcp": "^0.17.0",
    "libp2p-webrtc-star": "^0.23.0",
    "libp2p-websockets": "^0.16.0",
    "multihashes": "^4.0.2",
    "nock": "^13.0.3",
    "p-defer": "^3.0.0",
    "p-times": "^3.0.0",
    "p-wait-for": "^3.2.0",
    "rimraf": "^3.0.2",
    "sinon": "^11.1.1",
    "uint8arrays": "^2.1.3",
    "util": "^0.12.3"
  },
  "contributors": ["Vasco Santos <vasco.santos@moxy.studio>", "David Dias <daviddias.p@gmail.com>", "Jacob Heun <jacobheun@gmail.com>", "Alex Potsides <alex@achingbrain.net>", "Alan Shaw <alan@tableflip.io>", "Cayman <caymannava@gmail.com>", "Pedro Teixeira <i@pgte.me>", "Friedel Ziegelmayer <dignifiedquire@gmail.com>", "Maciej Krüger <mkg20001@gmail.com>", "Hugo Dias <mail@hugodias.me>", "Volker Mische <volker.mische@gmail.com>", "Chris Dostert <chrisdostert@users.noreply.github.com>", "dirkmc <dirkmdev@gmail.com>", "Richard Littauer <richard.littauer@gmail.com>", "zeim839 <50573884+zeim839@users.noreply.github.com>", "Ryan Bell <ryan@piing.net>", "a1300 <matthias-knopp@gmx.net>", "ᴠɪᴄᴛᴏʀ ʙᴊᴇʟᴋʜᴏʟᴍ <victorbjelkholm@gmail.com>", "Andrew Nesbitt <andrewnez@gmail.com>", "Elven <mon.samuel@qq.com>", "Franck Royer <franck@royer.one>", "Giovanni T. Parra <fiatjaf@gmail.com>", "Samlior <samlior@foxmail.com>", "Thomas Eizinger <thomas@eizinger.io>", "acolytec3 <17355484+acolytec3@users.noreply.github.com>", "Didrik Nordström <didrik@betamos.se>", "Irakli Gozalishvili <rfobic@gmail.com>", "Joel Gustafson <joelg@mit.edu>", "John Rees <johnrees@users.noreply.github.com>", "João Santos <joaosantos15@users.noreply.github.com>", "Julien Bouquillon <contact@revolunet.com>", "Kevin Kwok <antimatter15@gmail.com>", "Kevin Lacker <lacker@gmail.com>", "Lars Gierth <lgierth@users.noreply.github.com>", "Ethan Lam <elmemphis2000@gmail.com>", "Marcin Tojek <mtojek@users.noreply.github.com>", "Michael Burns <5170+mburns@users.noreply.github.com>", "Miguel Mota <miguelmota2@gmail.com>", "Nuno Nogueira <nunofmn@gmail.com>", "Dmitriy Ryajov <dryajov@gmail.com>", "Philipp Muens <raute1337@gmx.de>", "RasmusErik Voel Jensen <github@solsort.com>", "Diogo Silva <fsdiogo@gmail.com>", "Robert Kiel <robert.kiel@hoprnet.org>", "phillmac <phillmac@users.noreply.github.com>", "robertkiel <robert.kiel@validitylabs.org>", "Smite Chow <xiaopengyou@live.com>", "Soeren <nikorpoulsen@gmail.com>", "Sönke Hahn <soenkehahn@gmail.com>", "TJKoury <TJKoury@gmail.com>", "shresthagrawal <34920931+shresthagrawal@users.noreply.github.com>", "Tiago Alves <alvesjtiago@gmail.com>", "Daijiro Wachi <daijiro.wachi@gmail.com>", "Yusef Napora <yusef@napora.org>", "Zane Starr <zcstarr@gmail.com>", "swedneck <40505480+swedneck@users.noreply.github.com>", "Aleksei <vozhdb@gmail.com>", "Cindy Wu <ciindy.wu@gmail.com>", "Aditya Bose <13054902+adbose@users.noreply.github.com>", "Chris Bratlien <chrisbratlien@gmail.com>", "ebinks <elizabethjbinks@gmail.com>", "greenSnot <greenSnot@users.noreply.github.com>", "Bernd Strehl <bernd.strehl@gmail.com>", "Francis Gulotta <wizard@roborooter.com>", "isan_rivkin <isanrivkin@gmail.com>", "Florian-Merle <florian.david.merle@gmail.com>", "mayerwin <mayerwin@users.noreply.github.com>", "Guy Sviry <32539816+guysv@users.noreply.github.com>", "Henrique Dias <hacdias@gmail.com>", "mcclure <andi.m.mcclure@gmail.com>", "Felipe Martins <felipebrasil93@gmail.com>", "Fei Liu <liu.feiwood@gmail.com>"]
};
},{}],"node_modules/libp2p/src/identify/consts.js":[function(require,module,exports) {
'use strict'; // @ts-ignore file not listed within the file list of projects

var libp2pVersion = require('../../package.json').version;

module.exports.PROTOCOL_VERSION = 'ipfs/0.1.0'; // deprecated

module.exports.AGENT_VERSION = "js-libp2p/".concat(libp2pVersion);
module.exports.MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0'; // deprecated

module.exports.MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0'; // deprecated

module.exports.IDENTIFY_PROTOCOL_VERSION = '0.1.0';
module.exports.MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id';
module.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push';
module.exports.MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0';
module.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0';
},{"../../package.json":"node_modules/libp2p/package.json"}],"node_modules/libp2p/src/circuit/constants.js":[function(require,module,exports) {
'use strict';

var minute = 60 * 1000;
module.exports = {
  ADVERTISE_BOOT_DELAY: 15 * minute,
  // Delay before HOP relay service is advertised on the network
  ADVERTISE_TTL: 30 * minute,
  // Delay Between HOP relay service advertisements on the network
  CIRCUIT_PROTO_CODE: 290,
  // Multicodec code
  HOP_METADATA_KEY: 'hop_relay',
  // PeerStore metadaBook key for HOP relay service
  HOP_METADATA_VALUE: 'true',
  // PeerStore metadaBook value for HOP relay service
  RELAY_RENDEZVOUS_NS: '/libp2p/relay' // Relay HOP relay service namespace for discovery

};
},{}],"node_modules/netmask/lib/netmask.js":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function () {
  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;

  long2ip = function (long) {
    var a, b, c, d;
    a = (long & 0xff << 24) >>> 24;
    b = (long & 0xff << 16) >>> 16;
    c = (long & 0xff << 8) >>> 8;
    d = long & 0xff;
    return [a, b, c, d].join('.');
  };

  ip2long = function (ip) {
    var b, c, i, j, n, ref;
    b = [];

    for (i = j = 0; j <= 3; i = ++j) {
      if (ip.length === 0) {
        break;
      }

      if (i > 0) {
        if (ip[0] !== '.') {
          throw new Error('Invalid IP');
        }

        ip = ip.substring(1);
      }

      ref = atob(ip), n = ref[0], c = ref[1];
      ip = ip.substring(c);
      b.push(n);
    }

    if (ip.length !== 0) {
      throw new Error('Invalid IP');
    }

    switch (b.length) {
      case 1:
        if (b[0] > 0xFFFFFFFF) {
          throw new Error('Invalid IP');
        }

        return b[0] >>> 0;

      case 2:
        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {
          throw new Error('Invalid IP');
        }

        return (b[0] << 24 | b[1]) >>> 0;

      case 3:
        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {
          throw new Error('Invalid IP');
        }

        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;

      case 4:
        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {
          throw new Error('Invalid IP');
        }

        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;

      default:
        throw new Error('Invalid IP');
    }
  };

  chr = function (b) {
    return b.charCodeAt(0);
  };

  chr0 = chr('0');
  chra = chr('a');
  chrA = chr('A');

  atob = function (s) {
    var base, dmax, i, n, start;
    n = 0;
    base = 10;
    dmax = '9';
    i = 0;

    if (s.length > 1 && s[i] === '0') {
      if (s[i + 1] === 'x' || s[i + 1] === 'X') {
        i += 2;
        base = 16;
      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {
        i++;
        base = 8;
        dmax = '7';
      }
    }

    start = i;

    while (i < s.length) {
      if ('0' <= s[i] && s[i] <= dmax) {
        n = n * base + (chr(s[i]) - chr0) >>> 0;
      } else if (base === 16) {
        if ('a' <= s[i] && s[i] <= 'f') {
          n = n * base + (10 + chr(s[i]) - chra) >>> 0;
        } else if ('A' <= s[i] && s[i] <= 'F') {
          n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }

      if (n > 0xFFFFFFFF) {
        throw new Error('too large');
      }

      i++;
    }

    if (i === start) {
      throw new Error('empty octet');
    }

    return [n, i];
  };

  Netmask = function () {
    function Netmask(net, mask) {
      var error, i, j, ref;

      if (typeof net !== 'string') {
        throw new Error("Missing `net' parameter");
      }

      if (!mask) {
        ref = net.split('/', 2), net = ref[0], mask = ref[1];
      }

      if (!mask) {
        mask = 32;
      }

      if (typeof mask === 'string' && mask.indexOf('.') > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          error = error1;
          throw new Error("Invalid mask: " + mask);
        }

        for (i = j = 32; j >= 0; i = --j) {
          if (this.maskLong === 0xffffffff << 32 - i >>> 0) {
            this.bitmask = i;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;

        if (this.bitmask > 0) {
          this.maskLong = 0xffffffff << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }

      try {
        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
      } catch (error1) {
        error = error1;
        throw new Error("Invalid net address: " + net);
      }

      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }

      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }

    Netmask.prototype.contains = function (ip) {
      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {
        ip = new Netmask(ip);
      }

      if (ip instanceof Netmask) {
        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
      } else {
        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };

    Netmask.prototype.next = function (count) {
      if (count == null) {
        count = 1;
      }

      return new Netmask(long2ip(this.netLong + this.size * count), this.mask);
    };

    Netmask.prototype.forEach = function (fn) {
      var index, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index = 0;

      while (long <= lastLong) {
        fn(long2ip(long), long, index);
        index++;
        long++;
      }
    };

    Netmask.prototype.toString = function () {
      return this.base + "/" + this.bitmask;
    };

    return Netmask;
  }();

  exports.ip2long = ip2long;
  exports.long2ip = long2ip;
  exports.Netmask = Netmask;
}).call(this);
},{}],"node_modules/private-ip/lib/index.js":[function(require,module,exports) {
const Netmask = require('netmask').Netmask;
const ip_regex = require('ip-regex');

const PRIVATE_IP_RANGES = ['0.0.0.0/8', '10.0.0.0/8', '100.64.0.0/10', '127.0.0.0/8', '169.254.0.0/16', '172.16.0.0/12', '192.0.0.0/24', '192.0.0.0/29', '192.0.0.8/32', '192.0.0.9/32', '192.0.0.10/32', '192.0.0.170/32', '192.0.0.171/32', '192.0.2.0/24', '192.31.196.0/24', '192.52.193.0/24', '192.88.99.0/24', '192.168.0.0/16', '192.175.48.0/24', '198.18.0.0/15', '198.51.100.0/24', '203.0.113.0/24', '240.0.0.0/4', '255.255.255.255/32'];

const NETMASK_RANGES = PRIVATE_IP_RANGES.map(ip_range => new Netmask(ip_range));

function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr)) return true;
  }

  return false;
}

function ipv6_check(ip_addr) {
  return (/^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr)
  );
}

module.exports = ip_addr => {
  if (ip_regex.v6().test(ip_addr)) return ipv6_check(ip_addr);else if (ip_regex().test(ip_addr) || ip_addr.startsWith('0')) return ipv4_check(ip_addr);

  return false;
};
},{"netmask":"node_modules/netmask/lib/netmask.js","ip-regex":"node_modules/ip-regex/index.js"}],"node_modules/private-ip/index.js":[function(require,module,exports) {
'use strict'

module.exports = require('./lib')

},{"./lib":"node_modules/private-ip/lib/index.js"}],"node_modules/libp2p-utils/src/multiaddr/is-private.js":[function(require,module,exports) {
'use strict'

// @ts-ignore private-ip does not publish types
const isIpPrivate = require('private-ip')

/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * Check if a given multiaddr has a private address.
 *
 * @param {Multiaddr} ma
 * @returns {boolean}
 */
function isPrivate (ma) {
  const { address } = ma.nodeAddress()

  return isIpPrivate(address)
}

module.exports = isPrivate

},{"private-ip":"node_modules/private-ip/index.js"}],"node_modules/libp2p-utils/src/address-sort.js":[function(require,module,exports) {
'use strict'

const isPrivate = require('./multiaddr/is-private')

/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @typedef {Object} Address
 * @property {Multiaddr} multiaddr peer multiaddr.
 * @property {boolean} isCertified obtained from a signed peer record.
 */

/**
 * Compare function for array.sort().
 * This sort aims to move the private adresses to the end of the array.
 * In case of equality, a certified address will come first.
 *
 * @param {Address} a
 * @param {Address} b
 * @returns {number}
 */
function addressesPublicFirstCompareFunction (a, b) {
  const isAPrivate = isPrivate(a.multiaddr)
  const isBPrivate = isPrivate(b.multiaddr)

  if (isAPrivate && !isBPrivate) {
    return 1
  } else if (!isAPrivate && isBPrivate) {
    return -1
  }
  // Check certified?
  if (a.isCertified && !b.isCertified) {
    return -1
  } else if (!a.isCertified && b.isCertified) {
    return 1
  }

  return 0
}

/**
 * Sort given addresses by putting public addresses first.
 * In case of equality, a certified address will come first.
 *
 * @param {Array<Address>} addresses
 * @returns {Array<Address>}
 */
function publicAddressesFirst (addresses) {
  return [...addresses].sort(addressesPublicFirstCompareFunction)
}

module.exports.publicAddressesFirst = publicAddressesFirst

},{"./multiaddr/is-private":"node_modules/libp2p-utils/src/multiaddr/is-private.js"}],"node_modules/p-reflect/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var pReflect = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(promise) {
    var value;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return promise;

          case 3:
            value = _context.sent;
            return _context.abrupt("return", {
              isFulfilled: true,
              isRejected: false,
              value: value
            });

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            return _context.abrupt("return", {
              isFulfilled: false,
              isRejected: true,
              reason: _context.t0
            });

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));

  return function pReflect(_x) {
    return _ref.apply(this, arguments);
  };
}();

module.exports = pReflect; // TODO: Remove this for the next major release

module.exports.default = pReflect;
},{}],"node_modules/p-try/index.js":[function(require,module,exports) {
'use strict';

var pTry = function (fn) {
  for (var _len = arguments.length, arguments_ = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    arguments_[_key - 1] = arguments[_key];
  }

  return new Promise(function (resolve) {
    resolve(fn.apply(void 0, arguments_));
  });
};

module.exports = pTry; // TODO: remove this in the next major version

module.exports.default = pTry;
},{}],"node_modules/p-limit/index.js":[function(require,module,exports) {
'use strict';

var pTry = require('p-try');

var pLimit = function (concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
  }

  var queue = [];
  var activeCount = 0;

  var next = function () {
    activeCount--;

    if (queue.length > 0) {
      queue.shift()();
    }
  };

  var run = function (fn, resolve) {
    activeCount++;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var result = pTry.apply(void 0, [fn].concat(args));
    resolve(result);
    result.then(next, next);
  };

  var enqueue = function (fn, resolve) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    if (activeCount < concurrency) {
      run.apply(void 0, [fn, resolve].concat(args));
    } else {
      queue.push(run.bind.apply(run, [null, fn, resolve].concat(args)));
    }
  };

  var generator = function (fn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return new Promise(function (resolve) {
      return enqueue.apply(void 0, [fn, resolve].concat(args));
    });
  };

  Object.defineProperties(generator, {
    activeCount: {
      get: function () {
        return activeCount;
      }
    },
    pendingCount: {
      get: function () {
        return queue.length;
      }
    },
    clearQueue: {
      value: function () {
        queue.length = 0;
      }
    }
  });
  return generator;
};

module.exports = pLimit;
module.exports.default = pLimit;
},{"p-try":"node_modules/p-try/index.js"}],"node_modules/p-settle/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var pReflect = require('p-reflect');

var pLimit = require('p-limit');

module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(array) {
    var options,
        _options$concurrency,
        concurrency,
        limit,
        _args = arguments;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            _options$concurrency = options.concurrency, concurrency = _options$concurrency === void 0 ? Infinity : _options$concurrency;
            limit = pLimit(concurrency);
            return _context.abrupt("return", Promise.all(array.map(function (element) {
              if (element && typeof element.then === 'function') {
                // eslint-disable-line promise/prefer-await-to-then
                return pReflect(element);
              }

              if (typeof element === 'function') {
                return pReflect(limit(function () {
                  return element();
                }));
              }

              return pReflect(Promise.resolve(element));
            })));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
},{"p-reflect":"node_modules/p-reflect/index.js","p-limit":"node_modules/p-limit/index.js"}],"node_modules/libp2p/src/record/envelope/envelope.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-envelope"] || ($protobuf.roots["libp2p-envelope"] = {});

$root.Envelope = function () {
  /**
   * Properties of an Envelope.
   * @exports IEnvelope
   * @interface IEnvelope
   * @property {Uint8Array|null} [publicKey] Envelope publicKey
   * @property {Uint8Array|null} [payloadType] Envelope payloadType
   * @property {Uint8Array|null} [payload] Envelope payload
   * @property {Uint8Array|null} [signature] Envelope signature
   */

  /**
   * Constructs a new Envelope.
   * @exports Envelope
   * @classdesc Represents an Envelope.
   * @implements IEnvelope
   * @constructor
   * @param {IEnvelope=} [p] Properties to set
   */
  function Envelope(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Envelope publicKey.
   * @member {Uint8Array} publicKey
   * @memberof Envelope
   * @instance
   */


  Envelope.prototype.publicKey = $util.newBuffer([]);
  /**
   * Envelope payloadType.
   * @member {Uint8Array} payloadType
   * @memberof Envelope
   * @instance
   */

  Envelope.prototype.payloadType = $util.newBuffer([]);
  /**
   * Envelope payload.
   * @member {Uint8Array} payload
   * @memberof Envelope
   * @instance
   */

  Envelope.prototype.payload = $util.newBuffer([]);
  /**
   * Envelope signature.
   * @member {Uint8Array} signature
   * @memberof Envelope
   * @instance
   */

  Envelope.prototype.signature = $util.newBuffer([]);
  /**
   * Encodes the specified Envelope message. Does not implicitly {@link Envelope.verify|verify} messages.
   * @function encode
   * @memberof Envelope
   * @static
   * @param {IEnvelope} m Envelope message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Envelope.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey")) w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType")) w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload")) w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature")) w.uint32(42).bytes(m.signature);
    return w;
  };
  /**
   * Decodes an Envelope message from the specified reader or buffer.
   * @function decode
   * @memberof Envelope
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Envelope} Envelope
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Envelope.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Envelope();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;

        case 2:
          m.payloadType = r.bytes();
          break;

        case 3:
          m.payload = r.bytes();
          break;

        case 5:
          m.signature = r.bytes();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Envelope
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Envelope} Envelope
   */


  Envelope.fromObject = function fromObject(d) {
    if (d instanceof $root.Envelope) return d;
    var m = new $root.Envelope();

    if (d.publicKey != null) {
      if (typeof d.publicKey === "string") $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);else if (d.publicKey.length) m.publicKey = d.publicKey;
    }

    if (d.payloadType != null) {
      if (typeof d.payloadType === "string") $util.base64.decode(d.payloadType, m.payloadType = $util.newBuffer($util.base64.length(d.payloadType)), 0);else if (d.payloadType.length) m.payloadType = d.payloadType;
    }

    if (d.payload != null) {
      if (typeof d.payload === "string") $util.base64.decode(d.payload, m.payload = $util.newBuffer($util.base64.length(d.payload)), 0);else if (d.payload.length) m.payload = d.payload;
    }

    if (d.signature != null) {
      if (typeof d.signature === "string") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;
    }

    return m;
  };
  /**
   * Creates a plain object from an Envelope message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Envelope
   * @static
   * @param {Envelope} m Envelope
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Envelope.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      if (o.bytes === String) d.publicKey = "";else {
        d.publicKey = [];
        if (o.bytes !== Array) d.publicKey = $util.newBuffer(d.publicKey);
      }
      if (o.bytes === String) d.payloadType = "";else {
        d.payloadType = [];
        if (o.bytes !== Array) d.payloadType = $util.newBuffer(d.payloadType);
      }
      if (o.bytes === String) d.payload = "";else {
        d.payload = [];
        if (o.bytes !== Array) d.payload = $util.newBuffer(d.payload);
      }
      if (o.bytes === String) d.signature = "";else {
        d.signature = [];
        if (o.bytes !== Array) d.signature = $util.newBuffer(d.signature);
      }
    }

    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }

    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }

    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }

    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }

    return d;
  };
  /**
   * Converts this Envelope to JSON.
   * @function toJSON
   * @memberof Envelope
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Envelope.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return Envelope;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p/src/record/envelope/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var errCode = require('err-code');

var uint8arraysConcat = require('uint8arrays/concat');

var uint8arraysFromString = require('uint8arrays/from-string'); // @ts-ignore libp2p-crypto does not support types


var cryptoKeys = require('libp2p-crypto/src/keys');

var PeerId = require('peer-id');

var varint = require('varint');

var uint8arraysEquals = require('uint8arrays/equals');

var _require = require('../../errors'),
    codes = _require.codes;

var _require2 = require('./envelope'),
    Protobuf = _require2.Envelope;
/**
 * @typedef {import('libp2p-interfaces/src/record/types').Record} Record
 */


var Envelope = /*#__PURE__*/function () {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   *
   * @class
   * @param {object} params
   * @param {PeerId} params.peerId
   * @param {Uint8Array} params.payloadType
   * @param {Uint8Array} params.payload - marshaled record
   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.
   */
  function Envelope(_ref) {
    var peerId = _ref.peerId,
        payloadType = _ref.payloadType,
        payload = _ref.payload,
        signature = _ref.signature;

    _classCallCheck(this, Envelope);

    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature; // Cache

    this._marshal = undefined;
  }
  /**
   * Marshal the envelope content.
   *
   * @returns {Uint8Array}
   */


  _createClass(Envelope, [{
    key: "marshal",
    value: function marshal() {
      if (this._marshal) {
        return this._marshal;
      }

      var publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);
      this._marshal = Protobuf.encode({
        publicKey: publicKey,
        payloadType: this.payloadType,
        payload: this.payload,
        signature: this.signature
      }).finish();
      return this._marshal;
    }
    /**
     * Verifies if the other Envelope is identical to this one.
     *
     * @param {Envelope} other
     * @returns {boolean}
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);
    }
    /**
     * Validate envelope data signature for the given domain.
     *
     * @param {string} domain
     * @returns {Promise<boolean>}
     */

  }, {
    key: "validate",
    value: function validate(domain) {
      var signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      return this.peerId.pubKey.verify(signData, this.signature);
    }
  }]);

  return Envelope;
}();
/**
 * Helper function that prepares a Uint8Array to sign or verify a signature.
 *
 * @param {string} domain
 * @param {Uint8Array} payloadType
 * @param {Uint8Array} payload
 * @returns {Uint8Array}
 */


var formatSignaturePayload = function formatSignaturePayload(domain, payloadType, payload) {
  // When signing, a peer will prepare a Uint8Array by concatenating the following:
  // - The length of the domain separation string string in bytes
  // - The domain separation string, encoded as UTF-8
  // - The length of the payload_type field in bytes
  // - The value of the payload_type field
  // - The length of the payload field in bytes
  // - The value of the payload field
  var domainUint8Array = uint8arraysFromString(domain);
  var domainLength = varint.encode(domainUint8Array.byteLength);
  var payloadTypeLength = varint.encode(payloadType.length);
  var payloadLength = varint.encode(payload.length);
  return uint8arraysConcat([new Uint8Array(domainLength), domainUint8Array, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);
};
/**
 * Unmarshal a serialized Envelope protobuf message.
 *
 * @param {Uint8Array} data
 * @returns {Promise<Envelope>}
 */


Envelope.createFromProtobuf = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data) {
    var envelopeData, peerId;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            envelopeData = Protobuf.decode(data);
            _context.next = 3;
            return PeerId.createFromPubKey(envelopeData.publicKey);

          case 3:
            peerId = _context.sent;
            return _context.abrupt("return", new Envelope({
              peerId: peerId,
              payloadType: envelopeData.payloadType,
              payload: envelopeData.payload,
              signature: envelopeData.signature
            }));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key.
 *
 * @async
 * @param {Record} record
 * @param {PeerId} peerId
 * @returns {Promise<Envelope>}
 */


Envelope.seal = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(record, peerId) {
    var domain, payloadType, payload, signData, signature;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            domain = record.domain;
            payloadType = record.codec;
            payload = record.marshal();
            signData = formatSignaturePayload(domain, payloadType, payload);
            _context2.next = 6;
            return peerId.privKey.sign(signData);

          case 6:
            signature = _context2.sent;
            return _context2.abrupt("return", new Envelope({
              peerId: peerId,
              payloadType: payloadType,
              payload: payload,
              signature: signature
            }));

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Open and certify a given marshalled envelope.
 * Data is unmarshalled and the signature validated for the given domain.
 *
 * @param {Uint8Array} data
 * @param {string} domain
 * @returns {Promise<Envelope>}
 */


Envelope.openAndCertify = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(data, domain) {
    var envelope, valid;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return Envelope.createFromProtobuf(data);

          case 2:
            envelope = _context3.sent;
            _context3.next = 5;
            return envelope.validate(domain);

          case 5:
            valid = _context3.sent;

            if (valid) {
              _context3.next = 8;
              break;
            }

            throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);

          case 8:
            return _context3.abrupt("return", envelope);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();

module.exports = Envelope;
},{"err-code":"node_modules/err-code/index.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","libp2p-crypto/src/keys":"node_modules/libp2p-crypto/src/keys/index.js","peer-id":"node_modules/peer-id/src/index.js","varint":"node_modules/varint/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","../../errors":"node_modules/libp2p/src/errors.js","./envelope":"node_modules/libp2p/src/record/envelope/envelope.js"}],"node_modules/libp2p-utils/src/array-equals.js":[function(require,module,exports) {
'use strict'

/**
 * Verify if two arrays of non primitive types with the "equals" function are equal.
 * Compatible with multiaddr, peer-id and others.
 *
 * @param {Array<*>} a
 * @param {Array<*>} b
 * @returns {boolean}
 */
function arrayEquals (a, b) {
  return a.length === b.length && b.sort() && a.sort().every((item, index) => b[index].equals(item))
}

module.exports = arrayEquals

},{}],"node_modules/libp2p/src/record/peer-record/peer-record.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-peer-record"] || ($protobuf.roots["libp2p-peer-record"] = {});

$root.PeerRecord = function () {
  /**
   * Properties of a PeerRecord.
   * @exports IPeerRecord
   * @interface IPeerRecord
   * @property {Uint8Array|null} [peerId] PeerRecord peerId
   * @property {number|null} [seq] PeerRecord seq
   * @property {Array.<PeerRecord.IAddressInfo>|null} [addresses] PeerRecord addresses
   */

  /**
   * Constructs a new PeerRecord.
   * @exports PeerRecord
   * @classdesc Represents a PeerRecord.
   * @implements IPeerRecord
   * @constructor
   * @param {IPeerRecord=} [p] Properties to set
   */
  function PeerRecord(p) {
    this.addresses = [];
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * PeerRecord peerId.
   * @member {Uint8Array} peerId
   * @memberof PeerRecord
   * @instance
   */


  PeerRecord.prototype.peerId = $util.newBuffer([]);
  /**
   * PeerRecord seq.
   * @member {number} seq
   * @memberof PeerRecord
   * @instance
   */

  PeerRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  /**
   * PeerRecord addresses.
   * @member {Array.<PeerRecord.IAddressInfo>} addresses
   * @memberof PeerRecord
   * @instance
   */

  PeerRecord.prototype.addresses = $util.emptyArray;
  /**
   * Encodes the specified PeerRecord message. Does not implicitly {@link PeerRecord.verify|verify} messages.
   * @function encode
   * @memberof PeerRecord
   * @static
   * @param {IPeerRecord} m PeerRecord message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  PeerRecord.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId")) w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq")) w.uint32(16).uint64(m.seq);

    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i) {
        $root.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
      }
    }

    return w;
  };
  /**
   * Decodes a PeerRecord message from the specified reader or buffer.
   * @function decode
   * @memberof PeerRecord
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {PeerRecord} PeerRecord
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  PeerRecord.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.PeerRecord();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;

        case 2:
          m.seq = r.uint64();
          break;

        case 3:
          if (!(m.addresses && m.addresses.length)) m.addresses = [];
          m.addresses.push($root.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a PeerRecord message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof PeerRecord
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {PeerRecord} PeerRecord
   */


  PeerRecord.fromObject = function fromObject(d) {
    if (d instanceof $root.PeerRecord) return d;
    var m = new $root.PeerRecord();

    if (d.peerId != null) {
      if (typeof d.peerId === "string") $util.base64.decode(d.peerId, m.peerId = $util.newBuffer($util.base64.length(d.peerId)), 0);else if (d.peerId.length) m.peerId = d.peerId;
    }

    if (d.seq != null) {
      if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === "string") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === "number") m.seq = d.seq;else if (_typeof(d.seq) === "object") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }

    if (d.addresses) {
      if (!Array.isArray(d.addresses)) throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];

      for (var i = 0; i < d.addresses.length; ++i) {
        if (_typeof(d.addresses[i]) !== "object") throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i] = $root.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
      }
    }

    return m;
  };
  /**
   * Creates a plain object from a PeerRecord message. Also converts values to other types if specified.
   * @function toObject
   * @memberof PeerRecord
   * @static
   * @param {PeerRecord} m PeerRecord
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  PeerRecord.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.arrays || o.defaults) {
      d.addresses = [];
    }

    if (o.defaults) {
      if (o.bytes === String) d.peerId = "";else {
        d.peerId = [];
        if (o.bytes !== Array) d.peerId = $util.newBuffer(d.peerId);
      }

      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else d.seq = o.longs === String ? "0" : 0;
    }

    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }

    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }

    if (m.addresses && m.addresses.length) {
      d.addresses = [];

      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }

    return d;
  };
  /**
   * Converts this PeerRecord to JSON.
   * @function toJSON
   * @memberof PeerRecord
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  PeerRecord.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  PeerRecord.AddressInfo = function () {
    /**
     * Properties of an AddressInfo.
     * @memberof PeerRecord
     * @interface IAddressInfo
     * @property {Uint8Array|null} [multiaddr] AddressInfo multiaddr
     */

    /**
     * Constructs a new AddressInfo.
     * @memberof PeerRecord
     * @classdesc Represents an AddressInfo.
     * @implements IAddressInfo
     * @constructor
     * @param {PeerRecord.IAddressInfo=} [p] Properties to set
     */
    function AddressInfo(p) {
      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
      }
    }
    /**
     * AddressInfo multiaddr.
     * @member {Uint8Array} multiaddr
     * @memberof PeerRecord.AddressInfo
     * @instance
     */


    AddressInfo.prototype.multiaddr = $util.newBuffer([]);
    /**
     * Encodes the specified AddressInfo message. Does not implicitly {@link PeerRecord.AddressInfo.verify|verify} messages.
     * @function encode
     * @memberof PeerRecord.AddressInfo
     * @static
     * @param {PeerRecord.IAddressInfo} m AddressInfo message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */

    AddressInfo.encode = function encode(m, w) {
      if (!w) w = $Writer.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr")) w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    /**
     * Decodes an AddressInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PeerRecord.AddressInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {PeerRecord.AddressInfo} AddressInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */


    AddressInfo.decode = function decode(r, l) {
      if (!(r instanceof $Reader)) r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l,
          m = new $root.PeerRecord.AddressInfo();

      while (r.pos < c) {
        var t = r.uint32();

        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;

          default:
            r.skipType(t & 7);
            break;
        }
      }

      return m;
    };
    /**
     * Creates an AddressInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerRecord.AddressInfo
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {PeerRecord.AddressInfo} AddressInfo
     */


    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root.PeerRecord.AddressInfo) return d;
      var m = new $root.PeerRecord.AddressInfo();

      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;
      }

      return m;
    };
    /**
     * Creates a plain object from an AddressInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerRecord.AddressInfo
     * @static
     * @param {PeerRecord.AddressInfo} m AddressInfo
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */


    AddressInfo.toObject = function toObject(m, o) {
      if (!o) o = {};
      var d = {};

      if (o.defaults) {
        if (o.bytes === String) d.multiaddr = "";else {
          d.multiaddr = [];
          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);
        }
      }

      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }

      return d;
    };
    /**
     * Converts this AddressInfo to JSON.
     * @function toJSON
     * @memberof PeerRecord.AddressInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */


    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AddressInfo;
  }();

  return PeerRecord;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p/src/record/peer-record/consts.js":[function(require,module,exports) {
'use strict'; // The domain string used for peer records contained in a Envelope.

var domain = 'libp2p-peer-record'; // The type hint used to identify peer records in a Envelope.
// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv
// with name "libp2p-peer-record"

var payloadType = Uint8Array.from([3, 1]);
module.exports = {
  ENVELOPE_DOMAIN_PEER_RECORD: domain,
  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: payloadType
};
},{}],"node_modules/libp2p/src/record/peer-record/index.js":[function(require,module,exports) {
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var PeerId = require('peer-id');

var arrayEquals = require('libp2p-utils/src/array-equals');

var _require2 = require('./peer-record'),
    Protobuf = _require2.PeerRecord;

var _require3 = require('./consts'),
    ENVELOPE_DOMAIN_PEER_RECORD = _require3.ENVELOPE_DOMAIN_PEER_RECORD,
    ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = _require3.ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
/**
 * @typedef {import('../../peer-store/address-book.js').Address} Address
 * @typedef {import('libp2p-interfaces/src/record/types').Record} Record
 */

/**
 * @implements {Record}
 */


var PeerRecord = /*#__PURE__*/function () {
  /**
   * The PeerRecord is used for distributing peer routing records across the network.
   * It contains the peer's reachable listen addresses.
   *
   * @class
   * @param {Object} params
   * @param {PeerId} params.peerId
   * @param {Multiaddr[]} params.multiaddrs - addresses of the associated peer.
   * @param {number} [params.seqNumber] - monotonically-increasing sequence counter that's used to order PeerRecords in time.
   */
  function PeerRecord(_ref) {
    var peerId = _ref.peerId,
        _ref$multiaddrs = _ref.multiaddrs,
        multiaddrs = _ref$multiaddrs === void 0 ? [] : _ref$multiaddrs,
        _ref$seqNumber = _ref.seqNumber,
        seqNumber = _ref$seqNumber === void 0 ? Date.now() : _ref$seqNumber;

    _classCallCheck(this, PeerRecord);

    this.domain = ENVELOPE_DOMAIN_PEER_RECORD;
    this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs;
    this.seqNumber = seqNumber; // Cache

    this._marshal = undefined;
  }
  /**
   * Marshal a record to be used in an envelope.
   *
   * @returns {Uint8Array}
   */


  _createClass(PeerRecord, [{
    key: "marshal",
    value: function marshal() {
      if (this._marshal) {
        return this._marshal;
      }

      this._marshal = Protobuf.encode({
        peerId: this.peerId.toBytes(),
        seq: this.seqNumber,
        addresses: this.multiaddrs.map(function (m) {
          return {
            multiaddr: m.bytes
          };
        })
      }).finish();
      return this._marshal;
    }
    /**
     * Returns true if `this` record equals the `other`.
     *
     * @param {unknown} other
     * @returns {boolean}
     */

  }, {
    key: "equals",
    value: function equals(other) {
      if (!(other instanceof PeerRecord)) {
        return false;
      } // Validate PeerId


      if (!this.peerId.equals(other.peerId)) {
        return false;
      } // Validate seqNumber


      if (this.seqNumber !== other.seqNumber) {
        return false;
      } // Validate multiaddrs


      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }

      return true;
    }
  }]);

  return PeerRecord;
}();
/**
 * Unmarshal Peer Record Protobuf.
 *
 * @param {Uint8Array} buf - marshaled peer record.
 * @returns {PeerRecord}
 */


PeerRecord.createFromProtobuf = function (buf) {
  var peerRecord = Protobuf.decode(buf);
  var peerId = PeerId.createFromBytes(peerRecord.peerId);
  var multiaddrs = (peerRecord.addresses || []).map(function (a) {
    return new Multiaddr(a.multiaddr);
  });
  var seqNumber = Number(peerRecord.seq);
  return new PeerRecord({
    peerId: peerId,
    multiaddrs: multiaddrs,
    seqNumber: seqNumber
  });
};

PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
module.exports = PeerRecord;
},{"multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js","libp2p-utils/src/array-equals":"node_modules/libp2p-utils/src/array-equals.js","./peer-record":"node_modules/libp2p/src/record/peer-record/peer-record.js","./consts":"node_modules/libp2p/src/record/peer-record/consts.js"}],"node_modules/libp2p/src/record/utils.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Envelope = require('./envelope');

var PeerRecord = require('./peer-record');
/**
 * @typedef {import('../')} Libp2p
 */

/**
 * Create (or update if existing) self peer record and store it in the AddressBook.
 *
 * @param {Libp2p} libp2p
 * @returns {Promise<void>}
 */


function updateSelfPeerRecord(_x) {
  return _updateSelfPeerRecord.apply(this, arguments);
}

function _updateSelfPeerRecord() {
  _updateSelfPeerRecord = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libp2p) {
    var peerRecord, envelope;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            peerRecord = new PeerRecord({
              peerId: libp2p.peerId,
              multiaddrs: libp2p.multiaddrs
            });
            _context.next = 3;
            return Envelope.seal(peerRecord, libp2p.peerId);

          case 3:
            envelope = _context.sent;
            libp2p.peerStore.addressBook.consumePeerRecord(envelope);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _updateSelfPeerRecord.apply(this, arguments);
}

module.exports.updateSelfPeerRecord = updateSelfPeerRecord;
},{"./envelope":"node_modules/libp2p/src/record/envelope/index.js","./peer-record":"node_modules/libp2p/src/record/peer-record/index.js"}],"node_modules/libp2p/src/transport-manager.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:transports'), {
  error: debug('libp2p:transports:err')
});

var pSettle = require('p-settle');

var _require = require('./errors'),
    codes = _require.codes;

var errCode = require('err-code');

var _require2 = require('./record/utils'),
    updateSelfPeerRecord = _require2.updateSelfPeerRecord;
/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory
 * @typedef {import('libp2p-interfaces/src/transport/types').Transport<any, any>} Transport
 *
 * @typedef {Object} TransportManagerProperties
 * @property {import('./')} libp2p
 * @property {import('./upgrader')} upgrader
 *
 * @typedef {Object} TransportManagerOptions
 * @property {number} [faultTolerance = FAULT_TOLERANCE.FATAL_ALL] - Address listen error tolerance.
 */


var TransportManager = /*#__PURE__*/function () {
  /**
   * @class
   * @param {TransportManagerProperties & TransportManagerOptions} options
   */
  function TransportManager(_ref) {
    var libp2p = _ref.libp2p,
        upgrader = _ref.upgrader,
        _ref$faultTolerance = _ref.faultTolerance,
        faultTolerance = _ref$faultTolerance === void 0 ? FAULT_TOLERANCE.FATAL_ALL : _ref$faultTolerance;

    _classCallCheck(this, TransportManager);

    this.libp2p = libp2p;
    this.upgrader = upgrader;
    /** @type {Map<string, Transport>} */

    this._transports = new Map();
    this._listeners = new Map();
    this._listenerOptions = new Map();
    this.faultTolerance = faultTolerance;
  }
  /**
   * Adds a `Transport` to the manager
   *
   * @param {string} key
   * @param {TransportFactory} Transport
   * @param {*} transportOptions - Additional options to pass to the transport
   * @returns {void}
   */


  _createClass(TransportManager, [{
    key: "add",
    value: function add(key, Transport) {
      var transportOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      log('adding %s', key);

      if (!key) {
        throw errCode(new Error("Transport must have a valid key, was given '".concat(key, "'")), codes.ERR_INVALID_KEY);
      }

      if (this._transports.has(key)) {
        throw errCode(new Error('There is already a transport with this key'), codes.ERR_DUPLICATE_TRANSPORT);
      }

      var transport = new Transport(_objectSpread(_objectSpread({}, transportOptions), {}, {
        libp2p: this.libp2p,
        upgrader: this.upgrader
      }));

      this._transports.set(key, transport);

      this._listenerOptions.set(key, transportOptions.listenerOptions || {});

      if (!this._listeners.has(key)) {
        this._listeners.set(key, []);
      }
    }
    /**
     * Stops all listeners
     *
     * @async
     */

  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var tasks, _iterator, _step, _step$value, key, listeners, listener, _iterator2, _step2, _key;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                tasks = [];
                _iterator = _createForOfIteratorHelper(this._listeners);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], listeners = _step$value[1];
                    log('closing listeners for %s', key);

                    while (listeners.length) {
                      listener = listeners.pop();
                      listener.removeAllListeners('listening');
                      listener.removeAllListeners('close');
                      tasks.push(listener.close());
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                _context.next = 5;
                return Promise.all(tasks);

              case 5:
                log('all listeners closed');
                _iterator2 = _createForOfIteratorHelper(this._listeners.keys());

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    _key = _step2.value;

                    this._listeners.set(_key, []);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Dials the given Multiaddr over it's supported transport
     *
     * @param {Multiaddr} ma
     * @param {*} options
     * @returns {Promise<Connection>}
     */

  }, {
    key: "dial",
    value: function () {
      var _dial = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(ma, options) {
        var transport;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                transport = this.transportForMultiaddr(ma);

                if (transport) {
                  _context2.next = 3;
                  break;
                }

                throw errCode(new Error("No transport available for address ".concat(String(ma))), codes.ERR_TRANSPORT_UNAVAILABLE);

              case 3:
                _context2.prev = 3;
                _context2.next = 6;
                return transport.dial(ma, options);

              case 6:
                return _context2.abrupt("return", _context2.sent);

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](3);
                if (!_context2.t0.code) _context2.t0.code = codes.ERR_TRANSPORT_DIAL_FAILED;
                throw _context2.t0;

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 9]]);
      }));

      function dial(_x, _x2) {
        return _dial.apply(this, arguments);
      }

      return dial;
    }()
    /**
     * Returns all Multiaddr's the listeners are using
     *
     * @returns {Multiaddr[]}
     */

  }, {
    key: "getAddrs",
    value: function getAddrs() {
      /** @type {Multiaddr[]} */
      var addrs = [];

      var _iterator3 = _createForOfIteratorHelper(this._listeners.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var listeners = _step3.value;

          var _iterator4 = _createForOfIteratorHelper(listeners),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var listener = _step4.value;
              addrs = [].concat(_toConsumableArray(addrs), _toConsumableArray(listener.getAddrs()));
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return addrs;
    }
    /**
     * Returns all the transports instances.
     *
     * @returns {IterableIterator<Transport>}
     */

  }, {
    key: "getTransports",
    value: function getTransports() {
      return this._transports.values();
    }
    /**
     * Finds a transport that matches the given Multiaddr
     *
     * @param {Multiaddr} ma
     * @returns {Transport|null}
     */

  }, {
    key: "transportForMultiaddr",
    value: function transportForMultiaddr(ma) {
      var _iterator5 = _createForOfIteratorHelper(this._transports.values()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var transport = _step5.value;
          var addrs = transport.filter([ma]);
          if (addrs.length) return transport;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return null;
    }
    /**
     * Starts listeners for each listen Multiaddr.
     *
     * @async
     * @param {Multiaddr[]} addrs - addresses to attempt to listen on
     */

  }, {
    key: "listen",
    value: function () {
      var _listen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(addrs) {
        var _this = this;

        var couldNotListen, _iterator6, _step6, _step6$value, key, transport, supportedAddrs, tasks, _iterator7, _step7, addr, listener, results, isListening, message;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!addrs || addrs.length === 0)) {
                  _context3.next = 3;
                  break;
                }

                log('no addresses were provided for listening, this node is dial only');
                return _context3.abrupt("return");

              case 3:
                couldNotListen = [];
                _iterator6 = _createForOfIteratorHelper(this._transports.entries());
                _context3.prev = 5;

                _iterator6.s();

              case 7:
                if ((_step6 = _iterator6.n()).done) {
                  _context3.next = 24;
                  break;
                }

                _step6$value = _slicedToArray(_step6.value, 2), key = _step6$value[0], transport = _step6$value[1];
                supportedAddrs = transport.filter(addrs);
                tasks = []; // For each supported multiaddr, create a listener

                _iterator7 = _createForOfIteratorHelper(supportedAddrs);

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    addr = _step7.value;
                    log('creating listener for %s on %s', key, addr);
                    listener = transport.createListener(this._listenerOptions.get(key));

                    this._listeners.get(key).push(listener); // Track listen/close events


                    listener.on('listening', function () {
                      return updateSelfPeerRecord(_this.libp2p);
                    });
                    listener.on('close', function () {
                      return updateSelfPeerRecord(_this.libp2p);
                    }); // We need to attempt to listen on everything

                    tasks.push(listener.listen(addr));
                  } // Keep track of transports we had no addresses for

                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }

                if (!(tasks.length === 0)) {
                  _context3.next = 16;
                  break;
                }

                couldNotListen.push(key);
                return _context3.abrupt("continue", 22);

              case 16:
                _context3.next = 18;
                return pSettle(tasks);

              case 18:
                results = _context3.sent;
                // If we are listening on at least 1 address, succeed.
                // TODO: we should look at adding a retry (`p-retry`) here to better support
                // listening on remote addresses as they may be offline. We could then potentially
                // just wait for any (`p-any`) listener to succeed on each transport before returning
                isListening = results.find(function (r) {
                  return r.isFulfilled === true;
                });

                if (!(!isListening && this.faultTolerance !== FAULT_TOLERANCE.NO_FATAL)) {
                  _context3.next = 22;
                  break;
                }

                throw errCode(new Error("Transport (".concat(key, ") could not listen on any available address")), codes.ERR_NO_VALID_ADDRESSES);

              case 22:
                _context3.next = 7;
                break;

              case 24:
                _context3.next = 29;
                break;

              case 26:
                _context3.prev = 26;
                _context3.t0 = _context3["catch"](5);

                _iterator6.e(_context3.t0);

              case 29:
                _context3.prev = 29;

                _iterator6.f();

                return _context3.finish(29);

              case 32:
                if (!(couldNotListen.length === this._transports.size)) {
                  _context3.next = 37;
                  break;
                }

                message = "no valid addresses were provided for transports [".concat(couldNotListen, "]");

                if (!(this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL)) {
                  _context3.next = 36;
                  break;
                }

                throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);

              case 36:
                log("libp2p in dial mode only: ".concat(message));

              case 37:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[5, 26, 29, 32]]);
      }));

      function listen(_x3) {
        return _listen.apply(this, arguments);
      }

      return listen;
    }()
    /**
     * Removes the given transport from the manager.
     * If a transport has any running listeners, they will be closed.
     *
     * @async
     * @param {string} key
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key) {
        var _iterator8, _step8, listener;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                log('removing %s', key);

                if (!this._listeners.has(key)) {
                  _context4.next = 21;
                  break;
                }

                // Close any running listeners
                _iterator8 = _createForOfIteratorHelper(this._listeners.get(key));
                _context4.prev = 3;

                _iterator8.s();

              case 5:
                if ((_step8 = _iterator8.n()).done) {
                  _context4.next = 13;
                  break;
                }

                listener = _step8.value;
                listener.removeAllListeners('listening');
                listener.removeAllListeners('close');
                _context4.next = 11;
                return listener.close();

              case 11:
                _context4.next = 5;
                break;

              case 13:
                _context4.next = 18;
                break;

              case 15:
                _context4.prev = 15;
                _context4.t0 = _context4["catch"](3);

                _iterator8.e(_context4.t0);

              case 18:
                _context4.prev = 18;

                _iterator8.f();

                return _context4.finish(18);

              case 21:
                this._transports.delete(key);

                this._listeners.delete(key);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 15, 18, 21]]);
      }));

      function remove(_x4) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Removes all transports from the manager.
     * If any listeners are running, they will be closed.
     *
     * @async
     */

  }, {
    key: "removeAll",
    value: function () {
      var _removeAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var tasks, _iterator9, _step9, key;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                tasks = [];
                _iterator9 = _createForOfIteratorHelper(this._transports.keys());

                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    key = _step9.value;
                    tasks.push(this.remove(key));
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }

                _context5.next = 5;
                return Promise.all(tasks);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function removeAll() {
        return _removeAll.apply(this, arguments);
      }

      return removeAll;
    }()
  }]);

  return TransportManager;
}();
/**
 * Enum Transport Manager Fault Tolerance values.
 * FATAL_ALL should be used for failing in any listen circumstance.
 * NO_FATAL should be used for not failing when not listening.
 *
 * @readonly
 * @enum {number}
 */


var FAULT_TOLERANCE = {
  FATAL_ALL: 0,
  NO_FATAL: 1
};
TransportManager.FaultTolerance = FAULT_TOLERANCE;
module.exports = TransportManager;
},{"debug":"node_modules/debug/src/browser.js","p-settle":"node_modules/p-settle/index.js","./errors":"node_modules/libp2p/src/errors.js","err-code":"node_modules/err-code/index.js","./record/utils":"node_modules/libp2p/src/record/utils.js"}],"node_modules/libp2p/src/config.js":[function(require,module,exports) {
'use strict';

var mergeOptions = require('merge-options'); // @ts-ignore no types in multiaddr path


var _require = require('multiaddr/src/resolvers'),
    dnsaddrResolver = _require.dnsaddrResolver;

var Constants = require('./constants');

var _require2 = require('./identify/consts'),
    AGENT_VERSION = _require2.AGENT_VERSION;

var RelayConstants = require('./circuit/constants');

var _require3 = require('libp2p-utils/src/address-sort'),
    publicAddressesFirst = _require3.publicAddressesFirst;

var _require4 = require('./transport-manager'),
    FaultTolerance = _require4.FaultTolerance;
/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('.').Libp2pOptions} Libp2pOptions
 * @typedef {import('.').constructorOptions} constructorOptions
 */


var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: function announceFilter(
    /** @type {Multiaddr[]} */
    multiaddrs) {
      return multiaddrs;
    }
  },
  connectionManager: {
    minConnections: 25
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  dialer: {
    maxParallelDials: Constants.MAX_PARALLEL_DIALS,
    maxDialsPerPeer: Constants.MAX_PER_PEER_DIALS,
    dialTimeout: Constants.DIAL_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  host: {
    agentVersion: AGENT_VERSION
  },
  metrics: {
    enabled: false
  },
  peerStore: {
    persistence: false,
    threshold: 5
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 10e3
    }
  },
  config: {
    protocolPrefix: 'ipfs',
    dht: {
      enabled: false,
      kBucketSize: 20,
      randomWalk: {
        enabled: false,
        // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86
        queriesPerPeriod: 1,
        interval: 300e3,
        timeout: 10e3
      }
    },
    nat: {
      enabled: true,
      ttl: 7200,
      keepAlive: true,
      gateway: null,
      externalIp: null,
      pmp: {
        enabled: false
      }
    },
    peerDiscovery: {
      autoDial: true
    },
    pubsub: {
      enabled: true
    },
    relay: {
      enabled: true,
      advertise: {
        bootDelay: RelayConstants.ADVERTISE_BOOT_DELAY,
        enabled: false,
        ttl: RelayConstants.ADVERTISE_TTL
      },
      hop: {
        enabled: false,
        active: false
      },
      autoRelay: {
        enabled: false,
        maxListeners: 2
      }
    },
    transport: {}
  }
};
/**
 * @param {Libp2pOptions} opts
 * @returns {DefaultConfig & Libp2pOptions & constructorOptions}
 */

module.exports.validate = function (opts) {
  /** @type {DefaultConfig & Libp2pOptions & constructorOptions} */
  var resultingOptions = mergeOptions(DefaultConfig, opts);
  if (resultingOptions.modules.transport.length < 1) throw new Error("'options.modules.transport' must contain at least 1 transport");
  return resultingOptions;
};
},{"merge-options":"node_modules/merge-options/index.js","multiaddr/src/resolvers":"node_modules/multiaddr/src/resolvers/index.js","./constants":"node_modules/libp2p/src/constants.js","./identify/consts":"node_modules/libp2p/src/identify/consts.js","./circuit/constants":"node_modules/libp2p/src/circuit/constants.js","libp2p-utils/src/address-sort":"node_modules/libp2p-utils/src/address-sort.js","./transport-manager":"node_modules/libp2p/src/transport-manager.js"}],"node_modules/libp2p/src/address-manager/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('multiaddr'),
    Multiaddr = _require2.Multiaddr;

var PeerId = require('peer-id');
/**
 * @typedef {Object} AddressManagerOptions
 * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.
 * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.
 */

/**
 * @fires AddressManager#change:addresses Emitted when a addresses change.
 */


var AddressManager = /*#__PURE__*/function (_EventEmitter) {
  _inherits(AddressManager, _EventEmitter);

  var _super = _createSuper(AddressManager);

  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   *
   * @class
   * @param {PeerId} peerId - The Peer ID of the node
   * @param {object} [options]
   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.
   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.
   */
  function AddressManager(peerId) {
    var _this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$listen = _ref.listen,
        listen = _ref$listen === void 0 ? [] : _ref$listen,
        _ref$announce = _ref.announce,
        announce = _ref$announce === void 0 ? [] : _ref$announce;

    _classCallCheck(this, AddressManager);

    _this = _super.call(this);
    _this.peerId = peerId;
    _this.listen = new Set(listen.map(function (ma) {
      return ma.toString();
    }));
    _this.announce = new Set(announce.map(function (ma) {
      return ma.toString();
    }));
    _this.observed = new Set();
    return _this;
  }
  /**
   * Get peer listen multiaddrs.
   *
   * @returns {Multiaddr[]}
   */


  _createClass(AddressManager, [{
    key: "getListenAddrs",
    value: function getListenAddrs() {
      return Array.from(this.listen).map(function (a) {
        return new Multiaddr(a);
      });
    }
    /**
     * Get peer announcing multiaddrs.
     *
     * @returns {Multiaddr[]}
     */

  }, {
    key: "getAnnounceAddrs",
    value: function getAnnounceAddrs() {
      return Array.from(this.announce).map(function (a) {
        return new Multiaddr(a);
      });
    }
    /**
     * Get observed multiaddrs.
     *
     * @returns {Array<Multiaddr>}
     */

  }, {
    key: "getObservedAddrs",
    value: function getObservedAddrs() {
      return Array.from(this.observed).map(function (a) {
        return new Multiaddr(a);
      });
    }
    /**
     * Add peer observed addresses
     *
     * @param {string | Multiaddr} addr
     */

  }, {
    key: "addObservedAddr",
    value: function addObservedAddr(addr) {
      var ma = new Multiaddr(addr);
      var remotePeer = ma.getPeerId(); // strip our peer id if it has been passed

      if (remotePeer) {
        var remotePeerId = PeerId.createFromB58String(remotePeer); // use same encoding for comparison

        if (remotePeerId.equals(this.peerId)) {
          ma = ma.decapsulate(new Multiaddr("/p2p/".concat(this.peerId)));
        }
      }

      var addrString = ma.toString(); // do not trigger the change:addresses event if we already know about this address

      if (this.observed.has(addrString)) {
        return;
      }

      this.observed.add(addrString);
      this.emit('change:addresses');
    }
  }]);

  return AddressManager;
}(EventEmitter);

module.exports = AddressManager;
},{"events":"node_modules/events/events.js","multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js"}],"node_modules/libp2p/src/connection-manager/visibility-change-emitter.js":[function(require,module,exports) {
// @ts-nocheck

/* global document */

/**
 * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)
 */
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var debug = require('debug')('latency-monitor:VisibilityChangeEmitter');
/**
 * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.
 *
 * Warning: This does not work on all browsers, but should work on all modern browsers
 *
 * @example
 *
 *     const myVisibilityEmitter = new VisibilityChangeEmitter();
 *
 *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {
 *        if ( pageInFocus ){
 *            // Page is in focus
 *            console.log('In focus');
 *        }
 *        else {
 *            // Page is blurred
 *            console.log('Out of focus');
 *        }
 *     });
 *     // To access the visibility state directly, call:
 *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());
 */


var VisibilityChangeEmitter = /*#__PURE__*/function (_EventEmitter) {
  _inherits(VisibilityChangeEmitter, _EventEmitter);

  var _super = _createSuper(VisibilityChangeEmitter);

  /**
   * Creates a VisibilityChangeEmitter
   *
   * @class
   */
  function VisibilityChangeEmitter() {
    var _this;

    _classCallCheck(this, VisibilityChangeEmitter);

    _this = _super.call(this);

    if (typeof document === 'undefined') {
      debug('This is not a browser, no "document" found. Stopping.');
      return _possibleConstructorReturn(_this);
    }

    _this._initializeVisibilityVarNames();

    _this._addVisibilityChangeListener();

    return _this;
  }
  /**
   * document.hidden and document.visibilityChange are the two variables we need to check for;
   * Since these variables are named differently in different browsers, this function sets
   * the appropriate name based on the browser being used. Once executed, tha actual names of
   * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange
   * respectively
   *
   * @private
   */


  _createClass(VisibilityChangeEmitter, [{
    key: "_initializeVisibilityVarNames",
    value: function _initializeVisibilityVarNames() {
      var hidden;
      var visibilityChange;

      if (typeof document.hidden !== 'undefined') {
        // Opera 12.10 and Firefox 18 and later support
        hidden = 'hidden';
        visibilityChange = 'visibilitychange';
      } else if (typeof document.mozHidden !== 'undefined') {
        hidden = 'mozHidden';
        visibilityChange = 'mozvisibilitychange';
      } else if (typeof document.msHidden !== 'undefined') {
        hidden = 'msHidden';
        visibilityChange = 'msvisibilitychange';
      } else if (typeof document.webkitHidden !== 'undefined') {
        hidden = 'webkitHidden';
        visibilityChange = 'webkitvisibilitychange';
      }

      this._hidden = hidden;
      this._visibilityChange = visibilityChange;
    }
    /**
     * Adds an event listener on the document that listens to changes in document.visibilityChange
     * (or whatever name by which the visibilityChange variable is known in the browser)
     *
     * @private
     */

  }, {
    key: "_addVisibilityChangeListener",
    value: function _addVisibilityChangeListener() {
      if (typeof document.addEventListener === 'undefined' || typeof document[this._hidden] === 'undefined') {
        debug('Checking page visibility requires a browser that supports the Page Visibility API.');
      } else {
        // Handle page visibility change
        document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
      }
    }
    /**
     * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and
     * ```undefined``` if the page visibility API is not supported by the browser.
     *
     * @returns {boolean | void} whether the page is now visible or not (undefined is unknown)
     */

  }, {
    key: "isVisible",
    value: function isVisible() {
      if (this._hidden === undefined || document[this._hidden] === undefined) {
        return undefined;
      }

      return !document[this._hidden];
    }
    /**
     * The function that is called when document.visibilityChange has changed
     * It emits an event called visibilityChange and sends the value of document.hidden as a
     * parameter
     *
     * @private
     */

  }, {
    key: "_handleVisibilityChange",
    value: function _handleVisibilityChange() {
      var visible = !document[this._hidden];
      debug(visible ? 'Page Visible' : 'Page Hidden'); // Emit the event

      this.emit('visibilityChange', visible);
    }
  }]);

  return VisibilityChangeEmitter;
}(EventEmitter);

module.exports = VisibilityChangeEmitter;
},{"events":"node_modules/events/events.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/libp2p/src/connection-manager/latency-monitor.js":[function(require,module,exports) {
// @ts-nocheck
'use strict';
/**
 * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var VisibilityChangeEmitter = require('./visibility-change-emitter');

var debug = require('debug')('latency-monitor:LatencyMonitor');
/**
 * @typedef {Object} SummaryObject
 * @property {number} events How many events were called
 * @property {number} minMS What was the min time for a cb to be called
 * @property {number} maxMS What was the max time for a cb to be called
 * @property {number} avgMs What was the average time for a cb to be called
 * @property {number} lengthMs How long this interval was in ms
 *
 * @typedef {Object} LatencyMonitorOptions
 * @property {number} [latencyCheckIntervalMs=500] - How often to add a latency check event (ms)
 * @property {number} [dataEmitIntervalMs=5000] - How often to summarize latency check events. null or 0 disables event firing
 * @property {Function} [asyncTestFn] - What cb-style async function to use
 * @property {number} [latencyRandomPercentage=5] - What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.
 */

/**
 * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling
 * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.
 * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.
 *
 * @extends {EventEmitter}
 *
 * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop
 * and timing how long it takes to get back.
 *
 * @example
 * const monitor = new LatencyMonitor();
 * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));
 *
 * @example
 * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});
 * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));
 */


var LatencyMonitor = /*#__PURE__*/function (_EventEmitter) {
  _inherits(LatencyMonitor, _EventEmitter);

  var _super = _createSuper(LatencyMonitor);

  /**
   * @class
   * @param {LatencyMonitorOptions} [options]
   */
  function LatencyMonitor() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        latencyCheckIntervalMs = _ref.latencyCheckIntervalMs,
        dataEmitIntervalMs = _ref.dataEmitIntervalMs,
        asyncTestFn = _ref.asyncTestFn,
        latencyRandomPercentage = _ref.latencyRandomPercentage;

    _classCallCheck(this, LatencyMonitor);

    _this = _super.call(this);

    var that = _assertThisInitialized(_this); // 0 isn't valid here, so its ok to use ||


    that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s

    that.latencyRandomPercentage = latencyRandomPercentage || 10;
    that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;
    that._latecyCheckSubtract = that._latecyCheckMultiply / 2;
    that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs || 5 * 1000; // 5s

    debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', that.latencyCheckIntervalMs, that.dataEmitIntervalMs);

    if (that.dataEmitIntervalMs) {
      debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
    } else {
      debug('Not emitting summaries');
    }

    that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency

    return _this;
  }

  _createClass(LatencyMonitor, [{
    key: "start",
    value: function start() {
      var _this2 = this;

      // If process: use high resolution timer
      if (globalThis.process && globalThis.process.hrtime) {
        // eslint-disable-line no-undef
        debug('Using process.hrtime for timing');
        this.now = globalThis.process.hrtime; // eslint-disable-line no-undef

        this.getDeltaMS = function (startTime) {
          var hrtime = _this2.now(startTime);

          return hrtime[0] * 1000 + hrtime[1] / 1000000;
        }; // Let's try for a timer that only monotonically increases

      } else if (typeof window !== 'undefined' && window.performance && window.performance.now) {
        debug('Using performance.now for timing');
        this.now = window.performance.now.bind(window.performance);

        this.getDeltaMS = function (startTime) {
          return Math.round(_this2.now() - startTime);
        };
      } else {
        debug('Using Date.now for timing');
        this.now = Date.now;

        this.getDeltaMS = function (startTime) {
          return _this2.now() - startTime;
        };
      }

      this._latencyData = this._initLatencyData(); // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,
      // so we fall back to another library
      // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs

      if (isBrowser()) {
        this._visibilityChangeEmitter = new VisibilityChangeEmitter();

        this._visibilityChangeEmitter.on('visibilityChange', function (pageInFocus) {
          if (pageInFocus) {
            _this2._startTimers();
          } else {
            _this2._emitSummary();

            _this2._stopTimers();
          }
        });
      }

      if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {
        this._startTimers();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      this._stopTimers();
    }
    /**
     * Start internal timers
     *
     * @private
     */

  }, {
    key: "_startTimers",
    value: function _startTimers() {
      var _this3 = this;

      // Timer already started, ignore this
      if (this._checkLatencyID) {
        return;
      }

      this._checkLatency();

      if (this.dataEmitIntervalMs) {
        this._emitIntervalID = setInterval(function () {
          return _this3._emitSummary();
        }, this.dataEmitIntervalMs);

        if (typeof this._emitIntervalID.unref === 'function') {
          this._emitIntervalID.unref(); // Doesn't block exit

        }
      }
    }
    /**
     * Stop internal timers
     *
     * @private
     */

  }, {
    key: "_stopTimers",
    value: function _stopTimers() {
      if (this._checkLatencyID) {
        clearTimeout(this._checkLatencyID);
        this._checkLatencyID = undefined;
      }

      if (this._emitIntervalID) {
        clearInterval(this._emitIntervalID);
        this._emitIntervalID = undefined;
      }
    }
    /**
     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show
     *
     * @private
     */

  }, {
    key: "_emitSummary",
    value: function _emitSummary() {
      var summary = this.getSummary();

      if (summary.events > 0) {
        this.emit('data', summary);
      }
    }
    /**
     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,
     * it will not count for this time period
     *
     * @returns {SummaryObject}
     */

  }, {
    key: "getSummary",
    value: function getSummary() {
      // We might want to adjust for the number of expected events
      // Example: first 1 event it comes back, then such a long blocker that the next emit check comes
      // Then this fires - looks like no latency!!
      var latency = {
        events: this._latencyData.events,
        minMs: this._latencyData.minMs,
        maxMs: this._latencyData.maxMs,
        avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
        lengthMs: this.getDeltaMS(this._latencyData.startTime)
      };
      this._latencyData = this._initLatencyData(); // Clear

      debug('Summary: %O', latency);
      return latency;
    }
    /**
     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,
     * it will simply report on event loop latency.
     *
     * @private
     */

  }, {
    key: "_checkLatency",
    value: function _checkLatency() {
      var _this4 = this;

      var that = this; // Randomness is needed to avoid alignment by accident to regular things in the event loop

      var randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract; // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset


      var localData = {
        deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
        startTime: that.now()
      };

      var cb = function cb() {
        // We are already stopped, ignore this datapoint
        if (!_this4._checkLatencyID) {
          return;
        }

        var deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;

        that._checkLatency(); // Start again ASAP
        // Add the data point. If this gets complex, refactor it


        that._latencyData.events++;
        that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
        that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
        that._latencyData.totalMs += deltaMS;
        debug('MS: %s Data: %O', deltaMS, that._latencyData);
      };

      debug('localData: %O', localData);
      this._checkLatencyID = setTimeout(function () {
        // This gets rid of including event loop
        if (that.asyncTestFn) {
          // Clear timing related things
          localData.deltaOffset = 0;
          localData.startTime = that.now();
          that.asyncTestFn(cb);
        } else {
          // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.
          // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.
          localData.deltaOffset -= 1; // If there is no function to test, we mean check latency which is a special case that is really cb => cb()
          // We avoid that for the few extra function all overheads. Also, we want to keep the timers different

          cb();
        }
      }, localData.deltaOffset);

      if (typeof this._checkLatencyID.unref === 'function') {
        this._checkLatencyID.unref(); // Doesn't block exit

      }
    }
  }, {
    key: "_initLatencyData",
    value: function _initLatencyData() {
      return {
        startTime: this.now(),
        minMs: Number.POSITIVE_INFINITY,
        maxMs: Number.NEGATIVE_INFINITY,
        events: 0,
        totalMs: 0
      };
    }
  }]);

  return LatencyMonitor;
}(EventEmitter);

function isBrowser() {
  return typeof window !== 'undefined';
}

module.exports = LatencyMonitor;
},{"events":"node_modules/events/events.js","./visibility-change-emitter":"node_modules/libp2p/src/connection-manager/visibility-change-emitter.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/retimer/time-browser.js":[function(require,module,exports) {
'use strict'

module.exports = function getTime () {
  return Date.now()
}

},{}],"node_modules/retimer/retimer.js":[function(require,module,exports) {
'use strict'

const getTime = require('./time')

class Retimer {
  constructor (callback, timeout, args) {
    const that = this

    this._started = getTime()
    this._rescheduled = 0
    this._scheduled = timeout
    this._args = args
    this._triggered = false

    this._timerWrapper = () => {
      if (that._rescheduled > 0) {
        that._scheduled = that._rescheduled - (getTime() - that._started)
        that._schedule(that._scheduled)
      } else {
        that._triggered = true
        callback.apply(null, that._args)
      }
    }

    this._timer = setTimeout(this._timerWrapper, timeout)
  }

  reschedule (timeout) {
    if (!timeout) {
      timeout = this._scheduled
    }
    const now = getTime()
    if ((now + timeout) - (this._started + this._scheduled) < 0) {
      clearTimeout(this._timer)
      this._schedule(timeout)
    } else if (!this._triggered) {
      this._started = now
      this._rescheduled = timeout
    } else {
      this._schedule(timeout)
    }
  }

  _schedule (timeout) {
    this._triggered = false
    this._started = getTime()
    this._rescheduled = 0
    this._scheduled = timeout
    this._timer = setTimeout(this._timerWrapper, timeout)
  }

  clear () {
    clearTimeout(this._timer)
  }
}

function retimer () {
  if (typeof arguments[0] !== 'function') {
    throw new Error('callback needed')
  }

  if (typeof arguments[1] !== 'number') {
    throw new Error('timeout needed')
  }

  let args

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2)

    /* eslint-disable no-var */
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2]
    }
  }

  return new Retimer(arguments[0], arguments[1], args)
}

module.exports = retimer

},{"./time":"node_modules/retimer/time-browser.js"}],"node_modules/libp2p/src/connection-manager/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:connection-manager'), {
  error: debug('libp2p:connection-manager:err')
});

var errcode = require('err-code');

var mergeOptions = require('merge-options');

var LatencyMonitor = require('./latency-monitor'); // @ts-ignore retimer does not have types


var retimer = require('retimer');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var PeerId = require('peer-id');

var _require2 = require('../errors'),
    ERR_INVALID_PARAMETERS = _require2.codes.ERR_INVALID_PARAMETERS;

var defaultOptions = {
  maxConnections: Infinity,
  minConnections: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2000,
  autoDialInterval: 10000,
  movingAverageInterval: 60000,
  defaultPeerValue: 1
};
/**
 * @typedef {import('../')} Libp2p
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 */

/**
 * @typedef {Object} ConnectionManagerOptions
 * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.
 * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.
 * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.
 * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.
 * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.
 * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.
 * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.
 * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.
 * @property {number} [defaultPeerValue = 1] - The value of the peer.
 * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.
 * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.
 */

/**
 *
 * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.
 * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.
 */

var ConnectionManager = /*#__PURE__*/function (_EventEmitter) {
  _inherits(ConnectionManager, _EventEmitter);

  var _super = _createSuper(ConnectionManager);

  /**
   * Responsible for managing known connections.
   *
   * @class
   * @param {Libp2p} libp2p
   * @param {ConnectionManagerOptions} options
   */
  function ConnectionManager(libp2p) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConnectionManager);

    _this = _super.call(this);
    _this._libp2p = libp2p;
    _this._peerId = libp2p.peerId.toB58String();
    _this._options = mergeOptions.call({
      ignoreUndefined: true
    }, defaultOptions, options);

    if (_this._options.maxConnections < _this._options.minConnections) {
      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);
    }

    log('options: %j', _this._options);
    /**
     * Map of peer identifiers to their peer value for pruning connections.
     *
     * @type {Map<string, number>}
     */

    _this._peerValues = new Map();
    /**
     * Map of connections per peer
     *
     * @type {Map<string, Connection[]>}
     */

    _this.connections = new Map();
    _this._started = false;
    _this._timer = null;
    _this._autoDialTimeout = null;
    _this._checkMetrics = _this._checkMetrics.bind(_assertThisInitialized(_this));
    _this._autoDial = _this._autoDial.bind(_assertThisInitialized(_this));
    _this._latencyMonitor = new LatencyMonitor({
      latencyCheckIntervalMs: _this._options.pollInterval,
      dataEmitIntervalMs: _this._options.pollInterval
    });
    return _this;
  }
  /**
   * Get current number of open connections.
   */


  _createClass(ConnectionManager, [{
    key: "size",
    get: function get() {
      return Array.from(this.connections.values()).reduce(function (accumulator, value) {
        return accumulator + value.length;
      }, 0);
    }
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */

  }, {
    key: "start",
    value: function start() {
      if (this._libp2p.metrics) {
        this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);
      } // latency monitor


      this._latencyMonitor.start();

      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);

      this._latencyMonitor.on('data', this._onLatencyMeasure);

      this._started = true;
      log('started');
      this._options.autoDial && this._autoDial();
    }
    /**
     * Stops the Connection Manager
     *
     * @async
     */

  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._autoDialTimeout && this._autoDialTimeout.clear();
                this._timer && this._timer.clear();

                this._latencyMonitor.removeListener('data', this._onLatencyMeasure);

                this._latencyMonitor.stop();

                this._started = false;
                _context.next = 7;
                return this._close();

              case 7:
                log('stopped');

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Cleans up the connections
     *
     * @async
     */

  }, {
    key: "_close",
    value: function () {
      var _close2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var tasks, _iterator, _step, connectionList, _iterator2, _step2, connection;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Close all connections we're tracking
                tasks = [];
                _iterator = _createForOfIteratorHelper(this.connections.values());

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    connectionList = _step.value;
                    _iterator2 = _createForOfIteratorHelper(connectionList);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        connection = _step2.value;
                        tasks.push(connection.close());
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                _context2.next = 5;
                return Promise.all(tasks);

              case 5:
                this.connections.clear();

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _close() {
        return _close2.apply(this, arguments);
      }

      return _close;
    }()
    /**
     * Sets the value of the given peer. Peers with lower values
     * will be disconnected first.
     *
     * @param {PeerId} peerId
     * @param {number} value - A number between 0 and 1
     * @returns {void}
     */

  }, {
    key: "setPeerValue",
    value: function setPeerValue(peerId, value) {
      if (value < 0 || value > 1) {
        throw new Error('value should be a number between 0 and 1');
      }

      this._peerValues.set(peerId.toB58String(), value);
    }
    /**
     * Checks the libp2p metrics to determine if any values have exceeded
     * the configured maximums.
     *
     * @private
     */

  }, {
    key: "_checkMetrics",
    value: function _checkMetrics() {
      if (this._libp2p.metrics) {
        var movingAverages = this._libp2p.metrics.global.movingAverages; // @ts-ignore moving averages object types

        var received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();

        this._checkMaxLimit('maxReceivedData', received); // @ts-ignore moving averages object types


        var sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();

        this._checkMaxLimit('maxSentData', sent);

        var total = received + sent;

        this._checkMaxLimit('maxData', total);

        log('metrics update', total);
        this._timer = retimer(this._checkMetrics, this._options.pollInterval);
      }
    }
    /**
     * Tracks the incoming connection and check the connection limit
     *
     * @param {Connection} connection
     * @returns {void}
     */

  }, {
    key: "onConnect",
    value: function onConnect(connection) {
      var peerId = connection.remotePeer;
      var peerIdStr = peerId.toB58String();
      var storedConn = this.connections.get(peerIdStr);
      this.emit('peer:connect', connection);

      if (storedConn) {
        storedConn.push(connection);
      } else {
        this.connections.set(peerIdStr, [connection]);
      }

      this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);

      if (!this._peerValues.has(peerIdStr)) {
        this._peerValues.set(peerIdStr, this._options.defaultPeerValue);
      }

      this._checkMaxLimit('maxConnections', this.size);
    }
    /**
     * Removes the connection from tracking
     *
     * @param {Connection} connection
     * @returns {void}
     */

  }, {
    key: "onDisconnect",
    value: function onDisconnect(connection) {
      var peerId = connection.remotePeer.toB58String();
      var storedConn = this.connections.get(peerId);

      if (storedConn && storedConn.length > 1) {
        storedConn = storedConn.filter(function (conn) {
          return conn.id !== connection.id;
        });
        this.connections.set(peerId, storedConn);
      } else if (storedConn) {
        this.connections.delete(peerId);

        this._peerValues.delete(connection.remotePeer.toB58String());

        this.emit('peer:disconnect', connection);
      }
    }
    /**
     * Get a connection with a peer.
     *
     * @param {PeerId} peerId
     * @returns {Connection|null}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      var connections = this.getAll(peerId);

      if (connections.length) {
        return connections[0];
      }

      return null;
    }
    /**
     * Get all open connections with a peer.
     *
     * @param {PeerId} peerId
     * @returns {Connection[]}
     */

  }, {
    key: "getAll",
    value: function getAll(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var id = peerId.toB58String();
      var connections = this.connections.get(id); // Return all open connections

      if (connections) {
        return connections.filter(function (connection) {
          return connection.stat.status === 'open';
        });
      }

      return [];
    }
    /**
     * If the event loop is slow, maybe close a connection
     *
     * @private
     * @param {*} summary - The LatencyMonitor summary
     */

  }, {
    key: "_onLatencyMeasure",
    value: function _onLatencyMeasure(summary) {
      this._checkMaxLimit('maxEventLoopDelay', summary.avgMs);
    }
    /**
     * If the `value` of `name` has exceeded its limit, maybe close a connection
     *
     * @private
     * @param {string} name - The name of the field to check limits for
     * @param {number} value - The current value of the field
     */

  }, {
    key: "_checkMaxLimit",
    value: function _checkMaxLimit(name, value) {
      var limit = this._options[name];
      log('checking limit of %s. current value: %d of %d', name, value, limit);

      if (value > limit) {
        log('%s: limit exceeded: %s, %d', this._peerId, name, value);

        this._maybeDisconnectOne();
      }
    }
    /**
     * Proactively tries to connect to known peers stored in the PeerStore.
     * It will keep the number of connections below the upper limit and sort
     * the peers to connect based on wether we know their keys and protocols.
     *
     * @async
     * @private
     */

  }, {
    key: "_autoDial",
    value: function () {
      var _autoDial2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var minConnections, peers, i;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                minConnections = this._options.minConnections; // Already has enough connections

                if (!(this.size >= minConnections)) {
                  _context3.next = 4;
                  break;
                }

                this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
                return _context3.abrupt("return");

              case 4:
                // Sort peers on wether we know protocols of public keys for them
                peers = Array.from(this._libp2p.peerStore.peers.values()).sort(function (a, b) {
                  if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {
                    return 1;
                  } else if (b.id.pubKey && !a.id.pubKey) {
                    return 1;
                  }

                  return -1;
                });
                i = 0;

              case 6:
                if (!(i < peers.length && this.size < minConnections)) {
                  _context3.next = 22;
                  break;
                }

                if (this.get(peers[i].id)) {
                  _context3.next = 19;
                  break;
                }

                log('connecting to a peerStore stored peer %s', peers[i].id.toB58String());
                _context3.prev = 9;
                _context3.next = 12;
                return this._libp2p.dialer.connectToPeer(peers[i].id);

              case 12:
                if (this._started) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return");

              case 14:
                _context3.next = 19;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](9);
                log.error('could not connect to peerStore stored peer', _context3.t0);

              case 19:
                i++;
                _context3.next = 6;
                break;

              case 22:
                this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);

              case 23:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[9, 16]]);
      }));

      function _autoDial() {
        return _autoDial2.apply(this, arguments);
      }

      return _autoDial;
    }()
    /**
     * If we have more connections than our maximum, close a connection
     * to the lowest valued peer.
     *
     * @private
     */

  }, {
    key: "_maybeDisconnectOne",
    value: function _maybeDisconnectOne() {
      if (this._options.minConnections < this.connections.size) {
        var peerValues = Array.from(new Map(_toConsumableArray(this._peerValues.entries()).sort(function (a, b) {
          return a[1] - b[1];
        })));
        log('%s: sorted peer values: %j', this._peerId, peerValues);
        var disconnectPeer = peerValues[0];

        if (disconnectPeer) {
          var peerId = disconnectPeer[0];
          log('%s: lowest value peer is %s', this._peerId, peerId);
          log('%s: closing a connection to %j', this._peerId, peerId);

          var _iterator3 = _createForOfIteratorHelper(this.connections.values()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var connections = _step3.value;

              if (connections[0].remotePeer.toB58String() === peerId) {
                connections[0].close();
                break;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }
    }
  }]);

  return ConnectionManager;
}(EventEmitter);

module.exports = ConnectionManager;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","merge-options":"node_modules/merge-options/index.js","./latency-monitor":"node_modules/libp2p/src/connection-manager/latency-monitor.js","retimer":"node_modules/retimer/retimer.js","events":"node_modules/events/events.js","peer-id":"node_modules/peer-id/src/index.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/mafmt/src/index.js":[function(require,module,exports) {
'use strict'

const { Multiaddr } = require('multiaddr')

/**
 * @typedef {import('./types').MatchesFunction} MatchesFunction
 * @typedef {import('./types').PartialMatchesFunction} PartialMatchesFunction
 * @typedef {import('./types').Mafmt} Mafmt
 */

/*
 * Valid combinations
 */
const DNS4 = base('dns4')
const DNS6 = base('dns6')
const DNSADDR = base('dnsaddr')
const DNS = or(
  base('dns'),
  DNSADDR,
  DNS4,
  DNS6
)

const IP = or(base('ip4'), base('ip6'))
const TCP = or(
  and(IP, base('tcp')),
  and(DNS, base('tcp'))
)
const UDP = and(IP, base('udp'))
const UTP = and(UDP, base('utp'))

const QUIC = and(UDP, base('quic'))

const WebSockets = or(
  and(TCP, base('ws')),
  and(DNS, base('ws'))
)

const WebSocketsSecure = or(
  and(TCP, base('wss')),
  and(DNS, base('wss'))
)

const HTTP = or(
  and(TCP, base('http')),
  and(IP, base('http')),
  and(DNS, base('http'))
)

const HTTPS = or(
  and(TCP, base('https')),
  and(IP, base('https')),
  and(DNS, base('https'))
)

const WebRTCStar = or(
  and(WebSockets, base('p2p-webrtc-star'), base('p2p')),
  and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')),
  and(WebSockets, base('p2p-webrtc-star')),
  and(WebSocketsSecure, base('p2p-webrtc-star'))
)

const WebSocketStar = or(
  and(WebSockets, base('p2p-websocket-star'), base('p2p')),
  and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')),
  and(WebSockets, base('p2p-websocket-star')),
  and(WebSocketsSecure, base('p2p-websocket-star'))
)

const WebRTCDirect = or(
  and(HTTP, base('p2p-webrtc-direct'), base('p2p')),
  and(HTTPS, base('p2p-webrtc-direct'), base('p2p')),
  and(HTTP, base('p2p-webrtc-direct')),
  and(HTTPS, base('p2p-webrtc-direct'))
)

const Reliable = or(
  WebSockets,
  WebSocketsSecure,
  HTTP,
  HTTPS,
  WebRTCStar,
  WebRTCDirect,
  TCP,
  UTP,
  QUIC,
  DNS
)

// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )
const Stardust = or(
  and(Reliable, base('p2p-stardust'), base('p2p')),
  and(Reliable, base('p2p-stardust'))
)

const _P2P = or(
  and(Reliable, base('p2p')),
  WebRTCStar,
  WebRTCDirect,
  base('p2p')
)

const _Circuit = or(
  and(_P2P, base('p2p-circuit'), _P2P),
  and(_P2P, base('p2p-circuit')),
  and(base('p2p-circuit'), _P2P),
  and(Reliable, base('p2p-circuit')),
  and(base('p2p-circuit'), Reliable),
  base('p2p-circuit')
)

const CircuitRecursive = () => or(
  and(_Circuit, CircuitRecursive),
  _Circuit
)

const Circuit = CircuitRecursive()

const P2P = or(
  and(Circuit, _P2P, Circuit),
  and(_P2P, Circuit),
  and(Circuit, _P2P),
  Circuit,
  _P2P
)

module.exports = {
  DNS,
  DNS4,
  DNS6,
  DNSADDR,
  IP,
  TCP,
  UDP,
  QUIC,
  UTP,
  HTTP,
  HTTPS,
  WebSockets,
  WebSocketsSecure,
  WebSocketStar,
  WebRTCStar,
  WebRTCDirect,
  Reliable,
  Stardust,
  Circuit,
  P2P,
  IPFS: P2P
}

/*
 * Validation funcs
 */

/**
 * @param {PartialMatchesFunction} partialMatch
 */
function makeMatchesFunction (partialMatch) {
  /**
   * @type {MatchesFunction}
   */
  function matches (a) {
    if (!Multiaddr.isMultiaddr(a)) {
      try {
        a = new Multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's propably not matching as well so return false
      }
    }
    const out = partialMatch(a.protoNames())
    if (out === null) {
      return false
    }

    if (out === true || out === false) {
      return out
    }

    return out.length === 0
  }

  return matches
}

/**
 * @param {Array<Mafmt | (() => Mafmt)>} args
 * @returns {Mafmt}
 */
function and (...args) {
  /**
   * @type {PartialMatchesFunction}
   */
  function partialMatch (a) {
    if (a.length < args.length) {
      return null
    }

    /** @type {boolean | string[] | null} */
    let out = a

    args.some((arg) => {
      out = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)

      if (Array.isArray(out)) {
        a = out
      }

      if (out === null) {
        return true
      }

      return false
    })

    return out
  }

  return {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }
}

/**
 * @param {Array<Mafmt | (() => Mafmt)>} args
 * @returns {Mafmt}
 */
function or (...args) {
  /**
   * @type {PartialMatchesFunction}
   */
  function partialMatch (a) {
    let out = null
    args.some((arg) => {
      const res = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)
      if (res) {
        out = res
        return true
      }
      return false
    })

    return out
  }

  const result = {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }

  return result
}

/**
 * @param {string} n
 * @returns {Mafmt}
 */
function base (n) {
  const name = n

  /**
   * @type {MatchesFunction}
   */
  function matches (a) {
    let ma

    if (typeof a === 'string' || a instanceof Uint8Array) {
      try {
        ma = new Multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's probably not matching as well so return false
      }
    } else {
      ma = a
    }

    const pnames = ma.protoNames()
    if (pnames.length === 1 && pnames[0] === name) {
      return true
    }
    return false
  }

  /**
   * @type {PartialMatchesFunction}
   */
  function partialMatch (protos) {
    if (protos.length === 0) {
      return null
    }

    if (protos[0] === name) {
      return protos.slice(1)
    }
    return null
  }

  return {
    toString: function () { return name },
    matches: matches,
    partialMatch: partialMatch
  }
}

},{"multiaddr":"node_modules/multiaddr/src/index.js"}],"node_modules/libp2p/src/circuit/protocol/index.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-circuit"] || ($protobuf.roots["libp2p-circuit"] = {});

$root.CircuitRelay = function () {
  /**
   * Properties of a CircuitRelay.
   * @exports ICircuitRelay
   * @interface ICircuitRelay
   * @property {CircuitRelay.Type|null} [type] CircuitRelay type
   * @property {CircuitRelay.IPeer|null} [srcPeer] CircuitRelay srcPeer
   * @property {CircuitRelay.IPeer|null} [dstPeer] CircuitRelay dstPeer
   * @property {CircuitRelay.Status|null} [code] CircuitRelay code
   */

  /**
   * Constructs a new CircuitRelay.
   * @exports CircuitRelay
   * @classdesc Represents a CircuitRelay.
   * @implements ICircuitRelay
   * @constructor
   * @param {ICircuitRelay=} [p] Properties to set
   */
  function CircuitRelay(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * CircuitRelay type.
   * @member {CircuitRelay.Type} type
   * @memberof CircuitRelay
   * @instance
   */


  CircuitRelay.prototype.type = 1;
  /**
   * CircuitRelay srcPeer.
   * @member {CircuitRelay.IPeer|null|undefined} srcPeer
   * @memberof CircuitRelay
   * @instance
   */

  CircuitRelay.prototype.srcPeer = null;
  /**
   * CircuitRelay dstPeer.
   * @member {CircuitRelay.IPeer|null|undefined} dstPeer
   * @memberof CircuitRelay
   * @instance
   */

  CircuitRelay.prototype.dstPeer = null;
  /**
   * CircuitRelay code.
   * @member {CircuitRelay.Status} code
   * @memberof CircuitRelay
   * @instance
   */

  CircuitRelay.prototype.code = 100;
  /**
   * Encodes the specified CircuitRelay message. Does not implicitly {@link CircuitRelay.verify|verify} messages.
   * @function encode
   * @memberof CircuitRelay
   * @static
   * @param {ICircuitRelay} m CircuitRelay message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  CircuitRelay.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.type != null && Object.hasOwnProperty.call(m, "type")) w.uint32(8).int32(m.type);
    if (m.srcPeer != null && Object.hasOwnProperty.call(m, "srcPeer")) $root.CircuitRelay.Peer.encode(m.srcPeer, w.uint32(18).fork()).ldelim();
    if (m.dstPeer != null && Object.hasOwnProperty.call(m, "dstPeer")) $root.CircuitRelay.Peer.encode(m.dstPeer, w.uint32(26).fork()).ldelim();
    if (m.code != null && Object.hasOwnProperty.call(m, "code")) w.uint32(32).int32(m.code);
    return w;
  };
  /**
   * Decodes a CircuitRelay message from the specified reader or buffer.
   * @function decode
   * @memberof CircuitRelay
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {CircuitRelay} CircuitRelay
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  CircuitRelay.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.CircuitRelay();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.type = r.int32();
          break;

        case 2:
          m.srcPeer = $root.CircuitRelay.Peer.decode(r, r.uint32());
          break;

        case 3:
          m.dstPeer = $root.CircuitRelay.Peer.decode(r, r.uint32());
          break;

        case 4:
          m.code = r.int32();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a CircuitRelay message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof CircuitRelay
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {CircuitRelay} CircuitRelay
   */


  CircuitRelay.fromObject = function fromObject(d) {
    if (d instanceof $root.CircuitRelay) return d;
    var m = new $root.CircuitRelay();

    switch (d.type) {
      case "HOP":
      case 1:
        m.type = 1;
        break;

      case "STOP":
      case 2:
        m.type = 2;
        break;

      case "STATUS":
      case 3:
        m.type = 3;
        break;

      case "CAN_HOP":
      case 4:
        m.type = 4;
        break;
    }

    if (d.srcPeer != null) {
      if (_typeof(d.srcPeer) !== "object") throw TypeError(".CircuitRelay.srcPeer: object expected");
      m.srcPeer = $root.CircuitRelay.Peer.fromObject(d.srcPeer);
    }

    if (d.dstPeer != null) {
      if (_typeof(d.dstPeer) !== "object") throw TypeError(".CircuitRelay.dstPeer: object expected");
      m.dstPeer = $root.CircuitRelay.Peer.fromObject(d.dstPeer);
    }

    switch (d.code) {
      case "SUCCESS":
      case 100:
        m.code = 100;
        break;

      case "HOP_SRC_ADDR_TOO_LONG":
      case 220:
        m.code = 220;
        break;

      case "HOP_DST_ADDR_TOO_LONG":
      case 221:
        m.code = 221;
        break;

      case "HOP_SRC_MULTIADDR_INVALID":
      case 250:
        m.code = 250;
        break;

      case "HOP_DST_MULTIADDR_INVALID":
      case 251:
        m.code = 251;
        break;

      case "HOP_NO_CONN_TO_DST":
      case 260:
        m.code = 260;
        break;

      case "HOP_CANT_DIAL_DST":
      case 261:
        m.code = 261;
        break;

      case "HOP_CANT_OPEN_DST_STREAM":
      case 262:
        m.code = 262;
        break;

      case "HOP_CANT_SPEAK_RELAY":
      case 270:
        m.code = 270;
        break;

      case "HOP_CANT_RELAY_TO_SELF":
      case 280:
        m.code = 280;
        break;

      case "STOP_SRC_ADDR_TOO_LONG":
      case 320:
        m.code = 320;
        break;

      case "STOP_DST_ADDR_TOO_LONG":
      case 321:
        m.code = 321;
        break;

      case "STOP_SRC_MULTIADDR_INVALID":
      case 350:
        m.code = 350;
        break;

      case "STOP_DST_MULTIADDR_INVALID":
      case 351:
        m.code = 351;
        break;

      case "STOP_RELAY_REFUSED":
      case 390:
        m.code = 390;
        break;

      case "MALFORMED_MESSAGE":
      case 400:
        m.code = 400;
        break;
    }

    return m;
  };
  /**
   * Creates a plain object from a CircuitRelay message. Also converts values to other types if specified.
   * @function toObject
   * @memberof CircuitRelay
   * @static
   * @param {CircuitRelay} m CircuitRelay
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  CircuitRelay.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      d.type = o.enums === String ? "HOP" : 1;
      d.srcPeer = null;
      d.dstPeer = null;
      d.code = o.enums === String ? "SUCCESS" : 100;
    }

    if (m.type != null && m.hasOwnProperty("type")) {
      d.type = o.enums === String ? $root.CircuitRelay.Type[m.type] : m.type;
    }

    if (m.srcPeer != null && m.hasOwnProperty("srcPeer")) {
      d.srcPeer = $root.CircuitRelay.Peer.toObject(m.srcPeer, o);
    }

    if (m.dstPeer != null && m.hasOwnProperty("dstPeer")) {
      d.dstPeer = $root.CircuitRelay.Peer.toObject(m.dstPeer, o);
    }

    if (m.code != null && m.hasOwnProperty("code")) {
      d.code = o.enums === String ? $root.CircuitRelay.Status[m.code] : m.code;
    }

    return d;
  };
  /**
   * Converts this CircuitRelay to JSON.
   * @function toJSON
   * @memberof CircuitRelay
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  CircuitRelay.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  /**
   * Status enum.
   * @name CircuitRelay.Status
   * @enum {number}
   * @property {number} SUCCESS=100 SUCCESS value
   * @property {number} HOP_SRC_ADDR_TOO_LONG=220 HOP_SRC_ADDR_TOO_LONG value
   * @property {number} HOP_DST_ADDR_TOO_LONG=221 HOP_DST_ADDR_TOO_LONG value
   * @property {number} HOP_SRC_MULTIADDR_INVALID=250 HOP_SRC_MULTIADDR_INVALID value
   * @property {number} HOP_DST_MULTIADDR_INVALID=251 HOP_DST_MULTIADDR_INVALID value
   * @property {number} HOP_NO_CONN_TO_DST=260 HOP_NO_CONN_TO_DST value
   * @property {number} HOP_CANT_DIAL_DST=261 HOP_CANT_DIAL_DST value
   * @property {number} HOP_CANT_OPEN_DST_STREAM=262 HOP_CANT_OPEN_DST_STREAM value
   * @property {number} HOP_CANT_SPEAK_RELAY=270 HOP_CANT_SPEAK_RELAY value
   * @property {number} HOP_CANT_RELAY_TO_SELF=280 HOP_CANT_RELAY_TO_SELF value
   * @property {number} STOP_SRC_ADDR_TOO_LONG=320 STOP_SRC_ADDR_TOO_LONG value
   * @property {number} STOP_DST_ADDR_TOO_LONG=321 STOP_DST_ADDR_TOO_LONG value
   * @property {number} STOP_SRC_MULTIADDR_INVALID=350 STOP_SRC_MULTIADDR_INVALID value
   * @property {number} STOP_DST_MULTIADDR_INVALID=351 STOP_DST_MULTIADDR_INVALID value
   * @property {number} STOP_RELAY_REFUSED=390 STOP_RELAY_REFUSED value
   * @property {number} MALFORMED_MESSAGE=400 MALFORMED_MESSAGE value
   */


  CircuitRelay.Status = function () {
    var valuesById = {},
        values = Object.create(valuesById);
    values[valuesById[100] = "SUCCESS"] = 100;
    values[valuesById[220] = "HOP_SRC_ADDR_TOO_LONG"] = 220;
    values[valuesById[221] = "HOP_DST_ADDR_TOO_LONG"] = 221;
    values[valuesById[250] = "HOP_SRC_MULTIADDR_INVALID"] = 250;
    values[valuesById[251] = "HOP_DST_MULTIADDR_INVALID"] = 251;
    values[valuesById[260] = "HOP_NO_CONN_TO_DST"] = 260;
    values[valuesById[261] = "HOP_CANT_DIAL_DST"] = 261;
    values[valuesById[262] = "HOP_CANT_OPEN_DST_STREAM"] = 262;
    values[valuesById[270] = "HOP_CANT_SPEAK_RELAY"] = 270;
    values[valuesById[280] = "HOP_CANT_RELAY_TO_SELF"] = 280;
    values[valuesById[320] = "STOP_SRC_ADDR_TOO_LONG"] = 320;
    values[valuesById[321] = "STOP_DST_ADDR_TOO_LONG"] = 321;
    values[valuesById[350] = "STOP_SRC_MULTIADDR_INVALID"] = 350;
    values[valuesById[351] = "STOP_DST_MULTIADDR_INVALID"] = 351;
    values[valuesById[390] = "STOP_RELAY_REFUSED"] = 390;
    values[valuesById[400] = "MALFORMED_MESSAGE"] = 400;
    return values;
  }();
  /**
   * Type enum.
   * @name CircuitRelay.Type
   * @enum {number}
   * @property {number} HOP=1 HOP value
   * @property {number} STOP=2 STOP value
   * @property {number} STATUS=3 STATUS value
   * @property {number} CAN_HOP=4 CAN_HOP value
   */


  CircuitRelay.Type = function () {
    var valuesById = {},
        values = Object.create(valuesById);
    values[valuesById[1] = "HOP"] = 1;
    values[valuesById[2] = "STOP"] = 2;
    values[valuesById[3] = "STATUS"] = 3;
    values[valuesById[4] = "CAN_HOP"] = 4;
    return values;
  }();

  CircuitRelay.Peer = function () {
    /**
     * Properties of a Peer.
     * @memberof CircuitRelay
     * @interface IPeer
     * @property {Uint8Array} id Peer id
     * @property {Array.<Uint8Array>|null} [addrs] Peer addrs
     */

    /**
     * Constructs a new Peer.
     * @memberof CircuitRelay
     * @classdesc Represents a Peer.
     * @implements IPeer
     * @constructor
     * @param {CircuitRelay.IPeer=} [p] Properties to set
     */
    function Peer(p) {
      this.addrs = [];
      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
      }
    }
    /**
     * Peer id.
     * @member {Uint8Array} id
     * @memberof CircuitRelay.Peer
     * @instance
     */


    Peer.prototype.id = $util.newBuffer([]);
    /**
     * Peer addrs.
     * @member {Array.<Uint8Array>} addrs
     * @memberof CircuitRelay.Peer
     * @instance
     */

    Peer.prototype.addrs = $util.emptyArray;
    /**
     * Encodes the specified Peer message. Does not implicitly {@link CircuitRelay.Peer.verify|verify} messages.
     * @function encode
     * @memberof CircuitRelay.Peer
     * @static
     * @param {CircuitRelay.IPeer} m Peer message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */

    Peer.encode = function encode(m, w) {
      if (!w) w = $Writer.create();
      w.uint32(10).bytes(m.id);

      if (m.addrs != null && m.addrs.length) {
        for (var i = 0; i < m.addrs.length; ++i) {
          w.uint32(18).bytes(m.addrs[i]);
        }
      }

      return w;
    };
    /**
     * Decodes a Peer message from the specified reader or buffer.
     * @function decode
     * @memberof CircuitRelay.Peer
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {CircuitRelay.Peer} Peer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */


    Peer.decode = function decode(r, l) {
      if (!(r instanceof $Reader)) r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l,
          m = new $root.CircuitRelay.Peer();

      while (r.pos < c) {
        var t = r.uint32();

        switch (t >>> 3) {
          case 1:
            m.id = r.bytes();
            break;

          case 2:
            if (!(m.addrs && m.addrs.length)) m.addrs = [];
            m.addrs.push(r.bytes());
            break;

          default:
            r.skipType(t & 7);
            break;
        }
      }

      if (!m.hasOwnProperty("id")) throw $util.ProtocolError("missing required 'id'", {
        instance: m
      });
      return m;
    };
    /**
     * Creates a Peer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CircuitRelay.Peer
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {CircuitRelay.Peer} Peer
     */


    Peer.fromObject = function fromObject(d) {
      if (d instanceof $root.CircuitRelay.Peer) return d;
      var m = new $root.CircuitRelay.Peer();

      if (d.id != null) {
        if (typeof d.id === "string") $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);else if (d.id.length) m.id = d.id;
      }

      if (d.addrs) {
        if (!Array.isArray(d.addrs)) throw TypeError(".CircuitRelay.Peer.addrs: array expected");
        m.addrs = [];

        for (var i = 0; i < d.addrs.length; ++i) {
          if (typeof d.addrs[i] === "string") $util.base64.decode(d.addrs[i], m.addrs[i] = $util.newBuffer($util.base64.length(d.addrs[i])), 0);else if (d.addrs[i].length) m.addrs[i] = d.addrs[i];
        }
      }

      return m;
    };
    /**
     * Creates a plain object from a Peer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CircuitRelay.Peer
     * @static
     * @param {CircuitRelay.Peer} m Peer
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */


    Peer.toObject = function toObject(m, o) {
      if (!o) o = {};
      var d = {};

      if (o.arrays || o.defaults) {
        d.addrs = [];
      }

      if (o.defaults) {
        if (o.bytes === String) d.id = "";else {
          d.id = [];
          if (o.bytes !== Array) d.id = $util.newBuffer(d.id);
        }
      }

      if (m.id != null && m.hasOwnProperty("id")) {
        d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
      }

      if (m.addrs && m.addrs.length) {
        d.addrs = [];

        for (var j = 0; j < m.addrs.length; ++j) {
          d.addrs[j] = o.bytes === String ? $util.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
        }
      }

      return d;
    };
    /**
     * Converts this Peer to JSON.
     * @function toJSON
     * @memberof CircuitRelay.Peer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */


    Peer.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Peer;
  }();

  return CircuitRelay;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/get-iterator/index.js":[function(require,module,exports) {
// If the passed object is an (async) iterable, then get the iterator
// If it's probably an iterator already (i.e. has next function) return it
// else throw
module.exports = function getIterator (obj) {
  if (obj) {
    if (typeof obj[Symbol.iterator] === 'function') {
      return obj[Symbol.iterator]()
    }
    if (typeof obj[Symbol.asyncIterator] === 'function') {
      return obj[Symbol.asyncIterator]()
    }
    if (typeof obj.next === 'function') {
      return obj // probably an iterator
    }
  }
  throw new Error('argument is not an iterator or iterable')
}

},{}],"node_modules/abortable-iterator/AbortError.js":[function(require,module,exports) {
module.exports = class AbortError extends Error {
  constructor (message, code) {
    super(message || 'The operation was aborted')
    this.type = 'aborted'
    this.code = code || 'ABORT_ERR'
  }
}

},{}],"node_modules/abortable-iterator/index.js":[function(require,module,exports) {
const getIterator = require('get-iterator')
const AbortError = require('./AbortError')

// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort
const toAbortableSource = (source, signal, options) => (
  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])
)

const toMultiAbortableSource = (source, signals) => {
  source = getIterator(source)
  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))

  async function * abortable () {
    let nextAbortHandler
    const abortHandler = () => {
      if (nextAbortHandler) nextAbortHandler()
    }

    for (const { signal } of signals) {
      signal.addEventListener('abort', abortHandler)
    }

    while (true) {
      let result
      try {
        for (const { signal, options } of signals) {
          if (signal.aborted) {
            const { abortMessage, abortCode } = options
            throw new AbortError(abortMessage, abortCode)
          }
        }

        const abort = new Promise((resolve, reject) => {
          nextAbortHandler = () => {
            const { options } = signals.find(({ signal }) => signal.aborted)
            const { abortMessage, abortCode } = options
            reject(new AbortError(abortMessage, abortCode))
          }
        })

        // Race the iterator and the abort signals
        result = await Promise.race([abort, source.next()])
        nextAbortHandler = null
      } catch (err) {
        for (const { signal } of signals) {
          signal.removeEventListener('abort', abortHandler)
        }

        // Might not have been aborted by a known signal
        const aborter = signals.find(({ signal }) => signal.aborted)
        const isKnownAborter = err.type === 'aborted' && aborter

        if (isKnownAborter && aborter.options.onAbort) {
          // Do any custom abort handling for the iterator
          await aborter.options.onAbort(source)
        }

        // End the iterator if it is a generator
        if (typeof source.return === 'function') {
          await source.return()
        }

        if (isKnownAborter && aborter.options.returnOnAbort) {
          return
        }

        throw err
      }

      if (result.done) break
      yield result.value
    }

    for (const { signal } of signals) {
      signal.removeEventListener('abort', abortHandler)
    }
  }

  return abortable()
}

const toAbortableSink = (sink, signal, options) => (
  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])
)

const toMultiAbortableSink = (sink, signals) => source => (
  sink(toMultiAbortableSource(source, signals))
)

const toAbortableDuplex = (duplex, signal, options) => (
  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])
)

const toMultiAbortableDuplex = (duplex, signals) => ({
  sink: toMultiAbortableSink(duplex.sink, signals),
  source: toMultiAbortableSource(duplex.source, signals)
})

module.exports = toAbortableSource
module.exports.AbortError = AbortError
module.exports.source = toAbortableSource
module.exports.sink = toAbortableSink
module.exports.transform = toAbortableSink
module.exports.duplex = toAbortableDuplex

},{"get-iterator":"node_modules/get-iterator/index.js","./AbortError":"node_modules/abortable-iterator/AbortError.js"}],"node_modules/libp2p-utils/src/stream-to-ma-conn.js":[function(require,module,exports) {
'use strict'

const { source: abortable } = require('abortable-iterator')
const debug = require('debug')
const log = debug('libp2p:stream:converter')

/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 *
 * @typedef {Object} Timeline
 * @property {number} open - connection opening timestamp.
 * @property {number} [upgraded] - connection upgraded timestamp.
 * @property {number} [close]
 */

/**
 * Convert a duplex iterable into a MultiaddrConnection.
 * https://github.com/libp2p/interface-transport#multiaddrconnection
 *
 * @param {object} streamProperties
 * @param {MuxedStream} streamProperties.stream
 * @param {Multiaddr} streamProperties.remoteAddr
 * @param {Multiaddr} streamProperties.localAddr
 * @param {object} [options]
 * @param {AbortSignal} [options.signal]
 * @returns {import('libp2p-interfaces/src/transport/types').MultiaddrConnection}
 */
function streamToMaConnection ({ stream, remoteAddr, localAddr }, options = {}) {
  const { sink, source } = stream
  const maConn = {
    /**
     * @param {Uint8Array} source
     */
    async sink (source) {
      if (options.signal) {
        // @ts-ignore ts infers source template will be a number
        source = abortable(source, options.signal)
      }

      try {
        await sink(source)
      } catch (err) {
        // If aborted we can safely ignore
        if (err.type !== 'aborted') {
          // If the source errored the socket will already have been destroyed by
          // toIterable.duplex(). If the socket errored it will already be
          // destroyed. There's nothing to do here except log the error & return.
          log(err)
        }
      }
      close()
    },
    source: options.signal ? abortable(source, options.signal) : source,
    conn: stream,
    localAddr,
    remoteAddr,
    /** @type {Timeline} */
    timeline: { open: Date.now(), close: undefined },
    close () {
      sink(new Uint8Array(0))
      return close()
    }
  }

  function close () {
    if (!maConn.timeline.close) {
      maConn.timeline.close = Date.now()
    }
    return Promise.resolve()
  }

  return maConn
}

module.exports = streamToMaConnection

},{"abortable-iterator":"node_modules/abortable-iterator/index.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/libp2p/src/circuit/multicodec.js":[function(require,module,exports) {
'use strict';

module.exports = {
  relay: '/libp2p/circuit/relay/0.1.0'
};
},{}],"node_modules/libp2p/src/circuit/listener.js":[function(require,module,exports) {
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('multiaddr'),
    Multiaddr = _require2.Multiaddr;
/**
 * @typedef {import('libp2p-interfaces/src/transport/types').Listener} Listener
 */

/**
 * @param {import('../')} libp2p
 * @returns {Listener} a transport listener
 */


module.exports = function (libp2p) {
  var listeningAddrs = new Map();
  /**
   * Add swarm handler and listen for incoming connections
   *
   * @param {Multiaddr} addr
   * @returns {Promise<void>}
   */

  function listen(_x) {
    return _listen.apply(this, arguments);
  }
  /**
   * Get fixed up multiaddrs
   *
   * NOTE: This method will grab the peers multiaddrs and expand them such that:
   *
   * a) If it's an existing /p2p-circuit address for a specific relay i.e.
   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the
   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where
   * `QmPeer` is this peers id
   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit
   * addr, such when dialing over a relay with this address, it will create the circuit using
   * the encapsulated transport address. This is useful when for example, a peer should only
   * be dialed over TCP rather than any other transport
   *
   * @returns {Multiaddr[]}
   */


  function _listen() {
    _listen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(addr) {
      var addrString, relayConn, relayedAddr;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              addrString = String(addr).split('/p2p-circuit').find(function (a) {
                return a !== '';
              });
              _context.next = 3;
              return libp2p.dial(new Multiaddr(addrString));

            case 3:
              relayConn = _context.sent;
              relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');
              listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);
              listener.emit('listening');

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _listen.apply(this, arguments);
  }

  function getAddrs() {
    var addrs = [];

    var _iterator = _createForOfIteratorHelper(listeningAddrs.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var addr = _step.value;
        addrs.push(addr);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return addrs;
  }
  /** @type Listener */


  var listener = Object.assign(new EventEmitter(), {
    close: function close() {
      return Promise.resolve();
    },
    listen: listen,
    getAddrs: getAddrs
  }); // Remove listeningAddrs when a peer disconnects

  libp2p.connectionManager.on('peer:disconnect', function (connection) {
    var deleted = listeningAddrs.delete(connection.remotePeer.toB58String());

    if (deleted) {
      // Announce listen addresses change
      listener.emit('close');
    }
  });
  return listener;
};
},{"events":"node_modules/events/events.js","multiaddr":"node_modules/multiaddr/src/index.js"}],"node_modules/libp2p/src/circuit/circuit/utils.js":[function(require,module,exports) {
'use strict';

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var _require2 = require('../protocol'),
    CircuitRelay = _require2.CircuitRelay;
/**
 * @typedef {import('./stream-handler')} StreamHandler
 * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay
 */

/**
 * Write a response
 *
 * @param {StreamHandler} streamHandler
 * @param {import('../protocol').CircuitRelay.Status} status
 */


function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
/**
 * Validate incomming HOP/STOP message
 *
 * @param {ICircuitRelay} msg - A CircuitRelay unencoded protobuf message
 * @param {StreamHandler} streamHandler
 */


function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer && msg.dstPeer.addrs) {
      msg.dstPeer.addrs.forEach(function (addr) {
        return new Multiaddr(addr);
      });
    }
  } catch (err) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err;
  }

  try {
    if (msg.srcPeer && msg.srcPeer.addrs) {
      msg.srcPeer.addrs.forEach(function (addr) {
        return new Multiaddr(addr);
      });
    }
  } catch (err) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err;
  }
}

module.exports = {
  validateAddrs: validateAddrs
};
},{"multiaddr":"node_modules/multiaddr/src/index.js","../protocol":"node_modules/libp2p/src/circuit/protocol/index.js"}],"node_modules/bl/BufferList.js":[function(require,module,exports) {

'use strict'

const { Buffer } = require('buffer')
const symbol = Symbol.for('BufferList')

function BufferList (buf) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf)
  }

  BufferList._init.call(this, buf)
}

BufferList._init = function _init (buf) {
  Object.defineProperty(this, symbol, { value: true })

  this._bufs = []
  this.length = 0

  if (buf) {
    this.append(buf)
  }
}

BufferList.prototype._new = function _new (buf) {
  return new BufferList(buf)
}

BufferList.prototype._offset = function _offset (offset) {
  if (offset === 0) {
    return [0, 0]
  }

  let tot = 0

  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  const bufferId = blOffset[0]
  let offset = blOffset[1]

  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }

  return offset
}

BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }

  const offset = this._offset(index)

  return this._bufs[offset[0]][offset[1]]
}

BufferList.prototype.slice = function slice (start, end) {
  if (typeof start === 'number' && start < 0) {
    start += this.length
  }

  if (typeof end === 'number' && end < 0) {
    end += this.length
  }

  return this.copy(null, 0, start, end)
}

BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== 'number' || srcStart < 0) {
    srcStart = 0
  }

  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
    srcEnd = this.length
  }

  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0)
  }

  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0)
  }

  const copy = !!dst
  const off = this._offset(srcStart)
  const len = srcEnd - srcStart
  let bytes = len
  let bufoff = (copy && dstStart) || 0
  let start = off[1]

  // copy/slice everything
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy) {
      // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) {
    // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)
  }

  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
      bufoff += l
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      bufoff += l
      break
    }

    bytes -= l

    if (start) {
      start = 0
    }
  }

  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff)

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0) {
    start += this.length
  }

  if (end < 0) {
    end += this.length
  }

  if (start === end) {
    return this._new()
  }

  const startOffset = this._offset(start)
  const endOffset = this._offset(end)
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] === 0) {
    buffers.pop()
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
  }

  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1])
  }

  return this._new(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes)
  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }

  return this
}

BufferList.prototype.duplicate = function duplicate () {
  const copy = this._new()

  for (let i = 0; i < this._bufs.length; i++) {
    copy.append(this._bufs[i])
  }

  return copy
}

BufferList.prototype.append = function append (buf) {
  if (buf == null) {
    return this
  }

  if (buf.buffer) {
    // append a view of the underlying ArrayBuffer
    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i])
    }
  } else if (this._isBufferList(buf)) {
    // unwrap argument into individual BufferLists
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i])
    }
  } else {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf === 'number') {
      buf = buf.toString()
    }

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}

BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}

BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }

  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
    search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (this._isBufferList(search)) {
    search = search.slice()
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)

  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  const blOffset = this._offset(offset)
  let blIndex = blOffset[0] // index of which internal buffer we're working on
  let buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex]

    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset

      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset)

        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }

        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset])

        if (this._match(revOffset, search)) {
          return revOffset
        }

        buffOffset++
      }
    }

    buffOffset = 0
  }

  return -1
}

BufferList.prototype._match = function (offset, search) {
  if (this.length - offset < search.length) {
    return false
  }

  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false
    }
  }
  return true
}

;(function () {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  }

  for (const m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      } else {
        BufferList.prototype[m] = function (offset = 0) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())

// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList (b) {
  return b instanceof BufferList || BufferList.isBufferList(b)
}

BufferList.isBufferList = function isBufferList (b) {
  return b != null && b[symbol]
}

module.exports = BufferList

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/it-length-prefixed/src/varint-encode.js":[function(require,module,exports) {

'use strict'

// @ts-ignore no types
const Varint = require('varint')
const { Buffer } = require('buffer')

/**
 * Encode the passed length `value` to the `target` buffer at the given `offset`
 *
 * @type {import('./types').LengthEncoderFunction}
 */
// @ts-ignore cannot declare expected bytes property
const varintEncode = (value, target, offset) => {
  const ret = Varint.encode(value, target, offset)
  varintEncode.bytes = Varint.encode.bytes
  // If no target, create Buffer from returned array
  return target || Buffer.from(ret)
}

module.exports = varintEncode

},{"varint":"node_modules/varint/index.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/it-length-prefixed/src/encode.js":[function(require,module,exports) {

'use strict'

const { Buffer } = require('buffer')
// @ts-ignore
const BufferList = require('bl/BufferList')
const varintEncode = require('./varint-encode')

const MIN_POOL_SIZE = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length
const DEFAULT_POOL_SIZE = 10 * 1024

/**
 * @param {import('./types').EncoderOptions} [options]
 */
function encode (options) {
  options = options || {}

  const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE)
  const encodeLength = options.lengthEncoder || varintEncode

  /**
   * @param {AsyncIterable<BufferList>} source
   */
  const encoder = async function * (source) {
    let pool = Buffer.alloc(poolSize)
    let poolOffset = 0

    for await (const chunk of source) {
      encodeLength(chunk.length, pool, poolOffset)
      const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes)
      poolOffset += encodeLength.bytes

      if (pool.length - poolOffset < MIN_POOL_SIZE) {
        pool = Buffer.alloc(poolSize)
        poolOffset = 0
      }

      yield new BufferList().append(encodedLength).append(chunk)
      // yield Buffer.concat([encodedLength, chunk])
    }
  }

  return encoder
}

/**
 * @param {BufferList | Buffer} chunk
 * @param {import('./types').EncoderOptions} [options]
 */
encode.single = (chunk, options) => {
  options = options || {}
  const encodeLength = options.lengthEncoder || varintEncode
  return new BufferList([encodeLength(chunk.length), chunk.slice()])
}

module.exports = encode
module.exports.MIN_POOL_SIZE = MIN_POOL_SIZE
module.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","bl/BufferList":"node_modules/bl/BufferList.js","./varint-encode":"node_modules/it-length-prefixed/src/varint-encode.js"}],"node_modules/it-length-prefixed/src/varint-decode.js":[function(require,module,exports) {

'use strict'

// @ts-ignore no types
const Varint = require('varint')
const { Buffer } = require('buffer')

/**
 * @param {any} bl
 */
const toBufferProxy = bl => new Proxy({}, {
  get: (_, prop) => {
    // @ts-ignore magic
    return prop[0] === 'l' ? bl[prop] : bl.get(parseInt(prop))
  }
})

/**
 * @type {import('./types').LengthDecoderFunction}
 */
// @ts-ignore cannot declare expected bytes property
const varintDecode = data => {
  const len = Varint.decode(Buffer.isBuffer(data) ? data : toBufferProxy(data))
  varintDecode.bytes = Varint.decode.bytes
  return len
}

module.exports = varintDecode

},{"varint":"node_modules/varint/index.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/it-length-prefixed/src/decode.js":[function(require,module,exports) {

'use strict'

const { Buffer } = require('buffer')
// @ts-ignore
const BufferList = require('bl/BufferList')
const varintDecode = require('./varint-decode')

// Maximum length of the length section of the message
const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length
// Maximum length of the data section of the message
const MAX_DATA_LENGTH = 1024 * 1024 * 4

const Empty = Buffer.alloc(0)
const ReadModes = { LENGTH: 'readLength', DATA: 'readData' }

const ReadHandlers = {
  /**
   * @param {BufferList} chunk
   * @param {BufferList} buffer
   * @param {import('./types').ReadState | undefined} state
   * @param {import('./types').DecoderOptions} options
   * @returns {import('./types').ReadResult}
   */
  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {
    // console.log(ReadModes.LENGTH, chunk.length)
    buffer = buffer.append(chunk)

    let dataLength
    try {
      dataLength = options.lengthDecoder(buffer)
    } catch (err) {
      if (buffer.length > options.maxLengthLength) {
        throw Object.assign(err, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })
      }
      if (err instanceof RangeError) {
        return { mode: ReadModes.LENGTH, buffer, chunk: undefined, state: undefined, data: undefined }
      }
      throw err
    }

    if (dataLength > options.maxDataLength) {
      throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })
    }

    chunk = buffer.shallowSlice(options.lengthDecoder.bytes)
    buffer = new BufferList()

    if (options.onLength) options.onLength(dataLength)

    if (dataLength <= 0) {
      if (options.onData) options.onData(Empty)
      return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty }
    }

    return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: undefined }
  },

  /**
   * @param {BufferList} chunk
   * @param {BufferList} buffer
   * @param {import('./types').ReadState | undefined} state
   * @param {import('./types').DecoderOptions} options
   * @returns {import('./types').ReadResult}
   */
  [ReadModes.DATA]: (chunk, buffer, state, options) => {
    // console.log(ReadModes.DATA, chunk.length)
    buffer = buffer.append(chunk)

    if (!state) {
      throw new Error('state is required')
    }

    if (buffer.length < state.dataLength) {
      return { mode: ReadModes.DATA, buffer, state, chunk: undefined, data: undefined }
    }

    const { dataLength } = state
    const data = buffer.shallowSlice(0, dataLength)

    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined
    buffer = new BufferList()

    if (options.onData) options.onData(data)
    return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: undefined, data }
  }
}

/**
 * @param {any} [options]
 */
function decode (options) {
  options = options || {}

  /**
   * @type {import('./types').DecoderOptions}
   */
  const opts = {
    lengthDecoder: options.lengthDecoder || varintDecode,
    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
    onLength: options.onLength,
    onData: options.onData
  }

  /**
   * @param {AsyncIterable<BufferList>} source
   */
  const decoder = async function * (source) {
    let buffer = new BufferList()
    let mode = ReadModes.LENGTH // current parsing mode
    let state // accumulated state for the current mode

    for await (const chunk of source) {
      /** @type {BufferList | undefined} */
      let nextChunk = chunk

      // Each chunk may contain multiple messages - keep calling handler for the
      // current parsing mode until all handlers have consumed the chunk.
      while (nextChunk) {
        const result = ReadHandlers[mode](nextChunk, buffer, state, opts)

        mode = result.mode
        nextChunk = result.chunk
        buffer = result.buffer
        state = result.state

        if (result.data) {
          yield result.data
        }
      }
    }

    if (buffer.length) {
      throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })
    }
  }

  return decoder
}

/**
 * @param {*} reader
 * @param {import('./types').DecoderOptions} [options]
 * @returns
 */
decode.fromReader = (reader, options) => {
  let byteLength = 1 // Read single byte chunks until the length is known

  const varByteSource = {
    [Symbol.asyncIterator] () { return this },
    next: async () => {
      try {
        return await reader.next(byteLength)
      } catch (err) {
        if (err.code === 'ERR_UNDER_READ') {
          return { done: true, value: null }
        }
        throw err
      } finally {
        // Reset the byteLength so we continue to check for varints
        byteLength = 1
      }
    }
  }

  /**
   * Once the length has been parsed, read chunk for that length
   *
   * @param {number} l
   */
  const onLength = l => { byteLength = l }
  return decode({
    ...(options || {}),
    onLength
  })(varByteSource)
}

module.exports = decode
module.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH
module.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","bl/BufferList":"node_modules/bl/BufferList.js","./varint-decode":"node_modules/it-length-prefixed/src/varint-decode.js"}],"node_modules/it-length-prefixed/src/int32BE-encode.js":[function(require,module,exports) {

'use strict'

const { Buffer } = require('buffer')

/**
 * @param {number} value
 * @param {Buffer} target
 * @param {number} offset
 */
const int32BEEncode = (value, target, offset) => {
  target = target || Buffer.allocUnsafe(4)
  target.writeInt32BE(value, offset)
  return target
}

int32BEEncode.bytes = 4 // Always because fixed length

module.exports = int32BEEncode

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/it-length-prefixed/src/int32BE-decode.js":[function(require,module,exports) {
'use strict'

/**
 * @param {import('buffer').Buffer} data
 */
const int32BEDecode = data => {
  if (data.length < 4) throw RangeError('Could not decode int32BE')
  return data.readInt32BE(0)
}

int32BEDecode.bytes = 4 // Always because fixed length

module.exports = int32BEDecode

},{}],"node_modules/it-length-prefixed/src/index.js":[function(require,module,exports) {
'use strict'

/**
 * @typedef {import('./types').EncoderOptions} EncoderOptions
 * @typedef {import('./types').DecoderOptions} DecoderOptions
 */

exports.encode = require('./encode')
exports.decode = require('./decode')

exports.varintEncode = require('./varint-encode')
exports.varintDecode = require('./varint-decode')

exports.int32BEEncode = require('./int32BE-encode')
exports.int32BEDecode = require('./int32BE-decode')

},{"./encode":"node_modules/it-length-prefixed/src/encode.js","./decode":"node_modules/it-length-prefixed/src/decode.js","./varint-encode":"node_modules/it-length-prefixed/src/varint-encode.js","./varint-decode":"node_modules/it-length-prefixed/src/varint-decode.js","./int32BE-encode":"node_modules/it-length-prefixed/src/int32BE-encode.js","./int32BE-decode":"node_modules/it-length-prefixed/src/int32BE-decode.js"}],"node_modules/it-reader/index.js":[function(require,module,exports) {
const BufferList = require('bl/BufferList')

module.exports = source => {
  const reader = (async function * () {
    let bytes = yield // Allows us to receive 8 when reader.next(8) is called
    let bl = new BufferList()

    for await (const chunk of source) {
      if (!bytes) {
        bytes = yield bl.append(chunk)
        bl = new BufferList()
        continue
      }

      bl.append(chunk)

      while (bl.length >= bytes) {
        const data = bl.shallowSlice(0, bytes)
        bl.consume(bytes)
        bytes = yield data

        // If we no longer want a specific byte length, we yield the rest now
        if (!bytes) {
          if (bl.length) {
            bytes = yield bl
            bl = new BufferList()
          }
          break // bytes is null and/or no more buffer to yield
        }
      }
    }

    // Consumer wants more bytes but the source has ended and our buffer
    // is not big enough to satisfy.
    if (bytes) {
      throw Object.assign(
        new Error(`stream ended before ${bytes} bytes became available`),
        { code: 'ERR_UNDER_READ', buffer: bl }
      )
    }
  })()

  reader.next()
  return reader
}

},{"bl/BufferList":"node_modules/bl/BufferList.js"}],"node_modules/p-defer/index.js":[function(require,module,exports) {
'use strict';

var pDefer = function pDefer() {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

module.exports = pDefer;
},{}],"node_modules/it-handshake/src/index.js":[function(require,module,exports) {
'use strict'

const Reader = require('it-reader')
const Writer = require('it-pushable')
const defer = require('p-defer')

// Convert a duplex stream into a reader and writer and rest stream
module.exports = stream => {
  const writer = Writer() // Write bytes on demand to the sink
  const reader = Reader(stream.source) // Read bytes on demand from the source

  // Waits for a source to be passed to the rest stream's sink
  const sourcePromise = defer()
  let sinkErr

  const sinkPromise = stream.sink((async function * () {
    yield * writer
    const source = await sourcePromise.promise
    yield * source
  })())

  sinkPromise.catch(err => {
    sinkErr = err
  })

  const rest = {
    sink: source => {
      if (sinkErr) {
        return Promise.reject(sinkErr)
      }

      sourcePromise.resolve(source)
      return sinkPromise
    },
    source: reader
  }

  return {
    reader,
    writer,
    stream: rest,
    rest: () => writer.end(),
    write: writer.push,
    read: async () => {
      return (await reader.next()).value
    }
  }
}

},{"it-reader":"node_modules/it-reader/index.js","it-pushable":"node_modules/it-pushable/index.js","p-defer":"node_modules/p-defer/index.js"}],"node_modules/libp2p/src/circuit/circuit/stream-handler.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:circuit:stream-handler'), {
  error: debug('libp2p:circuit:stream-handler:err')
});

var lp = require('it-length-prefixed'); // @ts-ignore it-handshake does not export types


var handshake = require('it-handshake');

var _require = require('../protocol'),
    CircuitRelay = _require.CircuitRelay;
/**
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay
 */


var StreamHandler = /*#__PURE__*/function () {
  /**
   * Create a stream handler for connection
   *
   * @class
   * @param {object} options
   * @param {MuxedStream} options.stream - A duplex iterable
   * @param {number} [options.maxLength = 4096] - max bytes length of message
   */
  function StreamHandler(_ref) {
    var stream = _ref.stream,
        _ref$maxLength = _ref.maxLength,
        maxLength = _ref$maxLength === void 0 ? 4096 : _ref$maxLength;

    _classCallCheck(this, StreamHandler);

    this.stream = stream;
    this.shake = handshake(this.stream); // @ts-ignore options are not optional

    this.decoder = lp.decode.fromReader(this.shake.reader, {
      maxDataLength: maxLength
    });
  }
  /**
   * Read and decode message
   *
   * @async
   */


  _createClass(StreamHandler, [{
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var msg, value;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.decoder.next();

              case 2:
                msg = _context.sent;

                if (!msg.value) {
                  _context.next = 7;
                  break;
                }

                value = CircuitRelay.decode(msg.value.slice());
                log('read message type', value.type);
                return _context.abrupt("return", value);

              case 7:
                log('read received no value, closing stream'); // End the stream, we didn't get data

                this.close();

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }()
    /**
     * Encode and write array of buffers
     *
     * @param {ICircuitRelay} msg - An unencoded CircuitRelay protobuf message
     * @returns {void}
     */

  }, {
    key: "write",
    value: function write(msg) {
      log('write message type %s', msg.type); // @ts-ignore lp.encode expects type type 'Buffer | BufferList', not 'Uint8Array'

      this.shake.write(lp.encode.single(CircuitRelay.encode(msg).finish()));
    }
    /**
     * Return the handshake rest stream and invalidate handler
     *
     * @returns {*} A duplex iterable
     */

  }, {
    key: "rest",
    value: function rest() {
      this.shake.rest();
      return this.shake.stream;
    }
    /**
     * @param {ICircuitRelay} msg - An unencoded CircuitRelay protobuf message
     */

  }, {
    key: "end",
    value: function end(msg) {
      this.write(msg);
      this.close();
    }
    /**
     * Close the stream
     *
     * @returns {void}
     */

  }, {
    key: "close",
    value: function close() {
      log('closing the stream');
      this.rest().sink([]);
    }
  }]);

  return StreamHandler;
}();

module.exports = StreamHandler;
},{"debug":"node_modules/debug/src/browser.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","it-handshake":"node_modules/it-handshake/src/index.js","../protocol":"node_modules/libp2p/src/circuit/protocol/index.js"}],"node_modules/libp2p/src/circuit/circuit/stop.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:circuit:stop'), {
  error: debug('libp2p:circuit:stop:err')
});

var _require = require('../protocol'),
    CircuitPB = _require.CircuitRelay;

var multicodec = require('../multicodec');

var StreamHandler = require('./stream-handler');

var _require2 = require('./utils'),
    validateAddrs = _require2.validateAddrs;
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay
 */

/**
 * Handles incoming STOP requests
 *
 * @private
 * @param {Object} options
 * @param {Connection} options.connection
 * @param {ICircuitRelay} options.request - The CircuitRelay protobuf request (unencoded)
 * @param {StreamHandler} options.streamHandler
 * @returns {Promise<MuxedStream>|void} Resolves a duplex iterable
 */


module.exports.handleStop = function handleStop(_ref) {
  var connection = _ref.connection,
      request = _ref.request,
      streamHandler = _ref.streamHandler;

  // Validate the STOP request has the required input
  try {
    validateAddrs(request, streamHandler);
  } catch (err) {
    return log.error('invalid stop request via peer %s', connection.remotePeer.toB58String(), err);
  } // The request is valid


  log('stop request is valid');
  streamHandler.write({
    type: CircuitPB.Type.STATUS,
    code: CircuitPB.Status.SUCCESS
  });
  return streamHandler.rest();
};
/**
 * Creates a STOP request
 *
 * @private
 * @param {Object} options
 * @param {Connection} options.connection
 * @param {ICircuitRelay} options.request - The CircuitRelay protobuf request (unencoded)
 * @returns {Promise<MuxedStream|void>} Resolves a duplex iterable
 */


module.exports.stop = /*#__PURE__*/function () {
  var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
    var connection, request, _yield$connection$new, stream, streamHandler, response;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            connection = _ref2.connection, request = _ref2.request;
            _context.next = 3;
            return connection.newStream([multicodec.relay]);

          case 3:
            _yield$connection$new = _context.sent;
            stream = _yield$connection$new.stream;
            log('starting stop request to %s', connection.remotePeer.toB58String());
            streamHandler = new StreamHandler({
              stream: stream
            });
            streamHandler.write(request);
            _context.next = 10;
            return streamHandler.read();

          case 10:
            response = _context.sent;

            if (response) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return", streamHandler.close());

          case 13:
            if (!(response.code === CircuitPB.Status.SUCCESS)) {
              _context.next = 16;
              break;
            }

            log('stop request to %s was successful', connection.remotePeer.toB58String());
            return _context.abrupt("return", streamHandler.rest());

          case 16:
            log('stop request failed with code %d', response.code);
            streamHandler.close();

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function stop(_x) {
    return _stop.apply(this, arguments);
  }

  return stop;
}();
},{"debug":"node_modules/debug/src/browser.js","../protocol":"node_modules/libp2p/src/circuit/protocol/index.js","../multicodec":"node_modules/libp2p/src/circuit/multicodec.js","./stream-handler":"node_modules/libp2p/src/circuit/circuit/stream-handler.js","./utils":"node_modules/libp2p/src/circuit/circuit/utils.js"}],"node_modules/libp2p/src/circuit/circuit/hop.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:circuit:hop'), {
  error: debug('libp2p:circuit:hop:err')
});

var errCode = require('err-code');

var PeerId = require('peer-id');

var _require = require('./utils'),
    validateAddrs = _require.validateAddrs;

var StreamHandler = require('./stream-handler');

var _require2 = require('../protocol'),
    CircuitPB = _require2.CircuitRelay;

var _require3 = require('it-pipe'),
    pipe = _require3.pipe;

var _require4 = require('../../errors'),
    Errors = _require4.codes;

var _require5 = require('./stop'),
    stop = _require5.stop;

var multicodec = require('./../multicodec');
/**
 * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('../transport')} Transport
 */

/**
 * @typedef {Object} HopRequest
 * @property {Connection} connection
 * @property {ICircuitRelay} request
 * @property {StreamHandler} streamHandler
 * @property {Transport} circuit
 */

/**
 * @param {HopRequest} options
 * @returns {Promise<void>}
 */


function handleHop(_x) {
  return _handleHop.apply(this, arguments);
}
/**
 * Performs a HOP request to a relay peer, to request a connection to another
 * peer. A new, virtual, connection will be created between the two via the relay.
 *
 * @param {object} options
 * @param {Connection} options.connection - Connection to the relay
 * @param {ICircuitRelay} options.request
 * @returns {Promise<MuxedStream>}
 */


function _handleHop() {
  _handleHop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var connection, request, streamHandler, circuit, destinationPeer, destinationConnection, stopRequest, destinationStream, sourceStream;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            connection = _ref.connection, request = _ref.request, streamHandler = _ref.streamHandler, circuit = _ref.circuit;

            if (circuit._options.hop.enabled) {
              _context.next = 4;
              break;
            }

            log('HOP request received but we are not acting as a relay');
            return _context.abrupt("return", streamHandler.end({
              type: CircuitPB.Type.STATUS,
              code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY
            }));

          case 4:
            _context.prev = 4;
            validateAddrs(request, streamHandler);
            _context.next = 11;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](4);
            return _context.abrupt("return", log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), _context.t0));

          case 11:
            if (request.dstPeer) {
              _context.next = 14;
              break;
            }

            log('HOP request received but we do not receive a dstPeer');
            return _context.abrupt("return");

          case 14:
            // Get the connection to the destination (stop) peer
            destinationPeer = new PeerId(request.dstPeer.id);
            destinationConnection = circuit._connectionManager.get(destinationPeer);

            if (!(!destinationConnection && !circuit._options.hop.active)) {
              _context.next = 19;
              break;
            }

            log('HOP request received but we are not connected to the destination peer');
            return _context.abrupt("return", streamHandler.end({
              type: CircuitPB.Type.STATUS,
              code: CircuitPB.Status.HOP_NO_CONN_TO_DST
            }));

          case 19:
            if (destinationConnection) {
              _context.next = 21;
              break;
            }

            return _context.abrupt("return");

          case 21:
            // Handle the incoming HOP request by performing a STOP request
            stopRequest = {
              type: CircuitPB.Type.STOP,
              dstPeer: request.dstPeer,
              srcPeer: request.srcPeer
            };
            _context.prev = 22;
            _context.next = 25;
            return stop({
              connection: destinationConnection,
              request: stopRequest
            });

          case 25:
            destinationStream = _context.sent;
            _context.next = 31;
            break;

          case 28:
            _context.prev = 28;
            _context.t1 = _context["catch"](22);
            return _context.abrupt("return", log.error(_context.t1));

          case 31:
            log('hop request from %s is valid', connection.remotePeer.toB58String());
            streamHandler.write({
              type: CircuitPB.Type.STATUS,
              code: CircuitPB.Status.SUCCESS
            });
            sourceStream = streamHandler.rest(); // Short circuit the two streams to create the relayed connection

            return _context.abrupt("return", pipe(sourceStream, destinationStream, sourceStream));

          case 35:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 8], [22, 28]]);
  }));
  return _handleHop.apply(this, arguments);
}

function hop(_x2) {
  return _hop.apply(this, arguments);
}
/**
 * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities.
 *
 * @param {object} options
 * @param {Connection} options.connection - Connection to the relay
 * @returns {Promise<boolean>}
 */


function _hop() {
  _hop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
    var connection, request, _yield$connection$new, stream, streamHandler, response;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref2.connection, request = _ref2.request;
            _context2.next = 3;
            return connection.newStream([multicodec.relay]);

          case 3:
            _yield$connection$new = _context2.sent;
            stream = _yield$connection$new.stream;
            // Send the HOP request
            streamHandler = new StreamHandler({
              stream: stream
            });
            streamHandler.write(request);
            _context2.next = 9;
            return streamHandler.read();

          case 9:
            response = _context2.sent;

            if (response) {
              _context2.next = 12;
              break;
            }

            throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED);

          case 12:
            if (!(response.code === CircuitPB.Status.SUCCESS)) {
              _context2.next = 15;
              break;
            }

            log('hop request was successful');
            return _context2.abrupt("return", streamHandler.rest());

          case 15:
            log('hop request failed with code %d, closing stream', response.code);
            streamHandler.close();
            throw errCode(new Error("HOP request failed with code ".concat(response.code)), Errors.ERR_HOP_REQUEST_FAILED);

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _hop.apply(this, arguments);
}

function canHop(_x3) {
  return _canHop.apply(this, arguments);
}
/**
 * Creates an unencoded CAN_HOP response based on the Circuits configuration
 *
 * @param {Object} options
 * @param {Connection} options.connection
 * @param {StreamHandler} options.streamHandler
 * @param {Transport} options.circuit
 * @private
 */


function _canHop() {
  _canHop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
    var connection, _yield$connection$new2, stream, streamHandler, response;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            connection = _ref3.connection;
            _context3.next = 3;
            return connection.newStream([multicodec.relay]);

          case 3:
            _yield$connection$new2 = _context3.sent;
            stream = _yield$connection$new2.stream;
            // Send the HOP request
            streamHandler = new StreamHandler({
              stream: stream
            });
            streamHandler.write({
              type: CircuitPB.Type.CAN_HOP
            });
            _context3.next = 9;
            return streamHandler.read();

          case 9:
            response = _context3.sent;
            _context3.next = 12;
            return streamHandler.close();

          case 12:
            if (!(!response || response.code !== CircuitPB.Status.SUCCESS)) {
              _context3.next = 14;
              break;
            }

            return _context3.abrupt("return", false);

          case 14:
            return _context3.abrupt("return", true);

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _canHop.apply(this, arguments);
}

function handleCanHop(_ref4) {
  var connection = _ref4.connection,
      streamHandler = _ref4.streamHandler,
      circuit = _ref4.circuit;
  var canHop = circuit._options.hop.enabled;
  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String());
  streamHandler.end({
    type: CircuitPB.Type.STATUS,
    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY
  });
}

module.exports = {
  handleHop: handleHop,
  hop: hop,
  canHop: canHop,
  handleCanHop: handleCanHop
};
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","peer-id":"node_modules/peer-id/src/index.js","./utils":"node_modules/libp2p/src/circuit/circuit/utils.js","./stream-handler":"node_modules/libp2p/src/circuit/circuit/stream-handler.js","../protocol":"node_modules/libp2p/src/circuit/protocol/index.js","it-pipe":"node_modules/it-pipe/index.js","../../errors":"node_modules/libp2p/src/errors.js","./stop":"node_modules/libp2p/src/circuit/circuit/stop.js","./../multicodec":"node_modules/libp2p/src/circuit/multicodec.js"}],"node_modules/libp2p/src/circuit/transport.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:circuit'), {
  error: debug('libp2p:circuit:err')
});

var errCode = require('err-code');

var mafmt = require('mafmt');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var PeerId = require('peer-id');

var _require2 = require('./protocol'),
    CircuitPB = _require2.CircuitRelay;

var _require3 = require('../errors'),
    codes = _require3.codes;

var toConnection = require('libp2p-utils/src/stream-to-ma-conn');

var _require4 = require('./multicodec'),
    multicodec = _require4.relay;

var _createListener = require('./listener');

var _require5 = require('./circuit/hop'),
    handleCanHop = _require5.handleCanHop,
    handleHop = _require5.handleHop,
    hop = _require5.hop;

var _require6 = require('./circuit/stop'),
    handleStop = _require6.handleStop;

var StreamHandler = require('./circuit/stream-handler');

var transportSymbol = Symbol.for('@libp2p/js-libp2p-circuit/circuit');
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 */

var Circuit = /*#__PURE__*/function (_Symbol$toStringTag) {
  /**
   * Creates an instance of the Circuit Transport.
   *
   * @class
   * @param {object} options
   * @param {import('../')} options.libp2p
   * @param {import('../upgrader')} options.upgrader
   */
  function Circuit(_ref) {
    var libp2p = _ref.libp2p,
        upgrader = _ref.upgrader;

    _classCallCheck(this, Circuit);

    this._dialer = libp2p.dialer;
    this._registrar = libp2p.registrar;
    this._connectionManager = libp2p.connectionManager;
    this._upgrader = upgrader;
    this._options = libp2p._config.relay;
    this._libp2p = libp2p;
    this.peerId = libp2p.peerId;

    this._registrar.handle(multicodec, this._onProtocol.bind(this));
  }
  /**
   * @param {Object} props
   * @param {Connection} props.connection
   * @param {MuxedStream} props.stream
   */


  _createClass(Circuit, [{
    key: "_onProtocol",
    value: function () {
      var _onProtocol2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
        var connection, stream, streamHandler, request, circuit, virtualConnection, remoteAddr, localAddr, maConn, type, conn;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                connection = _ref2.connection, stream = _ref2.stream;

                /** @type {import('./circuit/stream-handler')} */
                streamHandler = new StreamHandler({
                  stream: stream
                });
                _context.next = 4;
                return streamHandler.read();

              case 4:
                request = _context.sent;

                if (request) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return");

              case 7:
                circuit = this;
                _context.t0 = request.type;
                _context.next = _context.t0 === CircuitPB.Type.CAN_HOP ? 11 : _context.t0 === CircuitPB.Type.HOP ? 15 : _context.t0 === CircuitPB.Type.STOP ? 20 : 25;
                break;

              case 11:
                log('received CAN_HOP request from %s', connection.remotePeer.toB58String());
                _context.next = 14;
                return handleCanHop({
                  circuit: circuit,
                  connection: connection,
                  streamHandler: streamHandler
                });

              case 14:
                return _context.abrupt("break", 26);

              case 15:
                log('received HOP request from %s', connection.remotePeer.toB58String());
                _context.next = 18;
                return handleHop({
                  connection: connection,
                  request: request,
                  streamHandler: streamHandler,
                  circuit: circuit
                });

              case 18:
                virtualConnection = _context.sent;
                return _context.abrupt("break", 26);

              case 20:
                log('received STOP request from %s', connection.remotePeer.toB58String());
                _context.next = 23;
                return handleStop({
                  connection: connection,
                  request: request,
                  streamHandler: streamHandler
                });

              case 23:
                virtualConnection = _context.sent;
                return _context.abrupt("break", 26);

              case 25:
                log('Request of type %s not supported', request.type);

              case 26:
                if (!virtualConnection) {
                  _context.next = 37;
                  break;
                }

                // @ts-ignore dst peer will not be undefined
                remoteAddr = new Multiaddr(request.dstPeer.addrs[0]); // @ts-ignore src peer will not be undefined

                localAddr = new Multiaddr(request.srcPeer.addrs[0]);
                maConn = toConnection({
                  stream: virtualConnection,
                  remoteAddr: remoteAddr,
                  localAddr: localAddr
                });
                type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound';
                log('new %s connection %s', type, maConn.remoteAddr);
                _context.next = 34;
                return this._upgrader.upgradeInbound(maConn);

              case 34:
                conn = _context.sent;
                log('%s connection %s upgraded', type, maConn.remoteAddr);
                this.handler && this.handler(conn);

              case 37:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _onProtocol(_x) {
        return _onProtocol2.apply(this, arguments);
      }

      return _onProtocol;
    }()
    /**
     * Dial a peer over a relay
     *
     * @param {Multiaddr} ma - the multiaddr of the peer to dial
     * @param {Object} options - dial options
     * @param {AbortSignal} [options.signal] - An optional abort signal
     * @returns {Promise<Connection>} - the connection
     */

  }, {
    key: "dial",
    value: function () {
      var _dial = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(ma, options) {
        var addrs, relayAddr, destinationAddr, relayId, destinationId, errMsg, relayPeer, destinationPeer, disconnectOnFailure, relayConnection, virtualConnection, localAddr, maConn;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Check the multiaddr to see if it contains a relay and a destination peer
                addrs = ma.toString().split('/p2p-circuit');
                relayAddr = new Multiaddr(addrs[0]);
                destinationAddr = new Multiaddr(addrs[addrs.length - 1]);
                relayId = relayAddr.getPeerId();
                destinationId = destinationAddr.getPeerId();

                if (!(!relayId || !destinationId)) {
                  _context2.next = 9;
                  break;
                }

                errMsg = 'Circuit relay dial failed as addresses did not have peer id';
                log.error(errMsg);
                throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL);

              case 9:
                relayPeer = PeerId.createFromB58String(relayId);
                destinationPeer = PeerId.createFromB58String(destinationId);
                disconnectOnFailure = false;
                relayConnection = this._connectionManager.get(relayPeer);

                if (relayConnection) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 16;
                return this._dialer.connectToPeer(relayAddr, options);

              case 16:
                relayConnection = _context2.sent;
                disconnectOnFailure = true;

              case 18:
                _context2.prev = 18;
                _context2.next = 21;
                return hop({
                  connection: relayConnection,
                  request: {
                    type: CircuitPB.Type.HOP,
                    srcPeer: {
                      id: this.peerId.toBytes(),
                      addrs: this._libp2p.multiaddrs.map(function (addr) {
                        return addr.bytes;
                      })
                    },
                    dstPeer: {
                      id: destinationPeer.toBytes(),
                      addrs: [new Multiaddr(destinationAddr).bytes]
                    }
                  }
                });

              case 21:
                virtualConnection = _context2.sent;
                localAddr = relayAddr.encapsulate("/p2p-circuit/p2p/".concat(this.peerId.toB58String()));
                maConn = toConnection({
                  stream: virtualConnection,
                  remoteAddr: ma,
                  localAddr: localAddr
                });
                log('new outbound connection %s', maConn.remoteAddr);
                return _context2.abrupt("return", this._upgrader.upgradeOutbound(maConn));

              case 28:
                _context2.prev = 28;
                _context2.t0 = _context2["catch"](18);
                log.error('Circuit relay dial failed', _context2.t0);
                _context2.t1 = disconnectOnFailure;

                if (!_context2.t1) {
                  _context2.next = 35;
                  break;
                }

                _context2.next = 35;
                return relayConnection.close();

              case 35:
                throw _context2.t0;

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[18, 28]]);
      }));

      function dial(_x2, _x3) {
        return _dial.apply(this, arguments);
      }

      return dial;
    }()
    /**
     * Create a listener
     *
     * @param {any} options
     * @param {Function} handler
     * @returns {import('libp2p-interfaces/src/transport/types').Listener}
     */

  }, {
    key: "createListener",
    value: function createListener(options, handler) {
      if (typeof options === 'function') {
        handler = options;
        options = {};
      } // Called on successful HOP and STOP requests


      this.handler = handler;
      return _createListener(this._libp2p);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial on
     *
     * @param {Multiaddr[]} multiaddrs
     * @returns {Multiaddr[]}
     */

  }, {
    key: "filter",
    value: function filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter(function (ma) {
        return mafmt.Circuit.matches(ma);
      });
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'Circuit';
    }
    /**
     * Checks if the given value is a Transport instance.
     *
     * @param {any} other
     * @returns {other is Transport}
     */

  }], [{
    key: "isTransport",
    value: function isTransport(other) {
      return Boolean(other && other[transportSymbol]);
    }
  }]);

  return Circuit;
}(Symbol.toStringTag);

module.exports = Circuit;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","mafmt":"node_modules/mafmt/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js","./protocol":"node_modules/libp2p/src/circuit/protocol/index.js","../errors":"node_modules/libp2p/src/errors.js","libp2p-utils/src/stream-to-ma-conn":"node_modules/libp2p-utils/src/stream-to-ma-conn.js","./multicodec":"node_modules/libp2p/src/circuit/multicodec.js","./listener":"node_modules/libp2p/src/circuit/listener.js","./circuit/hop":"node_modules/libp2p/src/circuit/circuit/hop.js","./circuit/stop":"node_modules/libp2p/src/circuit/circuit/stop.js","./circuit/stream-handler":"node_modules/libp2p/src/circuit/circuit/stream-handler.js"}],"node_modules/libp2p/src/circuit/utils.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/cid'),
    CID = _require.CID;

var _require2 = require('multiformats/hashes/sha2'),
    sha256 = _require2.sha256;
/**
 * Convert a namespace string into a cid.
 *
 * @param {string} namespace
 * @returns {Promise<CID>}
 */


module.exports.namespaceToCid = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(namespace) {
    var bytes, hash;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            bytes = new TextEncoder().encode(namespace);
            _context.next = 3;
            return sha256.digest(bytes);

          case 3:
            hash = _context.sent;
            return _context.abrupt("return", CID.createV0(hash));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
},{"multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js"}],"node_modules/libp2p/src/circuit/auto-relay.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:auto-relay'), {
  error: debug('libp2p:auto-relay:err')
});

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var PeerId = require('peer-id');

var _require2 = require('./multicodec'),
    multicodec = _require2.relay;

var _require3 = require('./circuit/hop'),
    canHop = _require3.canHop;

var _require4 = require('./utils'),
    namespaceToCid = _require4.namespaceToCid;

var _require5 = require('./constants'),
    CIRCUIT_PROTO_CODE = _require5.CIRCUIT_PROTO_CODE,
    HOP_METADATA_KEY = _require5.HOP_METADATA_KEY,
    HOP_METADATA_VALUE = _require5.HOP_METADATA_VALUE,
    RELAY_RENDEZVOUS_NS = _require5.RELAY_RENDEZVOUS_NS;
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('../peer-store/address-book').Address} Address
 */

/**
 * @typedef {Object} AutoRelayProperties
 * @property {import('../')} libp2p
 *
 * @typedef {Object} AutoRelayOptions
 * @property {number} [maxListeners = 1] - maximum number of relays to listen.
 * @property {(error: Error, msg?: string) => {}} [onError]
 */


var AutoRelay = /*#__PURE__*/function () {
  /**
   * Creates an instance of AutoRelay.
   *
   * @class
   * @param {AutoRelayProperties & AutoRelayOptions} props
   */
  function AutoRelay(_ref) {
    var libp2p = _ref.libp2p,
        _ref$maxListeners = _ref.maxListeners,
        maxListeners = _ref$maxListeners === void 0 ? 1 : _ref$maxListeners,
        onError = _ref.onError;

    _classCallCheck(this, AutoRelay);

    this._libp2p = libp2p;
    this._peerId = libp2p.peerId;
    this._peerStore = libp2p.peerStore;
    this._connectionManager = libp2p.connectionManager;
    this._transportManager = libp2p.transportManager;
    this._addressSorter = libp2p.dialer.addressSorter;
    this.maxListeners = maxListeners;
    /**
     * @type {Set<string>}
     */

    this._listenRelays = new Set();
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);

    this._peerStore.on('change:protocols', this._onProtocolChange);

    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected);
    /**
     * @param {Error} error
     * @param {string} [msg]
     */


    this._onError = function (error, msg) {
      log.error(msg || error);
      onError && onError(error, msg);
    };
  }
  /**
   * Check if a peer supports the relay protocol.
   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.
   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if
   * inside the threshold.
   *
   * @param {Object} props
   * @param {PeerId} props.peerId
   * @param {string[]} props.protocols
   * @returns {Promise<void>}
   */


  _createClass(AutoRelay, [{
    key: "_onProtocolChange",
    value: function () {
      var _onProtocolChange2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
        var peerId, protocols, id, hasProtocol, connection, supportsHop;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                peerId = _ref2.peerId, protocols = _ref2.protocols;
                id = peerId.toB58String(); // Check if it has the protocol

                hasProtocol = protocols.find(function (protocol) {
                  return protocol === multicodec;
                }); // If no protocol, check if we were keeping the peer before as a listenRelay

                if (!(!hasProtocol && this._listenRelays.has(id))) {
                  _context.next = 8;
                  break;
                }

                this._removeListenRelay(id);

                return _context.abrupt("return");

              case 8:
                if (!(!hasProtocol || this._listenRelays.has(id))) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return");

              case 10:
                _context.prev = 10;
                connection = this._connectionManager.get(peerId);

                if (connection) {
                  _context.next = 14;
                  break;
                }

                return _context.abrupt("return");

              case 14:
                if (!connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
                  _context.next = 17;
                  break;
                }

                log("relayed connection to ".concat(id, " will not be used to hop on"));
                return _context.abrupt("return");

              case 17:
                _context.next = 19;
                return canHop({
                  connection: connection
                });

              case 19:
                supportsHop = _context.sent;

                if (!supportsHop) {
                  _context.next = 24;
                  break;
                }

                this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));

                _context.next = 24;
                return this._addListenRelay(connection, id);

              case 24:
                _context.next = 29;
                break;

              case 26:
                _context.prev = 26;
                _context.t0 = _context["catch"](10);

                this._onError(_context.t0);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 26]]);
      }));

      function _onProtocolChange(_x) {
        return _onProtocolChange2.apply(this, arguments);
      }

      return _onProtocolChange;
    }()
    /**
     * Peer disconnects.
     *
     * @param {Connection} connection - connection to the peer
     * @returns {void}
     */

  }, {
    key: "_onPeerDisconnected",
    value: function _onPeerDisconnected(connection) {
      var peerId = connection.remotePeer;
      var id = peerId.toB58String(); // Not listening on this relay

      if (!this._listenRelays.has(id)) {
        return;
      }

      this._removeListenRelay(id);
    }
    /**
     * Attempt to listen on the given relay connection.
     *
     * @private
     * @param {Connection} connection - connection to the peer
     * @param {string} id - peer identifier string
     * @returns {Promise<void>}
     */

  }, {
    key: "_addListenRelay",
    value: function () {
      var _addListenRelay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(connection, id) {
        var remoteAddrs, listenAddr;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this._listenRelays.size >= this.maxListeners)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                // Get peer known addresses and sort them per public addresses first
                remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);

                if (!(!remoteAddrs || !remoteAddrs.length)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                listenAddr = "".concat(remoteAddrs[0].toString(), "/p2p-circuit");

                this._listenRelays.add(id); // Attempt to listen on relay


                _context2.prev = 7;
                _context2.next = 10;
                return this._transportManager.listen([new Multiaddr(listenAddr)]);

              case 10:
                _context2.next = 16;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](7);

                this._onError(_context2.t0);

                this._listenRelays.delete(id);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[7, 12]]);
      }));

      function _addListenRelay(_x2, _x3) {
        return _addListenRelay2.apply(this, arguments);
      }

      return _addListenRelay;
    }()
    /**
     * Remove listen relay.
     *
     * @private
     * @param {string} id - peer identifier string.
     * @returns {void}
     */

  }, {
    key: "_removeListenRelay",
    value: function _removeListenRelay(id) {
      if (this._listenRelays.delete(id)) {
        // TODO: this should be responsibility of the connMgr
        this._listenOnAvailableHopRelays([id]);
      }
    }
    /**
     * Try to listen on available hop relay connections.
     * The following order will happen while we do not have enough relays.
     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.
     * 2. Dial and try to listen on the peers we know that support hop but are not connected.
     * 3. Search the network.
     *
     * @param {string[]} [peersToIgnore]
     * @returns {Promise<void>}
     */

  }, {
    key: "_listenOnAvailableHopRelays",
    value: function () {
      var _listenOnAvailableHopRelays2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var peersToIgnore,
            knownHopsToDial,
            _iterator2,
            _step2,
            _step2$value,
            id,
            metadataMap,
            supportsHop,
            _peerId2,
            connection,
            _i,
            _knownHopsToDial,
            peerId,
            cid,
            _iteratorAbruptCompletion,
            _didIteratorError,
            _iteratorError,
            _iterator,
            _step,
            provider,
            _peerId,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                peersToIgnore = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : [];

                if (!(this._listenRelays.size >= this.maxListeners)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                knownHopsToDial = []; // Check if we have known hop peers to use and attempt to listen on the already connected

                _iterator2 = _createForOfIteratorHelper(this._peerStore.metadataBook.data.entries());
                _context3.prev = 5;

                _iterator2.s();

              case 7:
                if ((_step2 = _iterator2.n()).done) {
                  _context3.next = 25;
                  break;
                }

                _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], metadataMap = _step2$value[1];

                if (!(this._listenRelays.has(id) || peersToIgnore.includes(id))) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("continue", 23);

              case 11:
                supportsHop = metadataMap.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop

                if (!(!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("continue", 23);

              case 14:
                _peerId2 = PeerId.createFromB58String(id);
                connection = this._connectionManager.get(_peerId2); // If not connected, store for possible later use.

                if (connection) {
                  _context3.next = 19;
                  break;
                }

                knownHopsToDial.push(_peerId2);
                return _context3.abrupt("continue", 23);

              case 19:
                _context3.next = 21;
                return this._addListenRelay(connection, id);

              case 21:
                if (!(this._listenRelays.size >= this.maxListeners)) {
                  _context3.next = 23;
                  break;
                }

                return _context3.abrupt("return");

              case 23:
                _context3.next = 7;
                break;

              case 25:
                _context3.next = 30;
                break;

              case 27:
                _context3.prev = 27;
                _context3.t0 = _context3["catch"](5);

                _iterator2.e(_context3.t0);

              case 30:
                _context3.prev = 30;

                _iterator2.f();

                return _context3.finish(30);

              case 33:
                _i = 0, _knownHopsToDial = knownHopsToDial;

              case 34:
                if (!(_i < _knownHopsToDial.length)) {
                  _context3.next = 43;
                  break;
                }

                peerId = _knownHopsToDial[_i];
                _context3.next = 38;
                return this._tryToListenOnRelay(peerId);

              case 38:
                if (!(this._listenRelays.size >= this.maxListeners)) {
                  _context3.next = 40;
                  break;
                }

                return _context3.abrupt("return");

              case 40:
                _i++;
                _context3.next = 34;
                break;

              case 43:
                _context3.prev = 43;
                _context3.next = 46;
                return namespaceToCid(RELAY_RENDEZVOUS_NS);

              case 46:
                cid = _context3.sent;
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context3.prev = 49;
                _iterator = _asyncIterator(this._libp2p.contentRouting.findProviders(cid));

              case 51:
                _context3.next = 53;
                return _iterator.next();

              case 53:
                if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {
                  _context3.next = 66;
                  break;
                }

                provider = _step.value;

                if (provider.multiaddrs.length) {
                  _context3.next = 57;
                  break;
                }

                return _context3.abrupt("continue", 63);

              case 57:
                _peerId = provider.id;

                this._peerStore.addressBook.add(_peerId, provider.multiaddrs);

                _context3.next = 61;
                return this._tryToListenOnRelay(_peerId);

              case 61:
                if (!(this._listenRelays.size >= this.maxListeners)) {
                  _context3.next = 63;
                  break;
                }

                return _context3.abrupt("return");

              case 63:
                _iteratorAbruptCompletion = false;
                _context3.next = 51;
                break;

              case 66:
                _context3.next = 72;
                break;

              case 68:
                _context3.prev = 68;
                _context3.t1 = _context3["catch"](49);
                _didIteratorError = true;
                _iteratorError = _context3.t1;

              case 72:
                _context3.prev = 72;
                _context3.prev = 73;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context3.next = 77;
                  break;
                }

                _context3.next = 77;
                return _iterator.return();

              case 77:
                _context3.prev = 77;

                if (!_didIteratorError) {
                  _context3.next = 80;
                  break;
                }

                throw _iteratorError;

              case 80:
                return _context3.finish(77);

              case 81:
                return _context3.finish(72);

              case 82:
                _context3.next = 87;
                break;

              case 84:
                _context3.prev = 84;
                _context3.t2 = _context3["catch"](43);

                this._onError(_context3.t2);

              case 87:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[5, 27, 30, 33], [43, 84], [49, 68, 72, 82], [73,, 77, 81]]);
      }));

      function _listenOnAvailableHopRelays() {
        return _listenOnAvailableHopRelays2.apply(this, arguments);
      }

      return _listenOnAvailableHopRelays;
    }()
    /**
     * @param {PeerId} peerId
     */

  }, {
    key: "_tryToListenOnRelay",
    value: function () {
      var _tryToListenOnRelay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peerId) {
        var connection;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this._libp2p.dial(peerId);

              case 3:
                connection = _context4.sent;
                _context4.next = 6;
                return this._addListenRelay(connection, peerId.toB58String());

              case 6:
                _context4.next = 11;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](0);

                this._onError(_context4.t0, "could not connect and listen on known hop relay ".concat(peerId.toB58String()));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 8]]);
      }));

      function _tryToListenOnRelay(_x4) {
        return _tryToListenOnRelay2.apply(this, arguments);
      }

      return _tryToListenOnRelay;
    }()
  }]);

  return AutoRelay;
}();

module.exports = AutoRelay;
},{"debug":"node_modules/debug/src/browser.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js","./multicodec":"node_modules/libp2p/src/circuit/multicodec.js","./circuit/hop":"node_modules/libp2p/src/circuit/circuit/hop.js","./utils":"node_modules/libp2p/src/circuit/utils.js","./constants":"node_modules/libp2p/src/circuit/constants.js"}],"node_modules/libp2p/src/circuit/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:relay'), {
  error: debug('libp2p:relay:err')
});

var _require = require('set-delayed-interval'),
    setDelayedInterval = _require.setDelayedInterval,
    clearDelayedInterval = _require.clearDelayedInterval;

var AutoRelay = require('./auto-relay');

var _require2 = require('./utils'),
    namespaceToCid = _require2.namespaceToCid;

var _require3 = require('./constants'),
    RELAY_RENDEZVOUS_NS = _require3.RELAY_RENDEZVOUS_NS;
/**
 * @typedef {import('../')} Libp2p
 *
 * @typedef {Object} RelayAdvertiseOptions
 * @property {number} [bootDelay = ADVERTISE_BOOT_DELAY]
 * @property {boolean} [enabled = true]
 * @property {number} [ttl = ADVERTISE_TTL]
 *
 * @typedef {Object} HopOptions
 * @property {boolean} [enabled = false]
 * @property {boolean} [active = false]
 *
 * @typedef {Object} AutoRelayOptions
 * @property {number} [maxListeners = 2] - maximum number of relays to listen.
 * @property {boolean} [enabled = false]
 */


var Relay = /*#__PURE__*/function () {
  /**
   * Creates an instance of Relay.
   *
   * @class
   * @param {Libp2p} libp2p
   */
  function Relay(libp2p) {
    _classCallCheck(this, Relay);

    this._libp2p = libp2p;
    this._options = _objectSpread({}, libp2p._config.relay); // Create autoRelay if enabled

    this._autoRelay = this._options.autoRelay.enabled && new AutoRelay(_objectSpread({
      libp2p: libp2p
    }, this._options.autoRelay));
    this._advertiseService = this._advertiseService.bind(this);
  }
  /**
   * Start Relay service.
   *
   * @returns {void}
   */


  _createClass(Relay, [{
    key: "start",
    value: function start() {
      // Advertise service if HOP enabled
      var canHop = this._options.hop.enabled;

      if (canHop && this._options.advertise.enabled) {
        this._timeout = setDelayedInterval(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay);
      }
    }
    /**
     * Stop Relay service.
     *
     * @returns {void}
     */

  }, {
    key: "stop",
    value: function stop() {
      clearDelayedInterval(this._timeout);
    }
    /**
     * Advertise hop relay service in the network.
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "_advertiseService",
    value: function () {
      var _advertiseService2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var cid;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return namespaceToCid(RELAY_RENDEZVOUS_NS);

              case 3:
                cid = _context.sent;
                _context.next = 6;
                return this._libp2p.contentRouting.provide(cid);

              case 6:
                _context.next = 11;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);

                if (_context.t0.code === 'NO_ROUTERS_AVAILABLE') {
                  log.error('a content router, such as a DHT, must be provided in order to advertise the relay service', _context.t0); // Stop the advertise

                  this.stop();
                } else {
                  log.error(_context.t0);
                }

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 8]]);
      }));

      function _advertiseService() {
        return _advertiseService2.apply(this, arguments);
      }

      return _advertiseService;
    }()
  }]);

  return Relay;
}();

module.exports = Relay;
},{"debug":"node_modules/debug/src/browser.js","set-delayed-interval":"node_modules/set-delayed-interval/src/index.js","./auto-relay":"node_modules/libp2p/src/circuit/auto-relay.js","./utils":"node_modules/libp2p/src/circuit/utils.js","./constants":"node_modules/libp2p/src/circuit/constants.js"}],"node_modules/abort-controller/browser.js":[function(require,module,exports) {
/*globals self, window */
"use strict";
/*eslint-disable @mysticatea/prettier */

var _ref = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window :
/* otherwise */
undefined,
    AbortController = _ref.AbortController,
    AbortSignal = _ref.AbortSignal;
/*eslint-enable @mysticatea/prettier */


module.exports = AbortController;
module.exports.AbortSignal = AbortSignal;
module.exports.default = AbortController;
},{}],"node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js":[function(require,module,exports) {
'use strict'

module.exports = function getTime () {
  return Date.now()
}

},{}],"node_modules/timeout-abort-controller/node_modules/retimer/retimer.js":[function(require,module,exports) {
'use strict'

var getTime = require('./time')

function Retimer (callback, timeout, args) {
  var that = this

  this._started = getTime()
  this._rescheduled = 0
  this._scheduled = timeout
  this._args = args

  this._timer = setTimeout(timerWrapper, timeout)

  function timerWrapper () {
    if (that._rescheduled > 0) {
      that._scheduled = that._rescheduled - (getTime() - that._started)
      that._timer = setTimeout(timerWrapper, that._scheduled)
      that._rescheduled = 0
    } else {
      callback.apply(null, that._args)
    }
  }
}

Retimer.prototype.reschedule = function (timeout) {
  var now = getTime()
  if ((now + timeout) - (this._started + this._scheduled) < 0) {
    return false
  } else {
    this._started = now
    this._rescheduled = timeout
    return true
  }
}

Retimer.prototype.clear = function () {
  clearTimeout(this._timer)
}

function retimer () {
  if (typeof arguments[0] !== 'function') {
    throw new Error('callback needed')
  }

  if (typeof arguments[1] !== 'number') {
    throw new Error('timeout needed')
  }

  var args

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2)

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2]
    }
  }

  return new Retimer(arguments[0], arguments[1], args)
}

module.exports = retimer

},{"./time":"node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js"}],"node_modules/timeout-abort-controller/index.js":[function(require,module,exports) {
/* globals self, window */
'use strict'

// Get around https://github.com/mysticatea/abort-controller/pull/22
const { AbortController } =
  typeof self !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
    /* otherwise */ : require('abort-controller')

const retimer = require('retimer')

class TimeoutController extends AbortController {
  /**
   * @constructor
   * @param {number} ms milliseconds
   */
  constructor (ms) {
    super()
    this._ms = ms
    this._timer = retimer(() => this.abort(), ms)
    // Patch for safari not supported extending built in classes
    Object.setPrototypeOf(this, TimeoutController.prototype)
  }

  /**
   * Aborts the controller and clears the timer
   */
  abort () {
    this._timer.clear()
    return super.abort()
  }

  /**
   * Clears the timer
   */
  clear () {
    this._timer.clear()
  }

  /**
   * Resets the timer
   */
  reset () {
    this._timer.clear()
    this._timer = retimer(() => this.abort(), this._ms)
  }
}

module.exports = TimeoutController
module.exports.TimeoutController = TimeoutController

},{"abort-controller":"node_modules/abort-controller/browser.js","retimer":"node_modules/timeout-abort-controller/node_modules/retimer/retimer.js"}],"node_modules/native-abort-controller/src/index.js":[function(require,module,exports) {
'use strict'

let impl

if (globalThis.AbortController && globalThis.AbortSignal) {
  impl = globalThis
} else {
  impl = require('abort-controller')
}

module.exports = {
  AbortController: impl.AbortController,
  AbortSignal: impl.AbortSignal
}

},{"abort-controller":"node_modules/abort-controller/browser.js"}],"node_modules/any-signal/index.js":[function(require,module,exports) {
const { AbortController } = require('native-abort-controller')

/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 * @param {Array<AbortSignal>} signals
 * @returns {AbortSignal}
 */
function anySignal (signals) {
  const controller = new AbortController()

  function onAbort () {
    controller.abort()

    for (const signal of signals) {
      if (!signal || !signal.removeEventListener) continue
      signal.removeEventListener('abort', onAbort)
    }
  }

  for (const signal of signals) {
    if (!signal || !signal.addEventListener) continue
    if (signal.aborted) {
      onAbort()
      break
    }
    signal.addEventListener('abort', onAbort)
  }

  return controller.signal
}

module.exports = anySignal
module.exports.anySignal = anySignal

},{"native-abort-controller":"node_modules/native-abort-controller/src/index.js"}],"node_modules/p-fifo/index.js":[function(require,module,exports) {
const Fifo = require('fast-fifo')
const defer = require('p-defer')

module.exports = class PFifo {
  constructor () {
    this._buffer = new Fifo()
    this._waitingConsumers = new Fifo()
  }

  push (chunk) {
    const { promise, resolve } = defer()
    this._buffer.push({ chunk, resolve })
    this._consume()
    return promise
  }

  _consume () {
    while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
      const nextConsumer = this._waitingConsumers.shift()
      const nextChunk = this._buffer.shift()
      nextConsumer.resolve(nextChunk.chunk)
      nextChunk.resolve()
    }
  }

  shift () {
    const { promise, resolve } = defer()
    this._waitingConsumers.push({ resolve })
    this._consume()
    return promise
  }

  isEmpty () {
    return this._buffer.isEmpty()
  }
}

},{"fast-fifo":"node_modules/fast-fifo/index.js","p-defer":"node_modules/p-defer/index.js"}],"node_modules/indent-string/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (string) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  options = {
    indent: ' ',
    includeEmptyLines: false,
    ...options
  };

  if (typeof string !== 'string') {
    throw new TypeError("Expected `input` to be a `string`, got `".concat(_typeof(string), "`"));
  }

  if (typeof count !== 'number') {
    throw new TypeError("Expected `count` to be a `number`, got `".concat(_typeof(count), "`"));
  }

  if (typeof options.indent !== 'string') {
    throw new TypeError("Expected `options.indent` to be a `string`, got `".concat(_typeof(options.indent), "`"));
  }

  if (count === 0) {
    return string;
  }

  var regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex, options.indent.repeat(count));
};
},{}],"node_modules/clean-stack/index.js":[function(require,module,exports) {
'use strict';

var os = require('os');

var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
var homeDir = typeof os.homedir === 'undefined' ? '' : os.homedir();

module.exports = function (stack, options) {
  options = Object.assign({
    pretty: false
  }, options);
  return stack.replace(/\\/g, '/').split('\n').filter(function (line) {
    var pathMatches = line.match(extractPathRegex);

    if (pathMatches === null || !pathMatches[1]) {
      return true;
    }

    var match = pathMatches[1]; // Electron

    if (match.includes('.app/Contents/Resources/electron.asar') || match.includes('.app/Contents/Resources/default_app.asar')) {
      return false;
    }

    return !pathRegex.test(match);
  }).filter(function (line) {
    return line.trim() !== '';
  }).map(function (line) {
    if (options.pretty) {
      return line.replace(extractPathRegex, function (m, p1) {
        return m.replace(p1, p1.replace(homeDir, '~'));
      });
    }

    return line;
  }).join('\n');
};
},{"os":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/aggregate-error/index.js":[function(require,module,exports) {
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var indentString = require('indent-string');

var cleanStack = require('clean-stack');

var cleanInternalStack = function cleanInternalStack(stack) {
  return stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, '');
};

var AggregateError = /*#__PURE__*/function (_Error, _Symbol$iterator) {
  _inherits(AggregateError, _Error);

  var _super = _createSuper(AggregateError);

  function AggregateError(errors) {
    var _this;

    _classCallCheck(this, AggregateError);

    if (!Array.isArray(errors)) {
      throw new TypeError("Expected input to be an Array, got ".concat(_typeof(errors)));
    }

    errors = _toConsumableArray(errors).map(function (error) {
      if (error instanceof Error) {
        return error;
      }

      if (error !== null && _typeof(error) === 'object') {
        // Handle plain error objects with message property and/or possibly other metadata
        return Object.assign(new Error(error.message), error);
      }

      return new Error(error);
    });
    var message = errors.map(function (error) {
      // The `stack` property is not standardized, so we can't assume it exists
      return typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);
    }).join('\n');
    message = '\n' + indentString(message, 4);
    _this = _super.call(this, message);
    _this.name = 'AggregateError';
    Object.defineProperty(_assertThisInitialized(_this), '_errors', {
      value: errors
    });
    return _this;
  }

  _createClass(AggregateError, [{
    key: _Symbol$iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      var _iterator, _step, error;

      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelper(this._errors);
              _context.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context.next = 9;
                break;
              }

              error = _step.value;
              _context.next = 7;
              return error;

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
  }]);

  return AggregateError;
}( /*#__PURE__*/_wrapNativeSuper(Error), Symbol.iterator);

module.exports = AggregateError;
},{"indent-string":"node_modules/indent-string/index.js","clean-stack":"node_modules/clean-stack/index.js"}],"node_modules/p-cancelable/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var CancelError = /*#__PURE__*/function (_Error) {
  _inherits(CancelError, _Error);

  var _super = _createSuper(CancelError);

  function CancelError(reason) {
    var _this;

    _classCallCheck(this, CancelError);

    _this = _super.call(this, reason || 'Promise was canceled');
    _this.name = 'CancelError';
    return _this;
  }

  _createClass(CancelError, [{
    key: "isCanceled",
    get: function get() {
      return true;
    }
  }]);

  return CancelError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var PCancelable = /*#__PURE__*/function () {
  function PCancelable(executor) {
    var _this2 = this;

    _classCallCheck(this, PCancelable);

    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise(function (resolve, reject) {
      _this2._reject = reject;

      var onResolve = function onResolve(value) {
        if (!_this2._isCanceled || !onCancel.shouldReject) {
          _this2._isPending = false;
          resolve(value);
        }
      };

      var onReject = function onReject(error) {
        _this2._isPending = false;
        reject(error);
      };

      var onCancel = function onCancel(handler) {
        if (!_this2._isPending) {
          throw new Error('The `onCancel` handler was attached after the promise settled.');
        }

        _this2._cancelHandlers.push(handler);
      };

      Object.defineProperties(onCancel, {
        shouldReject: {
          get: function get() {
            return _this2._rejectOnCancel;
          },
          set: function set(boolean) {
            _this2._rejectOnCancel = boolean;
          }
        }
      });
      return executor(onResolve, onReject, onCancel);
    });
  }

  _createClass(PCancelable, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // eslint-disable-next-line promise/prefer-await-to-then
      return this._promise.then(onFulfilled, onRejected);
    }
  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this._promise.catch(onRejected);
    }
  }, {
    key: "finally",
    value: function _finally(onFinally) {
      return this._promise.finally(onFinally);
    }
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (!this._isPending || this._isCanceled) {
        return;
      }

      this._isCanceled = true;

      if (this._cancelHandlers.length > 0) {
        try {
          var _iterator = _createForOfIteratorHelper(this._cancelHandlers),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var handler = _step.value;
              handler();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } catch (error) {
          this._reject(error);

          return;
        }
      }

      if (this._rejectOnCancel) {
        this._reject(new CancelError(reason));
      }
    }
  }, {
    key: "isCanceled",
    get: function get() {
      return this._isCanceled;
    }
  }], [{
    key: "fn",
    value: function fn(userFn) {
      return function () {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }

        return new PCancelable(function (resolve, reject, onCancel) {
          arguments_.push(onCancel); // eslint-disable-next-line promise/prefer-await-to-then

          userFn.apply(void 0, arguments_).then(resolve, reject);
        });
      };
    }
  }]);

  return PCancelable;
}();

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
module.exports = PCancelable;
module.exports.CancelError = CancelError;
},{}],"node_modules/p-some/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AggregateError = require('aggregate-error');

var PCancelable = require('p-cancelable');

var FilterError = /*#__PURE__*/function (_Error) {
  _inherits(FilterError, _Error);

  var _super = _createSuper(FilterError);

  function FilterError() {
    _classCallCheck(this, FilterError);

    return _super.apply(this, arguments);
  }

  return FilterError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var pSome = function pSome(iterable, options) {
  return new PCancelable(function (resolve, reject, onCancel) {
    var count = options.count,
        _options$filter = options.filter,
        filter = _options$filter === void 0 ? function () {
      return true;
    } : _options$filter;

    if (!Number.isFinite(count)) {
      reject(new TypeError("Expected a finite number, got ".concat(_typeof(options.count))));
      return;
    }

    var values = [];
    var errors = [];
    var elementCount = 0;
    var isSettled = false;
    var completed = new Set();

    var maybeSettle = function maybeSettle() {
      if (values.length === count) {
        resolve(values);
        isSettled = true;
      }

      if (elementCount - errors.length < count) {
        reject(new AggregateError(errors));
        isSettled = true;
      }

      return isSettled;
    };

    var cancelPending = function cancelPending() {
      var _iterator = _createForOfIteratorHelper(iterable),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var promise = _step.value;

          if (!completed.has(promise) && typeof promise.cancel === 'function') {
            promise.cancel();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };

    onCancel(cancelPending);

    var _iterator2 = _createForOfIteratorHelper(iterable),
        _step2;

    try {
      var _loop = function _loop() {
        var element = _step2.value;
        elementCount++;

        _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var value;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return element;

                case 3:
                  value = _context.sent;

                  if (!isSettled) {
                    _context.next = 6;
                    break;
                  }

                  return _context.abrupt("return");

                case 6:
                  if (filter(value)) {
                    _context.next = 8;
                    break;
                  }

                  throw new FilterError('Value does not satisfy filter');

                case 8:
                  values.push(value);
                  _context.next = 14;
                  break;

                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](0);
                  errors.push(_context.t0);

                case 14:
                  _context.prev = 14;
                  completed.add(element);

                  if (!isSettled && maybeSettle()) {
                    cancelPending();
                  }

                  return _context.finish(14);

                case 18:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 11, 14, 18]]);
        }))();
      };

      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    if (count > elementCount) {
      reject(new RangeError("Expected input to contain at least ".concat(options.count, " items, but contains ").concat(elementCount, " items")));
      cancelPending();
    }
  });
};

module.exports = pSome;
module.exports.AggregateError = AggregateError;
module.exports.FilterError = FilterError;
},{"aggregate-error":"node_modules/aggregate-error/index.js","p-cancelable":"node_modules/p-cancelable/index.js"}],"node_modules/p-any/index.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var pSome = require('p-some');

var PCancelable = require('p-cancelable');

module.exports = function (iterable, options) {
  var anyCancelable = pSome(iterable, _objectSpread(_objectSpread({}, options), {}, {
    count: 1
  }));
  return PCancelable.fn( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(onCancel) {
      var _yield$anyCancelable, _yield$anyCancelable2, value;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              onCancel(function () {
                anyCancelable.cancel();
              });
              _context.next = 3;
              return anyCancelable;

            case 3:
              _yield$anyCancelable = _context.sent;
              _yield$anyCancelable2 = _slicedToArray(_yield$anyCancelable, 1);
              value = _yield$anyCancelable2[0];
              return _context.abrupt("return", value);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }())();
};

module.exports.AggregateError = pSome.AggregateError;
},{"p-some":"node_modules/p-some/index.js","p-cancelable":"node_modules/p-cancelable/index.js"}],"node_modules/libp2p/src/dialer/dial-request.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var errCode = require('err-code');

var AbortController = require('abort-controller').default;

var _require = require('any-signal'),
    anySignal = _require.anySignal; // @ts-ignore p-fifo does not export types


var FIFO = require('p-fifo');

var pAny = require('p-any');
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('./')} Dialer
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @typedef {Object} DialOptions
 * @property {AbortSignal} signal
 *
 * @typedef {Object} DialRequestOptions
 * @property {Multiaddr[]} addrs
 * @property {(m: Multiaddr, options: DialOptions) => Promise<Connection>} dialAction
 * @property {Dialer} dialer
 */


var DialRequest = /*#__PURE__*/function () {
  /**
   * Manages running the `dialAction` on multiple provided `addrs` in parallel
   * up to a maximum determined by the number of tokens returned
   * from `dialer.getTokens`. Once a DialRequest is created, it can be
   * started using `DialRequest.run(options)`. Once a single dial has succeeded,
   * all other dials in the request will be cancelled.
   *
   * @class
   * @param {DialRequestOptions} options
   */
  function DialRequest(_ref) {
    var addrs = _ref.addrs,
        dialAction = _ref.dialAction,
        dialer = _ref.dialer;

    _classCallCheck(this, DialRequest);

    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  /**
   * @async
   * @param {object} [options]
   * @param {AbortSignal} [options.signal] - An AbortController signal
   * @returns {Promise<Connection>}
   */


  _createClass(DialRequest, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var options,
            tokens,
            tokenHolder,
            dialAbortControllers,
            completedDials,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                tokens = this.dialer.getTokens(this.addrs.length); // If no tokens are available, throw

                if (!(tokens.length < 1)) {
                  _context2.next = 4;
                  break;
                }

                throw errCode(new Error('No dial tokens available'), 'ERR_NO_DIAL_TOKENS');

              case 4:
                tokenHolder = new FIFO();
                tokens.forEach(function (token) {
                  return tokenHolder.push(token);
                });
                dialAbortControllers = this.addrs.map(function () {
                  return new AbortController();
                });
                completedDials = 0;
                _context2.prev = 8;
                _context2.next = 11;
                return pAny(this.addrs.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(addr, i) {
                    var token, conn, signal;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return tokenHolder.shift();

                          case 2:
                            token = _context.sent;
                            _context.prev = 3;
                            signal = dialAbortControllers[i].signal;
                            _context.next = 7;
                            return _this.dialAction(addr, _objectSpread(_objectSpread({}, options), {}, {
                              signal: options.signal ? anySignal([signal, options.signal]) : signal
                            }));

                          case 7:
                            conn = _context.sent;
                            // Remove the successful AbortController so it is not aborted
                            dialAbortControllers.splice(i, 1);

                          case 9:
                            _context.prev = 9;
                            completedDials++; // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it

                            // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it
                            if (_this.addrs.length - completedDials >= tokens.length) {
                              tokenHolder.push(token);
                            } else {
                              _this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
                            }

                            return _context.finish(9);

                          case 13:
                            return _context.abrupt("return", conn);

                          case 14:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, null, [[3,, 9, 13]]);
                  }));

                  return function (_x, _x2) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 11:
                return _context2.abrupt("return", _context2.sent);

              case 12:
                _context2.prev = 12;
                dialAbortControllers.map(function (c) {
                  return c.abort();
                }); // success/failure happened, abort everything else

                tokens.forEach(function (token) {
                  return _this.dialer.releaseToken(token);
                }); // release tokens back to the dialer

                return _context2.finish(12);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[8,, 12, 16]]);
      }));

      function run() {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }]);

  return DialRequest;
}();

module.exports = DialRequest;
},{"err-code":"node_modules/err-code/index.js","abort-controller":"node_modules/abort-controller/browser.js","any-signal":"node_modules/any-signal/index.js","p-fifo":"node_modules/p-fifo/index.js","p-any":"node_modules/p-any/index.js"}],"node_modules/libp2p/src/dialer/index.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:dialer'), {
  error: debug('libp2p:dialer:err')
});

var errCode = require('err-code');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr; // @ts-ignore timeout-abourt-controles does not export types


var TimeoutController = require('timeout-abort-controller');

var _require2 = require('abortable-iterator'),
    AbortError = _require2.AbortError;

var _require3 = require('any-signal'),
    anySignal = _require3.anySignal;

var DialRequest = require('./dial-request');

var _require4 = require('libp2p-utils/src/address-sort'),
    publicAddressesFirst = _require4.publicAddressesFirst;

var getPeer = require('../get-peer');

var _require5 = require('../errors'),
    codes = _require5.codes;

var _require6 = require('../constants'),
    DIAL_TIMEOUT = _require6.DIAL_TIMEOUT,
    MAX_PARALLEL_DIALS = _require6.MAX_PARALLEL_DIALS,
    MAX_PER_PEER_DIALS = _require6.MAX_PER_PEER_DIALS,
    MAX_ADDRS_TO_DIAL = _require6.MAX_ADDRS_TO_DIAL;
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../peer-store')} PeerStore
 * @typedef {import('../peer-store/address-book').Address} Address
 * @typedef {import('../transport-manager')} TransportManager
 */

/**
 * @typedef {Object} DialerProperties
 * @property {PeerStore} peerStore
 * @property {TransportManager} transportManager
 *
 * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver
 *
 * @typedef {Object} DialerOptions
 * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.
 * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.
 * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.
 * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.
 * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.
 * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing
 *
 * @typedef DialTarget
 * @property {string} id
 * @property {Multiaddr[]} addrs
 *
 * @typedef PendingDial
 * @property {DialRequest} dialRequest
 * @property {TimeoutController} controller
 * @property {Promise<Connection>} promise
 * @property {function():void} destroy
 */


var Dialer = /*#__PURE__*/function () {
  /**
   * @class
   * @param {DialerProperties & DialerOptions} options
   */
  function Dialer(_ref) {
    var transportManager = _ref.transportManager,
        peerStore = _ref.peerStore,
        _ref$addressSorter = _ref.addressSorter,
        addressSorter = _ref$addressSorter === void 0 ? publicAddressesFirst : _ref$addressSorter,
        _ref$maxParallelDials = _ref.maxParallelDials,
        maxParallelDials = _ref$maxParallelDials === void 0 ? MAX_PARALLEL_DIALS : _ref$maxParallelDials,
        _ref$maxAddrsToDial = _ref.maxAddrsToDial,
        maxAddrsToDial = _ref$maxAddrsToDial === void 0 ? MAX_ADDRS_TO_DIAL : _ref$maxAddrsToDial,
        _ref$dialTimeout = _ref.dialTimeout,
        dialTimeout = _ref$dialTimeout === void 0 ? DIAL_TIMEOUT : _ref$dialTimeout,
        _ref$maxDialsPerPeer = _ref.maxDialsPerPeer,
        maxDialsPerPeer = _ref$maxDialsPerPeer === void 0 ? MAX_PER_PEER_DIALS : _ref$maxDialsPerPeer,
        _ref$resolvers = _ref.resolvers,
        resolvers = _ref$resolvers === void 0 ? {} : _ref$resolvers;

    _classCallCheck(this, Dialer);

    this.transportManager = transportManager;
    this.peerStore = peerStore;
    this.addressSorter = addressSorter;
    this.maxParallelDials = maxParallelDials;
    this.maxAddrsToDial = maxAddrsToDial;
    this.timeout = dialTimeout;
    this.maxDialsPerPeer = maxDialsPerPeer;
    this.tokens = _toConsumableArray(new Array(maxParallelDials)).map(function (_, index) {
      return index;
    });
    this._pendingDials = new Map();
    this._pendingDialTargets = new Map();

    for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      Multiaddr.resolvers.set(key, value);
    }
  }
  /**
   * Clears any pending dials
   */


  _createClass(Dialer, [{
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this._pendingDials.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dial = _step.value;

          try {
            dial.controller.abort();
          } catch (err) {
            log.error(err);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this._pendingDials.clear();

      var _iterator2 = _createForOfIteratorHelper(this._pendingDialTargets.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var pendingTarget = _step2.value;
          pendingTarget.reject(new AbortError('Dialer was destroyed'));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this._pendingDialTargets.clear();
    }
    /**
     * Connects to a given `peer` by dialing all of its known addresses.
     * The dial to the first address that is successfully able to upgrade a connection
     * will be used.
     *
     * @param {PeerId|Multiaddr|string} peer - The peer to dial
     * @param {object} [options]
     * @param {AbortSignal} [options.signal] - An AbortController signal
     * @returns {Promise<Connection>}
     */

  }, {
    key: "connectToPeer",
    value: function () {
      var _connectToPeer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peer) {
        var options,
            dialTarget,
            pendingDial,
            connection,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this._createCancellableDialTarget(peer);

              case 3:
                dialTarget = _context.sent;

                if (dialTarget.addrs.length) {
                  _context.next = 6;
                  break;
                }

                throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);

              case 6:
                pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);
                _context.prev = 7;
                _context.next = 10;
                return pendingDial.promise;

              case 10:
                connection = _context.sent;
                log('dial succeeded to %s', dialTarget.id);
                return _context.abrupt("return", connection);

              case 15:
                _context.prev = 15;
                _context.t0 = _context["catch"](7);

                // Error is a timeout
                if (pendingDial.controller.signal.aborted) {
                  _context.t0.code = codes.ERR_TIMEOUT;
                }

                log.error(_context.t0);
                throw _context.t0;

              case 20:
                _context.prev = 20;
                pendingDial.destroy();
                return _context.finish(20);

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 15, 20, 23]]);
      }));

      function connectToPeer(_x) {
        return _connectToPeer.apply(this, arguments);
      }

      return connectToPeer;
    }()
    /**
     * Connects to a given `peer` by dialing all of its known addresses.
     * The dial to the first address that is successfully able to upgrade a connection
     * will be used.
     *
     * @param {PeerId|Multiaddr|string} peer - The peer to dial
     * @returns {Promise<DialTarget>}
     */

  }, {
    key: "_createCancellableDialTarget",
    value: function () {
      var _createCancellableDialTarget2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
        var _this = this;

        var id, cancellablePromise, dialTarget;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Make dial target promise cancellable
                id = "".concat(parseInt(String(Math.random() * 1e9), 10).toString() + Date.now());
                cancellablePromise = new Promise(function (resolve, reject) {
                  _this._pendingDialTargets.set(id, {
                    resolve: resolve,
                    reject: reject
                  });
                });
                _context2.next = 4;
                return Promise.race([this._createDialTarget(peer), cancellablePromise]);

              case 4:
                dialTarget = _context2.sent;

                this._pendingDialTargets.delete(id);

                return _context2.abrupt("return", dialTarget);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _createCancellableDialTarget(_x2) {
        return _createCancellableDialTarget2.apply(this, arguments);
      }

      return _createCancellableDialTarget;
    }()
    /**
     * Creates a DialTarget. The DialTarget is used to create and track
     * the DialRequest to a given peer.
     * If a multiaddr is received it should be the first address attempted.
     * Multiaddrs not supported by the available transports will be filtered out.
     *
     * @private
     * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr
     * @returns {Promise<DialTarget>}
     */

  }, {
    key: "_createDialTarget",
    value: function () {
      var _createDialTarget2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(peer) {
        var _this2 = this;

        var _getPeer, id, multiaddrs, knownAddrs, addrs, _iterator3, _step3, a, resolvedAddrs, supportedAddrs;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _getPeer = getPeer(peer), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;

                if (multiaddrs) {
                  this.peerStore.addressBook.add(id, multiaddrs);
                }

                knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use
                // But, if we know other multiaddrs for the peer, we should try them too.

                if (Multiaddr.isMultiaddr(peer)) {
                  knownAddrs = knownAddrs.filter(function (addr) {
                    return !peer.equals(addr);
                  });
                  knownAddrs.unshift(peer);
                }
                /** @type {Multiaddr[]} */


                addrs = [];
                _iterator3 = _createForOfIteratorHelper(knownAddrs);
                _context3.prev = 6;

                _iterator3.s();

              case 8:
                if ((_step3 = _iterator3.n()).done) {
                  _context3.next = 16;
                  break;
                }

                a = _step3.value;
                _context3.next = 12;
                return this._resolve(a);

              case 12:
                resolvedAddrs = _context3.sent;
                resolvedAddrs.forEach(function (ra) {
                  return addrs.push(ra);
                });

              case 14:
                _context3.next = 8;
                break;

              case 16:
                _context3.next = 21;
                break;

              case 18:
                _context3.prev = 18;
                _context3.t0 = _context3["catch"](6);

                _iterator3.e(_context3.t0);

              case 21:
                _context3.prev = 21;

                _iterator3.f();

                return _context3.finish(21);

              case 24:
                // Multiaddrs not supported by the available transports will be filtered out.
                supportedAddrs = addrs.filter(function (a) {
                  return _this2.transportManager.transportForMultiaddr(a);
                });

                if (!(supportedAddrs.length > this.maxAddrsToDial)) {
                  _context3.next = 28;
                  break;
                }

                this.peerStore.delete(id);
                throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);

              case 28:
                return _context3.abrupt("return", {
                  id: id.toB58String(),
                  addrs: supportedAddrs
                });

              case 29:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 18, 21, 24]]);
      }));

      function _createDialTarget(_x3) {
        return _createDialTarget2.apply(this, arguments);
      }

      return _createDialTarget;
    }()
    /**
     * Creates a PendingDial that wraps the underlying DialRequest
     *
     * @private
     * @param {DialTarget} dialTarget
     * @param {object} [options]
     * @param {AbortSignal} [options.signal] - An AbortController signal
     * @returns {PendingDial}
     */

  }, {
    key: "_createPendingDial",
    value: function _createPendingDial(dialTarget) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      /**
       * @param {Multiaddr} addr
       * @param {{ signal: { aborted: any; }; }} options
       */
      var dialAction = function dialAction(addr, options) {
        if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);
        return _this3.transportManager.dial(addr, options);
      };

      var dialRequest = new DialRequest({
        addrs: dialTarget.addrs,
        dialAction: dialAction,
        dialer: this
      }); // Combine the timeout signal and options.signal, if provided

      var timeoutController = new TimeoutController(this.timeout);
      var signals = [timeoutController.signal];
      options.signal && signals.push(options.signal);
      var signal = anySignal(signals);
      var pendingDial = {
        dialRequest: dialRequest,
        controller: timeoutController,
        promise: dialRequest.run(_objectSpread(_objectSpread({}, options), {}, {
          signal: signal
        })),
        destroy: function destroy() {
          timeoutController.clear();

          _this3._pendingDials.delete(dialTarget.id);
        }
      };

      this._pendingDials.set(dialTarget.id, pendingDial);

      return pendingDial;
    }
    /**
     * @param {number} num
     */

  }, {
    key: "getTokens",
    value: function getTokens(num) {
      var total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
      var tokens = this.tokens.splice(0, total);
      log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);
      return tokens;
    }
    /**
     * @param {number} token
     */

  }, {
    key: "releaseToken",
    value: function releaseToken(token) {
      // Guard against duplicate releases
      if (this.tokens.indexOf(token) > -1) return;
      log('token %d released', token);
      this.tokens.push(token);
    }
    /**
     * Resolve multiaddr recursively.
     *
     * @param {Multiaddr} ma
     * @returns {Promise<Multiaddr[]>}
     */

  }, {
    key: "_resolve",
    value: function () {
      var _resolve2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(ma) {
        var _this4 = this;

        var resolvableProto, resolvedMultiaddrs, recursiveMultiaddrs, addrs;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place
                // Now only supporting resolve for dnsaddr
                resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!

                if (resolvableProto) {
                  _context4.next = 3;
                  break;
                }

                return _context4.abrupt("return", [ma]);

              case 3:
                _context4.next = 5;
                return this._resolveRecord(ma);

              case 5:
                resolvedMultiaddrs = _context4.sent;
                _context4.next = 8;
                return Promise.all(resolvedMultiaddrs.map(function (nm) {
                  return _this4._resolve(nm);
                }));

              case 8:
                recursiveMultiaddrs = _context4.sent;
                addrs = recursiveMultiaddrs.flat();
                return _context4.abrupt("return", addrs.reduce(function (array, newM) {
                  if (!array.find(function (m) {
                    return m.equals(newM);
                  })) {
                    array.push(newM);
                  }

                  return array;
                }, []));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _resolve(_x4) {
        return _resolve2.apply(this, arguments);
      }

      return _resolve;
    }()
    /**
     * Resolve a given multiaddr. If this fails, an empty array will be returned
     *
     * @param {Multiaddr} ma
     * @returns {Promise<Multiaddr[]>}
     */

  }, {
    key: "_resolveRecord",
    value: function () {
      var _resolveRecord2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ma) {
        var multiaddrs;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                ma = new Multiaddr(ma.toString()); // Use current multiaddr module

                _context5.next = 4;
                return ma.resolve();

              case 4:
                multiaddrs = _context5.sent;
                return _context5.abrupt("return", multiaddrs);

              case 8:
                _context5.prev = 8;
                _context5.t0 = _context5["catch"](0);
                log.error("multiaddr ".concat(ma, " could not be resolved"));
                return _context5.abrupt("return", []);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[0, 8]]);
      }));

      function _resolveRecord(_x5) {
        return _resolveRecord2.apply(this, arguments);
      }

      return _resolveRecord;
    }()
  }]);

  return Dialer;
}();

module.exports = Dialer;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","multiaddr":"node_modules/multiaddr/src/index.js","timeout-abort-controller":"node_modules/timeout-abort-controller/index.js","abortable-iterator":"node_modules/abortable-iterator/index.js","any-signal":"node_modules/any-signal/index.js","./dial-request":"node_modules/libp2p/src/dialer/dial-request.js","libp2p-utils/src/address-sort":"node_modules/libp2p-utils/src/address-sort.js","../get-peer":"node_modules/libp2p/src/get-peer.js","../errors":"node_modules/libp2p/src/errors.js","../constants":"node_modules/libp2p/src/constants.js"}],"node_modules/truncate-utf8-bytes/lib/truncate.js":[function(require,module,exports) {
'use strict';

function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function truncate(getLength, string, byteLength) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var curByteLength = 0;
  var codePoint;
  var segment;

  for (var i = 0; i < charLength; i += 1) {
    codePoint = string.charCodeAt(i);
    segment = string[i];

    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
      i += 1;
      segment += string[i];
    }

    curByteLength += getLength(segment);

    if (curByteLength === byteLength) {
      return string.slice(0, i + 1);
    }
    else if (curByteLength > byteLength) {
      return string.slice(0, i - segment.length + 1);
    }
  }

  return string;
};


},{}],"node_modules/utf8-byte-length/browser.js":[function(require,module,exports) {
'use strict';

function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function getByteLength(string) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var byteLength = 0;
  var codePoint = null;
  var prevCodePoint = null;
  for (var i = 0; i < charLength; i++) {
    codePoint = string.charCodeAt(i);
    // handle 4-byte non-BMP chars
    // low surrogate
    if (isLowSurrogate(codePoint)) {
      // when parsing previous hi-surrogate, 3 is added to byteLength
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength += 1;
      }
      else {
        byteLength += 3;
      }
    }
    else if (codePoint <= 0x7f ) {
      byteLength += 1;
    }
    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
      byteLength += 2;
    }
    else if (codePoint >= 0x800 && codePoint <= 0xffff) {
      byteLength += 3;
    }
    prevCodePoint = codePoint;
  }

  return byteLength;
};

},{}],"node_modules/truncate-utf8-bytes/browser.js":[function(require,module,exports) {
'use strict';

var truncate = require("./lib/truncate");
var getLength = require("utf8-byte-length/browser");
module.exports = truncate.bind(null, getLength);

},{"./lib/truncate":"node_modules/truncate-utf8-bytes/lib/truncate.js","utf8-byte-length/browser":"node_modules/utf8-byte-length/browser.js"}],"node_modules/sanitize-filename/index.js":[function(require,module,exports) {
/*jshint node:true*/
'use strict';

/**
 * Replaces characters in strings that are illegal/unsafe for filenames.
 * Unsafe characters are either removed or replaced by a substitute set
 * in the optional `options` object.
 *
 * Illegal Characters on Various Operating Systems
 * / ? < > \ : * | "
 * https://kb.acronis.com/content/39790
 *
 * Unicode Control codes
 * C0 0x00-0x1f & C1 (0x80-0x9f)
 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
 *
 * Reserved filenames on Unix-based systems (".", "..")
 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
 * "LPT9") case-insesitively and with or without filename extensions.
 *
 * Capped at 255 characters in length.
 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
 *
 * @param  {String} input   Original filename
 * @param  {Object} options {replacement: String | Function }
 * @return {String}         Sanitized filename
 */

var truncate = require("truncate-utf8-bytes");

var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;

function sanitize(input, replacement) {
  if (typeof input !== 'string') {
    throw new Error('Input must be string');
  }
  var sanitized = input
    .replace(illegalRe, replacement)
    .replace(controlRe, replacement)
    .replace(reservedRe, replacement)
    .replace(windowsReservedRe, replacement)
    .replace(windowsTrailingRe, replacement);
  return truncate(sanitized, 255);
}

module.exports = function (input, options) {
  var replacement = (options && options.replacement) || '';
  var output = sanitize(input, replacement);
  if (replacement === '') {
    return output;
  }
  return sanitize(output, '');
};

},{"truncate-utf8-bytes":"node_modules/truncate-utf8-bytes/browser.js"}],"node_modules/libp2p-crypto/src/aes/ciphers-browser.js":[function(require,module,exports) {
'use strict';

require('node-forge/lib/aes');

var forge = require('node-forge/lib/forge');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayFromString = require('uint8arrays/from-string');

module.exports = {
  createCipheriv: function createCipheriv(mode, key, iv) {
    var cipher2 = forge.cipher.createCipher('AES-CTR', uint8ArrayToString(key, 'ascii'));
    cipher2.start({
      iv: uint8ArrayToString(iv, 'ascii')
    });
    return {
      update: function update(data) {
        cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, 'ascii')));
        return uint8ArrayFromString(cipher2.output.getBytes(), 'ascii');
      }
    };
  },
  createDecipheriv: function createDecipheriv(mode, key, iv) {
    var cipher2 = forge.cipher.createDecipher('AES-CTR', uint8ArrayToString(key, 'ascii'));
    cipher2.start({
      iv: uint8ArrayToString(iv, 'ascii')
    });
    return {
      update: function update(data) {
        cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, 'ascii')));
        return uint8ArrayFromString(cipher2.output.getBytes(), 'ascii');
      }
    };
  }
};
},{"node-forge/lib/aes":"node_modules/node-forge/lib/aes.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js"}],"node_modules/libp2p-crypto/src/aes/cipher-mode.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var errcode = require('err-code');

var CIPHER_MODES = {
  16: 'aes-128-ctr',
  32: 'aes-256-ctr'
};

module.exports = function (key) {
  var mode = CIPHER_MODES[key.length];

  if (!mode) {
    var modes = Object.entries(CIPHER_MODES).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return "".concat(k, " (").concat(v, ")");
    }).join(' / ');
    throw errcode(new Error("Invalid key length ".concat(key.length, " bytes. Must be ").concat(modes)), 'ERR_INVALID_KEY_LENGTH');
  }

  return mode;
};
},{"err-code":"node_modules/err-code/index.js"}],"node_modules/libp2p-crypto/src/aes/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var ciphers = require('./ciphers');

var cipherMode = require('./cipher-mode');

exports.create = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, iv) {
    var mode, cipher, decipher, res;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // eslint-disable-line require-await
            mode = cipherMode(key);
            cipher = ciphers.createCipheriv(mode, key, iv);
            decipher = ciphers.createDecipheriv(mode, key, iv);
            res = {
              encrypt: function encrypt(data) {
                return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          return _context.abrupt("return", cipher.update(data));

                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }))();
              },
              decrypt: function decrypt(data) {
                return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          return _context2.abrupt("return", decipher.update(data));

                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }))();
              }
            };
            return _context3.abrupt("return", res);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
},{"./ciphers":"node_modules/libp2p-crypto/src/aes/ciphers-browser.js","./cipher-mode":"node_modules/libp2p-crypto/src/aes/cipher-mode.js"}],"node_modules/libp2p-crypto/src/pbkdf2.js":[function(require,module,exports) {
'use strict';

var forgePbkdf2 = require('node-forge/lib/pbkdf2');

var forgeUtil = require('node-forge/lib/util');

var errcode = require('err-code');
/**
 * Maps an IPFS hash name to its node-forge equivalent.
 *
 * See https://github.com/multiformats/multihash/blob/master/hashtable.csv
 *
 * @private
 */


var hashName = {
  sha1: 'sha1',
  'sha2-256': 'sha256',
  'sha2-512': 'sha512'
};
/**
 * Computes the Password-Based Key Derivation Function 2.
 *
 * @param {string} password
 * @param {string} salt
 * @param {number} iterations
 * @param {number} keySize - (in bytes)
 * @param {string} hash - The hash name ('sha1', 'sha2-512, ...)
 * @returns {string} - A new password
 */

function pbkdf2(password, salt, iterations, keySize, hash) {
  var hasher = hashName[hash];

  if (!hasher) {
    var types = Object.keys(hashName).join(' / ');
    throw errcode(new Error("Hash '".concat(hash, "' is unknown or not supported. Must be ").concat(types)), 'ERR_UNSUPPORTED_HASH_TYPE');
  }

  var dek = forgePbkdf2(password, salt, iterations, keySize, hasher);
  return forgeUtil.encode64(dek);
}

module.exports = pbkdf2;
},{"node-forge/lib/pbkdf2":"node_modules/node-forge/lib/pbkdf2.js","node-forge/lib/util":"node_modules/node-forge/lib/util.js","err-code":"node_modules/err-code/index.js"}],"node_modules/libp2p-crypto/src/index.js":[function(require,module,exports) {
'use strict';

var hmac = require('./hmac');

var aes = require('./aes');

var keys = require('./keys');

exports.aes = aes;
exports.hmac = hmac;
exports.keys = keys;
exports.randomBytes = require('./random-bytes');
exports.pbkdf2 = require('./pbkdf2');
},{"./hmac":"node_modules/libp2p-crypto/src/hmac/index-browser.js","./aes":"node_modules/libp2p-crypto/src/aes/index.js","./keys":"node_modules/libp2p-crypto/src/keys/index.js","./random-bytes":"node_modules/libp2p-crypto/src/random-bytes.js","./pbkdf2":"node_modules/libp2p-crypto/src/pbkdf2.js"}],"node_modules/nanoid/url-alphabet/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlAlphabet = void 0;
// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
let urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
exports.urlAlphabet = urlAlphabet;
},{}],"node_modules/nanoid/index.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "urlAlphabet", {
  enumerable: true,
  get: function () {
    return _index.urlAlphabet;
  }
});
exports.random = exports.customRandom = exports.customAlphabet = exports.nanoid = void 0;

var _index = require("./url-alphabet/index.js");

// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.
if ("development" !== 'production') {
  // All bundlers will remove this block in the production bundle.
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative' && typeof crypto === 'undefined') {
    throw new Error('React Native does not have a built-in secure random generator. ' + 'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' + 'For secure IDs, import `react-native-get-random-values` ' + 'before Nano ID.');
  }

  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error('Import file with `if (!window.crypto) window.crypto = window.msCrypto`' + ' before importing Nano ID to fix IE 11 support');
  }

  if (typeof crypto === 'undefined') {
    throw new Error('Your browser does not have secure random generator. ' + 'If you don’t need unpredictable IDs, you can use nanoid/non-secure.');
  }
}

var random = function random(bytes) {
  return crypto.getRandomValues(new Uint8Array(bytes));
};

exports.random = random;

var customRandom = function customRandom(alphabet, size, getRandom) {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1; // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.
  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.
  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).
  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer

  var step = -~(1.6 * mask * size / alphabet.length);
  return function () {
    var id = '';

    while (true) {
      var bytes = getRandom(step); // A compact alternative for `for (var i = 0; i < step; i++)`.

      var j = step;

      while (j--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[j] & mask] || '';
        if (id.length === size) return id;
      }
    }
  };
};

exports.customRandom = customRandom;

var customAlphabet = function customAlphabet(alphabet, size) {
  return customRandom(alphabet, size, random);
};

exports.customAlphabet = customAlphabet;

var nanoid = function nanoid() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
  var id = '';
  var bytes = crypto.getRandomValues(new Uint8Array(size)); // A compact alternative for `for (var i = 0; i < step; i++)`.

  while (size--) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    var byte = bytes[size] & 63;

    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36);
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id += '_';
    } else {
      id += '-';
    }
  }

  return id;
};

exports.nanoid = nanoid;
},{"./url-alphabet/index.js":"node_modules/nanoid/url-alphabet/index.js"}],"node_modules/interface-datastore/src/key.js":[function(require,module,exports) {
'use strict'

const { nanoid } = require('nanoid')

const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

const pathSepS = '/'
const pathSepB = new TextEncoder().encode(pathSepS)
const pathSep = pathSepB[0]

/**
 * A Key represents the unique identifier of an object.
 * Our Key scheme is inspired by file systems and Google App Engine key model.
 * Keys are meant to be unique across a system. Keys are hierarchical,
 * incorporating more and more specific namespaces. Thus keys can be deemed
 * 'children' or 'ancestors' of other keys:
 * - `new Key('/Comedy')`
 * - `new Key('/Comedy/MontyPython')`
 * Also, every namespace can be parametrized to embed relevant object
 * information. For example, the Key `name` (most specific namespace) could
 * include the object type:
 * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`
 *
 */
class Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor (s, clean) {
    if (typeof s === 'string') {
      this._buf = uint8ArrayFromString(s)
    } else if (s instanceof Uint8Array) {
      this._buf = s
    } else {
      throw new Error('Invalid key, should be String of Uint8Array')
    }

    if (clean == null) {
      clean = true
    }

    if (clean) {
      this.clean()
    }

    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error('Invalid key')
    }
  }

  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString (encoding = 'utf8') {
    return uint8ArrayToString(this._buf, encoding)
  }

  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array () {
    return this._buf
  }

  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag] () {
    return `Key(${this.toString()})`
  }

  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces (list) {
    return new Key(list.join(pathSepS))
  }

  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   * ```
   */
  static random () {
    return new Key(nanoid().replace(/-/g, ''))
  }

  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean () {
    if (!this._buf || this._buf.byteLength === 0) {
      this._buf = pathSepB
    }

    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1)
      bytes.fill(pathSep, 0, 1)
      bytes.set(this._buf, 1)
      this._buf = bytes
    }

    // normalize does not remove trailing slashes
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1)
    }
  }

  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less (key) {
    const list1 = this.list()
    const list2 = key.list()

    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false
      }

      const c1 = list1[i]
      const c2 = list2[i]

      if (c1 < c2) {
        return true
      } else if (c1 > c2) {
        return false
      }
    }

    return list1.length < list2.length
  }

  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse () {
    return Key.withNamespaces(this.list().slice().reverse())
  }

  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces () {
    return this.list()
  }

  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace () {
    const ns = this.namespaces()
    return ns[ns.length - 1]
  }

  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list () {
    return this.toString().split(pathSepS).slice(1)
  }

  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type () {
    return namespaceType(this.baseNamespace())
  }

  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name () {
    return namespaceValue(this.baseNamespace())
  }

  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance (s) {
    return new Key(this.toString() + ':' + s)
  }

  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path () {
    let p = this.parent().toString()
    if (!p.endsWith(pathSepS)) {
      p += pathSepS
    }
    p += this.type()
    return new Key(p)
  }

  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent () {
    const list = this.list()
    if (list.length === 1) {
      return new Key(pathSepS)
    }

    return new Key(list.slice(0, -1).join(pathSepS))
  }

  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child (key) {
    if (this.toString() === pathSepS) {
      return key
    } else if (key.toString() === pathSepS) {
      return this
    }

    return new Key(this.toString() + key.toString(), false)
  }

  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf (other) {
    if (other.toString() === this.toString()) {
      return false
    }

    return other.toString().startsWith(this.toString())
  }

  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf (other) {
    if (other.toString() === this.toString()) {
      return false
    }

    return this.toString().startsWith(other.toString())
  }

  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   *
   */
  isTopLevel () {
    return this.list().length === 1
  }

  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat (...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])
  }
}

/**
 * The first component of a namespace. `foo` in `foo:bar`
 *
 * @param {string} ns
 * @returns {string}
 */
function namespaceType (ns) {
  const parts = ns.split(':')
  if (parts.length < 2) {
    return ''
  }
  return parts.slice(0, -1).join(':')
}

/**
 * The last component of a namespace, `baz` in `foo:bar:baz`.
 *
 * @param {string} ns
 * @returns {string}
 */
function namespaceValue (ns) {
  const parts = ns.split(':')
  return parts[parts.length - 1]
}

/**
 * Flatten array of arrays (only one level)
 *
 * @template T
 * @param {Array<T|T[]>} arr
 * @returns {T[]}
 */
function flatten (arr) {
  return /** @type {T[]} */([]).concat(...arr)
}

module.exports = Key

},{"nanoid":"node_modules/nanoid/index.browser.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js"}],"node_modules/ipfs-utils/src/temp-dir.browser.js":[function(require,module,exports) {
'use strict'

const { nanoid } = require('nanoid')

/**
 * Temporary folder
 *
 * @param {(uuid: string) => string} transform - Transform function to add prefixes or sufixes to the unique id
 * @returns {string} - Full real path to a temporary folder
 */
const tempdir = (transform = d => d) => {
  return transform(nanoid())
}

module.exports = tempdir

},{"nanoid":"node_modules/nanoid/index.browser.js"}],"node_modules/it-all/index.js":[function(require,module,exports) {
'use strict'

/**
 * Collects all values from an (async) iterable into an array and returns it.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */
const all = async (source) => {
  const arr = []

  for await (const entry of source) {
    arr.push(entry)
  }

  return arr
}

module.exports = all

},{}],"node_modules/interface-datastore/src/utils.js":[function(require,module,exports) {
'use strict'

const tempdir = require('ipfs-utils/src/temp-dir')
const all = require('it-all')

/**
 * Collect all values from the iterable and sort them using
 * the passed sorter function
 *
 * @template T
 * @param {AsyncIterable<T> | Iterable<T>} iterable
 * @param {(a: T, b: T) => -1 | 0 | 1} sorter
 * @returns {AsyncIterable<T>}
 */
const sortAll = (iterable, sorter) => {
  return (async function * () {
    const values = await all(iterable)
    yield * values.sort(sorter)
  })()
}

/**
 * @param {string} s
 * @param {string} r
 */
const replaceStartWith = (s, r) => {
  const matcher = new RegExp('^' + r)
  return s.replace(matcher, '')
}

module.exports = {
  sortAll,
  tmpdir: tempdir,
  replaceStartWith
}

},{"ipfs-utils/src/temp-dir":"node_modules/ipfs-utils/src/temp-dir.browser.js","it-all":"node_modules/it-all/index.js"}],"node_modules/interface-datastore/src/adapter.js":[function(require,module,exports) {
'use strict'

const { sortAll } = require('./utils')
const drain = require('it-drain')
const filter = require('it-filter')
const take = require('it-take')

/**
 * @typedef {import('interface-store').Options} Options
 * @typedef {import('./key')} Key
 * @typedef {import('./types').Pair} Pair
 * @typedef {import('./types').Datastore} Datastore
 * @typedef {import('./types').Query} Query
 * @typedef {import('./types').KeyQuery} KeyQuery
 * @typedef {import('./types').Batch} Batch
 */

/**
 * @template O
 * @typedef {import('interface-store').AwaitIterable<O>} AwaitIterable
 */

/**
 * @implements {Datastore}
 */
class Adapter {
  /**
   * @returns {Promise<void>}
   */
  open () {
    return Promise.reject(new Error('.open is not implemented'))
  }

  /**
   * @returns {Promise<void>}
   */
  close () {
    return Promise.reject(new Error('.close is not implemented'))
  }

  /**
   * @param {Key} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put (key, val, options) {
    return Promise.reject(new Error('.put is not implemented'))
  }

  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get (key, options) {
    return Promise.reject(new Error('.get is not implemented'))
  }

  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has (key, options) {
    return Promise.reject(new Error('.has is not implemented'))
  }

  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete (key, options) {
    return Promise.reject(new Error('.delete is not implemented'))
  }

  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async * putMany (source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options)
      yield { key, value }
    }
  }

  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async * getMany (source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options)
    }
  }

  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  async * deleteMany (source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options)
      yield key
    }
  }

  /**
   * @returns {Batch}
   */
  batch () {
    /** @type {Pair[]} */
    let puts = []
    /** @type {Key[]} */
    let dels = []

    return {
      put (key, value) {
        puts.push({ key, value })
      },

      delete (key) {
        dels.push(key)
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options))
        puts = []
        await drain(this.deleteMany(dels, options))
        dels = []
      }
    }
  }

  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async * _all (q, options) {
    throw new Error('._all is not implemented')
  }

  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  // eslint-disable-next-line require-yield
  async * _allKeys (q, options) {
    throw new Error('._allKeys is not implemented')
  }

  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query (q, options) {
    let it = this._all(q, options)

    if (q.prefix != null) {
      it = filter(it, (e) =>
        e.key.toString().startsWith(/** @type {string} */ (q.prefix))
      )
    }

    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it, f) => filter(it, f), it)
    }

    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it, f) => sortAll(it, f), it)
    }

    if (q.offset != null) {
      let i = 0
      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))
    }

    if (q.limit != null) {
      it = take(it, q.limit)
    }

    return it
  }

  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys (q, options) {
    let it = this._allKeys(q, options)

    if (q.prefix != null) {
      it = filter(it, (key) =>
        key.toString().startsWith(/** @type {string} */ (q.prefix))
      )
    }

    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it, f) => filter(it, f), it)
    }

    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it, f) => sortAll(it, f), it)
    }

    if (q.offset != null) {
      let i = 0
      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))
    }

    if (q.limit != null) {
      it = take(it, q.limit)
    }

    return it
  }
}

module.exports = Adapter

},{"./utils":"node_modules/interface-datastore/src/utils.js","it-drain":"node_modules/it-drain/index.js","it-filter":"node_modules/it-filter/index.js","it-take":"node_modules/it-take/index.js"}],"node_modules/interface-datastore/src/errors.js":[function(require,module,exports) {
'use strict'

const errCode = require('err-code')

/**
 * @param {Error} [err]
 */
function dbOpenFailedError (err) {
  err = err || new Error('Cannot open database')
  return errCode(err, 'ERR_DB_OPEN_FAILED')
}

/**
 * @param {Error} [err]
 */
function dbDeleteFailedError (err) {
  err = err || new Error('Delete failed')
  return errCode(err, 'ERR_DB_DELETE_FAILED')
}

/**
 * @param {Error} [err]
 */
function dbWriteFailedError (err) {
  err = err || new Error('Write failed')
  return errCode(err, 'ERR_DB_WRITE_FAILED')
}

/**
 * @param {Error} [err]
 */
function notFoundError (err) {
  err = err || new Error('Not Found')
  return errCode(err, 'ERR_NOT_FOUND')
}

/**
 * @param {Error} [err]
 */
function abortedError (err) {
  err = err || new Error('Aborted')
  return errCode(err, 'ERR_ABORTED')
}

module.exports = {
  dbOpenFailedError,
  dbDeleteFailedError,
  dbWriteFailedError,
  notFoundError,
  abortedError
}

},{"err-code":"node_modules/err-code/index.js"}],"node_modules/interface-datastore/src/memory.js":[function(require,module,exports) {
'use strict'

const Key = require('./key')
const Adapter = require('./adapter')
const Errors = require('./errors')

/**
 * @typedef {import('./types').Pair} Pair
 * @typedef {import('./types').Datastore} Datastore
 * @typedef {import('interface-store').Options} Options
 */

/**
 * @class MemoryDatastore
 * @implements {Datastore}
 */
class MemoryDatastore extends Adapter {
  constructor () {
    super()

    /** @type {Record<string, Uint8Array>} */
    this.data = {}
  }

  open () {
    return Promise.resolve()
  }

  close () {
    return Promise.resolve()
  }

  /**
   * @param {Key} key
   * @param {Uint8Array} val
   */
  async put (key, val) { // eslint-disable-line require-await
    this.data[key.toString()] = val
  }

  /**
   * @param {Key} key
   */
  async get (key) {
    const exists = await this.has(key)
    if (!exists) throw Errors.notFoundError()
    return this.data[key.toString()]
  }

  /**
   * @param {Key} key
   */
  async has (key) { // eslint-disable-line require-await
    return this.data[key.toString()] !== undefined
  }

  /**
   * @param {Key} key
   */
  async delete (key) { // eslint-disable-line require-await
    delete this.data[key.toString()]
  }

  async * _all () {
    yield * Object.entries(this.data)
      .map(([key, value]) => ({ key: new Key(key), value }))
  }

  async * _allKeys () {
    yield * Object.entries(this.data)
      .map(([key]) => new Key(key))
  }
}

module.exports = MemoryDatastore

},{"./key":"node_modules/interface-datastore/src/key.js","./adapter":"node_modules/interface-datastore/src/adapter.js","./errors":"node_modules/interface-datastore/src/errors.js"}],"node_modules/interface-datastore/src/index.js":[function(require,module,exports) {
'use strict'

/**
 * @typedef {import('./types').Datastore} Datastore
 * @typedef {import('./types').Batch} Batch
 * @typedef {import('interface-store').Options} Options
 * @typedef {import('./types').Query} Query
 * @typedef {import('./types').QueryFilter} QueryFilter
 * @typedef {import('./types').QueryOrder} QueryOrder
 * @typedef {import('./types').KeyQuery} KeyQuery
 * @typedef {import('./types').KeyQueryFilter} KeyQueryFilter
 * @typedef {import('./types').KeyQueryOrder} KeyQueryOrder
 * @typedef {import('./types').Pair} Pair
 */

const Key = require('./key')
const MemoryDatastore = require('./memory')
const utils = require('./utils')
const Errors = require('./errors')
const Adapter = require('./adapter')

module.exports = {
  Key,
  MemoryDatastore,
  utils,
  Errors,
  Adapter
}

},{"./key":"node_modules/interface-datastore/src/key.js","./memory":"node_modules/interface-datastore/src/memory.js","./utils":"node_modules/interface-datastore/src/utils.js","./errors":"node_modules/interface-datastore/src/errors.js","./adapter":"node_modules/interface-datastore/src/adapter.js"}],"node_modules/node-forge/lib/pkcs7asn1.js":[function(require,module,exports) {
/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */
var forge = require('./forge');

require('./asn1');

require('./util'); // shortcut for ASN.1 API


var asn1 = forge.asn1; // shortcut for PKCS#7 API

var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
forge.pkcs7 = forge.pkcs7 || {};
forge.pkcs7.asn1 = p7v;
var contentInfoValidator = {
  name: 'ContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'ContentInfo.ContentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'ContentInfo.content',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: 'content'
  }]
};
p7v.contentInfoValidator = contentInfoValidator;
var encryptedContentInfoValidator = {
  name: 'EncryptedContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedContentInfo.contentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'EncryptedContentInfo.encryptedContent',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,

    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: 'encryptedContent',
    captureAsn1: 'encryptedContentAsn1'
  }]
};
p7v.envelopedDataValidator = {
  name: 'EnvelopedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EnvelopedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'EnvelopedData.RecipientInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'recipientInfos'
  }].concat(encryptedContentInfoValidator)
};
p7v.encryptedDataValidator = {
  name: 'EncryptedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }].concat(encryptedContentInfoValidator)
};
var signerValidator = {
  name: 'SignerInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignerInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false
  }, {
    name: 'SignerInfo.issuerAndSerialNumber',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.issuerAndSerialNumber.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'SignerInfo.digestAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.digestAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'digestAlgorithm'
    }, {
      name: 'SignerInfo.digestAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'digestParameter',
      optional: true
    }]
  }, {
    name: 'SignerInfo.authenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'authenticatedAttributes'
  }, {
    name: 'SignerInfo.digestEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    capture: 'signatureAlgorithm'
  }, {
    name: 'SignerInfo.encryptedDigest',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'signature'
  }, {
    name: 'SignerInfo.unauthenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: 'unauthenticatedAttributes'
  }]
};
p7v.signedDataValidator = {
  name: 'SignedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'SignedData.DigestAlgorithms',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'digestAlgorithms'
  }, contentInfoValidator, {
    name: 'SignedData.Certificates',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    optional: true,
    captureAsn1: 'certificates'
  }, {
    name: 'SignedData.CertificateRevocationLists',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    optional: true,
    captureAsn1: 'crls'
  }, {
    name: 'SignedData.SignerInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    capture: 'signerInfos',
    optional: true,
    value: [signerValidator]
  }]
};
p7v.recipientInfoValidator = {
  name: 'RecipientInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'RecipientInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'RecipientInfo.issuerAndSerial',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.issuerAndSerial.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'RecipientInfo.issuerAndSerial.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'RecipientInfo.keyEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'RecipientInfo.encryptedKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encKey'
  }]
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./asn1":"node_modules/node-forge/lib/asn1.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/mgf1.js":[function(require,module,exports) {
/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./util');

forge.mgf = forge.mgf || {};
var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */

mgf1.create = function (md) {
  var mgf = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function (seed, maskLen) {
      /* 2. Let T be the empty octet string. */
      var t = new forge.util.ByteBuffer();
      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */

      var len = Math.ceil(maskLen / md.digestLength);

      for (var i = 0; i < len; i++) {
        /* a. Convert counter to an octet string C of length 4 octets */
        var c = new forge.util.ByteBuffer();
        c.putInt32(i);
        /* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */

        md.start();
        md.update(seed + c.getBytes());
        t.putBuffer(md.digest());
      }
      /* Output the leading maskLen octets of T as the octet string mask. */


      t.truncate(t.length() - maskLen);
      return t.getBytes();
    }
  };
  return mgf;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/mgf.js":[function(require,module,exports) {
/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');

require('./mgf1');

module.exports = forge.mgf = forge.mgf || {};
forge.mgf.mgf1 = forge.mgf1;
},{"./forge":"node_modules/node-forge/lib/forge.js","./mgf1":"node_modules/node-forge/lib/mgf1.js"}],"node_modules/node-forge/lib/pss.js":[function(require,module,exports) {
/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');

require('./random');

require('./util'); // shortcut for PSS API


var pss = module.exports = forge.pss = forge.pss || {};
/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */

pss.create = function (options) {
  // backwards compatibility w/legacy args: hash, mgf, sLen
  if (arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }

  var hash = options.md;
  var mgf = options.mgf;
  var hLen = hash.digestLength;
  var salt_ = options.salt || null;

  if (typeof salt_ === 'string') {
    // assume binary-encoded string
    salt_ = forge.util.createBuffer(salt_);
  }

  var sLen;

  if ('saltLength' in options) {
    sLen = options.saltLength;
  } else if (salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error('Salt length not specified or specific salt not given.');
  }

  if (salt_ !== null && salt_.length() !== sLen) {
    throw new Error('Given salt length does not match length of given salt.');
  }

  var prng = options.prng || forge.random;
  var pssobj = {};
  /**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */

  pssobj.encode = function (md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    /* 2. Let mHash = Hash(M), an octet string of length hLen. */

    var mHash = md.digest().getBytes();
    /* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */

    if (emLen < hLen + sLen + 2) {
      throw new Error('Message is too long to encrypt.');
    }
    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */


    var salt;

    if (salt_ === null) {
      salt = prng.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }
    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */


    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    /* 6. Let H = Hash(M'), an octet string of length hLen. */

    hash.start();
    hash.update(m_.getBytes());
    var h = hash.digest().getBytes();
    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */

    var ps = new forge.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);
    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */

    ps.putByte(0x01);
    ps.putBytes(salt);
    var db = ps.getBytes();
    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */

    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);
    /* 10. Let maskedDB = DB \xor dbMask. */

    var maskedDB = '';

    for (i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */


    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
    /* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */

    return maskedDB + h + String.fromCharCode(0xbc);
  };
  /**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */


  pssobj.verify = function (mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    /* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */

    em = em.substr(-emLen);
    /* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */

    if (emLen < hLen + sLen + 2) {
      throw new Error('Inconsistent parameters to PSS signature verification.');
    }
    /* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */


    if (em.charCodeAt(emLen - 1) !== 0xbc) {
      throw new Error('Encoded message does not end in 0xBC.');
    }
    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */


    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h = em.substr(maskLen, hLen);
    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */

    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;

    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error('Bits beyond keysize not zero as expected.');
    }
    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */


    var dbMask = mgf.generate(h, maskLen);
    /* 8. Let DB = maskedDB \xor dbMask. */

    var db = '';

    for (i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */


    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */

    var checkLen = emLen - hLen - sLen - 2;

    for (i = 0; i < checkLen; i++) {
      if (db.charCodeAt(i) !== 0x00) {
        throw new Error('Leftmost octets not zero as expected');
      }
    }

    if (db.charCodeAt(checkLen) !== 0x01) {
      throw new Error('Inconsistent PSS signature, 0x01 marker not found');
    }
    /* 11. Let salt be the last sLen octets of DB. */


    var salt = db.substr(-sLen);
    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */

    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    /* 13. Let H' = Hash(M'), an octet string of length hLen. */

    hash.start();
    hash.update(m_.getBytes());
    var h_ = hash.digest().getBytes();
    /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */

    return h === h_;
  };

  return pssobj;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./random":"node_modules/node-forge/lib/random.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/x509.js":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */
var forge = require('./forge');

require('./aes');

require('./asn1');

require('./des');

require('./md');

require('./mgf');

require('./oids');

require('./pem');

require('./pss');

require('./rsa');

require('./util'); // shortcut for asn.1 API


var asn1 = forge.asn1;
/* Public Key Infrastructure (PKI) implementation. */

var pki = module.exports = forge.pki = forge.pki || {};
var oids = pki.oids; // short name OID mappings

var _shortNames = {};
_shortNames['CN'] = oids['commonName'];
_shortNames['commonName'] = 'CN';
_shortNames['C'] = oids['countryName'];
_shortNames['countryName'] = 'C';
_shortNames['L'] = oids['localityName'];
_shortNames['localityName'] = 'L';
_shortNames['ST'] = oids['stateOrProvinceName'];
_shortNames['stateOrProvinceName'] = 'ST';
_shortNames['O'] = oids['organizationName'];
_shortNames['organizationName'] = 'O';
_shortNames['OU'] = oids['organizationalUnitName'];
_shortNames['organizationalUnitName'] = 'OU';
_shortNames['E'] = oids['emailAddress'];
_shortNames['emailAddress'] = 'E'; // validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key

var publicKeyValidator = forge.pki.rsa.publicKeyValidator; // validator for an X.509v3 certificate

var x509CertificateValidator = {
  name: 'Certificate',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'Certificate.TBSCertificate',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'tbsCertificate',
    value: [{
      name: 'Certificate.TBSCertificate.version',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.version.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certVersion'
      }]
    }, {
      name: 'Certificate.TBSCertificate.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'certSerialNumber'
    }, {
      name: 'Certificate.TBSCertificate.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate.signature.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certinfoSignatureOid'
      }, {
        name: 'Certificate.TBSCertificate.signature.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'certinfoSignatureParams'
      }]
    }, {
      name: 'Certificate.TBSCertificate.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certIssuer'
    }, {
      name: 'Certificate.TBSCertificate.validity',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      // Note: UTC and generalized times may both appear so the capture
      // names are based on their detected order, the names used below
      // are only for the common case, which validity time really means
      // "notBefore" and which means "notAfter" will be determined by order
      value: [{
        // notBefore (Time) (UTC time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity1UTCTime'
      }, {
        // notBefore (Time) (generalized time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity2GeneralizedTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity3UTCTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity4GeneralizedTime'
      }]
    }, {
      // Name (subject) (RDNSequence)
      name: 'Certificate.TBSCertificate.subject',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certSubject'
    }, // SubjectPublicKeyInfo
    publicKeyValidator, {
      // issuerUniqueID (optional)
      name: 'Certificate.TBSCertificate.issuerUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.issuerUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certIssuerUniqueId'
      }]
    }, {
      // subjectUniqueID (optional)
      name: 'Certificate.TBSCertificate.subjectUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.subjectUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certSubjectUniqueId'
      }]
    }, {
      // Extensions (optional)
      name: 'Certificate.TBSCertificate.extensions',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      constructed: true,
      captureAsn1: 'certExtensions',
      optional: true
    }]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: 'Certificate.signatureAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: 'Certificate.signatureAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'certSignatureOid'
    }, {
      name: 'Certificate.TBSCertificate.signature.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: 'certSignatureParams'
    }]
  }, {
    // SignatureValue
    name: 'Certificate.signatureValue',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: 'certSignature'
  }]
};
var rsassaPssParameterValidator = {
  name: 'rsapss',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'rsapss.hashAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'hashOid'
        /* parameter block omitted, for SHA1 NULL anyhow. */

      }]
    }]
  }, {
    name: 'rsapss.maskGenAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'maskGenOid'
      }, {
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'maskGenHashOid'
          /* parameter block omitted, for SHA1 NULL anyhow. */

        }]
      }]
    }]
  }, {
    name: 'rsapss.saltLength',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: 'rsapss.saltLength.saltLength',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'saltLength'
    }]
  }, {
    name: 'rsapss.trailerField',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: 'rsapss.trailer.trailer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'trailer'
    }]
  }]
}; // validator for a CertificationRequestInfo structure

var certificationRequestInfoValidator = {
  name: 'CertificationRequestInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'certificationRequestInfo',
  value: [{
    name: 'CertificationRequestInfo.integer',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'certificationRequestInfoVersion'
  }, {
    // Name (subject) (RDNSequence)
    name: 'CertificationRequestInfo.subject',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'certificationRequestInfoSubject'
  }, // SubjectPublicKeyInfo
  publicKeyValidator, {
    name: 'CertificationRequestInfo.attributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'certificationRequestInfoAttributes',
    value: [{
      name: 'CertificationRequestInfo.attributes',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertificationRequestInfo.attributes.type',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false
      }, {
        name: 'CertificationRequestInfo.attributes.value',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true
      }]
    }]
  }]
}; // validator for a CertificationRequest structure

var certificationRequestValidator = {
  name: 'CertificationRequest',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'csr',
  value: [certificationRequestInfoValidator, {
    // AlgorithmIdentifier (signature algorithm)
    name: 'CertificationRequest.signatureAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: 'CertificationRequest.signatureAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'csrSignatureOid'
    }, {
      name: 'CertificationRequest.signatureAlgorithm.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: 'csrSignatureParams'
    }]
  }, {
    // signature
    name: 'CertificationRequest.signature',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: 'csrSignature'
  }]
};
/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */

pki.RDNAttributesAsArray = function (rdn, md) {
  var rval = []; // each value in 'rdn' in is a SET of RelativeDistinguishedName

  var set, attr, obj;

  for (var si = 0; si < rdn.value.length; ++si) {
    // get the RelativeDistinguishedName set
    set = rdn.value[si]; // each value in the SET is an AttributeTypeAndValue sequence
    // containing first a type (an OID) and second a value (defined by
    // the OID)

    for (var i = 0; i < set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type; // if the OID is known, get its name and short name

      if (obj.type in oids) {
        obj.name = oids[obj.type];

        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }

      if (md) {
        md.update(obj.type);
        md.update(obj.value);
      }

      rval.push(obj);
    }
  }

  return rval;
};
/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */


pki.CRIAttributesAsArray = function (attributes) {
  var rval = []; // each value in 'attributes' in is a SEQUENCE with an OID and a SET

  for (var si = 0; si < attributes.length; ++si) {
    // get the attribute sequence
    var seq = attributes[si]; // each value in the SEQUENCE containing first a type (an OID) and
    // second a set of values (defined by the OID)

    var type = asn1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;

    for (var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type; // if the OID is known, get its name and short name

      if (obj.type in oids) {
        obj.name = oids[obj.type];

        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      } // parse extensions


      if (obj.type === oids.extensionRequest) {
        obj.extensions = [];

        for (var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }

      rval.push(obj);
    }
  }

  return rval;
};
/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */


function _getAttribute(obj, options) {
  if (typeof options === 'string') {
    options = {
      shortName: options
    };
  }

  var rval = null;
  var attr;

  for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];

    if (options.type && options.type === attr.type) {
      rval = attr;
    } else if (options.name && options.name === attr.name) {
      rval = attr;
    } else if (options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }

  return rval;
}
/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */


var _readSignatureParameters = function (oid, obj, fillDefaults) {
  var params = {};

  if (oid !== oids['RSASSA-PSS']) {
    return params;
  }

  if (fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids['sha1']
      },
      mgf: {
        algorithmOid: oids['mgf1'],
        hash: {
          algorithmOid: oids['sha1']
        }
      },
      saltLength: 20
    };
  }

  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
    var error = new Error('Cannot read RSASSA-PSS parameter block.');
    error.errors = errors;
    throw error;
  }

  if (capture.hashOid !== undefined) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
  }

  if (capture.maskGenOid !== undefined) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
  }

  if (capture.saltLength !== undefined) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }

  return params;
};
/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */


pki.certificateFromPem = function (pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {
    var error = new Error('Could not convert certificate from PEM; PEM header type ' + 'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    error.headerType = msg.type;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
  } // convert DER to ASN.1 object


  var obj = asn1.fromDer(msg.body, strict);
  return pki.certificateFromAsn1(obj, computeHash);
};
/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */


pki.certificateToPem = function (cert, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE',
    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
  };
  return forge.pem.encode(msg, {
    maxline: maxline
  });
};
/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */


pki.publicKeyFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
    var error = new Error('Could not convert public key from PEM; PEM header ' + 'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error.headerType = msg.type;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert public key from PEM; PEM is encrypted.');
  } // convert DER to ASN.1 object


  var obj = asn1.fromDer(msg.body);
  return pki.publicKeyFromAsn1(obj);
};
/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */


pki.publicKeyToPem = function (key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {
    maxline: maxline
  });
};
/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */


pki.publicKeyToRSAPublicKeyPem = function (key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge.pem.encode(msg, {
    maxline: maxline
  });
};
/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */


pki.getPublicKeyFingerprint = function (key, options) {
  options = options || {};
  var md = options.md || forge.md.sha1.create();
  var type = options.type || 'RSAPublicKey';
  var bytes;

  switch (type) {
    case 'RSAPublicKey':
      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
      break;

    case 'SubjectPublicKeyInfo':
      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
      break;

    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  } // hash public key bytes


  md.start();
  md.update(bytes);
  var digest = md.digest();

  if (options.encoding === 'hex') {
    var hex = digest.toHex();

    if (options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }

    return hex;
  } else if (options.encoding === 'binary') {
    return digest.getBytes();
  } else if (options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }

  return digest;
};
/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */


pki.certificationRequestFromPem = function (pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'CERTIFICATE REQUEST') {
    var error = new Error('Could not convert certification request from PEM; ' + 'PEM header type is not "CERTIFICATE REQUEST".');
    error.headerType = msg.type;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certification request from PEM; ' + 'PEM is encrypted.');
  } // convert DER to ASN.1 object


  var obj = asn1.fromDer(msg.body, strict);
  return pki.certificationRequestFromAsn1(obj, computeHash);
};
/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */


pki.certificationRequestToPem = function (csr, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE REQUEST',
    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge.pem.encode(msg, {
    maxline: maxline
  });
};
/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */


pki.createCertificate = function () {
  var cert = {};
  cert.version = 0x02;
  cert.serialNumber = '00';
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.issuer = {};

  cert.issuer.getField = function (sn) {
    return _getAttribute(cert.issuer, sn);
  };

  cert.issuer.addField = function (attr) {
    _fillMissingFields([attr]);

    cert.issuer.attributes.push(attr);
  };

  cert.issuer.attributes = [];
  cert.issuer.hash = null;
  cert.subject = {};

  cert.subject.getField = function (sn) {
    return _getAttribute(cert.subject, sn);
  };

  cert.subject.addField = function (attr) {
    _fillMissingFields([attr]);

    cert.subject.attributes.push(attr);
  };

  cert.subject.attributes = [];
  cert.subject.hash = null;
  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;
  /**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */

  cert.setSubject = function (attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);

    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;

    if (uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.subject.uniqueId = uniqueId;
    }

    cert.subject.hash = null;
  };
  /**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */


  cert.setIssuer = function (attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);

    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;

    if (uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.issuer.uniqueId = uniqueId;
    }

    cert.issuer.hash = null;
  };
  /**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */


  cert.setExtensions = function (exts) {
    for (var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], {
        cert: cert
      });
    } // set new extensions


    cert.extensions = exts;
  };
  /**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */


  cert.getExtension = function (options) {
    if (typeof options === 'string') {
      options = {
        name: options
      };
    }

    var rval = null;
    var ext;

    for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];

      if (options.id && ext.id === options.id) {
        rval = ext;
      } else if (options.name && ext.name === options.name) {
        rval = ext;
      }
    }

    return rval;
  };
  /**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */


  cert.sign = function (key, md) {
    // TODO: get signature OID from private key
    cert.md = md || forge.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];

    if (!algorithmOid) {
      var error = new Error('Could not compute certificate digest. ' + 'Unknown message digest algorithm OID.');
      error.algorithm = cert.md.algorithm;
      throw error;
    }

    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid; // get TBSCertificate, convert to DER

    cert.tbsCertificate = pki.getTBSCertificate(cert);
    var bytes = asn1.toDer(cert.tbsCertificate); // digest and sign

    cert.md.update(bytes.getBytes());
    cert.signature = key.sign(cert.md);
  };
  /**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */


  cert.verify = function (child) {
    var rval = false;

    if (!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error = new Error('The parent certificate did not issue the given child ' + 'certificate; the child certificate\'s issuer does not match the ' + 'parent\'s subject.');
      error.expectedIssuer = issuer.attributes;
      error.actualIssuer = subject.attributes;
      throw error;
    }

    var md = child.md;

    if (md === null) {
      // check signature OID for supported signature types
      if (child.signatureOid in oids) {
        var oid = oids[child.signatureOid];

        switch (oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;

          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;

          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;

          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;

          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;

          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }

      if (md === null) {
        var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
        error.signatureOid = child.signatureOid;
        throw error;
      } // produce DER formatted TBSCertificate and digest it


      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
      var bytes = asn1.toDer(tbsCertificate);
      md.update(bytes.getBytes());
    }

    if (md !== null) {
      var scheme;

      switch (child.signatureOid) {
        case oids.sha1WithRSAEncryption:
          scheme = undefined;
          /* use PKCS#1 v1.5 padding scheme */

          break;

        case oids['RSASSA-PSS']:
          var hash, mgf;
          /* initialize mgf */

          hash = oids[child.signatureParameters.mgf.hash.algorithmOid];

          if (hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = child.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[child.signatureParameters.mgf.algorithmOid];

          if (mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = child.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());
          /* initialize hash function */

          hash = oids[child.signatureParameters.hash.algorithmOid];

          if (hash === undefined || forge.md[hash] === undefined) {
            throw {
              message: 'Unsupported RSASSA-PSS hash function.',
              oid: child.signatureParameters.hash.algorithmOid,
              name: hash
            };
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
          break;
      } // verify signature on cert using public key


      rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
    }

    return rval;
  };
  /**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */


  cert.isIssuer = function (parent) {
    var rval = false;
    var i = cert.issuer;
    var s = parent.subject; // compare hashes if present

    if (i.hash && s.hash) {
      rval = i.hash === s.hash;
    } else if (i.attributes.length === s.attributes.length) {
      // all attributes are the same so issuer matches subject
      rval = true;
      var iattr, sattr;

      for (var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s.attributes[n];

        if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
          // attribute mismatch
          rval = false;
        }
      }
    }

    return rval;
  };
  /**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */


  cert.issued = function (child) {
    return child.isIssuer(cert);
  };
  /**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */


  cert.generateSubjectKeyIdentifier = function () {
    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:
       (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).
       (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */
    // skipping the tag, length, and number of unused bits is the same
    // as just using the RSAPublicKey (for RSA keys, which are the
    // only ones supported)
    return pki.getPublicKeyFingerprint(cert.publicKey, {
      type: 'RSAPublicKey'
    });
  };
  /**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */


  cert.verifySubjectKeyIdentifier = function () {
    var oid = oids['subjectKeyIdentifier'];

    for (var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];

      if (ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
      }
    }

    return false;
  };

  return cert;
};
/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */


pki.certificateFromAsn1 = function (obj, computeHash) {
  // validate certificate and capture data
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
    var error = new Error('Cannot read X.509 certificate. ' + 'ASN.1 object is not an X509v3 Certificate.');
    error.errors = errors;
    throw error;
  } // get oid


  var oid = asn1.derToOid(capture.publicKeyOid);

  if (oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  } // create certificate


  var cert = pki.createCertificate();
  cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
  var serial = forge.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
  cert.signature = capture.certSignature;
  var validity = [];

  if (capture.certValidity1UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
  }

  if (capture.certValidity2GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
  }

  if (capture.certValidity3UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
  }

  if (capture.certValidity4GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
  }

  if (validity.length > 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; more ' + 'than two times were provided in the certificate.');
  }

  if (validity.length < 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; they ' + 'were not provided as either UTCTime or GeneralizedTime.');
  }

  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1]; // keep TBSCertificate to preserve signature when exporting

  cert.tbsCertificate = capture.tbsCertificate;

  if (computeHash) {
    // check signature OID for supported signature types
    cert.md = null;

    if (cert.signatureOid in oids) {
      var oid = oids[cert.signatureOid];

      switch (oid) {
        case 'sha1WithRSAEncryption':
          cert.md = forge.md.sha1.create();
          break;

        case 'md5WithRSAEncryption':
          cert.md = forge.md.md5.create();
          break;

        case 'sha256WithRSAEncryption':
          cert.md = forge.md.sha256.create();
          break;

        case 'sha384WithRSAEncryption':
          cert.md = forge.md.sha384.create();
          break;

        case 'sha512WithRSAEncryption':
          cert.md = forge.md.sha512.create();
          break;

        case 'RSASSA-PSS':
          cert.md = forge.md.sha256.create();
          break;
      }
    }

    if (cert.md === null) {
      var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');
      error.signatureOid = cert.signatureOid;
      throw error;
    } // produce DER formatted TBSCertificate and digest it


    var bytes = asn1.toDer(cert.tbsCertificate);
    cert.md.update(bytes.getBytes());
  } // handle issuer, build issuer message digest


  var imd = forge.md.sha1.create();

  cert.issuer.getField = function (sn) {
    return _getAttribute(cert.issuer, sn);
  };

  cert.issuer.addField = function (attr) {
    _fillMissingFields([attr]);

    cert.issuer.attributes.push(attr);
  };

  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);

  if (capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }

  cert.issuer.hash = imd.digest().toHex(); // handle subject, build subject message digest

  var smd = forge.md.sha1.create();

  cert.subject.getField = function (sn) {
    return _getAttribute(cert.subject, sn);
  };

  cert.subject.addField = function (attr) {
    _fillMissingFields([attr]);

    cert.subject.attributes.push(attr);
  };

  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);

  if (capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }

  cert.subject.hash = smd.digest().toHex(); // handle extensions

  if (capture.certExtensions) {
    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  } // convert RSA public key from ASN.1


  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  return cert;
};
/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */


pki.certificateExtensionsFromAsn1 = function (exts) {
  var rval = [];

  for (var i = 0; i < exts.value.length; ++i) {
    // get extension sequence
    var extseq = exts.value[i];

    for (var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }

  return rval;
};
/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */


pki.certificateExtensionFromAsn1 = function (ext) {
  // an extension has:
  // [0] extnID      OBJECT IDENTIFIER
  // [1] critical    BOOLEAN DEFAULT FALSE
  // [2] extnValue   OCTET STRING
  var e = {};
  e.id = asn1.derToOid(ext.value[0].value);
  e.critical = false;

  if (ext.value[1].type === asn1.Type.BOOLEAN) {
    e.critical = ext.value[1].value.charCodeAt(0) !== 0x00;
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  } // if the oid is known, get its name


  if (e.id in oids) {
    e.name = oids[e.id]; // handle key usage

    if (e.name === 'keyUsage') {
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      var b3 = 0x00;

      if (ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      } // set flags


      e.digitalSignature = (b2 & 0x80) === 0x80;
      e.nonRepudiation = (b2 & 0x40) === 0x40;
      e.keyEncipherment = (b2 & 0x20) === 0x20;
      e.dataEncipherment = (b2 & 0x10) === 0x10;
      e.keyAgreement = (b2 & 0x08) === 0x08;
      e.keyCertSign = (b2 & 0x04) === 0x04;
      e.cRLSign = (b2 & 0x02) === 0x02;
      e.encipherOnly = (b2 & 0x01) === 0x01;
      e.decipherOnly = (b3 & 0x80) === 0x80;
    } else if (e.name === 'basicConstraints') {
      // handle basic constraints
      // get value as SEQUENCE
      var ev = asn1.fromDer(e.value); // get cA BOOLEAN flag (defaults to false)

      if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
        e.cA = ev.value[0].value.charCodeAt(0) !== 0x00;
      } else {
        e.cA = false;
      } // get path length constraint


      var value = null;

      if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
        value = ev.value[0].value;
      } else if (ev.value.length > 1) {
        value = ev.value[1].value;
      }

      if (value !== null) {
        e.pathLenConstraint = asn1.derToInteger(value);
      }
    } else if (e.name === 'extKeyUsage') {
      // handle extKeyUsage
      // value is a SEQUENCE of OIDs
      var ev = asn1.fromDer(e.value);

      for (var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);

        if (oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if (e.name === 'nsCertType') {
      // handle nsCertType
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;

      if (ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
      } // set flags


      e.client = (b2 & 0x80) === 0x80;
      e.server = (b2 & 0x40) === 0x40;
      e.email = (b2 & 0x20) === 0x20;
      e.objsign = (b2 & 0x10) === 0x10;
      e.reserved = (b2 & 0x08) === 0x08;
      e.sslCA = (b2 & 0x04) === 0x04;
      e.emailCA = (b2 & 0x02) === 0x02;
      e.objCA = (b2 & 0x01) === 0x01;
    } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
      // handle subjectAltName/issuerAltName
      e.altNames = []; // ev is a SYNTAX SEQUENCE

      var gn;
      var ev = asn1.fromDer(e.value);

      for (var n = 0; n < ev.value.length; ++n) {
        // get GeneralName
        gn = ev.value[n];
        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName); // Note: Support for types 1,2,6,7,8

        switch (gn.type) {
          // rfc822Name
          case 1: // dNSName

          case 2: // uniformResourceIdentifier (URI)

          case 6:
            break;
          // IPAddress

          case 7:
            // convert to IPv4/IPv6 string representation
            altName.ip = forge.util.bytesToIP(gn.value);
            break;
          // registeredID

          case 8:
            altName.oid = asn1.derToOid(gn.value);
            break;

          default: // unsupported

        }
      }
    } else if (e.name === 'subjectKeyIdentifier') {
      // value is an OCTETSTRING w/the hash of the key-type specific
      // public key structure (eg: RSAPublicKey)
      var ev = asn1.fromDer(e.value);
      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
    }
  }

  return e;
};
/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */


pki.certificationRequestFromAsn1 = function (obj, computeHash) {
  // validate certification request and capture data
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#10 certificate request. ' + 'ASN.1 object is not a PKCS#10 CertificationRequest.');
    error.errors = errors;
    throw error;
  } // get oid


  var oid = asn1.derToOid(capture.publicKeyOid);

  if (oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  } // create certification request


  var csr = pki.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
  csr.signature = capture.csrSignature; // keep CertificationRequestInfo to preserve signature when exporting

  csr.certificationRequestInfo = capture.certificationRequestInfo;

  if (computeHash) {
    // check signature OID for supported signature types
    csr.md = null;

    if (csr.signatureOid in oids) {
      var oid = oids[csr.signatureOid];

      switch (oid) {
        case 'sha1WithRSAEncryption':
          csr.md = forge.md.sha1.create();
          break;

        case 'md5WithRSAEncryption':
          csr.md = forge.md.md5.create();
          break;

        case 'sha256WithRSAEncryption':
          csr.md = forge.md.sha256.create();
          break;

        case 'sha384WithRSAEncryption':
          csr.md = forge.md.sha384.create();
          break;

        case 'sha512WithRSAEncryption':
          csr.md = forge.md.sha512.create();
          break;

        case 'RSASSA-PSS':
          csr.md = forge.md.sha256.create();
          break;
      }
    }

    if (csr.md === null) {
      var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
      error.signatureOid = csr.signatureOid;
      throw error;
    } // produce DER formatted CertificationRequestInfo and digest it


    var bytes = asn1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes.getBytes());
  } // handle subject, build subject message digest


  var smd = forge.md.sha1.create();

  csr.subject.getField = function (sn) {
    return _getAttribute(csr.subject, sn);
  };

  csr.subject.addField = function (attr) {
    _fillMissingFields([attr]);

    csr.subject.attributes.push(attr);
  };

  csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
  csr.subject.hash = smd.digest().toHex(); // convert RSA public key from ASN.1

  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo); // convert attributes from ASN.1

  csr.getAttribute = function (sn) {
    return _getAttribute(csr, sn);
  };

  csr.addAttribute = function (attr) {
    _fillMissingFields([attr]);

    csr.attributes.push(attr);
  };

  csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
  return csr;
};
/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */


pki.createCertificationRequest = function () {
  var csr = {};
  csr.version = 0x00;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;
  csr.subject = {};

  csr.subject.getField = function (sn) {
    return _getAttribute(csr.subject, sn);
  };

  csr.subject.addField = function (attr) {
    _fillMissingFields([attr]);

    csr.subject.attributes.push(attr);
  };

  csr.subject.attributes = [];
  csr.subject.hash = null;
  csr.publicKey = null;
  csr.attributes = [];

  csr.getAttribute = function (sn) {
    return _getAttribute(csr, sn);
  };

  csr.addAttribute = function (attr) {
    _fillMissingFields([attr]);

    csr.attributes.push(attr);
  };

  csr.md = null;
  /**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */

  csr.setSubject = function (attrs) {
    // set new attributes
    _fillMissingFields(attrs);

    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };
  /**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */


  csr.setAttributes = function (attrs) {
    // set new attributes
    _fillMissingFields(attrs);

    csr.attributes = attrs;
  };
  /**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */


  csr.sign = function (key, md) {
    // TODO: get signature OID from private key
    csr.md = md || forge.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];

    if (!algorithmOid) {
      var error = new Error('Could not compute certification request digest. ' + 'Unknown message digest algorithm OID.');
      error.algorithm = csr.md.algorithm;
      throw error;
    }

    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid; // get CertificationRequestInfo, convert to DER

    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
    var bytes = asn1.toDer(csr.certificationRequestInfo); // digest and sign

    csr.md.update(bytes.getBytes());
    csr.signature = key.sign(csr.md);
  };
  /**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */


  csr.verify = function () {
    var rval = false;
    var md = csr.md;

    if (md === null) {
      // check signature OID for supported signature types
      if (csr.signatureOid in oids) {
        // TODO: create DRY `OID to md` function
        var oid = oids[csr.signatureOid];

        switch (oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;

          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;

          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;

          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;

          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;

          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }

      if (md === null) {
        var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');
        error.signatureOid = csr.signatureOid;
        throw error;
      } // produce DER formatted CertificationRequestInfo and digest it


      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(cri);
      md.update(bytes.getBytes());
    }

    if (md !== null) {
      var scheme;

      switch (csr.signatureOid) {
        case oids.sha1WithRSAEncryption:
          /* use PKCS#1 v1.5 padding scheme */
          break;

        case oids['RSASSA-PSS']:
          var hash, mgf;
          /* initialize mgf */

          hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];

          if (hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[csr.signatureParameters.mgf.algorithmOid];

          if (mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = csr.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());
          /* initialize hash function */

          hash = oids[csr.signatureParameters.hash.algorithmOid];

          if (hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported RSASSA-PSS hash function.');
            error.oid = csr.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
          break;
      } // verify signature on csr using its public key


      rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
    }

    return rval;
  };

  return csr;
};
/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */


function _dnToAsn1(obj) {
  // create an empty RDNSequence
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // iterate over attributes

  var attr, set;
  var attrs = obj.attributes;

  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value = attr.value; // reuse tag class for attribute value if available

    var valueTagClass = asn1.Type.PRINTABLESTRING;

    if ('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;

      if (valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      } // FIXME: handle more encodings

    } // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value


    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AttributeType
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), // AttributeValue
    asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);
    rval.value.push(set);
  }

  return rval;
}
/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */


function _getAttributesAsJson(attrs) {
  var rval = {};

  for (var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];

    if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) {
      var value = attr.value;

      if (attr.valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(attr.value);
      }

      if (!(attr.shortName in rval)) {
        rval[attr.shortName] = value;
      } else if (forge.util.isArray(rval[attr.shortName])) {
        rval[attr.shortName].push(value);
      } else {
        rval[attr.shortName] = [rval[attr.shortName], value];
      }
    }
  }

  return rval;
}
/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */


function _fillMissingFields(attrs) {
  var attr;

  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i]; // populate missing name

    if (typeof attr.name === 'undefined') {
      if (attr.type && attr.type in pki.oids) {
        attr.name = pki.oids[attr.type];
      } else if (attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki.oids[_shortNames[attr.shortName]];
      }
    } // populate missing type (OID)


    if (typeof attr.type === 'undefined') {
      if (attr.name && attr.name in pki.oids) {
        attr.type = pki.oids[attr.name];
      } else {
        var error = new Error('Attribute type not specified.');
        error.attribute = attr;
        throw error;
      }
    } // populate missing shortname


    if (typeof attr.shortName === 'undefined') {
      if (attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    } // convert extensions to value


    if (attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1.Type.SEQUENCE;

      if (!attr.value && attr.extensions) {
        attr.value = [];

        for (var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
        }
      }
    }

    if (typeof attr.value === 'undefined') {
      var error = new Error('Attribute value not specified.');
      error.attribute = attr;
      throw error;
    }
  }
}
/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */


function _fillMissingExtensionFields(e, options) {
  options = options || {}; // populate missing name

  if (typeof e.name === 'undefined') {
    if (e.id && e.id in pki.oids) {
      e.name = pki.oids[e.id];
    }
  } // populate missing id


  if (typeof e.id === 'undefined') {
    if (e.name && e.name in pki.oids) {
      e.id = pki.oids[e.name];
    } else {
      var error = new Error('Extension ID not specified.');
      error.extension = e;
      throw error;
    }
  }

  if (typeof e.value !== 'undefined') {
    return e;
  } // handle missing value:
  // value is a BIT STRING


  if (e.name === 'keyUsage') {
    // build flags
    var unused = 0;
    var b2 = 0x00;
    var b3 = 0x00;

    if (e.digitalSignature) {
      b2 |= 0x80;
      unused = 7;
    }

    if (e.nonRepudiation) {
      b2 |= 0x40;
      unused = 6;
    }

    if (e.keyEncipherment) {
      b2 |= 0x20;
      unused = 5;
    }

    if (e.dataEncipherment) {
      b2 |= 0x10;
      unused = 4;
    }

    if (e.keyAgreement) {
      b2 |= 0x08;
      unused = 3;
    }

    if (e.keyCertSign) {
      b2 |= 0x04;
      unused = 2;
    }

    if (e.cRLSign) {
      b2 |= 0x02;
      unused = 1;
    }

    if (e.encipherOnly) {
      b2 |= 0x01;
      unused = 0;
    }

    if (e.decipherOnly) {
      b3 |= 0x80;
      unused = 7;
    } // create bit string


    var value = String.fromCharCode(unused);

    if (b3 !== 0) {
      value += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if (b2 !== 0) {
      value += String.fromCharCode(b2);
    }

    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if (e.name === 'basicConstraints') {
    // basicConstraints is a SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // cA BOOLEAN flag defaults to false

    if (e.cA) {
      e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
    }

    if ('pathLenConstraint' in e) {
      e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
    }
  } else if (e.name === 'extKeyUsage') {
    // extKeyUsage is a SEQUENCE of OIDs
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    for (var key in e) {
      if (e[key] !== true) {
        continue;
      } // key is name in OID map


      if (key in oids) {
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
      } else if (key.indexOf('.') !== -1) {
        // assume key is an OID
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
      }
    }
  } else if (e.name === 'nsCertType') {
    // nsCertType is a BIT STRING
    // build flags
    var unused = 0;
    var b2 = 0x00;

    if (e.client) {
      b2 |= 0x80;
      unused = 7;
    }

    if (e.server) {
      b2 |= 0x40;
      unused = 6;
    }

    if (e.email) {
      b2 |= 0x20;
      unused = 5;
    }

    if (e.objsign) {
      b2 |= 0x10;
      unused = 4;
    }

    if (e.reserved) {
      b2 |= 0x08;
      unused = 3;
    }

    if (e.sslCA) {
      b2 |= 0x04;
      unused = 2;
    }

    if (e.emailCA) {
      b2 |= 0x02;
      unused = 1;
    }

    if (e.objCA) {
      b2 |= 0x01;
      unused = 0;
    } // create bit string


    var value = String.fromCharCode(unused);

    if (b2 !== 0) {
      value += String.fromCharCode(b2);
    }

    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var altName;

    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value; // handle IP

      if (altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);

        if (value === null) {
          var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if (altName.type === 8) {
        // handle OID
        if (altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }

      e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
    }
  } else if (e.name === 'nsComment' && options.cert) {
    // sanity check value is ASCII (req'd) and not too big
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
      throw new Error('Invalid "nsComment" content.');
    } // IA5STRING opaque comment


    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
  } else if (e.name === 'subjectKeyIdentifier' && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex(); // OCTETSTRING w/digest

    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
  } else if (e.name === 'authorityKeyIdentifier' && options.cert) {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    if (e.keyIdentifier) {
      var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
    }

    if (e.authorityCertIssuer) {
      var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [_dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)])];
      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
    }

    if (e.serialNumber) {
      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
    }
  } else if (e.name === 'cRLDistributionPoints') {
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value; // Create sub SEQUENCE of DistributionPointName

    var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // Create fullName CHOICE

    var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    var altName;

    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value; // handle IP

      if (altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);

        if (value === null) {
          var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if (altName.type === 8) {
        // handle OID
        if (altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }

      fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
    } // Add to the parent SEQUENCE


    subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
    seq.push(subSeq);
  } // ensure value has been defined by now


  if (typeof e.value === 'undefined') {
    var error = new Error('Extension value not specified.');
    error.extension = e;
    throw error;
  }

  return e;
}
/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */


function _signatureParametersToAsn1(oid, params) {
  switch (oid) {
    case oids['RSASSA-PSS']:
      var parts = [];

      if (params.hash.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]));
      }

      if (params.mgf.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])])]));
      }

      if (params.saltLength !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));
      }

      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);

    default:
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
  }
}
/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */


function _CRIAttributesToAsn1(csr) {
  // create an empty context-specific container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); // no attributes, return empty container

  if (csr.attributes.length === 0) {
    return rval;
  } // each attribute has a sequence with a type and a set of values


  var attrs = csr.attributes;

  for (var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value = attr.value; // reuse tag class for attribute value if available

    var valueTagClass = asn1.Type.UTF8;

    if ('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;
    }

    if (valueTagClass === asn1.Type.UTF8) {
      value = forge.util.encodeUtf8(value);
    }

    var valueConstructed = false;

    if ('valueConstructed' in attr) {
      valueConstructed = attr.valueConstructed;
    } // FIXME: handle more encodings
    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value


    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AttributeType
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [// AttributeValue
    asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
    rval.value.push(seq);
  }

  return rval;
}

var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
var jan_1_2050 = new Date('2050-01-01T00:00:00Z');
/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */

function _dateToAsn1(date) {
  if (date >= jan_1_1950 && date < jan_1_2050) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
  } else {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
  }
}
/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */


pki.getTBSCertificate = function (cert) {
  // TBSCertificate
  var notBefore = _dateToAsn1(cert.validity.notBefore);

  var notAfter = _dateToAsn1(cert.validity.notAfter);

  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version
  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// integer
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]), // serialNumber
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)), // signature
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), // parameters
  _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), // issuer
  _dnToAsn1(cert.issuer), // validity
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [notBefore, notAfter]), // subject
  _dnToAsn1(cert.subject), // SubjectPublicKeyInfo
  pki.publicKeyToAsn1(cert.publicKey)]);

  if (cert.issuer.uniqueId) {
    // issuerUniqueID (optional)
    tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids
    String.fromCharCode(0x00) + cert.issuer.uniqueId)]));
  }

  if (cert.subject.uniqueId) {
    // subjectUniqueID (optional)
    tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids
    String.fromCharCode(0x00) + cert.subject.uniqueId)]));
  }

  if (cert.extensions.length > 0) {
    // extensions (optional)
    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
  }

  return tbs;
};
/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */


pki.getCertificationRequestInfo = function (csr) {
  // CertificationRequestInfo
  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()), // subject
  _dnToAsn1(csr.subject), // SubjectPublicKeyInfo
  pki.publicKeyToAsn1(csr.publicKey), // attributes
  _CRIAttributesToAsn1(csr)]);
  return cri;
};
/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */


pki.distinguishedNameToAsn1 = function (dn) {
  return _dnToAsn1(dn);
};
/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */


pki.certificateToAsn1 = function (cert) {
  // prefer cached TBSCertificate over generating one
  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert); // Certificate

  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// TBSCertificate
  tbsCertificate, // AlgorithmIdentifier (signature algorithm)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), // parameters
  _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), // SignatureValue
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.signature)]);
};
/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */


pki.certificateExtensionsToAsn1 = function (exts) {
  // create top-level extension container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []); // create extension sequence (stores a sequence for each extension)

  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  rval.value.push(seq);

  for (var i = 0; i < exts.length; ++i) {
    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
  }

  return rval;
};
/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */


pki.certificateExtensionToAsn1 = function (ext) {
  // create a sequence for each extension
  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // extnID (OID)

  extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes())); // critical defaults to false

  if (ext.critical) {
    // critical BOOLEAN DEFAULT FALSE
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));
  }

  var value = ext.value;

  if (typeof ext.value !== 'string') {
    // value is asn.1
    value = asn1.toDer(value).getBytes();
  } // extnValue (OCTET STRING)


  extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
  return extseq;
};
/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */


pki.certificationRequestToAsn1 = function (csr) {
  // prefer cached CertificationRequestInfo over generating one
  var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr); // Certificate

  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// CertificationRequestInfo
  cri, // AlgorithmIdentifier (signature algorithm)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), // parameters
  _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), // signature
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + csr.signature)]);
};
/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */


pki.createCaStore = function (certs) {
  // create CA store
  var caStore = {
    // stored certificates
    certs: {}
  };
  /**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */

  caStore.getIssuer = function (cert) {
    var rval = getBySubject(cert.issuer); // see if there are multiple matches

    /*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/

    return rval;
  };
  /**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */


  caStore.addCertificate = function (cert) {
    // convert from pem if necessary
    if (typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if (!caStore.hasCertificate(cert)) {
      // avoid duplicate certificates in store
      if (cert.subject.hash in caStore.certs) {
        // subject hash already exists, append to array
        var tmp = caStore.certs[cert.subject.hash];

        if (!forge.util.isArray(tmp)) {
          tmp = [tmp];
        }

        tmp.push(cert);
        caStore.certs[cert.subject.hash] = tmp;
      } else {
        caStore.certs[cert.subject.hash] = cert;
      }
    }
  };
  /**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */


  caStore.hasCertificate = function (cert) {
    // convert from pem if necessary
    if (typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    var match = getBySubject(cert.subject);

    if (!match) {
      return false;
    }

    if (!forge.util.isArray(match)) {
      match = [match];
    } // compare DER-encoding of certificates


    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();

    for (var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();

      if (der1 === der2) {
        return true;
      }
    }

    return false;
  };
  /**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */


  caStore.listAllCertificates = function () {
    var certList = [];

    for (var hash in caStore.certs) {
      if (caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];

        if (!forge.util.isArray(value)) {
          certList.push(value);
        } else {
          for (var i = 0; i < value.length; ++i) {
            certList.push(value[i]);
          }
        }
      }
    }

    return certList;
  };
  /**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */


  caStore.removeCertificate = function (cert) {
    var result; // convert from pem if necessary

    if (typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if (!caStore.hasCertificate(cert)) {
      return null;
    }

    var match = getBySubject(cert.subject);

    if (!forge.util.isArray(match)) {
      result = caStore.certs[cert.subject.hash];
      delete caStore.certs[cert.subject.hash];
      return result;
    } // compare DER-encoding of certificates


    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();

    for (var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();

      if (der1 === der2) {
        result = match[i];
        match.splice(i, 1);
      }
    }

    if (match.length === 0) {
      delete caStore.certs[cert.subject.hash];
    }

    return result;
  };

  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }

  function ensureSubjectHasHash(subject) {
    // produce subject hash if it doesn't exist
    if (!subject.hash) {
      var md = forge.md.sha1.create();
      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  } // auto-add passed in certs


  if (certs) {
    // parse PEM-formatted certificates as necessary
    for (var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }

  return caStore;
};
/**
 * Certificate verification errors, based on TLS.
 */


pki.certificateError = {
  bad_certificate: 'forge.pki.BadCertificate',
  unsupported_certificate: 'forge.pki.UnsupportedCertificate',
  certificate_revoked: 'forge.pki.CertificateRevoked',
  certificate_expired: 'forge.pki.CertificateExpired',
  certificate_unknown: 'forge.pki.CertificateUnknown',
  unknown_ca: 'forge.pki.UnknownCertificateAuthority'
};
/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param options a callback to be called for every certificate in the chain or
 *                  an object with:
 *                  verify a callback to be called for every certificate in the
 *                    chain
 *                  validityCheckDate the date against which the certificate
 *                    validity period should be checked. Pass null to not check
 *                    the validity period. By default, the current date is used.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */

pki.verifyCertificateChain = function (caStore, chain, options) {
  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.
     The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.
     To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:
     (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;
     (b) certificate 1 is issued by the trust anchor;
     (c) certificate n is the certificate to be validated; and
     (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.
     Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.
     The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.
     Note: Policy mapping extension not supported (Not Required).
     Note: If the certificate has an unsupported critical extension, then it
    must be rejected.
     Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.
     The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:
     (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:
       (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.
       (Trust anchors are provided via certificates in the CA store).
       The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).
     (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)
     (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)
     (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */

  /* Basic Path Processing:
     For each certificate in the 'chain', the following is checked:
     1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */
  // if a verify callback is passed as the third parameter, package it within
  // the options object. This is to support a legacy function signature that
  // expected the verify callback as the third parameter.
  if (typeof options === 'function') {
    options = {
      verify: options
    };
  }

  options = options || {}; // copy cert chain references to another array to protect against changes
  // in verify callback

  chain = chain.slice(0);
  var certs = chain.slice(0);
  var validityCheckDate = options.validityCheckDate; // if no validityCheckDate is specified, default to the current date. Make
  // sure to maintain the value null because it indicates that the validity
  // period should not be checked.

  if (typeof validityCheckDate === 'undefined') {
    validityCheckDate = new Date();
  } // verify each cert in the chain using its parent, where the parent
  // is either the next in the chain or from the CA store


  var first = true;
  var error = null;
  var depth = 0;

  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;

    if (validityCheckDate) {
      // 1. check valid time
      if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
        error = {
          message: 'Certificate is not valid yet or has expired.',
          error: pki.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    } // 2. verify with parent from chain or CA store


    if (error === null) {
      parent = chain[0] || caStore.getIssuer(cert);

      if (parent === null) {
        // check for self-signed cert
        if (cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }

      if (parent) {
        // FIXME: current CA store implementation might have multiple
        // certificates where the issuer can't be determined from the
        // certificate (happens rarely with, eg: old certificates) so normalize
        // by always putting parents into an array
        // TODO: there's may be an extreme degenerate case currently uncovered
        // where an old intermediate certificate seems to have a matching parent
        // but none of the parents actually verify ... but the intermediate
        // is in the CA and it should pass this check; needs investigation
        var parents = parent;

        if (!forge.util.isArray(parents)) {
          parents = [parents];
        } // try to verify with each possible parent (typically only one)


        var verified = false;

        while (!verified && parents.length > 0) {
          parent = parents.shift();

          try {
            verified = parent.verify(cert);
          } catch (ex) {// failure to verify, don't care why, try next one
          }
        }

        if (!verified) {
          error = {
            message: 'Certificate signature is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
      }

      if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
        // no parent issuer and certificate itself is not trusted
        error = {
          message: 'Certificate is not trusted.',
          error: pki.certificateError.unknown_ca
        };
      }
    } // TODO: 3. check revoked
    // 4. check for matching issuer/subject


    if (error === null && parent && !cert.isIssuer(parent)) {
      // parent is not issuer
      error = {
        message: 'Certificate issuer is invalid.',
        error: pki.certificateError.bad_certificate
      };
    } // 5. TODO: check names with permitted names tree
    // 6. TODO: check names against excluded names tree
    // 7. check for unsupported critical extensions


    if (error === null) {
      // supported extensions
      var se = {
        keyUsage: true,
        basicConstraints: true
      };

      for (var i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];

        if (ext.critical && !(ext.name in se)) {
          error = {
            message: 'Certificate has an unsupported critical extension.',
            error: pki.certificateError.unsupported_certificate
          };
        }
      }
    } // 8. check for CA if cert is not first or is the only certificate
    // remaining in chain with no parent or is self-signed


    if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
      // first check keyUsage extension and then basic constraints
      var bcExt = cert.getExtension('basicConstraints');
      var keyUsageExt = cert.getExtension('keyUsage');

      if (keyUsageExt !== null) {
        // keyCertSign must be true and there must be a basic
        // constraints extension
        if (!keyUsageExt.keyCertSign || bcExt === null) {
          // bad certificate
          error = {
            message: 'Certificate keyUsage or basicConstraints conflict ' + 'or indicate that the certificate is not a CA. ' + 'If the certificate is the only one in the chain or ' + 'isn\'t the first then the certificate must be a ' + 'valid CA.',
            error: pki.certificateError.bad_certificate
          };
        }
      } // basic constraints cA flag must be set


      if (error === null && bcExt !== null && !bcExt.cA) {
        // bad certificate
        error = {
          message: 'Certificate basicConstraints indicates the certificate ' + 'is not a CA.',
          error: pki.certificateError.bad_certificate
        };
      } // if error is not null and keyUsage is available, then we know it
      // has keyCertSign and there is a basic constraints extension too,
      // which means we can check pathLenConstraint (if it exists)


      if (error === null && keyUsageExt !== null && 'pathLenConstraint' in bcExt) {
        // pathLen is the maximum # of intermediate CA certs that can be
        // found between the current certificate and the end-entity (depth 0)
        // certificate; this number does not include the end-entity (depth 0,
        // last in the chain) even if it happens to be a CA certificate itself
        var pathLen = depth - 1;

        if (pathLen > bcExt.pathLenConstraint) {
          // pathLenConstraint violated, bad certificate
          error = {
            message: 'Certificate basicConstraints pathLenConstraint violated.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
    } // call application callback


    var vfd = error === null ? true : error.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;

    if (ret === true) {
      // clear any set error
      error = null;
    } else {
      // if passed basic tests, set default message and alert
      if (vfd === true) {
        error = {
          message: 'The application rejected the certificate.',
          error: pki.certificateError.bad_certificate
        };
      } // check for custom error info


      if (ret || ret === 0) {
        // set custom message and error
        if (_typeof(ret) === 'object' && !forge.util.isArray(ret)) {
          if (ret.message) {
            error.message = ret.message;
          }

          if (ret.error) {
            error.error = ret.error;
          }
        } else if (typeof ret === 'string') {
          // set custom error
          error.error = ret;
        }
      } // throw error


      throw error;
    } // no longer first cert in chain


    first = false;
    ++depth;
  } while (chain.length > 0);

  return true;
};
},{"./forge":"node_modules/node-forge/lib/forge.js","./aes":"node_modules/node-forge/lib/aes.js","./asn1":"node_modules/node-forge/lib/asn1.js","./des":"node_modules/node-forge/lib/des.js","./md":"node_modules/node-forge/lib/md.js","./mgf":"node_modules/node-forge/lib/mgf.js","./oids":"node_modules/node-forge/lib/oids.js","./pem":"node_modules/node-forge/lib/pem.js","./pss":"node_modules/node-forge/lib/pss.js","./rsa":"node_modules/node-forge/lib/rsa.js","./util":"node_modules/node-forge/lib/util.js"}],"node_modules/node-forge/lib/pkcs7.js":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Javascript implementation of PKCS#7 v1.5.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 *
 * Currently this implementation only supports ContentType of EnvelopedData,
 * EncryptedData, or SignedData at the root level. The top level elements may
 * contain only a ContentInfo of ContentType Data, i.e. plain data. Further
 * nesting is not (yet) supported.
 *
 * The Forge validators for PKCS #7's ASN.1 structures are available from
 * a separate file pkcs7asn1.js, since those are referenced from other
 * PKCS standards like PKCS #12.
 */
var forge = require('./forge');

require('./aes');

require('./asn1');

require('./des');

require('./oids');

require('./pem');

require('./pkcs7asn1');

require('./random');

require('./util');

require('./x509'); // shortcut for ASN.1 API


var asn1 = forge.asn1; // shortcut for PKCS#7 API

var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
/**
 * Converts a PKCS#7 message from PEM format.
 *
 * @param pem the PEM-formatted PKCS#7 message.
 *
 * @return the PKCS#7 message.
 */

p7.messageFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if (msg.type !== 'PKCS7') {
    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' + 'header type is not "PKCS#7".');
    error.headerType = msg.type;
    throw error;
  }

  if (msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
  } // convert DER to ASN.1 object


  var obj = asn1.fromDer(msg.body);
  return p7.messageFromAsn1(obj);
};
/**
 * Converts a PKCS#7 message to PEM format.
 *
 * @param msg The PKCS#7 message object
 * @param maxline The maximum characters per line, defaults to 64.
 *
 * @return The PEM-formatted PKCS#7 message.
 */


p7.messageToPem = function (msg, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var pemObj = {
    type: 'PKCS7',
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge.pem.encode(pemObj, {
    maxline: maxline
  });
};
/**
 * Converts a PKCS#7 message from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a ContentInfo.
 *
 * @return the PKCS#7 message.
 */


p7.messageFromAsn1 = function (obj) {
  // validate root level ContentInfo and capture data
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not an PKCS#7 ContentInfo.');
    error.errors = errors;
    throw error;
  }

  var contentType = asn1.derToOid(capture.contentType);
  var msg;

  switch (contentType) {
    case forge.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;

    case forge.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;

    case forge.pki.oids.signedData:
      msg = p7.createSignedData();
      break;

    default:
      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' + contentType + ' is not (yet) supported.');
  }

  msg.fromAsn1(capture.content.value[0]);
  return msg;
};

p7.createSignedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function (obj) {
      // validate SignedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);

      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];

      if (msg.rawCapture.certificates) {
        var certs = msg.rawCapture.certificates.value;

        for (var i = 0; i < certs.length; ++i) {
          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
        }
      } // TODO: parse crls

    },
    toAsn1: function () {
      // degenerate case with no content
      if (!msg.contentInfo) {
        msg.sign();
      }

      var certs = [];

      for (var i = 0; i < msg.certificates.length; ++i) {
        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
      }

      var crls = []; // TODO: implement CRLs
      // [0] SignedData

      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Version
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), // DigestAlgorithmIdentifiers
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers), // ContentInfo
      msg.contentInfo])]);

      if (certs.length > 0) {
        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
        signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
      }

      if (crls.length > 0) {
        // [1] IMPLICIT CertificateRevocationLists OPTIONAL
        signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
      } // SignerInfos


      signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos)); // ContentInfo

      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// ContentType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), // [0] SignedData
      signedData]);
    },

    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function (signer) {
      var issuer = signer.issuer;
      var serialNumber = signer.serialNumber;

      if (signer.certificate) {
        var cert = signer.certificate;

        if (typeof cert === 'string') {
          cert = forge.pki.certificateFromPem(cert);
        }

        issuer = cert.issuer.attributes;
        serialNumber = cert.serialNumber;
      }

      var key = signer.key;

      if (!key) {
        throw new Error('Could not add PKCS#7 signer; no private key specified.');
      }

      if (typeof key === 'string') {
        key = forge.pki.privateKeyFromPem(key);
      } // ensure OID known for digest algorithm


      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;

      switch (digestAlgorithm) {
        case forge.pki.oids.sha1:
        case forge.pki.oids.sha256:
        case forge.pki.oids.sha384:
        case forge.pki.oids.sha512:
        case forge.pki.oids.md5:
          break;

        default:
          throw new Error('Could not add PKCS#7 signer; unknown message digest algorithm: ' + digestAlgorithm);
      } // if authenticatedAttributes is present, then the attributes
      // must contain at least PKCS #9 content-type and message-digest


      var authenticatedAttributes = signer.authenticatedAttributes || [];

      if (authenticatedAttributes.length > 0) {
        var contentType = false;
        var messageDigest = false;

        for (var i = 0; i < authenticatedAttributes.length; ++i) {
          var attr = authenticatedAttributes[i];

          if (!contentType && attr.type === forge.pki.oids.contentType) {
            contentType = true;

            if (messageDigest) {
              break;
            }

            continue;
          }

          if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
            messageDigest = true;

            if (contentType) {
              break;
            }

            continue;
          }
        }

        if (!contentType || !messageDigest) {
          throw new Error('Invalid signer.authenticatedAttributes. If ' + 'signer.authenticatedAttributes is specified, then it must ' + 'contain at least two attributes, PKCS #9 content-type and ' + 'PKCS #9 message-digest.');
        }
      }

      msg.signers.push({
        key: key,
        version: 1,
        issuer: issuer,
        serialNumber: serialNumber,
        digestAlgorithm: digestAlgorithm,
        signatureAlgorithm: forge.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes: authenticatedAttributes,
        unauthenticatedAttributes: []
      });
    },

    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function (options) {
      options = options || {}; // auto-generate content info

      if (_typeof(msg.content) !== 'object' || msg.contentInfo === null) {
        // use Data ContentInfo
        msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// ContentType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]); // add actual content, if present

        if ('content' in msg) {
          var content;

          if (msg.content instanceof forge.util.ByteBuffer) {
            content = msg.content.bytes();
          } else if (typeof msg.content === 'string') {
            content = forge.util.encodeUtf8(msg.content);
          }

          if (options.detached) {
            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
          } else {
            msg.contentInfo.value.push( // [0] EXPLICIT content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)]));
          }
        }
      } // no signers, return early (degenerate case for certificate container)


      if (msg.signers.length === 0) {
        return;
      } // generate digest algorithm identifiers


      var mds = addDigestAlgorithmIds(); // generate signerInfos

      addSignerInfos(mds);
    },
    verify: function () {
      throw new Error('PKCS#7 signature verification not yet implemented.');
    },

    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function (cert) {
      // convert from PEM
      if (typeof cert === 'string') {
        cert = forge.pki.certificateFromPem(cert);
      }

      msg.certificates.push(cert);
    },

    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function (crl) {
      throw new Error('PKCS#7 CRL support not yet implemented.');
    }
  };
  return msg;

  function addDigestAlgorithmIds() {
    var mds = {};

    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      var oid = signer.digestAlgorithm;

      if (!(oid in mds)) {
        // content digest
        mds[oid] = forge.md[forge.pki.oids[oid]].create();
      }

      if (signer.authenticatedAttributes.length === 0) {
        // no custom attributes to digest; use content message digest
        signer.md = mds[oid];
      } else {
        // custom attributes to be digested; use own message digest
        // TODO: optimize to just copy message digest state if that
        // feature is ever supported with message digests
        signer.md = forge.md[forge.pki.oids[oid]].create();
      }
    } // add unique digest algorithm identifiers


    msg.digestAlgorithmIdentifiers = [];

    for (var oid in mds) {
      msg.digestAlgorithmIdentifiers.push( // AlgorithmIdentifier
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()), // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]));
    }

    return mds;
  }

  function addSignerInfos(mds) {
    var content;

    if (msg.detachedContent) {
      // Signature has been made in detached mode.
      content = msg.detachedContent;
    } else {
      // Note: ContentInfo is a SEQUENCE with 2 values, second value is
      // the content field and is optional for a ContentInfo but required here
      // since signers are present
      // get ContentInfo content
      content = msg.contentInfo.value[1]; // skip [0] EXPLICIT content wrapper

      content = content.value[0];
    }

    if (!content) {
      throw new Error('Could not sign PKCS#7 message; there is no content to sign.');
    } // get ContentInfo content type


    var contentType = asn1.derToOid(msg.contentInfo.value[0].value); // serialize content

    var bytes = asn1.toDer(content); // skip identifier and length per RFC 2315 9.3
    // skip identifier (1 byte)

    bytes.getByte(); // read and discard length bytes

    asn1.getBerValueLength(bytes);
    bytes = bytes.getBytes(); // digest content DER value bytes

    for (var oid in mds) {
      mds[oid].start().update(bytes);
    } // sign content


    var signingTime = new Date();

    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];

      if (signer.authenticatedAttributes.length === 0) {
        // if ContentInfo content type is not "Data", then
        // authenticatedAttributes must be present per RFC 2315
        if (contentType !== forge.pki.oids.data) {
          throw new Error('Invalid signer; authenticatedAttributes must be present ' + 'when the ContentInfo content type is not PKCS#7 Data.');
        }
      } else {
        // process authenticated attributes
        // [0] IMPLICIT
        signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); // per RFC 2315, attributes are to be digested using a SET container
        // not the above [0] IMPLICIT container

        var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);

        for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
          var attr = signer.authenticatedAttributes[ai];

          if (attr.type === forge.pki.oids.messageDigest) {
            // use content message digest as value
            attr.value = mds[signer.digestAlgorithm].digest();
          } else if (attr.type === forge.pki.oids.signingTime) {
            // auto-populate signing time if not already set
            if (!attr.value) {
              attr.value = signingTime;
            }
          } // convert to ASN.1 and push onto Attributes SET (for signing) and
          // onto authenticatedAttributesAsn1 to complete SignedData ASN.1
          // TODO: optimize away duplication


          attrsAsn1.value.push(_attributeToAsn1(attr));
          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
        } // DER-serialize and digest SET OF attributes only


        bytes = asn1.toDer(attrsAsn1).getBytes();
        signer.md.start().update(bytes);
      } // sign digest


      signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');
    } // add signer info


    msg.signerInfos = _signersToAsn1(msg.signers);
  }
};
/**
 * Creates an empty PKCS#7 message of type EncryptedData.
 *
 * @return the message.
 */


p7.createEncryptedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function (obj) {
      // Validate EncryptedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },

    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function (key) {
      if (key !== undefined) {
        msg.encryptedContent.key = key;
      }

      _decryptContent(msg);
    }
  };
  return msg;
};
/**
 * Creates an empty PKCS#7 message of type EnvelopedData.
 *
 * @return the message.
 */


p7.createEnvelopedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function (obj) {
      // validate EnvelopedData content block and capture data
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);

      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },
    toAsn1: function () {
      // ContentInfo
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// ContentType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), // [0] EnvelopedData
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Version
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), // RecipientInfos
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)), // EncryptedContentInfo
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))])])]);
    },

    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function (cert) {
      var sAttr = cert.issuer.attributes;

      for (var i = 0; i < msg.recipients.length; ++i) {
        var r = msg.recipients[i];
        var rAttr = r.issuer;

        if (r.serialNumber !== cert.serialNumber) {
          continue;
        }

        if (rAttr.length !== sAttr.length) {
          continue;
        }

        var match = true;

        for (var j = 0; j < sAttr.length; ++j) {
          if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
            match = false;
            break;
          }
        }

        if (match) {
          return r;
        }
      }

      return null;
    },

    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function (recipient, privKey) {
      if (msg.encryptedContent.key === undefined && recipient !== undefined && privKey !== undefined) {
        switch (recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
          case forge.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge.util.createBuffer(key);
            break;

          default:
            throw new Error('Unsupported asymmetric cipher, ' + 'OID ' + recipient.encryptedContent.algorithm);
        }
      }

      _decryptContent(msg);
    },

    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function (cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },

    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function (key, cipher) {
      // Part 1: Symmetric encryption
      if (msg.encryptedContent.content === undefined) {
        cipher = cipher || msg.encryptedContent.algorithm;
        key = key || msg.encryptedContent.key;
        var keyLen, ivLen, ciphFn;

        switch (cipher) {
          case forge.pki.oids['aes128-CBC']:
            keyLen = 16;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['aes192-CBC']:
            keyLen = 24;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['aes256-CBC']:
            keyLen = 32;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['des-EDE3-CBC']:
            keyLen = 24;
            ivLen = 8;
            ciphFn = forge.des.createEncryptionCipher;
            break;

          default:
            throw new Error('Unsupported symmetric cipher, OID ' + cipher);
        }

        if (key === undefined) {
          key = forge.util.createBuffer(forge.random.getBytes(keyLen));
        } else if (key.length() != keyLen) {
          throw new Error('Symmetric key has wrong length; ' + 'got ' + key.length() + ' bytes, expected ' + keyLen + '.');
        } // Keep a copy of the key & IV in the object, so the caller can
        // use it for whatever reason.


        msg.encryptedContent.algorithm = cipher;
        msg.encryptedContent.key = key;
        msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
        var ciph = ciphFn(key);
        ciph.start(msg.encryptedContent.parameter.copy());
        ciph.update(msg.content); // The finish function does PKCS#7 padding by default, therefore
        // no action required by us.

        if (!ciph.finish()) {
          throw new Error('Symmetric encryption failed.');
        }

        msg.encryptedContent.content = ciph.output;
      } // Part 2: asymmetric encryption for each recipient


      for (var i = 0; i < msg.recipients.length; ++i) {
        var recipient = msg.recipients[i]; // Nothing to do, encryption already done.

        if (recipient.encryptedContent.content !== undefined) {
          continue;
        }

        switch (recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
            recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
            break;

          default:
            throw new Error('Unsupported asymmetric cipher, OID ' + recipient.encryptedContent.algorithm);
        }
      }
    }
  };
  return msg;
};
/**
 * Converts a single recipient from an ASN.1 object.
 *
 * @param obj the ASN.1 RecipientInfo.
 *
 * @return the recipient object.
 */


function _recipientFromAsn1(obj) {
  // validate EnvelopedData content block and capture data
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 RecipientInfo. ' + 'ASN.1 object is not an PKCS#7 RecipientInfo.');
    error.errors = errors;
    throw error;
  }

  return {
    version: capture.version.charCodeAt(0),
    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge.util.createBuffer(capture.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: capture.encParameter.value,
      content: capture.encKey
    }
  };
}
/**
 * Converts a single recipient object to an ASN.1 object.
 *
 * @param obj the recipient object.
 *
 * @return the ASN.1 RecipientInfo.
 */


function _recipientToAsn1(obj) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Version
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), // IssuerAndSerialNumber
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Name
  forge.pki.distinguishedNameToAsn1({
    attributes: obj.issuer
  }), // Serial
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), // KeyEncryptionAlgorithmIdentifier
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), // Parameter, force NULL, only RSA supported for now.
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // EncryptedKey
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)]);
}
/**
 * Map a set of RecipientInfo ASN.1 objects to recipient objects.
 *
 * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).
 *
 * @return an array of recipient objects.
 */


function _recipientsFromAsn1(infos) {
  var ret = [];

  for (var i = 0; i < infos.length; ++i) {
    ret.push(_recipientFromAsn1(infos[i]));
  }

  return ret;
}
/**
 * Map an array of recipient objects to ASN.1 RecipientInfo objects.
 *
 * @param recipients an array of recipientInfo objects.
 *
 * @return an array of ASN.1 RecipientInfos.
 */


function _recipientsToAsn1(recipients) {
  var ret = [];

  for (var i = 0; i < recipients.length; ++i) {
    ret.push(_recipientToAsn1(recipients[i]));
  }

  return ret;
}
/**
 * Converts a single signer from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a SignerInfo.
 *
 * @return the signer object.
 */


function _signerFromAsn1(obj) {
  // validate EnvelopedData content block and capture data
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 SignerInfo. ' + 'ASN.1 object is not an PKCS#7 SignerInfo.');
    error.errors = errors;
    throw error;
  }

  var rval = {
    version: capture.version.charCodeAt(0),
    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge.util.createBuffer(capture.serial).toHex(),
    digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),
    signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),
    signature: capture.signature,
    authenticatedAttributes: [],
    unauthenticatedAttributes: []
  }; // TODO: convert attributes

  var authenticatedAttributes = capture.authenticatedAttributes || [];
  var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];
  return rval;
}
/**
 * Converts a single signerInfo object to an ASN.1 object.
 *
 * @param obj the signerInfo object.
 *
 * @return the ASN.1 representation of a SignerInfo.
 */


function _signerToAsn1(obj) {
  // SignerInfo
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), // issuerAndSerialNumber
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// name
  forge.pki.distinguishedNameToAsn1({
    attributes: obj.issuer
  }), // serial
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), // digestAlgorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()), // parameters (null)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]); // authenticatedAttributes (OPTIONAL)

  if (obj.authenticatedAttributesAsn1) {
    // add ASN.1 previously generated during signing
    rval.value.push(obj.authenticatedAttributesAsn1);
  } // digestEncryptionAlgorithm


  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), // parameters (null)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])); // encryptedDigest

  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature)); // unauthenticatedAttributes (OPTIONAL)

  if (obj.unauthenticatedAttributes.length > 0) {
    // [1] IMPLICIT
    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);

    for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
      var attr = obj.unauthenticatedAttributes[i];
      attrsAsn1.values.push(_attributeToAsn1(attr));
    }

    rval.value.push(attrsAsn1);
  }

  return rval;
}
/**
 * Map a set of SignerInfo ASN.1 objects to an array of signer objects.
 *
 * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).
 *
 * @return an array of signers objects.
 */


function _signersFromAsn1(signerInfoAsn1s) {
  var ret = [];

  for (var i = 0; i < signerInfoAsn1s.length; ++i) {
    ret.push(_signerFromAsn1(signerInfoAsn1s[i]));
  }

  return ret;
}
/**
 * Map an array of signer objects to ASN.1 objects.
 *
 * @param signers an array of signer objects.
 *
 * @return an array of ASN.1 SignerInfos.
 */


function _signersToAsn1(signers) {
  var ret = [];

  for (var i = 0; i < signers.length; ++i) {
    ret.push(_signerToAsn1(signers[i]));
  }

  return ret;
}
/**
 * Convert an attribute object to an ASN.1 Attribute.
 *
 * @param attr the attribute object.
 *
 * @return the ASN.1 Attribute.
 */


function _attributeToAsn1(attr) {
  var value; // TODO: generalize to support more attributes

  if (attr.type === forge.pki.oids.contentType) {
    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
  } else if (attr.type === forge.pki.oids.messageDigest) {
    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
  } else if (attr.type === forge.pki.oids.signingTime) {
    /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049
      (inclusive) MUST be encoded as UTCTime. Any dates with year values
      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]
      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST
      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the
      number of seconds is zero.  Midnight (GMT) must be represented as
      "YYMMDD000000Z". */
    // TODO: make these module-level constants
    var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
    var jan_1_2050 = new Date('2050-01-01T00:00:00Z');
    var date = attr.value;

    if (typeof date === 'string') {
      // try to parse date
      var timestamp = Date.parse(date);

      if (!isNaN(timestamp)) {
        date = new Date(timestamp);
      } else if (date.length === 13) {
        // YYMMDDHHMMSSZ (13 chars for UTCTime)
        date = asn1.utcTimeToDate(date);
      } else {
        // assume generalized time
        date = asn1.generalizedTimeToDate(date);
      }
    }

    if (date >= jan_1_1950 && date < jan_1_2050) {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
    } else {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
    }
  } // TODO: expose as common API call
  // create a RelativeDistinguishedName set
  // each value in the set is an AttributeTypeAndValue first
  // containing the type (an OID) and second the value


  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AttributeType
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [// AttributeValue
  value])]);
}
/**
 * Map messages encrypted content to ASN.1 objects.
 *
 * @param ec The encryptedContent object of the message.
 *
 * @return ASN.1 representation of the encryptedContent object (SEQUENCE).
 */


function _encryptedContentToAsn1(ec) {
  return [// ContentType, always Data for the moment
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()), // ContentEncryptionAlgorithmIdentifier
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// Algorithm
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), // Parameters (IV)
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]), // [0] EncryptedContent
  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])];
}
/**
 * Reads the "common part" of an PKCS#7 content block (in ASN.1 format)
 *
 * This function reads the "common part" of the PKCS#7 content blocks
 * EncryptedData and EnvelopedData, i.e. version number and symmetrically
 * encrypted content block.
 *
 * The result of the ASN.1 validate and capture process is returned
 * to allow the caller to extract further data, e.g. the list of recipients
 * in case of a EnvelopedData object.
 *
 * @param msg the PKCS#7 object to read the data to.
 * @param obj the ASN.1 representation of the content block.
 * @param validator the ASN.1 structure validator object to use.
 *
 * @return the value map captured by validator object.
 */


function _fromAsn1(msg, obj, validator) {
  var capture = {};
  var errors = [];

  if (!asn1.validate(obj, validator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 message. ' + 'ASN.1 object is not a supported PKCS#7 message.');
    error.errors = error;
    throw error;
  } // Check contentType, so far we only support (raw) Data.


  var contentType = asn1.derToOid(capture.contentType);

  if (contentType !== forge.pki.oids.data) {
    throw new Error('Unsupported PKCS#7 message. ' + 'Only wrapped ContentType Data supported.');
  }

  if (capture.encryptedContent) {
    var content = '';

    if (forge.util.isArray(capture.encryptedContent)) {
      for (var i = 0; i < capture.encryptedContent.length; ++i) {
        if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error('Malformed PKCS#7 message, expecting encrypted ' + 'content constructed of only OCTET STRING objects.');
        }

        content += capture.encryptedContent[i].value;
      }
    } else {
      content = capture.encryptedContent;
    }

    msg.encryptedContent = {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: forge.util.createBuffer(capture.encParameter.value),
      content: forge.util.createBuffer(content)
    };
  }

  if (capture.content) {
    var content = '';

    if (forge.util.isArray(capture.content)) {
      for (var i = 0; i < capture.content.length; ++i) {
        if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error('Malformed PKCS#7 message, expecting ' + 'content constructed of only OCTET STRING objects.');
        }

        content += capture.content[i].value;
      }
    } else {
      content = capture.content;
    }

    msg.content = forge.util.createBuffer(content);
  }

  msg.version = capture.version.charCodeAt(0);
  msg.rawCapture = capture;
  return capture;
}
/**
 * Decrypt the symmetrically encrypted content block of the PKCS#7 message.
 *
 * Decryption is skipped in case the PKCS#7 message object already has a
 * (decrypted) content attribute.  The algorithm, key and cipher parameters
 * (probably the iv) are taken from the encryptedContent attribute of the
 * message object.
 *
 * @param The PKCS#7 message object.
 */


function _decryptContent(msg) {
  if (msg.encryptedContent.key === undefined) {
    throw new Error('Symmetric key not available.');
  }

  if (msg.content === undefined) {
    var ciph;

    switch (msg.encryptedContent.algorithm) {
      case forge.pki.oids['aes128-CBC']:
      case forge.pki.oids['aes192-CBC']:
      case forge.pki.oids['aes256-CBC']:
        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
        break;

      case forge.pki.oids['desCBC']:
      case forge.pki.oids['des-EDE3-CBC']:
        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
        break;

      default:
        throw new Error('Unsupported symmetric cipher, OID ' + msg.encryptedContent.algorithm);
    }

    ciph.start(msg.encryptedContent.parameter);
    ciph.update(msg.encryptedContent.content);

    if (!ciph.finish()) {
      throw new Error('Symmetric decryption failed.');
    }

    msg.content = ciph.output;
  }
}
},{"./forge":"node_modules/node-forge/lib/forge.js","./aes":"node_modules/node-forge/lib/aes.js","./asn1":"node_modules/node-forge/lib/asn1.js","./des":"node_modules/node-forge/lib/des.js","./oids":"node_modules/node-forge/lib/oids.js","./pem":"node_modules/node-forge/lib/pem.js","./pkcs7asn1":"node_modules/node-forge/lib/pkcs7asn1.js","./random":"node_modules/node-forge/lib/random.js","./util":"node_modules/node-forge/lib/util.js","./x509":"node_modules/node-forge/lib/x509.js"}],"node_modules/libp2p/src/keychain/util.js":[function(require,module,exports) {
// @ts-nocheck
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

require('node-forge/lib/x509');

var forge = require('node-forge/lib/forge');

var pki = forge.pki;
/**
 * Gets a self-signed X.509 certificate for the key.
 *
 * The output Uint8Array contains the PKCS #7 message in DER.
 *
 * TODO: move to libp2p-crypto package
 *
 * @param {KeyInfo} key - The id and name of the key
 * @param {RsaPrivateKey} privateKey - The naked key
 * @returns {Uint8Array}
 */

var certificateForKey = function certificateForKey(key, privateKey) {
  var publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
  var cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = '01';
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  var attrs = [{
    name: 'organizationName',
    value: 'ipfs'
  }, {
    shortName: 'OU',
    value: 'keystore'
  }, {
    name: 'commonName',
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: 'basicConstraints',
    cA: true
  }, {
    name: 'keyUsage',
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: 'extKeyUsage',
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: 'nsCertType',
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]); // self-sign certificate

  cert.sign(privateKey);
  return cert;
};
/**
 * Finds the first item in a collection that is matched in the
 * `asyncCompare` function.
 *
 * `asyncCompare` is an async function that must
 * resolve to either `true` or `false`.
 *
 * @param {Array} array
 * @param {function(*)} asyncCompare - An async function that returns a boolean
 */


function findAsync(_x, _x2) {
  return _findAsync.apply(this, arguments);
}

function _findAsync() {
  _findAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(array, asyncCompare) {
    var promises, results, index;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promises = array.map(asyncCompare);
            _context.next = 3;
            return Promise.all(promises);

          case 3:
            results = _context.sent;
            index = results.findIndex(function (result) {
              return result;
            });
            return _context.abrupt("return", array[index]);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _findAsync.apply(this, arguments);
}

module.exports = {
  certificateForKey: certificateForKey,
  findAsync: findAsync
};
},{"node-forge/lib/x509":"node_modules/node-forge/lib/x509.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js"}],"node_modules/libp2p/src/keychain/cms.js":[function(require,module,exports) {
'use strict'; // @ts-ignore node-forge types not exported

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

require('node-forge/lib/pkcs7'); // @ts-ignore node-forge types not exported


require('node-forge/lib/pbe'); // @ts-ignore node-forge types not exported


var forge = require('node-forge/lib/forge');

var _require = require('./util'),
    certificateForKey = _require.certificateForKey,
    findAsync = _require.findAsync;

var errcode = require('err-code');

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string');

var privates = new WeakMap();
/**
 * Cryptographic Message Syntax (aka PKCS #7)
 *
 * CMS describes an encapsulation syntax for data protection. It
 * is used to digitally sign, digest, authenticate, or encrypt
 * arbitrary message content.
 *
 * See RFC 5652 for all the details.
 */

var CMS = /*#__PURE__*/function () {
  /**
   * Creates a new instance with a keychain
   *
   * @param {import('./index')} keychain - the available keys
   * @param {string} dek
   */
  function CMS(keychain, dek) {
    _classCallCheck(this, CMS);

    if (!keychain) {
      throw errcode(new Error('keychain is required'), 'ERR_KEYCHAIN_REQUIRED');
    }

    this.keychain = keychain;
    privates.set(this, {
      dek: dek
    });
  }
  /**
   * Creates some protected data.
   *
   * The output Uint8Array contains the PKCS #7 message in DER.
   *
   * @param {string} name - The local key name.
   * @param {Uint8Array} plain - The data to encrypt.
   * @returns {Promise<Uint8Array>}
   */


  _createClass(CMS, [{
    key: "encrypt",
    value: function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name, plain) {
        var key, pem, dek, privateKey, certificate, p7, der;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (plain instanceof Uint8Array) {
                  _context.next = 2;
                  break;
                }

                throw errcode(new Error('Plain data must be a Uint8Array'), 'ERR_INVALID_PARAMS');

              case 2:
                _context.next = 4;
                return this.keychain.findKeyByName(name);

              case 4:
                key = _context.sent;
                _context.next = 7;
                return this.keychain._getPrivateKey(name);

              case 7:
                pem = _context.sent;

                /** @type {string} */
                dek = privates.get(this).dek;
                privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
                _context.next = 12;
                return certificateForKey(key, privateKey);

              case 12:
                certificate = _context.sent;
                // create a p7 enveloped message
                p7 = forge.pkcs7.createEnvelopedData();
                p7.addRecipient(certificate);
                p7.content = forge.util.createBuffer(plain);
                p7.encrypt(); // convert message to DER

                der = forge.asn1.toDer(p7.toAsn1()).getBytes();
                return _context.abrupt("return", uint8ArrayFromString(der, 'ascii'));

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function encrypt(_x, _x2) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
    /**
     * Reads some protected data.
     *
     * The keychain must contain one of the keys used to encrypt the data.  If none of the keys
     * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.
     *
     * @param {Uint8Array} cmsData - The CMS encrypted data to decrypt.
     * @returns {Promise<Uint8Array>}
     */

  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cmsData) {
        var _this = this;

        var cms, buf, obj, recipients, r, missingKeys, key, pem, dek, privateKey;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (cmsData instanceof Uint8Array) {
                  _context3.next = 2;
                  break;
                }

                throw errcode(new Error('CMS data is required'), 'ERR_INVALID_PARAMS');

              case 2:
                _context3.prev = 2;
                buf = forge.util.createBuffer(uint8ArrayToString(cmsData, 'ascii'));
                obj = forge.asn1.fromDer(buf); // @ts-ignore not defined

                cms = forge.pkcs7.messageFromAsn1(obj);
                _context3.next = 11;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](2);
                throw errcode(new Error('Invalid CMS: ' + _context3.t0.message), 'ERR_INVALID_CMS');

              case 11:
                // Find a recipient whose key we hold. We only deal with recipient certs
                // issued by ipfs (O=ipfs).
                recipients = cms.recipients // @ts-ignore cms types not defined
                .filter(function (r) {
                  return r.issuer.find(function (a) {
                    return a.shortName === 'O' && a.value === 'ipfs';
                  });
                }) // @ts-ignore cms types not defined
                .filter(function (r) {
                  return r.issuer.find(function (a) {
                    return a.shortName === 'CN';
                  });
                }) // @ts-ignore cms types not defined
                .map(function (r) {
                  return {
                    recipient: r,
                    // @ts-ignore cms types not defined
                    keyId: r.issuer.find(function (a) {
                      return a.shortName === 'CN';
                    }).value
                  };
                });
                _context3.next = 14;
                return findAsync(recipients, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(recipient) {
                    var _key;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.prev = 0;
                            _context2.next = 3;
                            return _this.keychain.findKeyById(recipient.keyId);

                          case 3:
                            _key = _context2.sent;

                            if (!_key) {
                              _context2.next = 6;
                              break;
                            }

                            return _context2.abrupt("return", true);

                          case 6:
                            _context2.next = 11;
                            break;

                          case 8:
                            _context2.prev = 8;
                            _context2.t0 = _context2["catch"](0);
                            return _context2.abrupt("return", false);

                          case 11:
                            return _context2.abrupt("return", false);

                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[0, 8]]);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }());

              case 14:
                r = _context3.sent;

                if (r) {
                  _context3.next = 18;
                  break;
                }

                // @ts-ignore cms types not defined
                missingKeys = recipients.map(function (r) {
                  return r.keyId;
                });
                throw errcode(new Error('Decryption needs one of the key(s): ' + missingKeys.join(', ')), 'ERR_MISSING_KEYS', {
                  missingKeys: missingKeys
                });

              case 18:
                _context3.next = 20;
                return this.keychain.findKeyById(r.keyId);

              case 20:
                key = _context3.sent;

                if (key) {
                  _context3.next = 23;
                  break;
                }

                throw errcode(new Error('No key available to decrypto'), 'ERR_NO_KEY');

              case 23:
                _context3.next = 25;
                return this.keychain._getPrivateKey(key.name);

              case 25:
                pem = _context3.sent;
                dek = privates.get(this).dek;
                privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
                cms.decrypt(r.recipient, privateKey);
                return _context3.abrupt("return", uint8ArrayFromString(cms.content.getBytes(), 'ascii'));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 8]]);
      }));

      function decrypt(_x3) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }]);

  return CMS;
}();

module.exports = CMS;
},{"node-forge/lib/pkcs7":"node_modules/node-forge/lib/pkcs7.js","node-forge/lib/pbe":"node_modules/node-forge/lib/pbe.js","node-forge/lib/forge":"node_modules/node-forge/lib/forge.js","./util":"node_modules/libp2p/src/keychain/util.js","err-code":"node_modules/err-code/index.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js"}],"node_modules/libp2p/src/keychain/index.js":[function(require,module,exports) {
/* eslint max-nested-callbacks: ["error", 5] */
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:keychain'), {
  error: debug('libp2p:keychain:err')
});

var sanitize = require('sanitize-filename');

var mergeOptions = require('merge-options');

var crypto = require('libp2p-crypto');

var _require = require('interface-datastore'),
    Key = _require.Key;

var CMS = require('./cms');

var errcode = require('err-code');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayFromString = require('uint8arrays/from-string'); // @ts-ignore node-forge sha512 types not exported


require('node-forge/lib/sha512');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('interface-datastore').Datastore} Datastore
 */

/**
 * @typedef {Object} DekOptions
 * @property {string} hash
 * @property {string} salt
 * @property {number} iterationCount
 * @property {number} keyLength
 *
 * @typedef {Object} KeychainOptions
 * @property {string} [pass]
 * @property {DekOptions} [dek]
 */

/**
 * Information about a key.
 *
 * @typedef {Object} KeyInfo
 * @property {string} id - The universally unique key id.
 * @property {string} name - The local key name.
 */


var keyPrefix = '/pkcs8/';
var infoPrefix = '/info/';
var privates = new WeakMap(); // NIST SP 800-132

var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1000
};
var defaultOptions = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 10000,
    salt: 'you should override this value with a crypto secure random number',
    hash: 'sha2-512'
  }
};
/**
 * @param {string} name
 */

function validateKeyName(name) {
  if (!name) return false;
  if (typeof name !== 'string') return false;
  return name === sanitize(name.trim());
}
/**
 * Throws an error after a delay
 *
 * This assumes than an error indicates that the keychain is under attack. Delay returning an
 * error to make brute force attacks harder.
 *
 * @param {string|Error} err - The error
 * @returns {Promise<never>}
 * @private
 */


function throwDelayed(_x) {
  return _throwDelayed.apply(this, arguments);
}
/**
 * Converts a key name into a datastore name.
 *
 * @param {string} name
 * @returns {Key}
 * @private
 */


function _throwDelayed() {
  _throwDelayed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(err) {
    var min, max, delay;
    return regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            min = 200;
            max = 1000;
            delay = Math.random() * (max - min) + min;
            _context12.next = 5;
            return new Promise(function (resolve) {
              return setTimeout(resolve, delay);
            });

          case 5:
            throw err;

          case 6:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _throwDelayed.apply(this, arguments);
}

function DsName(name) {
  return new Key(keyPrefix + name);
}
/**
 * Converts a key name into a datastore info name.
 *
 * @param {string} name
 * @returns {Key}
 * @private
 */


function DsInfoName(name) {
  return new Key(infoPrefix + name);
}
/**
 * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.
 *
 * A key in the store has two entries
 * - '/info/*key-name*', contains the KeyInfo for the key
 * - '/pkcs8/*key-name*', contains the PKCS #8 for the key
 *
 */


var Keychain = /*#__PURE__*/function () {
  /**
   * Creates a new instance of a key chain.
   *
   * @param {Datastore} store - where the key are.
   * @param {KeychainOptions} options
   * @class
   */
  function Keychain(store, options) {
    _classCallCheck(this, Keychain);

    if (!store) {
      throw new Error('store is required');
    }

    this.store = store;
    this.opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132

    if (this.opts.pass && this.opts.pass.length < 20) {
      throw new Error('pass must be least 20 characters');
    }

    if (this.opts.dek.keyLength < NIST.minKeyLength) {
      throw new Error("dek.keyLength must be least ".concat(NIST.minKeyLength, " bytes"));
    }

    if (this.opts.dek.salt.length < NIST.minSaltLength) {
      throw new Error("dek.saltLength must be least ".concat(NIST.minSaltLength, " bytes"));
    }

    if (this.opts.dek.iterationCount < NIST.minIterationCount) {
      throw new Error("dek.iterationCount must be least ".concat(NIST.minIterationCount));
    }

    var dek = this.opts.pass ? crypto.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';
    privates.set(this, {
      dek: dek
    });
  }
  /**
   * Gets an object that can encrypt/decrypt protected data
   * using the Cryptographic Message Syntax (CMS).
   *
   * CMS describes an encapsulation syntax for data protection. It
   * is used to digitally sign, digest, authenticate, or encrypt
   * arbitrary message content.
   *
   * @returns {CMS}
   */


  _createClass(Keychain, [{
    key: "cms",
    get: function get() {
      return new CMS(this, privates.get(this).dek);
    }
    /**
     * Generates the options for a keychain.  A random salt is produced.
     *
     * @returns {Object}
     */

  }, {
    key: "createKey",
    value:
    /**
     * Create a new key.
     *
     * @param {string} name - The local key name; cannot already exist.
     * @param {string} type - One of the key types; 'rsa'.
     * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.
     * @returns {Promise<KeyInfo>}
     */
    function () {
      var _createKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name, type) {
        var size,
            self,
            dsname,
            exists,
            keyInfo,
            keypair,
            kid,
            dek,
            pem,
            batch,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                size = _args.length > 2 && _args[2] !== undefined ? _args[2] : 2048;
                self = this;

                if (!(!validateKeyName(name) || name === 'self')) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 4:
                if (!(typeof type !== 'string')) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", throwDelayed(errcode(new Error("Invalid key type '".concat(type, "'")), 'ERR_INVALID_KEY_TYPE')));

              case 6:
                dsname = DsName(name);
                _context.next = 9;
                return self.store.has(dsname);

              case 9:
                exists = _context.sent;

                if (!exists) {
                  _context.next = 12;
                  break;
                }

                return _context.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(name, "' already exists")), 'ERR_KEY_ALREADY_EXISTS')));

              case 12:
                _context.t0 = type.toLowerCase();
                _context.next = _context.t0 === 'rsa' ? 15 : 18;
                break;

              case 15:
                if (!(!Number.isSafeInteger(size) || size < 2048)) {
                  _context.next = 17;
                  break;
                }

                return _context.abrupt("return", throwDelayed(errcode(new Error("Invalid RSA key size ".concat(size)), 'ERR_INVALID_KEY_SIZE')));

              case 17:
                return _context.abrupt("break", 19);

              case 18:
                return _context.abrupt("break", 19);

              case 19:
                _context.prev = 19;
                _context.next = 22;
                return crypto.keys.generateKeyPair(type, size);

              case 22:
                keypair = _context.sent;
                _context.next = 25;
                return keypair.id();

              case 25:
                kid = _context.sent;

                /** @type {string} */
                dek = privates.get(this).dek;
                _context.next = 29;
                return keypair.export(dek);

              case 29:
                pem = _context.sent;
                keyInfo = {
                  name: name,
                  id: kid
                };
                batch = self.store.batch();
                batch.put(dsname, uint8ArrayFromString(pem));
                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
                _context.next = 36;
                return batch.commit();

              case 36:
                _context.next = 41;
                break;

              case 38:
                _context.prev = 38;
                _context.t1 = _context["catch"](19);
                return _context.abrupt("return", throwDelayed(_context.t1));

              case 41:
                return _context.abrupt("return", keyInfo);

              case 42:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[19, 38]]);
      }));

      function createKey(_x2, _x3) {
        return _createKey.apply(this, arguments);
      }

      return createKey;
    }()
    /**
     * List all the keys.
     *
     * @returns {Promise<KeyInfo[]>}
     */

  }, {
    key: "listKeys",
    value: function () {
      var _listKeys = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var self, query, info, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                self = this;
                query = {
                  prefix: infoPrefix
                };
                info = [];
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context2.prev = 5;
                _iterator = _asyncIterator(self.store.query(query));

              case 7:
                _context2.next = 9;
                return _iterator.next();

              case 9:
                if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                  _context2.next = 15;
                  break;
                }

                value = _step.value;
                info.push(JSON.parse(uint8ArrayToString(value.value)));

              case 12:
                _iteratorAbruptCompletion = false;
                _context2.next = 7;
                break;

              case 15:
                _context2.next = 21;
                break;

              case 17:
                _context2.prev = 17;
                _context2.t0 = _context2["catch"](5);
                _didIteratorError = true;
                _iteratorError = _context2.t0;

              case 21:
                _context2.prev = 21;
                _context2.prev = 22;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context2.next = 26;
                  break;
                }

                _context2.next = 26;
                return _iterator.return();

              case 26:
                _context2.prev = 26;

                if (!_didIteratorError) {
                  _context2.next = 29;
                  break;
                }

                throw _iteratorError;

              case 29:
                return _context2.finish(26);

              case 30:
                return _context2.finish(21);

              case 31:
                return _context2.abrupt("return", info);

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 17, 21, 31], [22,, 26, 30]]);
      }));

      function listKeys() {
        return _listKeys.apply(this, arguments);
      }

      return listKeys;
    }()
    /**
     * Find a key by it's id.
     *
     * @param {string} id - The universally unique key identifier.
     * @returns {Promise<KeyInfo|undefined>}
     */

  }, {
    key: "findKeyById",
    value: function () {
      var _findKeyById = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id) {
        var keys;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return this.listKeys();

              case 3:
                keys = _context3.sent;
                return _context3.abrupt("return", keys.find(function (k) {
                  return k.id === id;
                }));

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](0);
                return _context3.abrupt("return", throwDelayed(_context3.t0));

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 7]]);
      }));

      function findKeyById(_x4) {
        return _findKeyById.apply(this, arguments);
      }

      return findKeyById;
    }()
    /**
     * Find a key by it's name.
     *
     * @param {string} name - The local key name.
     * @returns {Promise<KeyInfo>}
     */

  }, {
    key: "findKeyByName",
    value: function () {
      var _findKeyByName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(name) {
        var dsname, res;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (validateKeyName(name)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 2:
                dsname = DsInfoName(name);
                _context4.prev = 3;
                _context4.next = 6;
                return this.store.get(dsname);

              case 6:
                res = _context4.sent;
                return _context4.abrupt("return", JSON.parse(uint8ArrayToString(res)));

              case 10:
                _context4.prev = 10;
                _context4.t0 = _context4["catch"](3);
                return _context4.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(name, "' does not exist. ").concat(_context4.t0.message)), 'ERR_KEY_NOT_FOUND')));

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 10]]);
      }));

      function findKeyByName(_x5) {
        return _findKeyByName.apply(this, arguments);
      }

      return findKeyByName;
    }()
    /**
     * Remove an existing key.
     *
     * @param {string} name - The local key name; must already exist.
     * @returns {Promise<KeyInfo>}
     */

  }, {
    key: "removeKey",
    value: function () {
      var _removeKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(name) {
        var self, dsname, keyInfo, batch;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                self = this;

                if (!(!validateKeyName(name) || name === 'self')) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 3:
                dsname = DsName(name);
                _context5.next = 6;
                return self.findKeyByName(name);

              case 6:
                keyInfo = _context5.sent;
                batch = self.store.batch();
                batch.delete(dsname);
                batch.delete(DsInfoName(name));
                _context5.next = 12;
                return batch.commit();

              case 12:
                return _context5.abrupt("return", keyInfo);

              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function removeKey(_x6) {
        return _removeKey.apply(this, arguments);
      }

      return removeKey;
    }()
    /**
     * Rename a key
     *
     * @param {string} oldName - The old local key name; must already exist.
     * @param {string} newName - The new local key name; must not already exist.
     * @returns {Promise<KeyInfo>}
     */

  }, {
    key: "renameKey",
    value: function () {
      var _renameKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(oldName, newName) {
        var self, oldDsname, newDsname, oldInfoName, newInfoName, exists, pem, res, keyInfo, batch;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                self = this;

                if (!(!validateKeyName(oldName) || oldName === 'self')) {
                  _context6.next = 3;
                  break;
                }

                return _context6.abrupt("return", throwDelayed(errcode(new Error("Invalid old key name '".concat(oldName, "'")), 'ERR_OLD_KEY_NAME_INVALID')));

              case 3:
                if (!(!validateKeyName(newName) || newName === 'self')) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt("return", throwDelayed(errcode(new Error("Invalid new key name '".concat(newName, "'")), 'ERR_NEW_KEY_NAME_INVALID')));

              case 5:
                oldDsname = DsName(oldName);
                newDsname = DsName(newName);
                oldInfoName = DsInfoName(oldName);
                newInfoName = DsInfoName(newName);
                _context6.next = 11;
                return self.store.has(newDsname);

              case 11:
                exists = _context6.sent;

                if (!exists) {
                  _context6.next = 14;
                  break;
                }

                return _context6.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(newName, "' already exists")), 'ERR_KEY_ALREADY_EXISTS')));

              case 14:
                _context6.prev = 14;
                _context6.next = 17;
                return self.store.get(oldDsname);

              case 17:
                pem = _context6.sent;
                _context6.next = 20;
                return self.store.get(oldInfoName);

              case 20:
                res = _context6.sent;
                keyInfo = JSON.parse(uint8ArrayToString(res));
                keyInfo.name = newName;
                batch = self.store.batch();
                batch.put(newDsname, pem);
                batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));
                batch.delete(oldDsname);
                batch.delete(oldInfoName);
                _context6.next = 30;
                return batch.commit();

              case 30:
                return _context6.abrupt("return", keyInfo);

              case 33:
                _context6.prev = 33;
                _context6.t0 = _context6["catch"](14);
                return _context6.abrupt("return", throwDelayed(_context6.t0));

              case 36:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[14, 33]]);
      }));

      function renameKey(_x7, _x8) {
        return _renameKey.apply(this, arguments);
      }

      return renameKey;
    }()
    /**
     * Export an existing key as a PEM encrypted PKCS #8 string
     *
     * @param {string} name - The local key name; must already exist.
     * @param {string} password - The password
     * @returns {Promise<string>}
     */

  }, {
    key: "exportKey",
    value: function () {
      var _exportKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(name, password) {
        var dsname, res, pem, dek, privateKey;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (validateKeyName(name)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 2:
                if (password) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED')));

              case 4:
                dsname = DsName(name);
                _context7.prev = 5;
                _context7.next = 8;
                return this.store.get(dsname);

              case 8:
                res = _context7.sent;
                pem = uint8ArrayToString(res);
                /** @type {string} */

                dek = privates.get(this).dek;
                _context7.next = 13;
                return crypto.keys.import(pem, dek);

              case 13:
                privateKey = _context7.sent;
                return _context7.abrupt("return", privateKey.export(password));

              case 17:
                _context7.prev = 17;
                _context7.t0 = _context7["catch"](5);
                return _context7.abrupt("return", throwDelayed(_context7.t0));

              case 20:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[5, 17]]);
      }));

      function exportKey(_x9, _x10) {
        return _exportKey.apply(this, arguments);
      }

      return exportKey;
    }()
    /**
     * Import a new key from a PEM encoded PKCS #8 string
     *
     * @param {string} name - The local key name; must not already exist.
     * @param {string} pem - The PEM encoded PKCS #8 string
     * @param {string} password - The password.
     * @returns {Promise<KeyInfo>}
     */

  }, {
    key: "importKey",
    value: function () {
      var _importKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(name, pem, password) {
        var self, dsname, exists, privateKey, kid, dek, keyInfo, batch;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                self = this;

                if (!(!validateKeyName(name) || name === 'self')) {
                  _context8.next = 3;
                  break;
                }

                return _context8.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 3:
                if (pem) {
                  _context8.next = 5;
                  break;
                }

                return _context8.abrupt("return", throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED')));

              case 5:
                dsname = DsName(name);
                _context8.next = 8;
                return self.store.has(dsname);

              case 8:
                exists = _context8.sent;

                if (!exists) {
                  _context8.next = 11;
                  break;
                }

                return _context8.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(name, "' already exists")), 'ERR_KEY_ALREADY_EXISTS')));

              case 11:
                _context8.prev = 11;
                _context8.next = 14;
                return crypto.keys.import(pem, password);

              case 14:
                privateKey = _context8.sent;
                _context8.next = 20;
                break;

              case 17:
                _context8.prev = 17;
                _context8.t0 = _context8["catch"](11);
                return _context8.abrupt("return", throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY')));

              case 20:
                _context8.prev = 20;
                _context8.next = 23;
                return privateKey.id();

              case 23:
                kid = _context8.sent;

                /** @type {string} */
                dek = privates.get(this).dek;
                _context8.next = 27;
                return privateKey.export(dek);

              case 27:
                pem = _context8.sent;
                _context8.next = 33;
                break;

              case 30:
                _context8.prev = 30;
                _context8.t1 = _context8["catch"](20);
                return _context8.abrupt("return", throwDelayed(_context8.t1));

              case 33:
                keyInfo = {
                  name: name,
                  id: kid
                };
                batch = self.store.batch();
                batch.put(dsname, uint8ArrayFromString(pem));
                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
                _context8.next = 39;
                return batch.commit();

              case 39:
                return _context8.abrupt("return", keyInfo);

              case 40:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[11, 17], [20, 30]]);
      }));

      function importKey(_x11, _x12, _x13) {
        return _importKey.apply(this, arguments);
      }

      return importKey;
    }()
    /**
     * Import a peer key
     *
     * @param {string} name - The local key name; must not already exist.
     * @param {PeerId} peer - The PEM encoded PKCS #8 string
     * @returns {Promise<KeyInfo>}
     */

  }, {
    key: "importPeer",
    value: function () {
      var _importPeer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(name, peer) {
        var self, privateKey, dsname, exists, kid, dek, pem, keyInfo, batch;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                self = this;

                if (validateKeyName(name)) {
                  _context9.next = 3;
                  break;
                }

                return _context9.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 3:
                if (!(!peer || !peer.privKey)) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY')));

              case 5:
                privateKey = peer.privKey;
                dsname = DsName(name);
                _context9.next = 9;
                return self.store.has(dsname);

              case 9:
                exists = _context9.sent;

                if (!exists) {
                  _context9.next = 12;
                  break;
                }

                return _context9.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(name, "' already exists")), 'ERR_KEY_ALREADY_EXISTS')));

              case 12:
                _context9.prev = 12;
                _context9.next = 15;
                return privateKey.id();

              case 15:
                kid = _context9.sent;

                /** @type {string} */
                dek = privates.get(this).dek;
                _context9.next = 19;
                return privateKey.export(dek);

              case 19:
                pem = _context9.sent;
                keyInfo = {
                  name: name,
                  id: kid
                };
                batch = self.store.batch();
                batch.put(dsname, uint8ArrayFromString(pem));
                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
                _context9.next = 26;
                return batch.commit();

              case 26:
                return _context9.abrupt("return", keyInfo);

              case 29:
                _context9.prev = 29;
                _context9.t0 = _context9["catch"](12);
                return _context9.abrupt("return", throwDelayed(_context9.t0));

              case 32:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[12, 29]]);
      }));

      function importPeer(_x14, _x15) {
        return _importPeer.apply(this, arguments);
      }

      return importPeer;
    }()
    /**
     * Gets the private key as PEM encoded PKCS #8 string.
     *
     * @param {string} name
     * @returns {Promise<string>}
     */

  }, {
    key: "_getPrivateKey",
    value: function () {
      var _getPrivateKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(name) {
        var dsname, res;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (validateKeyName(name)) {
                  _context10.next = 2;
                  break;
                }

                return _context10.abrupt("return", throwDelayed(errcode(new Error("Invalid key name '".concat(name, "'")), 'ERR_INVALID_KEY_NAME')));

              case 2:
                _context10.prev = 2;
                dsname = DsName(name);
                _context10.next = 6;
                return this.store.get(dsname);

              case 6:
                res = _context10.sent;
                return _context10.abrupt("return", uint8ArrayToString(res));

              case 10:
                _context10.prev = 10;
                _context10.t0 = _context10["catch"](2);
                return _context10.abrupt("return", throwDelayed(errcode(new Error("Key '".concat(name, "' does not exist. ").concat(_context10.t0.message)), 'ERR_KEY_NOT_FOUND')));

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[2, 10]]);
      }));

      function _getPrivateKey(_x16) {
        return _getPrivateKey2.apply(this, arguments);
      }

      return _getPrivateKey;
    }()
    /**
     * Rotate keychain password and re-encrypt all assosciated keys
     *
     * @param {string} oldPass - The old local keychain password
     * @param {string} newPass - The new local keychain password
     */

  }, {
    key: "rotateKeychainPass",
    value: function () {
      var _rotateKeychainPass = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(oldPass, newPass) {
        var oldDek, newDek, keys, _iterator2, _step2, key, res, pem, privateKey, password, keyAsPEM, batch, keyInfo;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(typeof oldPass !== 'string')) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", throwDelayed(errcode(new Error("Invalid old pass type '".concat(_typeof(oldPass), "'")), 'ERR_INVALID_OLD_PASS_TYPE')));

              case 2:
                if (!(typeof newPass !== 'string')) {
                  _context11.next = 4;
                  break;
                }

                return _context11.abrupt("return", throwDelayed(errcode(new Error("Invalid new pass type '".concat(_typeof(newPass), "'")), 'ERR_INVALID_NEW_PASS_TYPE')));

              case 4:
                if (!(newPass.length < 20)) {
                  _context11.next = 6;
                  break;
                }

                return _context11.abrupt("return", throwDelayed(errcode(new Error("Invalid pass length ".concat(newPass.length)), 'ERR_INVALID_PASS_LENGTH')));

              case 6:
                log('recreating keychain');
                oldDek = privates.get(this).dek;
                this.opts.pass = newPass;
                newDek = newPass ? crypto.pbkdf2(newPass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';
                privates.set(this, {
                  dek: newDek
                });
                _context11.next = 13;
                return this.listKeys();

              case 13:
                keys = _context11.sent;
                _iterator2 = _createForOfIteratorHelper(keys);
                _context11.prev = 15;

                _iterator2.s();

              case 17:
                if ((_step2 = _iterator2.n()).done) {
                  _context11.next = 38;
                  break;
                }

                key = _step2.value;
                _context11.next = 21;
                return this.store.get(DsName(key.name));

              case 21:
                res = _context11.sent;
                pem = uint8ArrayToString(res);
                _context11.next = 25;
                return crypto.keys.import(pem, oldDek);

              case 25:
                privateKey = _context11.sent;
                password = newDek.toString();
                _context11.next = 29;
                return privateKey.export(password);

              case 29:
                keyAsPEM = _context11.sent;
                // Update stored key
                batch = this.store.batch();
                keyInfo = {
                  name: key.name,
                  id: key.id
                };
                batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));
                batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));
                _context11.next = 36;
                return batch.commit();

              case 36:
                _context11.next = 17;
                break;

              case 38:
                _context11.next = 43;
                break;

              case 40:
                _context11.prev = 40;
                _context11.t0 = _context11["catch"](15);

                _iterator2.e(_context11.t0);

              case 43:
                _context11.prev = 43;

                _iterator2.f();

                return _context11.finish(43);

              case 46:
                log('keychain reconstructed');

              case 47:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[15, 40, 43, 46]]);
      }));

      function rotateKeychainPass(_x17, _x18) {
        return _rotateKeychainPass.apply(this, arguments);
      }

      return rotateKeychainPass;
    }()
  }], [{
    key: "generateOptions",
    value: function generateOptions() {
      var options = Object.assign({}, defaultOptions);
      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding

      options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64');
      return options;
    }
    /**
     * Gets an object that can encrypt/decrypt protected data.
     * The default options for a keychain.
     *
     * @returns {Object}
     */

  }, {
    key: "options",
    get: function get() {
      return defaultOptions;
    }
  }]);

  return Keychain;
}();

module.exports = Keychain;
},{"debug":"node_modules/debug/src/browser.js","sanitize-filename":"node_modules/sanitize-filename/index.js","merge-options":"node_modules/merge-options/index.js","libp2p-crypto":"node_modules/libp2p-crypto/src/index.js","interface-datastore":"node_modules/interface-datastore/src/index.js","./cms":"node_modules/libp2p/src/keychain/cms.js","err-code":"node_modules/err-code/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","node-forge/lib/sha512":"node_modules/node-forge/lib/sha512.js"}],"node_modules/streaming-iterables/dist/index.mjs":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batch = batch;
exports.buffer = buffer;
exports.collect = collect;
exports.concat = concat;
exports.consume = consume;
exports.filter = filter;
exports.flatMap = flatMap;
exports.flatTransform = flatTransform;
exports.flatten = flatten;
exports.fromStream = fromStream;
exports.getIterator = getIterator;
exports.map = map;
exports.merge = merge;
exports.parallelFlatMap = parallelFlatMap;
exports.parallelMap = parallelMap;
exports.parallelMerge = parallelMerge;
exports.pipeline = pipeline;
exports.reduce = reduce;
exports.take = take;
exports.tap = tap;
exports.time = time;
exports.transform = transform;
exports.writeToStream = writeToStream;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _marked = /*#__PURE__*/regeneratorRuntime.mark(_syncBatch),
    _marked2 = /*#__PURE__*/regeneratorRuntime.mark(syncBuffer),
    _marked3 = /*#__PURE__*/regeneratorRuntime.mark(_syncConcat),
    _marked4 = /*#__PURE__*/regeneratorRuntime.mark(_syncTake),
    _marked5 = /*#__PURE__*/regeneratorRuntime.mark(_syncTime);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _asyncGeneratorDelegate(inner, awaitWrap) { var iter = {}, waiting = false; function pump(key, value) { waiting = true; value = new Promise(function (resolve) { resolve(inner[key](value)); }); return { done: false, value: awaitWrap(value) }; } ; iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; }; iter.next = function (value) { if (waiting) { waiting = false; return value; } return pump("next", value); }; if (typeof inner.throw === "function") { iter.throw = function (value) { if (waiting) { waiting = false; throw value; } return pump("throw", value); }; } if (typeof inner.return === "function") { iter.return = function (value) { if (waiting) { waiting = false; return value; } return pump("return", value); }; } return iter; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

function _batch(_x, _x2) {
  return _batch2.apply(this, arguments);
}

function _batch2() {
  _batch2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(size, iterable) {
    var dataBatch, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            dataBatch = [];
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context.prev = 3;
            _iterator = _asyncIterator(iterable);

          case 5:
            _context.next = 7;
            return _awaitAsyncGenerator(_iterator.next());

          case 7:
            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
              _context.next = 17;
              break;
            }

            data = _step.value;
            dataBatch.push(data);

            if (!(dataBatch.length === size)) {
              _context.next = 14;
              break;
            }

            _context.next = 13;
            return dataBatch;

          case 13:
            dataBatch = [];

          case 14:
            _iteratorAbruptCompletion = false;
            _context.next = 5;
            break;

          case 17:
            _context.next = 23;
            break;

          case 19:
            _context.prev = 19;
            _context.t0 = _context["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 23:
            _context.prev = 23;
            _context.prev = 24;

            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context.next = 28;
              break;
            }

            _context.next = 28;
            return _awaitAsyncGenerator(_iterator.return());

          case 28:
            _context.prev = 28;

            if (!_didIteratorError) {
              _context.next = 31;
              break;
            }

            throw _iteratorError;

          case 31:
            return _context.finish(28);

          case 32:
            return _context.finish(23);

          case 33:
            if (!(dataBatch.length > 0)) {
              _context.next = 36;
              break;
            }

            _context.next = 36;
            return dataBatch;

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 19, 23, 33], [24,, 28, 32]]);
  }));
  return _batch2.apply(this, arguments);
}

function _syncBatch(size, iterable) {
  var dataBatch, _iterator14, _step14, data;

  return regeneratorRuntime.wrap(function _syncBatch$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          dataBatch = [];
          _iterator14 = _createForOfIteratorHelper(iterable);
          _context2.prev = 2;

          _iterator14.s();

        case 4:
          if ((_step14 = _iterator14.n()).done) {
            _context2.next = 13;
            break;
          }

          data = _step14.value;
          dataBatch.push(data);

          if (!(dataBatch.length === size)) {
            _context2.next = 11;
            break;
          }

          _context2.next = 10;
          return dataBatch;

        case 10:
          dataBatch = [];

        case 11:
          _context2.next = 4;
          break;

        case 13:
          _context2.next = 18;
          break;

        case 15:
          _context2.prev = 15;
          _context2.t0 = _context2["catch"](2);

          _iterator14.e(_context2.t0);

        case 18:
          _context2.prev = 18;

          _iterator14.f();

          return _context2.finish(18);

        case 21:
          if (!(dataBatch.length > 0)) {
            _context2.next = 24;
            break;
          }

          _context2.next = 24;
          return dataBatch;

        case 24:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked, null, [[2, 15, 18, 21]]);
}

function batch(size, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return batch(size, curriedIterable);
    };
  }

  if (iterable[Symbol.asyncIterator]) {
    return _batch(size, iterable);
  }

  return _syncBatch(size, iterable);
}

function getIterator(iterable) {
  if (typeof iterable.next === 'function') {
    return iterable;
  }

  if (typeof iterable[Symbol.iterator] === 'function') {
    return iterable[Symbol.iterator]();
  }

  if (typeof iterable[Symbol.asyncIterator] === 'function') {
    return iterable[Symbol.asyncIterator]();
  }

  throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
}

function defer() {
  var reject;
  var resolve;
  var promise = new Promise(function (resolveFunc, rejectFunc) {
    resolve = resolveFunc;
    reject = rejectFunc;
  });
  return {
    promise: promise,
    reject: reject,
    resolve: resolve
  };
} /// <reference lib="esnext.asynciterable" />


function _buffer(size, iterable) {
  var iterator = getIterator(iterable);
  var resultQueue = [];
  var readQueue = [];
  var reading = false;
  var ended = false;

  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      var readDeferred = readQueue.shift();

      var _resultQueue$shift = resultQueue.shift(),
          error = _resultQueue$shift.error,
          value = _resultQueue$shift.value;

      if (error) {
        readDeferred.reject(error);
      } else {
        readDeferred.resolve({
          done: false,
          value: value
        });
      }
    }

    while (readQueue.length > 0 && ended) {
      var _readQueue$shift = readQueue.shift(),
          resolve = _readQueue$shift.resolve;

      resolve({
        done: true,
        value: undefined
      });
    }
  }

  function fillQueue() {
    return _fillQueue.apply(this, arguments);
  }

  function _fillQueue() {
    _fillQueue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var _yield$iterator$next, done, value;

      return regeneratorRuntime.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!ended) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              if (!reading) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return");

            case 4:
              if (!(resultQueue.length >= size)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt("return");

            case 6:
              reading = true;
              _context3.prev = 7;
              _context3.next = 10;
              return iterator.next();

            case 10:
              _yield$iterator$next = _context3.sent;
              done = _yield$iterator$next.done;
              value = _yield$iterator$next.value;

              if (done) {
                ended = true;
              } else {
                resultQueue.push({
                  value: value
                });
              }

              _context3.next = 20;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t0 = _context3["catch"](7);
              ended = true;
              resultQueue.push({
                error: _context3.t0
              });

            case 20:
              fulfillReadQueue();
              reading = false;
              fillQueue();

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2, null, [[7, 16]]);
    }));
    return _fillQueue.apply(this, arguments);
  }

  function next() {
    return _next2.apply(this, arguments);
  }

  function _next2() {
    _next2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var _resultQueue$shift2, error, value, deferred;

      return regeneratorRuntime.wrap(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(resultQueue.length > 0)) {
                _context4.next = 6;
                break;
              }

              _resultQueue$shift2 = resultQueue.shift(), error = _resultQueue$shift2.error, value = _resultQueue$shift2.value;

              if (!error) {
                _context4.next = 4;
                break;
              }

              throw error;

            case 4:
              fillQueue();
              return _context4.abrupt("return", {
                done: false,
                value: value
              });

            case 6:
              if (!ended) {
                _context4.next = 8;
                break;
              }

              return _context4.abrupt("return", {
                done: true,
                value: undefined
              });

            case 8:
              deferred = defer();
              readQueue.push(deferred);
              fillQueue();
              return _context4.abrupt("return", deferred.promise);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee3);
    }));
    return _next2.apply(this, arguments);
  }

  var asyncIterableIterator = _defineProperty({
    next: next
  }, Symbol.asyncIterator, function () {
    return asyncIterableIterator;
  });

  return asyncIterableIterator;
}

function syncBuffer(size, iterable) {
  var valueQueue, e, _iterator15, _step15, value, _i, _valueQueue, _value;

  return regeneratorRuntime.wrap(function syncBuffer$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          valueQueue = [];
          _context5.prev = 1;
          _iterator15 = _createForOfIteratorHelper(iterable);
          _context5.prev = 3;

          _iterator15.s();

        case 5:
          if ((_step15 = _iterator15.n()).done) {
            _context5.next = 14;
            break;
          }

          value = _step15.value;
          valueQueue.push(value);

          if (!(valueQueue.length <= size)) {
            _context5.next = 10;
            break;
          }

          return _context5.abrupt("continue", 12);

        case 10:
          _context5.next = 12;
          return valueQueue.shift();

        case 12:
          _context5.next = 5;
          break;

        case 14:
          _context5.next = 19;
          break;

        case 16:
          _context5.prev = 16;
          _context5.t0 = _context5["catch"](3);

          _iterator15.e(_context5.t0);

        case 19:
          _context5.prev = 19;

          _iterator15.f();

          return _context5.finish(19);

        case 22:
          _context5.next = 27;
          break;

        case 24:
          _context5.prev = 24;
          _context5.t1 = _context5["catch"](1);
          e = _context5.t1;

        case 27:
          _i = 0, _valueQueue = valueQueue;

        case 28:
          if (!(_i < _valueQueue.length)) {
            _context5.next = 35;
            break;
          }

          _value = _valueQueue[_i];
          _context5.next = 32;
          return _value;

        case 32:
          _i++;
          _context5.next = 28;
          break;

        case 35:
          if (!e) {
            _context5.next = 37;
            break;
          }

          throw e;

        case 37:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked2, null, [[1, 24], [3, 16, 19, 22]]);
}

function buffer(size, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return buffer(size, curriedIterable);
    };
  }

  if (size === 0) {
    return iterable;
  }

  if (iterable[Symbol.asyncIterator]) {
    return _buffer(size, iterable);
  }

  return syncBuffer(size, iterable);
}

function _collect(_x20) {
  return _collect2.apply(this, arguments);
}

function _collect2() {
  _collect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(iterable) {
    var values, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, value;

    return regeneratorRuntime.wrap(function _callee23$(_context28) {
      while (1) {
        switch (_context28.prev = _context28.next) {
          case 0:
            values = [];
            _iteratorAbruptCompletion2 = false;
            _didIteratorError2 = false;
            _context28.prev = 3;
            _iterator2 = _asyncIterator(iterable);

          case 5:
            _context28.next = 7;
            return _iterator2.next();

          case 7:
            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context28.sent).done)) {
              _context28.next = 13;
              break;
            }

            value = _step2.value;
            values.push(value);

          case 10:
            _iteratorAbruptCompletion2 = false;
            _context28.next = 5;
            break;

          case 13:
            _context28.next = 19;
            break;

          case 15:
            _context28.prev = 15;
            _context28.t0 = _context28["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context28.t0;

          case 19:
            _context28.prev = 19;
            _context28.prev = 20;

            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {
              _context28.next = 24;
              break;
            }

            _context28.next = 24;
            return _iterator2.return();

          case 24:
            _context28.prev = 24;

            if (!_didIteratorError2) {
              _context28.next = 27;
              break;
            }

            throw _iteratorError2;

          case 27:
            return _context28.finish(24);

          case 28:
            return _context28.finish(19);

          case 29:
            return _context28.abrupt("return", values);

          case 30:
          case "end":
            return _context28.stop();
        }
      }
    }, _callee23, null, [[3, 15, 19, 29], [20,, 24, 28]]);
  }));
  return _collect2.apply(this, arguments);
}

function collect(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return _collect(iterable);
  }

  return Array.from(iterable);
}

function _concat(_x3) {
  return _concat2.apply(this, arguments);
}

function _concat2() {
  _concat2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iterables) {
    var _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, iterable;

    return regeneratorRuntime.wrap(function _callee4$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _iteratorAbruptCompletion3 = false;
            _didIteratorError3 = false;
            _context6.prev = 2;
            _iterator3 = _asyncIterator(iterables);

          case 4:
            _context6.next = 6;
            return _awaitAsyncGenerator(_iterator3.next());

          case 6:
            if (!(_iteratorAbruptCompletion3 = !(_step3 = _context6.sent).done)) {
              _context6.next = 12;
              break;
            }

            iterable = _step3.value;
            return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(iterable), _awaitAsyncGenerator), "t0", 9);

          case 9:
            _iteratorAbruptCompletion3 = false;
            _context6.next = 4;
            break;

          case 12:
            _context6.next = 18;
            break;

          case 14:
            _context6.prev = 14;
            _context6.t1 = _context6["catch"](2);
            _didIteratorError3 = true;
            _iteratorError3 = _context6.t1;

          case 18:
            _context6.prev = 18;
            _context6.prev = 19;

            if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {
              _context6.next = 23;
              break;
            }

            _context6.next = 23;
            return _awaitAsyncGenerator(_iterator3.return());

          case 23:
            _context6.prev = 23;

            if (!_didIteratorError3) {
              _context6.next = 26;
              break;
            }

            throw _iteratorError3;

          case 26:
            return _context6.finish(23);

          case 27:
            return _context6.finish(18);

          case 28:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee4, null, [[2, 14, 18, 28], [19,, 23, 27]]);
  }));
  return _concat2.apply(this, arguments);
}

function _syncConcat(iterables) {
  var _iterator16, _step16, iterable;

  return regeneratorRuntime.wrap(function _syncConcat$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _iterator16 = _createForOfIteratorHelper(iterables);
          _context7.prev = 1;

          _iterator16.s();

        case 3:
          if ((_step16 = _iterator16.n()).done) {
            _context7.next = 8;
            break;
          }

          iterable = _step16.value;
          return _context7.delegateYield(iterable, "t0", 6);

        case 6:
          _context7.next = 3;
          break;

        case 8:
          _context7.next = 13;
          break;

        case 10:
          _context7.prev = 10;
          _context7.t1 = _context7["catch"](1);

          _iterator16.e(_context7.t1);

        case 13:
          _context7.prev = 13;

          _iterator16.f();

          return _context7.finish(13);

        case 16:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked3, null, [[1, 10, 13, 16]]);
}

function concat() {
  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
    iterables[_key] = arguments[_key];
  }

  var hasAnyAsync = iterables.find(function (itr) {
    return itr[Symbol.asyncIterator] !== undefined;
  });

  if (hasAnyAsync) {
    return _concat(iterables);
  } else {
    return _syncConcat(iterables);
  }
}

function _consume(_x21) {
  return _consume2.apply(this, arguments);
}

function _consume2() {
  _consume2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(iterable) {
    var _iteratorAbruptCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, val;

    return regeneratorRuntime.wrap(function _callee24$(_context29) {
      while (1) {
        switch (_context29.prev = _context29.next) {
          case 0:
            _iteratorAbruptCompletion4 = false;
            _didIteratorError4 = false;
            _context29.prev = 2;
            _iterator4 = _asyncIterator(iterable);

          case 4:
            _context29.next = 6;
            return _iterator4.next();

          case 6:
            if (!(_iteratorAbruptCompletion4 = !(_step4 = _context29.sent).done)) {
              _context29.next = 11;
              break;
            }

            val = _step4.value;

          case 8:
            _iteratorAbruptCompletion4 = false;
            _context29.next = 4;
            break;

          case 11:
            _context29.next = 17;
            break;

          case 13:
            _context29.prev = 13;
            _context29.t0 = _context29["catch"](2);
            _didIteratorError4 = true;
            _iteratorError4 = _context29.t0;

          case 17:
            _context29.prev = 17;
            _context29.prev = 18;

            if (!(_iteratorAbruptCompletion4 && _iterator4.return != null)) {
              _context29.next = 22;
              break;
            }

            _context29.next = 22;
            return _iterator4.return();

          case 22:
            _context29.prev = 22;

            if (!_didIteratorError4) {
              _context29.next = 25;
              break;
            }

            throw _iteratorError4;

          case 25:
            return _context29.finish(22);

          case 26:
            return _context29.finish(17);

          case 27:
          case "end":
            return _context29.stop();
        }
      }
    }, _callee24, null, [[2, 13, 17, 27], [18,, 22, 26]]);
  }));
  return _consume2.apply(this, arguments);
}

function consume(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return _consume(iterable);
  }

  var _iterator17 = _createForOfIteratorHelper(iterable),
      _step17;

  try {
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {// do nothing

      var val = _step17.value;
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
}

function _filter(_x4, _x5) {
  return _filter2.apply(this, arguments);
}

function _filter2() {
  _filter2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(filterFunc, iterable) {
    var _iteratorAbruptCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, data;

    return regeneratorRuntime.wrap(function _callee5$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _iteratorAbruptCompletion5 = false;
            _didIteratorError5 = false;
            _context8.prev = 2;
            _iterator5 = _asyncIterator(iterable);

          case 4:
            _context8.next = 6;
            return _awaitAsyncGenerator(_iterator5.next());

          case 6:
            if (!(_iteratorAbruptCompletion5 = !(_step5 = _context8.sent).done)) {
              _context8.next = 16;
              break;
            }

            data = _step5.value;
            _context8.next = 10;
            return _awaitAsyncGenerator(filterFunc(data));

          case 10:
            if (!_context8.sent) {
              _context8.next = 13;
              break;
            }

            _context8.next = 13;
            return data;

          case 13:
            _iteratorAbruptCompletion5 = false;
            _context8.next = 4;
            break;

          case 16:
            _context8.next = 22;
            break;

          case 18:
            _context8.prev = 18;
            _context8.t0 = _context8["catch"](2);
            _didIteratorError5 = true;
            _iteratorError5 = _context8.t0;

          case 22:
            _context8.prev = 22;
            _context8.prev = 23;

            if (!(_iteratorAbruptCompletion5 && _iterator5.return != null)) {
              _context8.next = 27;
              break;
            }

            _context8.next = 27;
            return _awaitAsyncGenerator(_iterator5.return());

          case 27:
            _context8.prev = 27;

            if (!_didIteratorError5) {
              _context8.next = 30;
              break;
            }

            throw _iteratorError5;

          case 30:
            return _context8.finish(27);

          case 31:
            return _context8.finish(22);

          case 32:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee5, null, [[2, 18, 22, 32], [23,, 27, 31]]);
  }));
  return _filter2.apply(this, arguments);
}

function filter(filterFunc, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return _filter(filterFunc, curriedIterable);
    };
  }

  return _filter(filterFunc, iterable);
}

function flatten(_x6) {
  return _flatten.apply(this, arguments);
}

function _flatten() {
  _flatten = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(iterable) {
    var _iteratorAbruptCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, maybeItr;

    return regeneratorRuntime.wrap(function _callee6$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _iteratorAbruptCompletion6 = false;
            _didIteratorError6 = false;
            _context9.prev = 2;
            _iterator6 = _asyncIterator(iterable);

          case 4:
            _context9.next = 6;
            return _awaitAsyncGenerator(_iterator6.next());

          case 6:
            if (!(_iteratorAbruptCompletion6 = !(_step6 = _context9.sent).done)) {
              _context9.next = 17;
              break;
            }

            maybeItr = _step6.value;

            if (!(maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator]))) {
              _context9.next = 12;
              break;
            }

            return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(flatten(maybeItr)), _awaitAsyncGenerator), "t0", 10);

          case 10:
            _context9.next = 14;
            break;

          case 12:
            _context9.next = 14;
            return maybeItr;

          case 14:
            _iteratorAbruptCompletion6 = false;
            _context9.next = 4;
            break;

          case 17:
            _context9.next = 23;
            break;

          case 19:
            _context9.prev = 19;
            _context9.t1 = _context9["catch"](2);
            _didIteratorError6 = true;
            _iteratorError6 = _context9.t1;

          case 23:
            _context9.prev = 23;
            _context9.prev = 24;

            if (!(_iteratorAbruptCompletion6 && _iterator6.return != null)) {
              _context9.next = 28;
              break;
            }

            _context9.next = 28;
            return _awaitAsyncGenerator(_iterator6.return());

          case 28:
            _context9.prev = 28;

            if (!_didIteratorError6) {
              _context9.next = 31;
              break;
            }

            throw _iteratorError6;

          case 31:
            return _context9.finish(28);

          case 32:
            return _context9.finish(23);

          case 33:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee6, null, [[2, 19, 23, 33], [24,, 28, 32]]);
  }));
  return _flatten.apply(this, arguments);
}

function _map(_x7, _x8) {
  return _map2.apply(this, arguments);
}

function _map2() {
  _map2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(func, iterable) {
    var _iteratorAbruptCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, val;

    return regeneratorRuntime.wrap(function _callee7$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _iteratorAbruptCompletion7 = false;
            _didIteratorError7 = false;
            _context10.prev = 2;
            _iterator7 = _asyncIterator(iterable);

          case 4:
            _context10.next = 6;
            return _awaitAsyncGenerator(_iterator7.next());

          case 6:
            if (!(_iteratorAbruptCompletion7 = !(_step7 = _context10.sent).done)) {
              _context10.next = 13;
              break;
            }

            val = _step7.value;
            _context10.next = 10;
            return func(val);

          case 10:
            _iteratorAbruptCompletion7 = false;
            _context10.next = 4;
            break;

          case 13:
            _context10.next = 19;
            break;

          case 15:
            _context10.prev = 15;
            _context10.t0 = _context10["catch"](2);
            _didIteratorError7 = true;
            _iteratorError7 = _context10.t0;

          case 19:
            _context10.prev = 19;
            _context10.prev = 20;

            if (!(_iteratorAbruptCompletion7 && _iterator7.return != null)) {
              _context10.next = 24;
              break;
            }

            _context10.next = 24;
            return _awaitAsyncGenerator(_iterator7.return());

          case 24:
            _context10.prev = 24;

            if (!_didIteratorError7) {
              _context10.next = 27;
              break;
            }

            throw _iteratorError7;

          case 27:
            return _context10.finish(24);

          case 28:
            return _context10.finish(19);

          case 29:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee7, null, [[2, 15, 19, 29], [20,, 24, 28]]);
  }));
  return _map2.apply(this, arguments);
}

function map(func, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return _map(func, curriedIterable);
    };
  }

  return _map(func, iterable);
}

function flatMap(func, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return flatMap(func, curriedIterable);
    };
  }

  return filter(function (i) {
    return i !== undefined && i !== null;
  }, flatten(map(func, iterable)));
}

function _flatTransform(concurrency, func, iterable) {
  var iterator = getIterator(iterable);
  var resultQueue = [];
  var readQueue = [];
  var ended = false;
  var reading = false;
  var inflightCount = 0;
  var lastError = null;

  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      var _readQueue$shift2 = readQueue.shift(),
          resolve = _readQueue$shift2.resolve;

      var value = resultQueue.shift();
      resolve({
        done: false,
        value: value
      });
    }

    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      var _readQueue$shift3 = readQueue.shift(),
          _resolve = _readQueue$shift3.resolve,
          reject = _readQueue$shift3.reject;

      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        _resolve({
          done: true,
          value: undefined
        });
      }
    }
  }

  function fillQueue() {
    return _fillQueue2.apply(this, arguments);
  }

  function _fillQueue2() {
    _fillQueue2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var _yield$iterator$next2, done, value;

      return regeneratorRuntime.wrap(function _callee8$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (!ended) {
                _context11.next = 3;
                break;
              }

              fulfillReadQueue();
              return _context11.abrupt("return");

            case 3:
              if (!reading) {
                _context11.next = 5;
                break;
              }

              return _context11.abrupt("return");

            case 5:
              if (!(inflightCount + resultQueue.length >= concurrency)) {
                _context11.next = 7;
                break;
              }

              return _context11.abrupt("return");

            case 7:
              reading = true;
              inflightCount++;
              _context11.prev = 9;
              _context11.next = 12;
              return iterator.next();

            case 12:
              _yield$iterator$next2 = _context11.sent;
              done = _yield$iterator$next2.done;
              value = _yield$iterator$next2.value;

              if (done) {
                ended = true;
                inflightCount--;
                fulfillReadQueue();
              } else {
                mapAndQueue(value);
              }

              _context11.next = 24;
              break;

            case 18:
              _context11.prev = 18;
              _context11.t0 = _context11["catch"](9);
              ended = true;
              inflightCount--;
              lastError = _context11.t0;
              fulfillReadQueue();

            case 24:
              reading = false;
              fillQueue();

            case 26:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee8, null, [[9, 18]]);
    }));
    return _fillQueue2.apply(this, arguments);
  }

  function mapAndQueue(_x22) {
    return _mapAndQueue.apply(this, arguments);
  }

  function _mapAndQueue() {
    _mapAndQueue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(itrValue) {
      var value, _iteratorAbruptCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, asyncVal;

      return regeneratorRuntime.wrap(function _callee9$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.prev = 0;
              _context12.next = 3;
              return func(itrValue);

            case 3:
              value = _context12.sent;

              if (!(value && value[Symbol.asyncIterator])) {
                _context12.next = 35;
                break;
              }

              _iteratorAbruptCompletion8 = false;
              _didIteratorError8 = false;
              _context12.prev = 7;
              _iterator8 = _asyncIterator(value);

            case 9:
              _context12.next = 11;
              return _iterator8.next();

            case 11:
              if (!(_iteratorAbruptCompletion8 = !(_step8 = _context12.sent).done)) {
                _context12.next = 17;
                break;
              }

              asyncVal = _step8.value;
              resultQueue.push(asyncVal);

            case 14:
              _iteratorAbruptCompletion8 = false;
              _context12.next = 9;
              break;

            case 17:
              _context12.next = 23;
              break;

            case 19:
              _context12.prev = 19;
              _context12.t0 = _context12["catch"](7);
              _didIteratorError8 = true;
              _iteratorError8 = _context12.t0;

            case 23:
              _context12.prev = 23;
              _context12.prev = 24;

              if (!(_iteratorAbruptCompletion8 && _iterator8.return != null)) {
                _context12.next = 28;
                break;
              }

              _context12.next = 28;
              return _iterator8.return();

            case 28:
              _context12.prev = 28;

              if (!_didIteratorError8) {
                _context12.next = 31;
                break;
              }

              throw _iteratorError8;

            case 31:
              return _context12.finish(28);

            case 32:
              return _context12.finish(23);

            case 33:
              _context12.next = 36;
              break;

            case 35:
              resultQueue.push(value);

            case 36:
              _context12.next = 42;
              break;

            case 38:
              _context12.prev = 38;
              _context12.t1 = _context12["catch"](0);
              ended = true;
              lastError = _context12.t1;

            case 42:
              inflightCount--;
              fulfillReadQueue();
              fillQueue();

            case 45:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee9, null, [[0, 38], [7, 19, 23, 33], [24,, 28, 32]]);
    }));
    return _mapAndQueue.apply(this, arguments);
  }

  function next() {
    return _next3.apply(this, arguments);
  }

  function _next3() {
    _next3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var deferred, value;
      return regeneratorRuntime.wrap(function _callee10$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (!(resultQueue.length === 0)) {
                _context13.next = 5;
                break;
              }

              deferred = defer();
              readQueue.push(deferred);
              fillQueue();
              return _context13.abrupt("return", deferred.promise);

            case 5:
              value = resultQueue.shift();
              fillQueue();
              return _context13.abrupt("return", {
                done: false,
                value: value
              });

            case 8:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee10);
    }));
    return _next3.apply(this, arguments);
  }

  var asyncIterableIterator = _defineProperty({
    next: next
  }, Symbol.asyncIterator, function () {
    return asyncIterableIterator;
  });

  return asyncIterableIterator;
}

function flatTransform(concurrency, func, iterable) {
  if (func === undefined) {
    return function (curriedFunc, curriedIterable) {
      return curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);
    };
  }

  if (iterable === undefined) {
    return function (curriedIterable) {
      return flatTransform(concurrency, func, curriedIterable);
    };
  }

  return filter(function (i) {
    return i !== undefined && i !== null;
  }, flatten(_flatTransform(concurrency, func, iterable)));
}

function onceReadable(_x23) {
  return _onceReadable.apply(this, arguments);
}

function _onceReadable() {
  _onceReadable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(stream) {
    return regeneratorRuntime.wrap(function _callee25$(_context30) {
      while (1) {
        switch (_context30.prev = _context30.next) {
          case 0:
            return _context30.abrupt("return", new Promise(function (resolve) {
              stream.once('readable', function () {
                resolve();
              });
            }));

          case 1:
          case "end":
            return _context30.stop();
        }
      }
    }, _callee25);
  }));
  return _onceReadable.apply(this, arguments);
}

function _fromStream(_x9) {
  return _fromStream2.apply(this, arguments);
}

function _fromStream2() {
  _fromStream2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(stream) {
    var data;
    return regeneratorRuntime.wrap(function _callee11$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            if (!true) {
              _context14.next = 12;
              break;
            }

            data = stream.read();

            if (!(data !== null)) {
              _context14.next = 6;
              break;
            }

            _context14.next = 5;
            return data;

          case 5:
            return _context14.abrupt("continue", 0);

          case 6:
            if (!stream._readableState.ended) {
              _context14.next = 8;
              break;
            }

            return _context14.abrupt("break", 12);

          case 8:
            _context14.next = 10;
            return _awaitAsyncGenerator(onceReadable(stream));

          case 10:
            _context14.next = 0;
            break;

          case 12:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee11);
  }));
  return _fromStream2.apply(this, arguments);
}

function fromStream(stream) {
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return stream;
  }

  return _fromStream(stream);
}

function merge() {
  return _merge.apply(this, arguments);
}

function _merge() {
  _merge = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
    var _len2,
        iterables,
        _key2,
        sources,
        _iterator18,
        _step18,
        iterator,
        nextVal,
        _args15 = arguments;

    return regeneratorRuntime.wrap(function _callee12$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            for (_len2 = _args15.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              iterables[_key2] = _args15[_key2];
            }

            sources = new Set(iterables.map(getIterator));

          case 2:
            if (!(sources.size > 0)) {
              _context15.next = 29;
              break;
            }

            _iterator18 = _createForOfIteratorHelper(sources);
            _context15.prev = 4;

            _iterator18.s();

          case 6:
            if ((_step18 = _iterator18.n()).done) {
              _context15.next = 19;
              break;
            }

            iterator = _step18.value;
            _context15.next = 10;
            return _awaitAsyncGenerator(iterator.next());

          case 10:
            nextVal = _context15.sent;

            if (!nextVal.done) {
              _context15.next = 15;
              break;
            }

            sources.delete(iterator);
            _context15.next = 17;
            break;

          case 15:
            _context15.next = 17;
            return nextVal.value;

          case 17:
            _context15.next = 6;
            break;

          case 19:
            _context15.next = 24;
            break;

          case 21:
            _context15.prev = 21;
            _context15.t0 = _context15["catch"](4);

            _iterator18.e(_context15.t0);

          case 24:
            _context15.prev = 24;

            _iterator18.f();

            return _context15.finish(24);

          case 27:
            _context15.next = 2;
            break;

          case 29:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee12, null, [[4, 21, 24, 27]]);
  }));
  return _merge.apply(this, arguments);
}

function pipeline(firstFn) {
  var previousFn = firstFn();

  for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    fns[_key3 - 1] = arguments[_key3];
  }

  for (var _i2 = 0, _fns = fns; _i2 < _fns.length; _i2++) {
    var func = _fns[_i2];
    previousFn = func(previousFn);
  }

  return previousFn;
}

function _parallelMap(_x10, _x11, _x12) {
  return _parallelMap2.apply(this, arguments);
}

function _parallelMap2() {
  _parallelMap2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(concurrency, func, iterable) {
    var transformError, wrapFunc, stopOnError, output, itr, _yield$_awaitAsyncGen, value, done, val;

    return regeneratorRuntime.wrap(function _callee14$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            transformError = null;

            wrapFunc = function wrapFunc(value) {
              return {
                value: func(value)
              };
            };

            stopOnError = /*#__PURE__*/function () {
              var _ref = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(source) {
                var _iteratorAbruptCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, value;

                return regeneratorRuntime.wrap(function _callee13$(_context16) {
                  while (1) {
                    switch (_context16.prev = _context16.next) {
                      case 0:
                        _iteratorAbruptCompletion13 = false;
                        _didIteratorError13 = false;
                        _context16.prev = 2;
                        _iterator13 = _asyncIterator(source);

                      case 4:
                        _context16.next = 6;
                        return _awaitAsyncGenerator(_iterator13.next());

                      case 6:
                        if (!(_iteratorAbruptCompletion13 = !(_step13 = _context16.sent).done)) {
                          _context16.next = 15;
                          break;
                        }

                        value = _step13.value;

                        if (!transformError) {
                          _context16.next = 10;
                          break;
                        }

                        return _context16.abrupt("return");

                      case 10:
                        _context16.next = 12;
                        return value;

                      case 12:
                        _iteratorAbruptCompletion13 = false;
                        _context16.next = 4;
                        break;

                      case 15:
                        _context16.next = 21;
                        break;

                      case 17:
                        _context16.prev = 17;
                        _context16.t0 = _context16["catch"](2);
                        _didIteratorError13 = true;
                        _iteratorError13 = _context16.t0;

                      case 21:
                        _context16.prev = 21;
                        _context16.prev = 22;

                        if (!(_iteratorAbruptCompletion13 && _iterator13.return != null)) {
                          _context16.next = 26;
                          break;
                        }

                        _context16.next = 26;
                        return _awaitAsyncGenerator(_iterator13.return());

                      case 26:
                        _context16.prev = 26;

                        if (!_didIteratorError13) {
                          _context16.next = 29;
                          break;
                        }

                        throw _iteratorError13;

                      case 29:
                        return _context16.finish(26);

                      case 30:
                        return _context16.finish(21);

                      case 31:
                      case "end":
                        return _context16.stop();
                    }
                  }
                }, _callee13, null, [[2, 17, 21, 31], [22,, 26, 30]]);
              }));

              return function stopOnError(_x19) {
                return _ref.apply(this, arguments);
              };
            }();

            output = pipeline(function () {
              return iterable;
            }, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));
            itr = getIterator(output);

          case 5:
            if (!true) {
              _context17.next = 27;
              break;
            }

            _context17.next = 8;
            return _awaitAsyncGenerator(itr.next());

          case 8:
            _yield$_awaitAsyncGen = _context17.sent;
            value = _yield$_awaitAsyncGen.value;
            done = _yield$_awaitAsyncGen.done;

            if (!done) {
              _context17.next = 13;
              break;
            }

            return _context17.abrupt("break", 27);

          case 13:
            _context17.prev = 13;
            _context17.next = 16;
            return _awaitAsyncGenerator(value.value);

          case 16:
            val = _context17.sent;

            if (transformError) {
              _context17.next = 20;
              break;
            }

            _context17.next = 20;
            return val;

          case 20:
            _context17.next = 25;
            break;

          case 22:
            _context17.prev = 22;
            _context17.t0 = _context17["catch"](13);
            transformError = _context17.t0;

          case 25:
            _context17.next = 5;
            break;

          case 27:
            if (!transformError) {
              _context17.next = 29;
              break;
            }

            throw transformError;

          case 29:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee14, null, [[13, 22]]);
  }));
  return _parallelMap2.apply(this, arguments);
}

function parallelMap(concurrency, func, iterable) {
  if (func === undefined) {
    return function (curriedFunc, curriedIterable) {
      return parallelMap(concurrency, curriedFunc, curriedIterable);
    };
  }

  if (iterable === undefined) {
    return function (curriedIterable) {
      return parallelMap(concurrency, func, curriedIterable);
    };
  }

  if (concurrency === 1) {
    return map(func, iterable);
  }

  return _parallelMap(concurrency, func, iterable);
}

function parallelFlatMap(concurrency, func, iterable) {
  if (func === undefined) {
    return function (curriedFunc, curriedIterable) {
      return curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);
    };
  }

  if (iterable === undefined) {
    return function (curriedIterable) {
      return parallelFlatMap(concurrency, func, curriedIterable);
    };
  }

  return filter(function (i) {
    return i !== undefined && i !== null;
  }, flatten(parallelMap(concurrency, func, iterable)));
} /// <reference lib="esnext.asynciterable" />


function parallelMerge() {
  return _parallelMerge.apply(this, arguments);
}

function _parallelMerge() {
  _parallelMerge = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
    var _len4,
        iterables,
        _key4,
        inputs,
        concurrentWork,
        values,
        lastError,
        errCb,
        valueCb,
        notifyError,
        notifyDone,
        waitForQueue,
        queueNext,
        _iterator19,
        _step19,
        _input,
        _iterator20,
        _step20,
        _step20$value,
        input,
        value,
        _args19 = arguments;

    return regeneratorRuntime.wrap(function _callee16$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            for (_len4 = _args19.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              iterables[_key4] = _args19[_key4];
            }

            inputs = iterables.map(getIterator);
            concurrentWork = new Set();
            values = new Map();
            lastError = null;
            errCb = null;
            valueCb = null;

            notifyError = function notifyError(err) {
              lastError = err;

              if (errCb) {
                errCb(err);
              }
            };

            notifyDone = function notifyDone(value) {
              if (valueCb) {
                valueCb(value);
              }
            };

            waitForQueue = function waitForQueue() {
              return new Promise(function (resolve, reject) {
                if (lastError) {
                  reject(lastError);
                }

                if (values.size > 0) {
                  return resolve();
                }

                valueCb = resolve;
                errCb = reject;
              });
            };

            queueNext = function queueNext(input) {
              var nextVal = Promise.resolve(input.next()).then( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(_ref2) {
                  var done, value;
                  return regeneratorRuntime.wrap(function _callee15$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          done = _ref2.done, value = _ref2.value;

                          if (!done) {
                            values.set(input, value);
                          }

                          concurrentWork.delete(nextVal);

                        case 3:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee15);
                }));

                return function (_x24) {
                  return _ref3.apply(this, arguments);
                };
              }());
              concurrentWork.add(nextVal);
              nextVal.then(notifyDone, notifyError);
            };

            _iterator19 = _createForOfIteratorHelper(inputs);

            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                _input = _step19.value;
                queueNext(_input);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }

          case 13:
            if (!true) {
              _context19.next = 39;
              break;
            }

            if (!(concurrentWork.size === 0 && values.size === 0)) {
              _context19.next = 16;
              break;
            }

            return _context19.abrupt("return");

          case 16:
            _context19.next = 18;
            return _awaitAsyncGenerator(waitForQueue());

          case 18:
            _iterator20 = _createForOfIteratorHelper(values);
            _context19.prev = 19;

            _iterator20.s();

          case 21:
            if ((_step20 = _iterator20.n()).done) {
              _context19.next = 29;
              break;
            }

            _step20$value = _slicedToArray(_step20.value, 2), input = _step20$value[0], value = _step20$value[1];
            values.delete(input);
            _context19.next = 26;
            return value;

          case 26:
            queueNext(input);

          case 27:
            _context19.next = 21;
            break;

          case 29:
            _context19.next = 34;
            break;

          case 31:
            _context19.prev = 31;
            _context19.t0 = _context19["catch"](19);

            _iterator20.e(_context19.t0);

          case 34:
            _context19.prev = 34;

            _iterator20.f();

            return _context19.finish(34);

          case 37:
            _context19.next = 13;
            break;

          case 39:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee16, null, [[19, 31, 34, 37]]);
  }));
  return _parallelMerge.apply(this, arguments);
}

function _reduce(_x25, _x26, _x27) {
  return _reduce2.apply(this, arguments);
}

function _reduce2() {
  _reduce2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(func, start, iterable) {
    var value, _iteratorAbruptCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, nextItem;

    return regeneratorRuntime.wrap(function _callee26$(_context31) {
      while (1) {
        switch (_context31.prev = _context31.next) {
          case 0:
            value = start;
            _iteratorAbruptCompletion9 = false;
            _didIteratorError9 = false;
            _context31.prev = 3;
            _iterator9 = _asyncIterator(iterable);

          case 5:
            _context31.next = 7;
            return _iterator9.next();

          case 7:
            if (!(_iteratorAbruptCompletion9 = !(_step9 = _context31.sent).done)) {
              _context31.next = 15;
              break;
            }

            nextItem = _step9.value;
            _context31.next = 11;
            return func(value, nextItem);

          case 11:
            value = _context31.sent;

          case 12:
            _iteratorAbruptCompletion9 = false;
            _context31.next = 5;
            break;

          case 15:
            _context31.next = 21;
            break;

          case 17:
            _context31.prev = 17;
            _context31.t0 = _context31["catch"](3);
            _didIteratorError9 = true;
            _iteratorError9 = _context31.t0;

          case 21:
            _context31.prev = 21;
            _context31.prev = 22;

            if (!(_iteratorAbruptCompletion9 && _iterator9.return != null)) {
              _context31.next = 26;
              break;
            }

            _context31.next = 26;
            return _iterator9.return();

          case 26:
            _context31.prev = 26;

            if (!_didIteratorError9) {
              _context31.next = 29;
              break;
            }

            throw _iteratorError9;

          case 29:
            return _context31.finish(26);

          case 30:
            return _context31.finish(21);

          case 31:
            return _context31.abrupt("return", value);

          case 32:
          case "end":
            return _context31.stop();
        }
      }
    }, _callee26, null, [[3, 17, 21, 31], [22,, 26, 30]]);
  }));
  return _reduce2.apply(this, arguments);
}

function reduce(func, start, iterable) {
  if (start === undefined) {
    return function (curriedStart, curriedIterable) {
      return curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);
    };
  }

  if (iterable === undefined) {
    return function (curriedIterable) {
      return reduce(func, start, curriedIterable);
    };
  }

  return _reduce(func, start, iterable);
}

function _take(_x13, _x14) {
  return _take2.apply(this, arguments);
}

function _take2() {
  _take2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(count, iterable) {
    var taken, _iteratorAbruptCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, val;

    return regeneratorRuntime.wrap(function _callee17$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            taken = 0;
            _iteratorAbruptCompletion10 = false;
            _didIteratorError10 = false;
            _context20.prev = 3;
            _iterator10 = _asyncIterator(iterable);

          case 5:
            _context20.next = 7;
            return _awaitAsyncGenerator(_iterator10.next());

          case 7:
            if (!(_iteratorAbruptCompletion10 = !(_step10 = _context20.sent).done)) {
              _context20.next = 17;
              break;
            }

            val = _step10.value;
            _context20.next = 11;
            return val;

          case 11:
            taken++;

            if (!(taken >= count)) {
              _context20.next = 14;
              break;
            }

            return _context20.abrupt("break", 17);

          case 14:
            _iteratorAbruptCompletion10 = false;
            _context20.next = 5;
            break;

          case 17:
            _context20.next = 23;
            break;

          case 19:
            _context20.prev = 19;
            _context20.t0 = _context20["catch"](3);
            _didIteratorError10 = true;
            _iteratorError10 = _context20.t0;

          case 23:
            _context20.prev = 23;
            _context20.prev = 24;

            if (!(_iteratorAbruptCompletion10 && _iterator10.return != null)) {
              _context20.next = 28;
              break;
            }

            _context20.next = 28;
            return _awaitAsyncGenerator(_iterator10.return());

          case 28:
            _context20.prev = 28;

            if (!_didIteratorError10) {
              _context20.next = 31;
              break;
            }

            throw _iteratorError10;

          case 31:
            return _context20.finish(28);

          case 32:
            return _context20.finish(23);

          case 33:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee17, null, [[3, 19, 23, 33], [24,, 28, 32]]);
  }));
  return _take2.apply(this, arguments);
}

function _syncTake(count, iterable) {
  var taken, _iterator21, _step21, val;

  return regeneratorRuntime.wrap(function _syncTake$(_context21) {
    while (1) {
      switch (_context21.prev = _context21.next) {
        case 0:
          taken = 0;
          _iterator21 = _createForOfIteratorHelper(iterable);
          _context21.prev = 2;

          _iterator21.s();

        case 4:
          if ((_step21 = _iterator21.n()).done) {
            _context21.next = 13;
            break;
          }

          val = _step21.value;
          _context21.next = 8;
          return val;

        case 8:
          taken++;

          if (!(taken >= count)) {
            _context21.next = 11;
            break;
          }

          return _context21.abrupt("break", 13);

        case 11:
          _context21.next = 4;
          break;

        case 13:
          _context21.next = 18;
          break;

        case 15:
          _context21.prev = 15;
          _context21.t0 = _context21["catch"](2);

          _iterator21.e(_context21.t0);

        case 18:
          _context21.prev = 18;

          _iterator21.f();

          return _context21.finish(18);

        case 21:
        case "end":
          return _context21.stop();
      }
    }
  }, _marked4, null, [[2, 15, 18, 21]]);
}

function take(count, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return take(count, curriedIterable);
    };
  }

  if (iterable[Symbol.asyncIterator]) {
    return _take(count, iterable);
  }

  return _syncTake(count, iterable);
}

function _asyncTap(_x15, _x16) {
  return _asyncTap2.apply(this, arguments);
}

function _asyncTap2() {
  _asyncTap2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(func, iterable) {
    var _iteratorAbruptCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, val;

    return regeneratorRuntime.wrap(function _callee18$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            _iteratorAbruptCompletion11 = false;
            _didIteratorError11 = false;
            _context22.prev = 2;
            _iterator11 = _asyncIterator(iterable);

          case 4:
            _context22.next = 6;
            return _awaitAsyncGenerator(_iterator11.next());

          case 6:
            if (!(_iteratorAbruptCompletion11 = !(_step11 = _context22.sent).done)) {
              _context22.next = 15;
              break;
            }

            val = _step11.value;
            _context22.next = 10;
            return _awaitAsyncGenerator(func(val));

          case 10:
            _context22.next = 12;
            return val;

          case 12:
            _iteratorAbruptCompletion11 = false;
            _context22.next = 4;
            break;

          case 15:
            _context22.next = 21;
            break;

          case 17:
            _context22.prev = 17;
            _context22.t0 = _context22["catch"](2);
            _didIteratorError11 = true;
            _iteratorError11 = _context22.t0;

          case 21:
            _context22.prev = 21;
            _context22.prev = 22;

            if (!(_iteratorAbruptCompletion11 && _iterator11.return != null)) {
              _context22.next = 26;
              break;
            }

            _context22.next = 26;
            return _awaitAsyncGenerator(_iterator11.return());

          case 26:
            _context22.prev = 26;

            if (!_didIteratorError11) {
              _context22.next = 29;
              break;
            }

            throw _iteratorError11;

          case 29:
            return _context22.finish(26);

          case 30:
            return _context22.finish(21);

          case 31:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee18, null, [[2, 17, 21, 31], [22,, 26, 30]]);
  }));
  return _asyncTap2.apply(this, arguments);
}

function tap(func, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return _asyncTap(func, curriedIterable);
    };
  }

  return _asyncTap(func, iterable);
}

function addTime(a, b) {
  var seconds = a[0] + b[0];
  var nanoseconds = a[1] + b[1];

  if (nanoseconds >= 1000000000) {
    var remainder = nanoseconds % 1000000000;
    seconds += (nanoseconds - remainder) / 1000000000;
    nanoseconds = remainder;
  }

  return [seconds, nanoseconds];
}

function _asyncTime(_x17, _x18) {
  return _asyncTime2.apply(this, arguments);
}

function _asyncTime2() {
  _asyncTime2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(config, iterable) {
    var itr, total, start, _yield$_awaitAsyncGen2, value, done, delta;

    return regeneratorRuntime.wrap(function _callee19$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            itr = iterable[Symbol.asyncIterator]();
            total = [0, 0];

          case 2:
            if (!true) {
              _context23.next = 19;
              break;
            }

            start = process.hrtime();
            _context23.next = 6;
            return _awaitAsyncGenerator(itr.next());

          case 6:
            _yield$_awaitAsyncGen2 = _context23.sent;
            value = _yield$_awaitAsyncGen2.value;
            done = _yield$_awaitAsyncGen2.done;
            delta = process.hrtime(start);
            total = addTime(total, delta);

            if (config.progress) {
              config.progress(delta, total);
            }

            if (!done) {
              _context23.next = 15;
              break;
            }

            if (config.total) {
              config.total(total);
            }

            return _context23.abrupt("return", value);

          case 15:
            _context23.next = 17;
            return value;

          case 17:
            _context23.next = 2;
            break;

          case 19:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee19);
  }));
  return _asyncTime2.apply(this, arguments);
}

function _syncTime(config, iterable) {
  var itr, total, start, _itr$next, value, done, delta;

  return regeneratorRuntime.wrap(function _syncTime$(_context24) {
    while (1) {
      switch (_context24.prev = _context24.next) {
        case 0:
          itr = iterable[Symbol.iterator]();
          total = [0, 0];

        case 2:
          if (!true) {
            _context24.next = 15;
            break;
          }

          start = process.hrtime();
          _itr$next = itr.next(), value = _itr$next.value, done = _itr$next.done;
          delta = process.hrtime(start);
          total = addTime(total, delta);

          if (config.progress) {
            config.progress(delta, total);
          }

          if (!done) {
            _context24.next = 11;
            break;
          }

          if (config.total) {
            config.total(total);
          }

          return _context24.abrupt("return", value);

        case 11:
          _context24.next = 13;
          return value;

        case 13:
          _context24.next = 2;
          break;

        case 15:
        case "end":
          return _context24.stop();
      }
    }
  }, _marked5);
}

function time() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var iterable = arguments.length > 1 ? arguments[1] : undefined;

  if (iterable === undefined) {
    return function (curriedIterable) {
      return time(config, curriedIterable);
    };
  }

  if (iterable[Symbol.asyncIterator] !== undefined) {
    return _asyncTime(config, iterable);
  } else {
    return _syncTime(config, iterable);
  }
}

function _transform(concurrency, func, iterable) {
  var iterator = getIterator(iterable);
  var resultQueue = [];
  var readQueue = [];
  var ended = false;
  var reading = false;
  var inflightCount = 0;
  var lastError = null;

  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      var _readQueue$shift4 = readQueue.shift(),
          resolve = _readQueue$shift4.resolve;

      var value = resultQueue.shift();
      resolve({
        done: false,
        value: value
      });
    }

    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      var _readQueue$shift5 = readQueue.shift(),
          _resolve2 = _readQueue$shift5.resolve,
          reject = _readQueue$shift5.reject;

      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        _resolve2({
          done: true,
          value: undefined
        });
      }
    }
  }

  function fillQueue() {
    return _fillQueue3.apply(this, arguments);
  }

  function _fillQueue3() {
    _fillQueue3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
      var _yield$iterator$next3, done, value;

      return regeneratorRuntime.wrap(function _callee20$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              if (!ended) {
                _context25.next = 3;
                break;
              }

              fulfillReadQueue();
              return _context25.abrupt("return");

            case 3:
              if (!reading) {
                _context25.next = 5;
                break;
              }

              return _context25.abrupt("return");

            case 5:
              if (!(inflightCount + resultQueue.length >= concurrency)) {
                _context25.next = 7;
                break;
              }

              return _context25.abrupt("return");

            case 7:
              reading = true;
              inflightCount++;
              _context25.prev = 9;
              _context25.next = 12;
              return iterator.next();

            case 12:
              _yield$iterator$next3 = _context25.sent;
              done = _yield$iterator$next3.done;
              value = _yield$iterator$next3.value;

              if (done) {
                ended = true;
                inflightCount--;
                fulfillReadQueue();
              } else {
                mapAndQueue(value);
              }

              _context25.next = 24;
              break;

            case 18:
              _context25.prev = 18;
              _context25.t0 = _context25["catch"](9);
              ended = true;
              inflightCount--;
              lastError = _context25.t0;
              fulfillReadQueue();

            case 24:
              reading = false;
              fillQueue();

            case 26:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee20, null, [[9, 18]]);
    }));
    return _fillQueue3.apply(this, arguments);
  }

  function mapAndQueue(_x28) {
    return _mapAndQueue2.apply(this, arguments);
  }

  function _mapAndQueue2() {
    _mapAndQueue2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(itrValue) {
      var value;
      return regeneratorRuntime.wrap(function _callee21$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.prev = 0;
              _context26.next = 3;
              return func(itrValue);

            case 3:
              value = _context26.sent;
              resultQueue.push(value);
              _context26.next = 11;
              break;

            case 7:
              _context26.prev = 7;
              _context26.t0 = _context26["catch"](0);
              ended = true;
              lastError = _context26.t0;

            case 11:
              inflightCount--;
              fulfillReadQueue();
              fillQueue();

            case 14:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee21, null, [[0, 7]]);
    }));
    return _mapAndQueue2.apply(this, arguments);
  }

  function next() {
    return _next4.apply(this, arguments);
  }

  function _next4() {
    _next4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
      var deferred, value;
      return regeneratorRuntime.wrap(function _callee22$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              if (!(resultQueue.length === 0)) {
                _context27.next = 5;
                break;
              }

              deferred = defer();
              readQueue.push(deferred);
              fillQueue();
              return _context27.abrupt("return", deferred.promise);

            case 5:
              value = resultQueue.shift();
              fillQueue();
              return _context27.abrupt("return", {
                done: false,
                value: value
              });

            case 8:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee22);
    }));
    return _next4.apply(this, arguments);
  }

  var asyncIterableIterator = _defineProperty({
    next: next
  }, Symbol.asyncIterator, function () {
    return asyncIterableIterator;
  });

  return asyncIterableIterator;
}

function transform(concurrency, func, iterable) {
  if (func === undefined) {
    return function (curriedFunc, curriedIterable) {
      return curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
    };
  }

  if (iterable === undefined) {
    return function (curriedIterable) {
      return transform(concurrency, func, curriedIterable);
    };
  }

  return _transform(concurrency, func, iterable);
}

function _writeToStream(_x29, _x30) {
  return _writeToStream2.apply(this, arguments);
}

function _writeToStream2() {
  _writeToStream2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(stream, iterable) {
    var lastError, errCb, drainCb, notifyError, notifyDrain, cleanup, waitForDrain, _iteratorAbruptCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, value;

    return regeneratorRuntime.wrap(function _callee27$(_context32) {
      while (1) {
        switch (_context32.prev = _context32.next) {
          case 0:
            lastError = null;
            errCb = null;
            drainCb = null;

            notifyError = function notifyError(err) {
              lastError = err;

              if (errCb) {
                errCb(err);
              }
            };

            notifyDrain = function notifyDrain() {
              if (drainCb) {
                drainCb();
              }
            };

            cleanup = function cleanup() {
              stream.removeListener('error', notifyError);
              stream.removeListener('drain', notifyDrain);
            };

            stream.once('error', notifyError);

            waitForDrain = function waitForDrain() {
              return new Promise(function (resolve, reject) {
                if (lastError) {
                  return reject(lastError);
                }

                stream.once('drain', notifyDrain);
                drainCb = resolve;
                errCb = reject;
              });
            };

            _iteratorAbruptCompletion12 = false;
            _didIteratorError12 = false;
            _context32.prev = 10;
            _iterator12 = _asyncIterator(iterable);

          case 12:
            _context32.next = 14;
            return _iterator12.next();

          case 14:
            if (!(_iteratorAbruptCompletion12 = !(_step12 = _context32.sent).done)) {
              _context32.next = 24;
              break;
            }

            value = _step12.value;

            if (!(stream.write(value) === false)) {
              _context32.next = 19;
              break;
            }

            _context32.next = 19;
            return waitForDrain();

          case 19:
            if (!lastError) {
              _context32.next = 21;
              break;
            }

            return _context32.abrupt("break", 24);

          case 21:
            _iteratorAbruptCompletion12 = false;
            _context32.next = 12;
            break;

          case 24:
            _context32.next = 30;
            break;

          case 26:
            _context32.prev = 26;
            _context32.t0 = _context32["catch"](10);
            _didIteratorError12 = true;
            _iteratorError12 = _context32.t0;

          case 30:
            _context32.prev = 30;
            _context32.prev = 31;

            if (!(_iteratorAbruptCompletion12 && _iterator12.return != null)) {
              _context32.next = 35;
              break;
            }

            _context32.next = 35;
            return _iterator12.return();

          case 35:
            _context32.prev = 35;

            if (!_didIteratorError12) {
              _context32.next = 38;
              break;
            }

            throw _iteratorError12;

          case 38:
            return _context32.finish(35);

          case 39:
            return _context32.finish(30);

          case 40:
            cleanup();

            if (!lastError) {
              _context32.next = 43;
              break;
            }

            throw lastError;

          case 43:
          case "end":
            return _context32.stop();
        }
      }
    }, _callee27, null, [[10, 26, 30, 40], [31,, 35, 39]]);
  }));
  return _writeToStream2.apply(this, arguments);
}

function writeToStream(stream, iterable) {
  if (iterable === undefined) {
    return function (curriedIterable) {
      return _writeToStream(stream, curriedIterable);
    };
  }

  return _writeToStream(stream, iterable);
}
},{"process":"node_modules/process/browser.js"}],"node_modules/hashlru/index.js":[function(require,module,exports) {
module.exports = function (max) {

  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')

  var size = 0, cache = Object.create(null), _cache = Object.create(null)

  function update (key, value) {
    cache[key] = value
    size ++
    if(size >= max) {
      size = 0
      _cache = cache
      cache = Object.create(null)
    }
  }

  return {
    has: function (key) {
      return cache[key] !== undefined || _cache[key] !== undefined
    },
    remove: function (key) {
      if(cache[key] !== undefined)
        cache[key] = undefined
      if(_cache[key] !== undefined)
        _cache[key] = undefined
    },
    get: function (key) {
      var v = cache[key]
      if(v !== undefined) return v
      if((v = _cache[key]) !== undefined) {
        update(key, v)
        return v
      }
    },
    set: function (key, value) {
      if(cache[key] !== undefined) cache[key] = value
      else update(key, value)
    },
    clear: function () {
      cache = Object.create(null)
      _cache = Object.create(null)
    }
  }
}








},{}],"node_modules/libp2p/src/metrics/old-peers.js":[function(require,module,exports) {
'use strict';

var LRU = require('hashlru');
/**
 * Creates and returns a Least Recently Used Cache
 *
 * @param {number} maxSize
 * @returns {any}
 */


module.exports = function (maxSize) {
  // @ts-ignore LRU expression is not callable
  var patched = LRU(maxSize);
  patched.delete = patched.remove;
  return patched;
};
},{"hashlru":"node_modules/hashlru/index.js"}],"node_modules/bignumber.js/bignumber.js":[function(require,module,exports) {
var define;
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

},{}],"node_modules/@vascosantos/moving-average/index.js":[function(require,module,exports) {
'use strict'

const exp = Math.exp

exports =
module.exports =
function MovingAverage (timespan) {
  if (typeof timespan !== 'number') { throw new Error('must provide a timespan to the moving average constructor') }

  if (timespan <= 0) { throw new Error('must provide a timespan > 0 to the moving average constructor') }

  let ma     // moving average
  let v = 0  // variance
  let d = 0  // deviation
  let f = 0  // forecast

  let previousTime

  let ret = {}

  function alpha (t, pt) {
    return 1 - (exp(-(t - pt) / timespan))
  }

  ret.push =
  function push (time, value) {
    if (previousTime) {
      // calculate moving average
      const a = alpha(time, previousTime)
      const diff = value - ma
      const incr = a * diff
      ma = a * value + (1 - a) * ma
      // calculate variance & deviation
      v = (1 - a) * (v + diff * incr)
      d = Math.sqrt(v)
      // calculate forecast
      f = ma + a * diff
    } else {
      ma = value
    }
    previousTime = time
  }

  // Exponential Moving Average

  ret.movingAverage =
  function movingAverage () {
    return ma
  }

  // Variance
  ret.variance =
  function variance () {
    return v
  }

  ret.deviation =
  function deviation () {
    return d
  }

  ret.forecast =
  function forecast () {
    return f
  }

  return ret
}

},{}],"node_modules/libp2p/src/metrics/stats.js":[function(require,module,exports) {
// @ts-nocheck
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require2 = require('bignumber.js'),
    Big = _require2.BigNumber;

var MovingAverage = require('@vascosantos/moving-average');

var retimer = require('retimer');
/**
 * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage
 */


var Stats = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Stats, _EventEmitter);

  var _super = _createSuper(Stats);

  /**
   * A queue based manager for stat processing
   *
   * @class
   * @param {string[]} initialCounters
   * @param {any} options
   */
  function Stats(initialCounters, options) {
    var _this;

    _classCallCheck(this, Stats);

    _this = _super.call(this);
    _this._options = options;
    _this._queue = [];
    /** @type {{ dataReceived: Big, dataSent: Big }} */

    _this._stats = {
      dataReceived: Big(0),
      dataSent: Big(0)
    };
    _this._frequencyLastTime = Date.now();
    _this._frequencyAccumulators = {};
    /** @type {{ dataReceived: IMovingAverage[], dataSent: IMovingAverage[] }} */

    _this._movingAverages = {};
    _this._update = _this._update.bind(_assertThisInitialized(_this));
    var intervals = _this._options.movingAverageIntervals;

    for (var i = 0; i < initialCounters.length; i++) {
      var key = initialCounters[i];
      _this._stats[key] = Big(0);
      _this._movingAverages[key] = {};

      for (var k = 0; k < intervals.length; k++) {
        var interval = intervals[k];
        var ma = _this._movingAverages[key][interval] = MovingAverage(interval);
        ma.push(_this._frequencyLastTime, 0);
      }
    }

    return _this;
  }
  /**
   * Initializes the internal timer if there are items in the queue. This
   * should only need to be called if `Stats.stop` was previously called, as
   * `Stats.push` will also start the processing.
   *
   * @returns {void}
   */


  _createClass(Stats, [{
    key: "start",
    value: function start() {
      if (this._queue.length) {
        this._resetComputeTimeout();
      }
    }
    /**
     * Stops processing and computing of stats by clearing the internal
     * timer.
     *
     * @returns {void}
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._timeout) {
        this._timeout.clear();

        this._timeout = null;
      }
    }
    /**
     * Returns a clone of the current stats.
     */

  }, {
    key: "snapshot",
    get: function get() {
      return Object.assign({}, this._stats);
    }
    /**
     * Returns a clone of the internal movingAverages
     */

  }, {
    key: "movingAverages",
    get: function get() {
      return Object.assign({}, this._movingAverages);
    }
    /**
     * Returns a plain JSON object of the stats
     *
     * @returns {*}
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var snapshot = this.snapshot;
      var movingAverages = this.movingAverages;
      var data = {
        dataReceived: snapshot.dataReceived.toString(),
        dataSent: snapshot.dataSent.toString(),
        movingAverages: {}
      };
      var counters = Object.keys(movingAverages);

      for (var _i = 0, _counters = counters; _i < _counters.length; _i++) {
        var key = _counters[_i];
        data.movingAverages[key] = {};

        for (var _i2 = 0, _Object$keys = Object.keys(movingAverages[key]); _i2 < _Object$keys.length; _i2++) {
          var interval = _Object$keys[_i2];
          data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();
        }
      }

      return data;
    }
    /**
     * Pushes the given operation data to the queue, along with the
     * current Timestamp, then resets the update timer.
     *
     * @param {string} counter
     * @param {number} inc
     * @returns {void}
     */

  }, {
    key: "push",
    value: function push(counter, inc) {
      this._queue.push([counter, inc, Date.now()]);

      this._resetComputeTimeout();
    }
    /**
     * Resets the timeout for triggering updates.
     *
     * @private
     * @returns {void}
     */

  }, {
    key: "_resetComputeTimeout",
    value: function _resetComputeTimeout() {
      this._timeout = retimer(this._update, this._nextTimeout());
    }
    /**
     * Calculates and returns the timeout for the next update based on
     * the urgency of the update.
     *
     * @private
     * @returns {number}
     */

  }, {
    key: "_nextTimeout",
    value: function _nextTimeout() {
      // calculate the need for an update, depending on the queue length
      var urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
      var timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
      return timeout;
    }
    /**
     * If there are items in the queue, they will will be processed and
     * the frequency for all items will be updated based on the Timestamp
     * of the last item in the queue. The `update` event will also be emitted
     * with the latest stats.
     *
     * If there are no items in the queue, no action is taken.
     *
     * @private
     * @returns {void}
     */

  }, {
    key: "_update",
    value: function _update() {
      this._timeout = null;

      if (this._queue.length) {
        var last;

        var _iterator = _createForOfIteratorHelper(this._queue),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            last = _step.value;

            this._applyOp(last);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this._queue = [];

        this._updateFrequency(last[2]); // contains timestamp of last op


        this.emit('update', this._stats);
      }
    }
    /**
     * For each key in the stats, the frequency and moving averages
     * will be updated via Stats._updateFrequencyFor based on the time
     * difference between calls to this method.
     *
     * @private
     * @param {Timestamp} latestTime
     * @returns {void}
     */

  }, {
    key: "_updateFrequency",
    value: function _updateFrequency(latestTime) {
      var _this2 = this;

      var timeDiff = latestTime - this._frequencyLastTime;
      Object.keys(this._stats).forEach(function (key) {
        _this2._updateFrequencyFor(key, timeDiff, latestTime);
      });
      this._frequencyLastTime = latestTime;
    }
    /**
     * Updates the `movingAverages` for the given `key` and also
     * resets the `frequencyAccumulator` for the `key`.
     *
     * @private
     * @param {string} key
     * @param {number} timeDiffMS - Time in milliseconds
     * @param {Timestamp} latestTime - Time in ticks
     * @returns {void}
     */

  }, {
    key: "_updateFrequencyFor",
    value: function _updateFrequencyFor(key, timeDiffMS, latestTime) {
      var count = this._frequencyAccumulators[key] || 0;
      this._frequencyAccumulators[key] = 0; // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms

      var safeTimeDiff = timeDiffMS || 1;
      var hz = count / safeTimeDiff * 1000;
      var movingAverages = this._movingAverages[key];

      if (!movingAverages) {
        movingAverages = this._movingAverages[key] = {};
      }

      var intervals = this._options.movingAverageIntervals;

      for (var i = 0; i < intervals.length; i++) {
        var movingAverageInterval = intervals[i];
        var movingAverage = movingAverages[movingAverageInterval];

        if (!movingAverage) {
          movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);
        }

        movingAverage.push(latestTime, hz);
      }
    }
    /**
     * For the given operation, `op`, the stats and `frequencyAccumulator`
     * will be updated or initialized if they don't already exist.
     *
     * @private
     * @param {{string, number}[]} op
     * @throws {InvalidNumber}
     * @returns {void}
     */

  }, {
    key: "_applyOp",
    value: function _applyOp(op) {
      var key = op[0];
      var inc = op[1];

      if (typeof inc !== 'number') {
        throw new Error("invalid increment number: ".concat(inc));
      }

      var n;

      if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
        n = this._stats[key] = Big(0);
      } else {
        n = this._stats[key];
      }

      this._stats[key] = n.plus(inc);

      if (!this._frequencyAccumulators[key]) {
        this._frequencyAccumulators[key] = 0;
      }

      this._frequencyAccumulators[key] += inc;
    }
  }]);

  return Stats;
}(EventEmitter);

module.exports = Stats;
},{"events":"node_modules/events/events.js","bignumber.js":"node_modules/bignumber.js/bignumber.js","@vascosantos/moving-average":"node_modules/@vascosantos/moving-average/index.js","retimer":"node_modules/retimer/retimer.js"}],"node_modules/libp2p/src/metrics/index.js":[function(require,module,exports) {
// @ts-nocheck
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var mergeOptions = require('merge-options');

var _require = require('it-pipe'),
    pipe = _require.pipe;

var _require2 = require('streaming-iterables'),
    tap = _require2.tap;

var oldPeerLRU = require('./old-peers');

var _require3 = require('../constants'),
    defaultOptions = _require3.METRICS;

var Stats = require('./stats');

var initialCounters = ['dataReceived', 'dataSent'];
var directionToEvent = {
  in: 'dataReceived',
  out: 'dataSent'
};
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection
 */

/**
 * @typedef MetricsProperties
 * @property {import('../connection-manager')} connectionManager
 *
 * @typedef MetricsOptions
 * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]
 * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]
 * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]
 * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]
 */

var Metrics = /*#__PURE__*/function () {
  /**
   * @class
   * @param {MetricsProperties & MetricsOptions} options
   */
  function Metrics(options) {
    var _this = this;

    _classCallCheck(this, Metrics);

    this._options = mergeOptions(defaultOptions, options);
    this._globalStats = new Stats(initialCounters, this._options);
    this._peerStats = new Map();
    this._protocolStats = new Map();
    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);
    this._running = false;
    this._onMessage = this._onMessage.bind(this);
    this._connectionManager = options.connectionManager;

    this._connectionManager.on('peer:disconnect', function (connection) {
      _this.onPeerDisconnected(connection.remotePeer);
    });
  }
  /**
   * Must be called for stats to saved. Any data pushed for tracking
   * will be ignored.
   */


  _createClass(Metrics, [{
    key: "start",
    value: function start() {
      this._running = true;
    }
    /**
     * Stops all averages timers and prevents new data from being tracked.
     * Once `stop` is called, `start` must be called to resume stats tracking.
     */

  }, {
    key: "stop",
    value: function stop() {
      this._running = false;

      this._globalStats.stop();

      var _iterator = _createForOfIteratorHelper(this._peerStats.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var stats = _step.value;
          stats.stop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(this._protocolStats.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _stats = _step2.value;

          _stats.stop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Gets the global `Stats` object
     *
     * @returns {Stats}
     */

  }, {
    key: "global",
    get: function get() {
      return this._globalStats;
    }
    /**
     * Returns a list of `PeerId` strings currently being tracked
     *
     * @returns {string[]}
     */

  }, {
    key: "peers",
    get: function get() {
      return Array.from(this._peerStats.keys());
    }
    /**
     * Returns the `Stats` object for the given `PeerId` whether it
     * is a live peer, or in the disconnected peer LRU cache.
     *
     * @param {PeerId} peerId
     * @returns {Stats}
     */

  }, {
    key: "forPeer",
    value: function forPeer(peerId) {
      var idString = peerId.toB58String();
      return this._peerStats.get(idString) || this._oldPeers.get(idString);
    }
    /**
     * Returns a list of all protocol strings currently being tracked.
     *
     * @returns {string[]}
     */

  }, {
    key: "protocols",
    get: function get() {
      return Array.from(this._protocolStats.keys());
    }
    /**
     * Returns the `Stats` object for the given `protocol`.
     *
     * @param {string} protocol
     * @returns {Stats}
     */

  }, {
    key: "forProtocol",
    value: function forProtocol(protocol) {
      return this._protocolStats.get(protocol);
    }
    /**
     * Should be called when all connections to a given peer
     * have closed. The `Stats` collection for the peer will
     * be stopped and moved to an LRU for temporary retention.
     *
     * @param {PeerId} peerId
     */

  }, {
    key: "onPeerDisconnected",
    value: function onPeerDisconnected(peerId) {
      var idString = peerId.toB58String();

      var peerStats = this._peerStats.get(idString);

      if (peerStats) {
        peerStats.stop();

        this._peerStats.delete(idString);

        this._oldPeers.set(idString, peerStats);
      }
    }
    /**
     * Takes the metadata for a message and tracks it in the
     * appropriate categories. If the protocol is present, protocol
     * stats will also be tracked.
     *
     * @private
     * @param {object} params
     * @param {PeerId} params.remotePeer - Remote peer
     * @param {string} [params.protocol] - Protocol string the stream is running
     * @param {string} params.direction - One of ['in','out']
     * @param {number} params.dataLength - Size of the message
     * @returns {void}
     */

  }, {
    key: "_onMessage",
    value: function _onMessage(_ref) {
      var remotePeer = _ref.remotePeer,
          protocol = _ref.protocol,
          direction = _ref.direction,
          dataLength = _ref.dataLength;
      if (!this._running) return;
      var key = directionToEvent[direction];
      var peerStats = this.forPeer(remotePeer);

      if (!peerStats) {
        peerStats = new Stats(initialCounters, this._options);

        this._peerStats.set(remotePeer.toB58String(), peerStats);
      } // Peer and global stats


      peerStats.push(key, dataLength);

      this._globalStats.push(key, dataLength); // Protocol specific stats


      if (protocol) {
        var protocolStats = this.forProtocol(protocol);

        if (!protocolStats) {
          protocolStats = new Stats(initialCounters, this._options);

          this._protocolStats.set(protocol, protocolStats);
        }

        protocolStats.push(key, dataLength);
      }
    }
    /**
     * Replaces the `PeerId` string with the given `peerId`.
     * If stats are already being tracked for the given `peerId`, the
     * placeholder stats will be merged with the existing stats.
     *
     * @param {PeerId} placeholder - A peerId string
     * @param {PeerId} peerId
     * @returns {void}
     */

  }, {
    key: "updatePlaceholder",
    value: function updatePlaceholder(placeholder, peerId) {
      if (!this._running) return;
      var placeholderStats = this.forPeer(placeholder);
      var peerIdString = peerId.toB58String();
      var existingStats = this.forPeer(peerId);
      var mergedStats = placeholderStats; // If we already have stats, merge the two

      if (existingStats) {
        // If existing, merge
        mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there

        this._oldPeers.delete(peerIdString);
      }

      this._peerStats.delete(placeholder.toB58String());

      this._peerStats.set(peerIdString, mergedStats);

      mergedStats.start();
    }
    /**
     * Tracks data running through a given Duplex Iterable `stream`. If
     * the `peerId` is not provided, a placeholder string will be created and
     * returned. This allows lazy tracking of a peer when the peer is not yet known.
     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called
     * with the placeholder string returned from here, and the known `PeerId`.
     *
     * @param {Object} options
     * @param {MultiaddrConnection} options.stream - A duplex iterable stream
     * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected
     * @param {string} [options.protocol] - The protocol the stream is running
     * @returns {MultiaddrConnection} The peerId string or placeholder string
     */

  }, {
    key: "trackStream",
    value: function trackStream(_ref2) {
      var stream = _ref2.stream,
          remotePeer = _ref2.remotePeer,
          protocol = _ref2.protocol;
      var metrics = this;
      var _source = stream.source;
      stream.source = tap(function (chunk) {
        return metrics._onMessage({
          remotePeer: remotePeer,
          protocol: protocol,
          direction: 'in',
          dataLength: chunk.length
        });
      })(_source);
      var _sink = stream.sink;

      stream.sink = function (source) {
        return pipe(source, tap(function (chunk) {
          return metrics._onMessage({
            remotePeer: remotePeer,
            protocol: protocol,
            direction: 'out',
            dataLength: chunk.length
          });
        }), _sink);
      };

      return stream;
    }
    /**
     * Merges `other` into `target`. `target` will be modified
     * and returned.
     *
     * @param {Stats} target
     * @param {Stats} other
     * @returns {Stats}
     */

  }], [{
    key: "mergeStats",
    value: function mergeStats(target, other) {
      target.stop();
      other.stop(); // Merge queues

      target._queue = [].concat(_toConsumableArray(target._queue), _toConsumableArray(other._queue)); // TODO: how to merge moving averages?

      return target;
    }
  }]);

  return Metrics;
}();

module.exports = Metrics;
},{"merge-options":"node_modules/merge-options/index.js","it-pipe":"node_modules/it-pipe/index.js","streaming-iterables":"node_modules/streaming-iterables/dist/index.mjs","./old-peers":"node_modules/libp2p/src/metrics/old-peers.js","../constants":"node_modules/libp2p/src/constants.js","./stats":"node_modules/libp2p/src/metrics/stats.js"}],"node_modules/multistream-select/src/multistream.js":[function(require,module,exports) {
'use strict'

const BufferList = require('bl/BufferList')
const lp = require('it-length-prefixed')
const pipe = require('it-pipe')
const errCode = require('err-code')
const uint8ArrayFromString = require('uint8arrays/from-string')
const first = require('it-first')

const NewLine = uint8ArrayFromString('\n')

exports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine]))

// `write` encodes and writes a single buffer
exports.write = (writer, buffer) => writer.push(exports.encode(buffer))

// `writeAll` behaves like `write`, except it encodes an array of items as a single write
exports.writeAll = (writer, buffers) => {
  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()))
}

exports.read = async reader => {
  let byteLength = 1 // Read single byte chunks until the length is known
  const varByteSource = { // No return impl - we want the reader to remain readable
    [Symbol.asyncIterator] () { return this },
    next: () => reader.next(byteLength)
  }

  // Once the length has been parsed, read chunk for that length
  const onLength = l => { byteLength = l }
  const buf = await pipe(varByteSource, lp.decode({ onLength }), first)

  if (buf.get(buf.length - 1) !== NewLine[0]) {
    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')
  }

  return buf.shallowSlice(0, -1) // Remove newline
}

},{"bl/BufferList":"node_modules/bl/BufferList.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","it-pipe":"node_modules/it-pipe/index.js","err-code":"node_modules/err-code/index.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","it-first":"node_modules/it-first/index.js"}],"node_modules/multistream-select/src/select.js":[function(require,module,exports) {
'use strict'

const log = require('debug')('mss:select')
const errCode = require('err-code')
const multistream = require('./multistream')
const handshake = require('it-handshake')

module.exports = async (stream, protocols, protocolId) => {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]
  const { reader, writer, rest, stream: shakeStream } = handshake(stream)

  const protocol = protocols.shift()
  if (protocolId) {
    log('select: write ["%s", "%s"]', protocolId, protocol)
    multistream.writeAll(writer, [protocolId, protocol])
  } else {
    log('select: write "%s"', protocol)
    multistream.write(writer, protocol)
  }

  let response = (await multistream.read(reader)).toString()
  log('select: read "%s"', response)

  // Read the protocol response if we got the protocolId in return
  if (response === protocolId) {
    response = (await multistream.read(reader)).toString()
    log('select: read "%s"', response)
  }

  // We're done
  if (response === protocol) {
    rest()
    return { stream: shakeStream, protocol }
  }

  // We haven't gotten a valid ack, try the other protocols
  for (const protocol of protocols) {
    log('select: write "%s"', protocol)
    multistream.write(writer, protocol)
    const response = (await multistream.read(reader)).toString()
    log('select: read "%s" for "%s"', response, protocol)

    if (response === protocol) {
      rest() // End our writer so others can start writing to stream
      return { stream: shakeStream, protocol }
    }
  }

  rest()
  throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL')
}

},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","./multistream":"node_modules/multistream-select/src/multistream.js","it-handshake":"node_modules/it-handshake/src/index.js"}],"node_modules/multistream-select/src/constants.js":[function(require,module,exports) {
'use strict'

exports.PROTOCOL_ID = '/multistream/1.0.0'

},{}],"node_modules/multistream-select/src/handle.js":[function(require,module,exports) {
'use strict'

const log = require('debug')('mss:handle')
const BufferList = require('bl/BufferList')
const multistream = require('./multistream')
const handshake = require('it-handshake')
const { PROTOCOL_ID } = require('./constants')

module.exports = async (stream, protocols) => {
  protocols = Array.isArray(protocols) ? protocols : [protocols]
  const { writer, reader, rest, stream: shakeStream } = handshake(stream)

  while (true) {
    const protocol = (await multistream.read(reader)).toString()
    log('read "%s"', protocol)

    if (protocol === PROTOCOL_ID) {
      log('respond with "%s" for "%s"', PROTOCOL_ID, protocol)
      multistream.write(writer, PROTOCOL_ID)
      continue
    }

    if (protocols.includes(protocol)) {
      multistream.write(writer, protocol)
      log('respond with "%s" for "%s"', protocol, protocol)
      rest()
      return { stream: shakeStream, protocol }
    }

    if (protocol === 'ls') {
      // <varint-msg-len><varint-proto-name-len><proto-name>\n<varint-proto-name-len><proto-name>\n\n
      multistream.write(writer, new BufferList(
        protocols.map(p => multistream.encode(p))
      ))
      log('respond with "%s" for %s', protocols, protocol)
      continue
    }

    multistream.write(writer, 'na')
    log('respond with "na" for "%s"', protocol)
  }
}

},{"debug":"node_modules/debug/src/browser.js","bl/BufferList":"node_modules/bl/BufferList.js","./multistream":"node_modules/multistream-select/src/multistream.js","it-handshake":"node_modules/it-handshake/src/index.js","./constants":"node_modules/multistream-select/src/constants.js"}],"node_modules/multistream-select/src/ls.js":[function(require,module,exports) {
'use strict'

const Reader = require('it-reader')
const log = require('debug')('it-multistream-select:ls')
const multistream = require('./multistream')
const handshake = require('it-handshake')
const lp = require('it-length-prefixed')
const pipe = require('it-pipe')

module.exports = async stream => {
  const { reader, writer, rest, stream: shakeStream } = handshake(stream)

  log('write "ls"')
  multistream.write(writer, 'ls')
  rest()

  // Next message from remote will be (e.g. for 2 protocols):
  // <varint-msg-len><varint-proto-name-len><proto-name>\n<varint-proto-name-len><proto-name>\n
  const res = await multistream.read(reader)

  // After reading response we have:
  // <varint-proto-name-len><proto-name>\n<varint-proto-name-len><proto-name>\n
  const protocolsReader = Reader([res])
  const protocols = []

  // Decode each of the protocols from the reader
  await pipe(
    protocolsReader,
    lp.decode(),
    async source => {
      for await (const protocol of source) {
        // Remove the newline
        protocols.push(protocol.shallowSlice(0, -1).toString())
      }
    }
  )

  return { stream: shakeStream, protocols }
}

},{"it-reader":"node_modules/it-reader/index.js","debug":"node_modules/debug/src/browser.js","./multistream":"node_modules/multistream-select/src/multistream.js","it-handshake":"node_modules/it-handshake/src/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","it-pipe":"node_modules/it-pipe/index.js"}],"node_modules/multistream-select/src/index.js":[function(require,module,exports) {
'use strict'

const select = require('./select')
const handle = require('./handle')
const ls = require('./ls')
const { PROTOCOL_ID } = require('./constants')

exports.PROTOCOL_ID = PROTOCOL_ID

class MultistreamSelect {
  constructor (stream) {
    this._stream = stream
    this._shaken = false
  }

  // Perform the multistream-select handshake
  async _handshake () {
    if (this._shaken) return
    const { stream } = await select(this._stream, PROTOCOL_ID)
    this._stream = stream
    this._shaken = true
  }
}

class Dialer extends MultistreamSelect {
  select (protocols) {
    return select(this._stream, protocols, this._shaken ? null : PROTOCOL_ID)
  }

  async ls () {
    await this._handshake()
    const { stream, protocols } = await ls(this._stream)
    this._stream = stream
    return protocols
  }
}

exports.Dialer = Dialer

class Listener extends MultistreamSelect {
  handle (protocols) {
    return handle(this._stream, protocols)
  }
}

exports.Listener = Listener

},{"./select":"node_modules/multistream-select/src/select.js","./handle":"node_modules/multistream-select/src/handle.js","./ls":"node_modules/multistream-select/src/ls.js","./constants":"node_modules/multistream-select/src/constants.js"}],"node_modules/libp2p-interfaces/src/connection/status.js":[function(require,module,exports) {
'use strict'

const STATUS = {
  OPEN: /** @type {'open'} */('open'),
  CLOSING: /** @type {'closing'} */('closing'),
  CLOSED: /** @type {'closed'} */('closed')
}
module.exports = STATUS

/**
 * @typedef {STATUS[keyof STATUS]} Status
 */

},{}],"node_modules/libp2p-interfaces/src/connection/connection.js":[function(require,module,exports) {
'use strict'

const PeerId = require('peer-id')
const { Multiaddr } = require('multiaddr')
const errCode = require('err-code')
const { OPEN, CLOSING, CLOSED } = require('./status')

const connectionSymbol = Symbol.for('@libp2p/interface-connection/connection')

/**
 * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('./status').Status} Status
 */

/**
 * @typedef {Object} Timeline
 * @property {number} open - connection opening timestamp.
 * @property {number} [upgraded] - connection upgraded timestamp.
 * @property {number} [close]
 *
 * @typedef {Object} ConectionStat
 * @property {'inbound' | 'outbound'} direction - connection establishment direction
 * @property {Timeline} timeline - connection relevant events timestamp.
 * @property {string} [multiplexer] - connection multiplexing identifier.
 * @property {string} [encryption] - connection encryption method identifier.
 *
 * @typedef {(protocols: string|string[]) => Promise<{stream: MuxedStream, protocol: string}>} CreatedMuxedStream
 *
 * @typedef {Object} ConnectionOptions
 * @property {Multiaddr} [localAddr] - local multiaddr of the connection if known.
 * @property {Multiaddr} remoteAddr - remote multiaddr of the connection.
 * @property {PeerId} localPeer - local peer-id.
 * @property {PeerId} remotePeer - remote peer-id.
 * @property {CreatedMuxedStream} newStream - new stream muxer function.
 * @property {() => Promise<void>} close - close raw connection function.
 * @property {() => MuxedStream[]} getStreams - get streams from muxer function.
 * @property {ConectionStat} stat - metadata of the connection.
 *
 * @typedef {Object} StreamData
 * @property {string} protocol - the protocol used by the stream
 * @property {Object} [metadata] - metadata of the stream
 */

/**
 * An implementation of the js-libp2p connection.
 * Any libp2p transport should use an upgrader to return this connection.
 */
class Connection {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   *
   * @class
   * @param {ConnectionOptions} options
   */
  constructor ({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {
    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat)

    /**
     * Connection identifier.
     */
    this.id = (parseInt(String(Math.random() * 1e9))).toString(36) + Date.now()

    /**
     * Observed multiaddr of the local peer
     */
    this.localAddr = localAddr

    /**
     * Observed multiaddr of the remote peer
     */
    this.remoteAddr = remoteAddr

    /**
     * Local peer id.
     */
    this.localPeer = localPeer

    /**
     * Remote peer id.
     */
    this.remotePeer = remotePeer

    /**
     * Connection metadata.
     *
     * @type {ConectionStat & {status: Status}}
     */
    this._stat = {
      ...stat,
      status: OPEN
    }

    /**
     * Reference to the new stream function of the multiplexer
     */
    this._newStream = newStream

    /**
     * Reference to the close function of the raw connection
     */
    this._close = close

    /**
     * Reference to the getStreams function of the muxer
     */
    this._getStreams = getStreams

    /**
     * Connection streams registry
     */
    this.registry = new Map()

    /**
     * User provided tags
     *
     * @type {string[]}
     */
    this.tags = []
  }

  get [Symbol.toStringTag] () {
    return 'Connection'
  }

  get [connectionSymbol] () {
    return true
  }

  /**
   * Checks if the given value is a `Connection` instance.
   *
   * @param {any} other
   * @returns {other is Connection}
   */
  static isConnection (other) {
    return Boolean(other && other[connectionSymbol])
  }

  /**
   * Get connection metadata
   *
   * @this {Connection}
   */
  get stat () {
    return this._stat
  }

  /**
   * Get all the streams of the muxer.
   *
   * @this {Connection}
   */
  get streams () {
    return this._getStreams()
  }

  /**
   * Create a new stream from this connection
   *
   * @param {string|string[]} protocols - intended protocol for the stream
   * @returns {Promise<{stream: MuxedStream, protocol: string}>} with muxed+multistream-selected stream and selected protocol
   */
  async newStream (protocols) {
    if (this.stat.status === CLOSING) {
      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')
    }

    if (this.stat.status === CLOSED) {
      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')
    }

    if (!Array.isArray(protocols)) protocols = [protocols]

    const { stream, protocol } = await this._newStream(protocols)

    this.addStream(stream, { protocol })

    return {
      stream,
      protocol
    }
  }

  /**
   * Add a stream when it is opened to the registry.
   *
   * @param {MuxedStream} muxedStream - a muxed stream
   * @param {StreamData} data - the stream data to be registered
   * @returns {void}
   */
  addStream (muxedStream, { protocol, metadata = {} }) {
    // Add metadata for the stream
    this.registry.set(muxedStream.id, {
      protocol,
      ...metadata
    })
  }

  /**
   * Remove stream registry after it is closed.
   *
   * @param {string} id - identifier of the stream
   */
  removeStream (id) {
    this.registry.delete(id)
  }

  /**
   * Close the connection.
   *
   * @returns {Promise<void>}
   */
  async close () {
    if (this.stat.status === CLOSED) {
      return
    }

    if (this._closing) {
      return this._closing
    }

    this.stat.status = CLOSING

    // Close raw connection
    this._closing = await this._close()

    this._stat.timeline.close = Date.now()
    this.stat.status = CLOSED
  }
}

module.exports = Connection

/**
 * @param {Multiaddr|undefined} localAddr
 * @param {PeerId} localPeer
 * @param {PeerId} remotePeer
 * @param {(protocols: string | string[]) => Promise<{ stream: import("../stream-muxer/types").MuxedStream; protocol: string; }>} newStream
 * @param {() => Promise<void>} close
 * @param {() => import("../stream-muxer/types").MuxedStream[]} getStreams
 * @param {{ direction: any; timeline: any; multiplexer?: string | undefined; encryption?: string | undefined; }} stat
 */
function validateArgs (localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {
  if (localAddr && !Multiaddr.isMultiaddr(localAddr)) {
    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS')
  }

  if (!PeerId.isPeerId(localPeer)) {
    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')
  }

  if (!PeerId.isPeerId(remotePeer)) {
    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')
  }

  if (typeof newStream !== 'function') {
    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS')
  }

  if (typeof close !== 'function') {
    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS')
  }

  if (typeof getStreams !== 'function') {
    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS')
  }

  if (!stat) {
    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS')
  }

  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {
    throw errCode(new Error('direction must be "inbound" or "outbound"'), 'ERR_INVALID_PARAMETERS')
  }

  if (!stat.timeline) {
    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS')
  }

  if (!stat.timeline.open) {
    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS')
  }

  if (!stat.timeline.upgraded) {
    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS')
  }
}

},{"peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","err-code":"node_modules/err-code/index.js","./status":"node_modules/libp2p-interfaces/src/connection/status.js"}],"node_modules/libp2p-interfaces/src/connection/index.js":[function(require,module,exports) {
'use strict'

exports.Connection = require('./connection')

},{"./connection":"node_modules/libp2p-interfaces/src/connection/connection.js"}],"node_modules/mutable-proxy/build/index.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

module.exports = function mutableProxyFactory(defaultTarget) {
  var mutableHandler = void 0;
  var mutableTarget = void 0;

  function setTarget(target) {
    if (!(target instanceof Object)) {
      throw new Error('Target "' + target + '" is not an object');
    }

    mutableTarget = target;
  }

  function setHandler(handler) {
    Object.keys(handler).forEach(function (key) {
      var value = handler[key];

      if (typeof value !== 'function') {
        throw new Error('Trap "' + key + ': ' + value + '" is not a function');
      }

      if (!Reflect[key]) {
        throw new Error('Trap "' + key + ': ' + value + '" is not a valid trap');
      }
    });
    mutableHandler = handler;
  }

  setTarget(function () {});

  if (defaultTarget) {
    setTarget(defaultTarget);
  }

  setHandler(Reflect); // Dynamically forward all the traps to the associated methods on the mutable handler

  var handler = new Proxy({}, {
    get: function get(target, property) {
      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
      };
    }
  });
  return {
    setTarget: setTarget,
    setHandler: setHandler,
    getTarget: function getTarget() {
      return mutableTarget;
    },
    getHandler: function getHandler() {
      return mutableHandler;
    },
    proxy: new Proxy(mutableTarget, handler)
  };
};
},{}],"node_modules/libp2p/src/upgrader.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:upgrader'), {
  error: debug('libp2p:upgrader:err')
});

var errCode = require('err-code'); // @ts-ignore multistream-select does not export types


var Multistream = require('multistream-select');

var _require = require('libp2p-interfaces/src/connection'),
    Connection = _require.Connection;

var PeerId = require('peer-id');

var _require2 = require('it-pipe'),
    pipe = _require2.pipe; // @ts-ignore mutable-proxy does not export types


var mutableProxy = require('mutable-proxy');

var _require3 = require('./errors'),
    codes = _require3.codes;
/**
 * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @typedef CryptoResult
 * @property {MultiaddrConnection} conn A duplex iterable
 * @property {PeerId} remotePeer
 * @property {string} protocol
 */


var Upgrader = /*#__PURE__*/function () {
  /**
   * @param {object} options
   * @param {PeerId} options.localPeer
   * @param {import('./metrics')} [options.metrics]
   * @param {Map<string, Crypto>} [options.cryptos]
   * @param {Map<string, MuxerFactory>} [options.muxers]
   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded
   * @param {(connection: Connection) => void} options.onConnectionEnd
   */
  function Upgrader(_ref) {
    var localPeer = _ref.localPeer,
        metrics = _ref.metrics,
        _ref$cryptos = _ref.cryptos,
        cryptos = _ref$cryptos === void 0 ? new Map() : _ref$cryptos,
        _ref$muxers = _ref.muxers,
        muxers = _ref$muxers === void 0 ? new Map() : _ref$muxers,
        _ref$onConnectionEnd = _ref.onConnectionEnd,
        onConnectionEnd = _ref$onConnectionEnd === void 0 ? function () {} : _ref$onConnectionEnd,
        _ref$onConnection = _ref.onConnection,
        onConnection = _ref$onConnection === void 0 ? function () {} : _ref$onConnection;

    _classCallCheck(this, Upgrader);

    this.localPeer = localPeer;
    this.metrics = metrics;
    this.cryptos = cryptos;
    this.muxers = muxers;
    /** @type {import("./pnet") | null} */

    this.protector = null;
    this.protocols = new Map();
    this.onConnection = onConnection;
    this.onConnectionEnd = onConnectionEnd;
  }
  /**
   * Upgrades an inbound connection
   *
   * @async
   * @param {MultiaddrConnection} maConn
   * @returns {Promise<Connection>}
   */


  _createClass(Upgrader, [{
    key: "upgradeInbound",
    value: function () {
      var _upgradeInbound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(maConn) {
        var encryptedConn, remotePeer, upgradedConn, Muxer, cryptoProtocol, setPeer, proxyPeer, _mutableProxy, idString, protectedConn, _yield$this$_encryptI, _yield$this$_multiple;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.metrics) {
                  _mutableProxy = mutableProxy();
                  setPeer = _mutableProxy.setTarget;
                  proxyPeer = _mutableProxy.proxy;
                  idString = (Math.random() * 1e9).toString(36) + Date.now();
                  setPeer({
                    toB58String: function toB58String() {
                      return idString;
                    }
                  });
                  maConn = this.metrics.trackStream({
                    stream: maConn,
                    remotePeer: proxyPeer
                  });
                }

                log('Starting the inbound connection upgrade'); // Protect

                protectedConn = maConn;

                if (!this.protector) {
                  _context.next = 7;
                  break;
                }

                _context.next = 6;
                return this.protector.protect(maConn);

              case 6:
                protectedConn = _context.sent;

              case 7:
                _context.prev = 7;
                _context.next = 10;
                return this._encryptInbound(this.localPeer, protectedConn, this.cryptos);

              case 10:
                _yield$this$_encryptI = _context.sent;
                encryptedConn = _yield$this$_encryptI.conn;
                remotePeer = _yield$this$_encryptI.remotePeer;
                cryptoProtocol = _yield$this$_encryptI.protocol;

                if (!this.muxers.size) {
                  _context.next = 22;
                  break;
                }

                _context.next = 17;
                return this._multiplexInbound(encryptedConn, this.muxers);

              case 17:
                _yield$this$_multiple = _context.sent;
                upgradedConn = _yield$this$_multiple.stream;
                Muxer = _yield$this$_multiple.Muxer;
                _context.next = 23;
                break;

              case 22:
                upgradedConn = encryptedConn;

              case 23:
                _context.next = 31;
                break;

              case 25:
                _context.prev = 25;
                _context.t0 = _context["catch"](7);
                log.error('Failed to upgrade inbound connection', _context.t0);
                _context.next = 30;
                return maConn.close(_context.t0);

              case 30:
                throw _context.t0;

              case 31:
                if (this.metrics) {
                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);
                  setPeer(remotePeer);
                }

                log('Successfully upgraded inbound connection');
                return _context.abrupt("return", this._createConnection({
                  cryptoProtocol: cryptoProtocol,
                  direction: 'inbound',
                  maConn: maConn,
                  upgradedConn: upgradedConn,
                  Muxer: Muxer,
                  remotePeer: remotePeer
                }));

              case 34:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 25]]);
      }));

      function upgradeInbound(_x) {
        return _upgradeInbound.apply(this, arguments);
      }

      return upgradeInbound;
    }()
    /**
     * Upgrades an outbound connection
     *
     * @async
     * @param {MultiaddrConnection} maConn
     * @returns {Promise<Connection>}
     */

  }, {
    key: "upgradeOutbound",
    value: function () {
      var _upgradeOutbound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(maConn) {
        var idStr, remotePeerId, encryptedConn, remotePeer, upgradedConn, cryptoProtocol, Muxer, setPeer, proxyPeer, _mutableProxy2, idString, protectedConn, _yield$this$_encryptO, _yield$this$_multiple2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                idStr = maConn.remoteAddr.getPeerId();

                if (idStr) {
                  _context2.next = 3;
                  break;
                }

                throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);

              case 3:
                remotePeerId = PeerId.createFromB58String(idStr);

                if (this.metrics) {
                  _mutableProxy2 = mutableProxy();
                  setPeer = _mutableProxy2.setTarget;
                  proxyPeer = _mutableProxy2.proxy;
                  idString = (Math.random() * 1e9).toString(36) + Date.now();
                  setPeer({
                    toB58String: function toB58String() {
                      return idString;
                    }
                  });
                  maConn = this.metrics.trackStream({
                    stream: maConn,
                    remotePeer: proxyPeer
                  });
                }

                log('Starting the outbound connection upgrade'); // Protect

                protectedConn = maConn;

                if (!this.protector) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 10;
                return this.protector.protect(maConn);

              case 10:
                protectedConn = _context2.sent;

              case 11:
                _context2.prev = 11;
                _context2.next = 14;
                return this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos);

              case 14:
                _yield$this$_encryptO = _context2.sent;
                encryptedConn = _yield$this$_encryptO.conn;
                remotePeer = _yield$this$_encryptO.remotePeer;
                cryptoProtocol = _yield$this$_encryptO.protocol;

                if (!this.muxers.size) {
                  _context2.next = 26;
                  break;
                }

                _context2.next = 21;
                return this._multiplexOutbound(encryptedConn, this.muxers);

              case 21:
                _yield$this$_multiple2 = _context2.sent;
                upgradedConn = _yield$this$_multiple2.stream;
                Muxer = _yield$this$_multiple2.Muxer;
                _context2.next = 27;
                break;

              case 26:
                upgradedConn = encryptedConn;

              case 27:
                _context2.next = 35;
                break;

              case 29:
                _context2.prev = 29;
                _context2.t0 = _context2["catch"](11);
                log.error('Failed to upgrade outbound connection', _context2.t0);
                _context2.next = 34;
                return maConn.close(_context2.t0);

              case 34:
                throw _context2.t0;

              case 35:
                if (this.metrics) {
                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);
                  setPeer(remotePeer);
                }

                log('Successfully upgraded outbound connection');
                return _context2.abrupt("return", this._createConnection({
                  cryptoProtocol: cryptoProtocol,
                  direction: 'outbound',
                  maConn: maConn,
                  upgradedConn: upgradedConn,
                  Muxer: Muxer,
                  remotePeer: remotePeer
                }));

              case 38:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[11, 29]]);
      }));

      function upgradeOutbound(_x2) {
        return _upgradeOutbound.apply(this, arguments);
      }

      return upgradeOutbound;
    }()
    /**
     * A convenience method for generating a new `Connection`
     *
     * @private
     * @param {object} options
     * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated
     * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']
     * @param {MultiaddrConnection} options.maConn - The transport layer connection
     * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection
     * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing
     * @param {PeerId} options.remotePeer - The peer the connection is with
     * @returns {Connection}
     */

  }, {
    key: "_createConnection",
    value: function _createConnection(_ref2) {
      var _this = this;

      var cryptoProtocol = _ref2.cryptoProtocol,
          direction = _ref2.direction,
          maConn = _ref2.maConn,
          upgradedConn = _ref2.upgradedConn,
          Muxer = _ref2.Muxer,
          remotePeer = _ref2.remotePeer;

      /** @type {import("libp2p-interfaces/src/stream-muxer/types").Muxer} */
      var muxer;
      /** @type {import("libp2p-interfaces/src/connection/connection").CreatedMuxedStream | undefined} */

      var newStream;
      /** @type {Connection} */

      var connection; // eslint-disable-line prefer-const

      if (Muxer) {
        // Create the muxer
        muxer = new Muxer({
          // Run anytime a remote stream is created
          onStream: function () {
            var _onStream2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(muxedStream) {
              var mss, _yield$mss$handle, stream, protocol;

              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (connection) {
                        _context3.next = 2;
                        break;
                      }

                      return _context3.abrupt("return");

                    case 2:
                      mss = new Multistream.Listener(muxedStream);
                      _context3.prev = 3;
                      _context3.next = 6;
                      return mss.handle(Array.from(_this.protocols.keys()));

                    case 6:
                      _yield$mss$handle = _context3.sent;
                      stream = _yield$mss$handle.stream;
                      protocol = _yield$mss$handle.protocol;
                      log('%s: incoming stream opened on %s', direction, protocol);
                      if (_this.metrics) _this.metrics.trackStream({
                        stream: stream,
                        remotePeer: remotePeer,
                        protocol: protocol
                      });
                      connection.addStream(muxedStream, {
                        protocol: protocol
                      });

                      _this._onStream({
                        connection: connection,
                        stream: _objectSpread(_objectSpread({}, muxedStream), stream),
                        protocol: protocol
                      });

                      _context3.next = 18;
                      break;

                    case 15:
                      _context3.prev = 15;
                      _context3.t0 = _context3["catch"](3);
                      log.error(_context3.t0);

                    case 18:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[3, 15]]);
            }));

            function onStream(_x3) {
              return _onStream2.apply(this, arguments);
            }

            return onStream;
          }(),
          // Run anytime a stream closes
          onStreamEnd: function onStreamEnd(muxedStream) {
            connection.removeStream(muxedStream.id);
          }
        });

        newStream = /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(protocols) {
            var muxedStream, mss, _yield$mss$select, stream, protocol;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    log('%s: starting new stream on %s', direction, protocols);
                    muxedStream = muxer.newStream();
                    mss = new Multistream.Dialer(muxedStream);
                    _context4.prev = 3;
                    _context4.next = 6;
                    return mss.select(protocols);

                  case 6:
                    _yield$mss$select = _context4.sent;
                    stream = _yield$mss$select.stream;
                    protocol = _yield$mss$select.protocol;
                    if (_this.metrics) _this.metrics.trackStream({
                      stream: stream,
                      remotePeer: remotePeer,
                      protocol: protocol
                    });
                    return _context4.abrupt("return", {
                      stream: _objectSpread(_objectSpread({}, muxedStream), stream),
                      protocol: protocol
                    });

                  case 13:
                    _context4.prev = 13;
                    _context4.t0 = _context4["catch"](3);
                    log.error('could not create new stream', _context4.t0);
                    throw errCode(_context4.t0, codes.ERR_UNSUPPORTED_PROTOCOL);

                  case 17:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, null, [[3, 13]]);
          }));

          return function newStream(_x4) {
            return _ref3.apply(this, arguments);
          };
        }(); // Pipe all data through the muxer


        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);
      }

      var _timeline = maConn.timeline;
      maConn.timeline = new Proxy(_timeline, {
        set: function set() {
          if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {
            // Wait for close to finish before notifying of the closure
            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.prev = 0;

                      if (!(connection.stat.status === 'open')) {
                        _context5.next = 4;
                        break;
                      }

                      _context5.next = 4;
                      return connection.close();

                    case 4:
                      _context5.next = 9;
                      break;

                    case 6:
                      _context5.prev = 6;
                      _context5.t0 = _context5["catch"](0);
                      log.error(_context5.t0);

                    case 9:
                      _context5.prev = 9;

                      _this.onConnectionEnd(connection);

                      return _context5.finish(9);

                    case 12:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, null, [[0, 6, 9, 12]]);
            }))();
          }

          return Reflect.set.apply(Reflect, arguments);
        }
      });
      maConn.timeline.upgraded = Date.now();

      var errConnectionNotMultiplexed = function errConnectionNotMultiplexed() {
        throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');
      }; // Create the connection


      connection = new Connection({
        localAddr: maConn.localAddr,
        remoteAddr: maConn.remoteAddr,
        localPeer: this.localPeer,
        remotePeer: remotePeer,
        stat: {
          direction: direction,
          // @ts-ignore
          timeline: maConn.timeline,
          multiplexer: Muxer && Muxer.multicodec,
          encryption: cryptoProtocol
        },
        newStream: newStream || errConnectionNotMultiplexed,
        getStreams: function getStreams() {
          return muxer ? muxer.streams : errConnectionNotMultiplexed();
        },
        close: function () {
          var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return maConn.close();

                  case 2:
                    // Ensure remaining streams are aborted
                    if (muxer) {
                      muxer.streams.map(function (stream) {
                        return stream.abort();
                      });
                    }

                  case 3:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function close() {
            return _close.apply(this, arguments);
          }

          return close;
        }()
      });
      this.onConnection(connection);
      return connection;
    }
    /**
     * Routes incoming streams to the correct handler
     *
     * @private
     * @param {object} options
     * @param {Connection} options.connection - The connection the stream belongs to
     * @param {MuxedStream} options.stream
     * @param {string} options.protocol
     */

  }, {
    key: "_onStream",
    value: function _onStream(_ref5) {
      var connection = _ref5.connection,
          stream = _ref5.stream,
          protocol = _ref5.protocol;
      var handler = this.protocols.get(protocol);
      handler({
        connection: connection,
        stream: stream,
        protocol: protocol
      });
    }
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`.
     *
     * @private
     * @async
     * @param {PeerId} localPeer - The initiators PeerId
     * @param {*} connection
     * @param {Map<string, Crypto>} cryptos
     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used
     */

  }, {
    key: "_encryptInbound",
    value: function () {
      var _encryptInbound2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localPeer, connection, cryptos) {
        var mss, protocols, _yield$mss$handle2, stream, protocol, crypto;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                mss = new Multistream.Listener(connection);
                protocols = Array.from(cryptos.keys());
                log('handling inbound crypto protocol selection', protocols);
                _context7.prev = 3;
                _context7.next = 6;
                return mss.handle(protocols);

              case 6:
                _yield$mss$handle2 = _context7.sent;
                stream = _yield$mss$handle2.stream;
                protocol = _yield$mss$handle2.protocol;
                crypto = cryptos.get(protocol);
                log('encrypting inbound connection...');

                if (crypto) {
                  _context7.next = 13;
                  break;
                }

                throw new Error("no crypto module found for ".concat(protocol));

              case 13:
                _context7.t0 = _objectSpread;
                _context7.t1 = _objectSpread;
                _context7.t2 = {};
                _context7.next = 18;
                return crypto.secureInbound(localPeer, stream);

              case 18:
                _context7.t3 = _context7.sent;
                _context7.t4 = (0, _context7.t1)(_context7.t2, _context7.t3);
                _context7.t5 = {};
                _context7.t6 = {
                  protocol: protocol
                };
                return _context7.abrupt("return", (0, _context7.t0)(_context7.t4, _context7.t5, _context7.t6));

              case 25:
                _context7.prev = 25;
                _context7.t7 = _context7["catch"](3);
                throw errCode(_context7.t7, codes.ERR_ENCRYPTION_FAILED);

              case 28:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[3, 25]]);
      }));

      function _encryptInbound(_x5, _x6, _x7) {
        return _encryptInbound2.apply(this, arguments);
      }

      return _encryptInbound;
    }()
    /**
     * Attempts to encrypt the given `connection` with the provided `cryptos`.
     * The first `Crypto` module to succeed will be used
     *
     * @private
     * @async
     * @param {PeerId} localPeer - The initiators PeerId
     * @param {MultiaddrConnection} connection
     * @param {PeerId} remotePeerId
     * @param {Map<string, Crypto>} cryptos
     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used
     */

  }, {
    key: "_encryptOutbound",
    value: function () {
      var _encryptOutbound2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localPeer, connection, remotePeerId, cryptos) {
        var mss, protocols, _yield$mss$select2, stream, protocol, crypto;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                mss = new Multistream.Dialer(connection);
                protocols = Array.from(cryptos.keys());
                log('selecting outbound crypto protocol', protocols);
                _context8.prev = 3;
                _context8.next = 6;
                return mss.select(protocols);

              case 6:
                _yield$mss$select2 = _context8.sent;
                stream = _yield$mss$select2.stream;
                protocol = _yield$mss$select2.protocol;
                crypto = cryptos.get(protocol);
                log('encrypting outbound connection to %j', remotePeerId);

                if (crypto) {
                  _context8.next = 13;
                  break;
                }

                throw new Error("no crypto module found for ".concat(protocol));

              case 13:
                _context8.t0 = _objectSpread;
                _context8.t1 = _objectSpread;
                _context8.t2 = {};
                _context8.next = 18;
                return crypto.secureOutbound(localPeer, stream, remotePeerId);

              case 18:
                _context8.t3 = _context8.sent;
                _context8.t4 = (0, _context8.t1)(_context8.t2, _context8.t3);
                _context8.t5 = {};
                _context8.t6 = {
                  protocol: protocol
                };
                return _context8.abrupt("return", (0, _context8.t0)(_context8.t4, _context8.t5, _context8.t6));

              case 25:
                _context8.prev = 25;
                _context8.t7 = _context8["catch"](3);
                throw errCode(_context8.t7, codes.ERR_ENCRYPTION_FAILED);

              case 28:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[3, 25]]);
      }));

      function _encryptOutbound(_x8, _x9, _x10, _x11) {
        return _encryptOutbound2.apply(this, arguments);
      }

      return _encryptOutbound;
    }()
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     *
     * @private
     * @async
     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex
     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with
     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection
     */

  }, {
    key: "_multiplexOutbound",
    value: function () {
      var _multiplexOutbound2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(connection, muxers) {
        var dialer, protocols, _yield$dialer$select, stream, protocol, Muxer;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                dialer = new Multistream.Dialer(connection);
                protocols = Array.from(muxers.keys());
                log('outbound selecting muxer %s', protocols);
                _context9.prev = 3;
                _context9.next = 6;
                return dialer.select(protocols);

              case 6:
                _yield$dialer$select = _context9.sent;
                stream = _yield$dialer$select.stream;
                protocol = _yield$dialer$select.protocol;
                log('%s selected as muxer protocol', protocol);
                Muxer = muxers.get(protocol);
                return _context9.abrupt("return", {
                  stream: stream,
                  Muxer: Muxer
                });

              case 14:
                _context9.prev = 14;
                _context9.t0 = _context9["catch"](3);
                throw errCode(_context9.t0, codes.ERR_MUXER_UNAVAILABLE);

              case 17:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, null, [[3, 14]]);
      }));

      function _multiplexOutbound(_x12, _x13) {
        return _multiplexOutbound2.apply(this, arguments);
      }

      return _multiplexOutbound;
    }()
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     *
     * @private
     * @async
     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex
     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with
     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection
     */

  }, {
    key: "_multiplexInbound",
    value: function () {
      var _multiplexInbound2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(connection, muxers) {
        var listener, protocols, _yield$listener$handl, stream, protocol, Muxer;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                listener = new Multistream.Listener(connection);
                protocols = Array.from(muxers.keys());
                log('inbound handling muxers %s', protocols);
                _context10.prev = 3;
                _context10.next = 6;
                return listener.handle(protocols);

              case 6:
                _yield$listener$handl = _context10.sent;
                stream = _yield$listener$handl.stream;
                protocol = _yield$listener$handl.protocol;
                Muxer = muxers.get(protocol);
                return _context10.abrupt("return", {
                  stream: stream,
                  Muxer: Muxer
                });

              case 13:
                _context10.prev = 13;
                _context10.t0 = _context10["catch"](3);
                throw errCode(_context10.t0, codes.ERR_MUXER_UNAVAILABLE);

              case 16:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[3, 13]]);
      }));

      function _multiplexInbound(_x14, _x15) {
        return _multiplexInbound2.apply(this, arguments);
      }

      return _multiplexInbound;
    }()
  }]);

  return Upgrader;
}();

module.exports = Upgrader;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","multistream-select":"node_modules/multistream-select/src/index.js","libp2p-interfaces/src/connection":"node_modules/libp2p-interfaces/src/connection/index.js","peer-id":"node_modules/peer-id/src/index.js","it-pipe":"node_modules/it-pipe/index.js","mutable-proxy":"node_modules/mutable-proxy/build/index.js","./errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/peer-store/book.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var errcode = require('err-code');

var PeerId = require('peer-id');

var _require = require('../errors'),
    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;
/**
 * @param {any} data
 */


var passthrough = function passthrough(data) {
  return data;
};
/**
 * @typedef {import('./')} PeerStore
 */


var Book = /*#__PURE__*/function () {
  /**
   * The Book is the skeleton for the PeerStore books.
   *
   * @class
   * @param {Object} properties
   * @param {PeerStore} properties.peerStore - PeerStore instance.
   * @param {string} properties.eventName - Name of the event to emit by the PeerStore.
   * @param {string} properties.eventProperty - Name of the property to emit by the PeerStore.
   * @param {(data: any) => any[]} [properties.eventTransformer] - Transformer function of the provided data for being emitted.
   */
  function Book(_ref) {
    var peerStore = _ref.peerStore,
        eventName = _ref.eventName,
        eventProperty = _ref.eventProperty,
        _ref$eventTransformer = _ref.eventTransformer,
        eventTransformer = _ref$eventTransformer === void 0 ? passthrough : _ref$eventTransformer;

    _classCallCheck(this, Book);

    this._ps = peerStore;
    this.eventName = eventName;
    this.eventProperty = eventProperty;
    this.eventTransformer = eventTransformer;
    /**
     * Map known peers to their data.
     *
     * @type {Map<string, any[]|any>}
     */

    this.data = new Map();
  }
  /**
   * Set known data of a provided peer.
   *
   * @param {PeerId} peerId
   * @param {any[]|any} data
   */


  _createClass(Book, [{
    key: "set",
    value: function set(peerId, data) {
      throw errcode(new Error('set must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');
    }
    /**
     * Set data into the datastructure, persistence and emit it using the provided transformers.
     *
     * @protected
     * @param {PeerId} peerId - peerId of the data to store
     * @param {any} data - data to store.
     * @param {Object} [options] - storing options.
     * @param {boolean} [options.emit = true] - emit the provided data.
     * @returns {void}
     */

  }, {
    key: "_setData",
    value: function _setData(peerId, data) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref2$emit = _ref2.emit,
          emit = _ref2$emit === void 0 ? true : _ref2$emit;

      var b58key = peerId.toB58String(); // Store data in memory

      this.data.set(b58key, data); // Emit event

      emit && this._emit(peerId, data);
    }
    /**
     * Emit data.
     *
     * @protected
     * @param {PeerId} peerId
     * @param {any} [data]
     */

  }, {
    key: "_emit",
    value: function _emit(peerId, data) {
      this._ps.emit(this.eventName, _defineProperty({
        peerId: peerId
      }, this.eventProperty, this.eventTransformer(data)));
    }
    /**
     * Get the known data of a provided peer.
     * Returns `undefined` if there is no available data for the given peer.
     *
     * @param {PeerId} peerId
     * @returns {any[]|any|undefined}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var rec = this.data.get(peerId.toB58String()); // @ts-ignore

      return rec ? _toConsumableArray(rec) : undefined;
    }
    /**
     * Deletes the provided peer from the book.
     *
     * @param {PeerId} peerId
     * @returns {boolean}
     */

  }, {
    key: "delete",
    value: function _delete(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (!this.data.delete(peerId.toB58String())) {
        return false;
      }

      this._emit(peerId, []);

      return true;
    }
  }]);

  return Book;
}();

module.exports = Book;
},{"err-code":"node_modules/err-code/index.js","peer-id":"node_modules/peer-id/src/index.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/peer-store/address-book.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:peer-store:address-book'), {
  error: debug('libp2p:peer-store:address-book:err')
});

var errcode = require('err-code');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var PeerId = require('peer-id');

var Book = require('./book');

var PeerRecord = require('../record/peer-record');

var _require2 = require('../errors'),
    ERR_INVALID_PARAMETERS = _require2.codes.ERR_INVALID_PARAMETERS;

var Envelope = require('../record/envelope');
/**
 * @typedef {import('./')} PeerStore
 */

/**
 * @typedef {Object} Address
 * @property {Multiaddr} multiaddr peer multiaddr.
 * @property {boolean} isCertified obtained from a signed peer record.
 *
 * @typedef {Object} CertifiedRecord
 * @property {Uint8Array} raw raw envelope.
 * @property {number} seqNumber seq counter.
 *
 * @typedef {Object} Entry
 * @property {Address[]} addresses peer Addresses.
 * @property {CertifiedRecord} record certified peer record.
 */

/**
 * @extends {Book}
 */


var AddressBook = /*#__PURE__*/function (_Book) {
  _inherits(AddressBook, _Book);

  var _super = _createSuper(AddressBook);

  /**
   * The AddressBook is responsible for keeping the known multiaddrs of a peer.
   *
   * @class
   * @param {PeerStore} peerStore
   */
  function AddressBook(peerStore) {
    var _this;

    _classCallCheck(this, AddressBook);

    /**
     * PeerStore Event emitter, used by the AddressBook to emit:
     * "peer" - emitted when a peer is discovered by the node.
     * "change:multiaddrs" - emitted when the known multiaddrs of a peer change.
     */
    _this = _super.call(this, {
      peerStore: peerStore,
      eventName: 'change:multiaddrs',
      eventProperty: 'multiaddrs',
      eventTransformer: function eventTransformer(data) {
        if (!data.addresses) {
          return [];
        }

        return data.addresses.map(function (
        /** @type {Address} */
        address) {
          return address.multiaddr;
        });
      }
    });
    /**
     * Map known peers to their known Address Entries.
     *
     * @type {Map<string, Entry>}
     */

    _this.data = new Map();
    return _this;
  }
  /**
   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.
   * This will return a boolean that indicates if the record was successfully processed and added
   * into the AddressBook.
   *
   * @param {Envelope} envelope
   * @returns {boolean}
   */


  _createClass(AddressBook, [{
    key: "consumePeerRecord",
    value: function consumePeerRecord(envelope) {
      var peerRecord;

      try {
        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      } catch (err) {
        log.error('invalid peer record received');
        return false;
      } // Verify peerId


      if (!peerRecord.peerId.equals(envelope.peerId)) {
        log('signing key does not match PeerId in the PeerRecord');
        return false;
      } // ensure the record has multiaddrs


      if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {
        return false;
      }

      var peerId = peerRecord.peerId;
      var id = peerId.toB58String();
      var entry = this.data.get(id) || {
        record: undefined
      };
      var storedRecord = entry.record; // ensure seq is greater than, or equal to, the last received

      if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {
        return false;
      }

      var addresses = this._toAddresses(peerRecord.multiaddrs, true); // Replace unsigned addresses by the new ones from the record
      // TODO: Once we have ttls for the addresses, we should merge these in.


      this._setData(peerId, {
        addresses: addresses,
        record: {
          raw: envelope.marshal(),
          seqNumber: peerRecord.seqNumber
        }
      });

      log("stored provided peer record for ".concat(id));
      return true;
    }
    /**
     * Get the raw Envelope for a peer. Returns
     * undefined if no Envelope is found.
     *
     * @param {PeerId} peerId
     * @returns {Uint8Array|undefined}
     */

  }, {
    key: "getRawEnvelope",
    value: function getRawEnvelope(peerId) {
      var entry = this.data.get(peerId.toB58String());

      if (!entry || !entry.record || !entry.record.raw) {
        return undefined;
      }

      return entry.record.raw;
    }
    /**
     * Get an Envelope containing a PeerRecord for the given peer.
     * Returns undefined if no record exists.
     *
     * @param {PeerId} peerId
     * @returns {Promise<Envelope|void>|undefined}
     */

  }, {
    key: "getPeerRecord",
    value: function getPeerRecord(peerId) {
      var raw = this.getRawEnvelope(peerId);

      if (!raw) {
        return undefined;
      }

      return Envelope.createFromProtobuf(raw);
    }
    /**
     * Set known multiaddrs of a provided peer.
     * This will replace previously stored multiaddrs, if available.
     * Replacing stored multiaddrs might result in losing obtained certified addresses.
     * If you are not sure, it's recommended to use `add` instead.
     *
     * @override
     * @param {PeerId} peerId
     * @param {Multiaddr[]} multiaddrs
     * @returns {AddressBook}
     */

  }, {
    key: "set",
    value: function set(peerId, multiaddrs) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var addresses = this._toAddresses(multiaddrs); // Not replace multiaddrs


      if (!addresses.length) {
        return this;
      }

      var id = peerId.toB58String();
      var entry = this.data.get(id); // Already knows the peer

      if (entry && entry.addresses && entry.addresses.length === addresses.length) {
        var intersection = entry.addresses.filter(function (addr) {
          return addresses.some(function (newAddr) {
            return addr.multiaddr.equals(newAddr.multiaddr);
          });
        }); // Are new addresses equal to the old ones?
        // If yes, no changes needed!

        if (intersection.length === entry.addresses.length) {
          log("the addresses provided to store are equal to the already stored for ".concat(id));
          return this;
        }
      }

      this._setData(peerId, {
        addresses: addresses,
        record: entry && entry.record
      });

      log("stored provided multiaddrs for ".concat(id)); // Notify the existance of a new peer

      if (!entry) {
        this._ps.emit('peer', peerId);
      }

      return this;
    }
    /**
     * Add known addresses of a provided peer.
     * If the peer is not known, it is set with the given addresses.
     *
     * @param {PeerId} peerId
     * @param {Multiaddr[]} multiaddrs
     * @returns {AddressBook}
     */

  }, {
    key: "add",
    value: function add(peerId, multiaddrs) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var addresses = this._toAddresses(multiaddrs);

      var id = peerId.toB58String(); // No addresses to be added

      if (!addresses.length) {
        return this;
      }

      var entry = this.data.get(id);

      if (entry && entry.addresses) {
        // Add recorded uniquely to the new array (Union)
        entry.addresses.forEach(function (addr) {
          if (!addresses.find(function (r) {
            return r.multiaddr.equals(addr.multiaddr);
          })) {
            addresses.push(addr);
          }
        }); // If the recorded length is equal to the new after the unique union
        // The content is the same, no need to update.

        if (entry.addresses.length === addresses.length) {
          log("the addresses provided to store are already stored for ".concat(id));
          return this;
        }
      }

      this._setData(peerId, {
        addresses: addresses,
        record: entry && entry.record
      });

      log("added provided multiaddrs for ".concat(id)); // Notify the existance of a new peer

      if (!(entry && entry.addresses)) {
        this._ps.emit('peer', peerId);
      }

      return this;
    }
    /**
     * Get the known data of a provided peer.
     *
     * @override
     * @param {PeerId} peerId
     * @returns {Address[]|undefined}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var entry = this.data.get(peerId.toB58String());
      return entry && entry.addresses ? _toConsumableArray(entry.addresses) : undefined;
    }
    /**
     * Transforms received multiaddrs into Address.
     *
     * @private
     * @param {Multiaddr[]} multiaddrs
     * @param {boolean} [isCertified]
     * @returns {Address[]}
     */

  }, {
    key: "_toAddresses",
    value: function _toAddresses(multiaddrs) {
      var isCertified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!multiaddrs) {
        log.error('multiaddrs must be provided to store data');
        throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);
      } // create Address for each address

      /** @type {Address[]} */


      var addresses = [];
      multiaddrs.forEach(function (addr) {
        if (!Multiaddr.isMultiaddr(addr)) {
          log.error("multiaddr ".concat(addr, " must be an instance of multiaddr"));
          throw errcode(new Error("multiaddr ".concat(addr, " must be an instance of multiaddr")), ERR_INVALID_PARAMETERS);
        } // Guarantee no replicates


        if (!addresses.find(function (a) {
          return a.multiaddr.equals(addr);
        })) {
          addresses.push({
            multiaddr: addr,
            isCertified: isCertified
          });
        }
      });
      return addresses;
    }
    /**
     * Get the known multiaddrs for a given peer. All returned multiaddrs
     * will include the encapsulated `PeerId` of the peer.
     * Returns `undefined` if there are no known multiaddrs for the given peer.
     *
     * @param {PeerId} peerId
     * @param {(addresses: Address[]) => Address[]} [addressSorter]
     * @returns {Multiaddr[]|undefined}
     */

  }, {
    key: "getMultiaddrsForPeer",
    value: function getMultiaddrsForPeer(peerId) {
      var addressSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ms) {
        return ms;
      };

      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var entry = this.data.get(peerId.toB58String());

      if (!entry || !entry.addresses) {
        return undefined;
      }

      return addressSorter(entry.addresses || []).map(function (address) {
        var multiaddr = address.multiaddr;
        var idString = multiaddr.getPeerId();
        if (idString && idString === peerId.toB58String()) return multiaddr;
        return multiaddr.encapsulate("/p2p/".concat(peerId.toB58String()));
      });
    }
  }]);

  return AddressBook;
}(Book);

module.exports = AddressBook;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js","./book":"node_modules/libp2p/src/peer-store/book.js","../record/peer-record":"node_modules/libp2p/src/record/peer-record/index.js","../errors":"node_modules/libp2p/src/errors.js","../record/envelope":"node_modules/libp2p/src/record/envelope/index.js"}],"node_modules/libp2p/src/peer-store/key-book.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:peer-store:key-book'), {
  error: debug('libp2p:peer-store:key-book:err')
});

var errcode = require('err-code');

var PeerId = require('peer-id');

var Book = require('./book');

var _require = require('../errors'),
    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;
/**
 * @typedef {import('./')} PeerStore
 * @typedef {import('libp2p-crypto').PublicKey} PublicKey
 */

/**
 * @extends {Book}
 */


var KeyBook = /*#__PURE__*/function (_Book) {
  _inherits(KeyBook, _Book);

  var _super = _createSuper(KeyBook);

  /**
   * The KeyBook is responsible for keeping the known public keys of a peer.
   *
   * @class
   * @param {PeerStore} peerStore
   */
  function KeyBook(peerStore) {
    var _this;

    _classCallCheck(this, KeyBook);

    _this = _super.call(this, {
      peerStore: peerStore,
      eventName: 'change:pubkey',
      eventProperty: 'pubkey',
      eventTransformer: function eventTransformer(data) {
        return data.pubKey;
      }
    });
    /**
     * Map known peers to their known Public Key.
     *
     * @type {Map<string, PeerId>}
     */

    _this.data = new Map();
    return _this;
  }
  /**
   * Set the Peer public key.
   *
   * @override
   * @param {PeerId} peerId
   * @param {PublicKey} publicKey
   * @returns {KeyBook}
   */


  _createClass(KeyBook, [{
    key: "set",
    value: function set(peerId, publicKey) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var id = peerId.toB58String();
      var recPeerId = this.data.get(id); // If no record available, and this is valid

      if (!recPeerId && publicKey) {
        // This might be unecessary, but we want to store the PeerId
        // to avoid an async operation when reconstructing the PeerId
        peerId.pubKey = publicKey;

        this._setData(peerId, peerId);

        log("stored provided public key for ".concat(id));
      }

      return this;
    }
    /**
     * Get Public key of the given PeerId, if stored.
     *
     * @override
     * @param {PeerId} peerId
     * @returns {PublicKey | undefined}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var rec = this.data.get(peerId.toB58String());
      return rec ? rec.pubKey : undefined;
    }
  }]);

  return KeyBook;
}(Book);

module.exports = KeyBook;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","peer-id":"node_modules/peer-id/src/index.js","./book":"node_modules/libp2p/src/peer-store/book.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/peer-store/metadata-book.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:peer-store:proto-book'), {
  error: debug('libp2p:peer-store:proto-book:err')
});

var errcode = require('err-code');

var uint8ArrayEquals = require('uint8arrays/equals');

var PeerId = require('peer-id');

var Book = require('./book');

var _require = require('../errors'),
    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;
/**
 * @typedef {import('./')} PeerStore
 */

/**
 * @extends {Book}
 *
 * @fires MetadataBook#change:metadata
 */


var MetadataBook = /*#__PURE__*/function (_Book) {
  _inherits(MetadataBook, _Book);

  var _super = _createSuper(MetadataBook);

  /**
   * The MetadataBook is responsible for keeping the known supported
   * protocols of a peer.
   *
   * @class
   * @param {PeerStore} peerStore
   */
  function MetadataBook(peerStore) {
    var _this;

    _classCallCheck(this, MetadataBook);

    /**
     * PeerStore Event emitter, used by the MetadataBook to emit:
     * "change:metadata" - emitted when the known metadata of a peer change.
     */
    _this = _super.call(this, {
      peerStore: peerStore,
      eventName: 'change:metadata',
      eventProperty: 'metadata'
    });
    /**
     * Map known peers to their known protocols.
     *
     * @type {Map<string, Map<string, Uint8Array>>}
     */

    _this.data = new Map();
    return _this;
  }
  /**
   * Set metadata key and value of a provided peer.
   *
   * @override
   * @param {PeerId} peerId
   * @param {string} key - metadata key
   * @param {Uint8Array} value - metadata value
   * @returns {MetadataBook}
   */
  // @ts-ignore override with more then the parameters expected in Book


  _createClass(MetadataBook, [{
    key: "set",
    value: function set(peerId, key, value) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (typeof key !== 'string' || !(value instanceof Uint8Array)) {
        log.error('valid key and value must be provided to store data');
        throw errcode(new Error('valid key and value must be provided'), ERR_INVALID_PARAMETERS);
      }

      this._setValue(peerId, key, value);

      return this;
    }
    /**
     * Set data into the datastructure
     *
     * @override
     * @param {PeerId} peerId
     * @param {string} key
     * @param {Uint8Array} value
     */

  }, {
    key: "_setValue",
    value: function _setValue(peerId, key, value) {
      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
          _ref$emit = _ref.emit,
          emit = _ref$emit === void 0 ? true : _ref$emit;

      var id = peerId.toB58String();
      var rec = this.data.get(id) || new Map();
      var recMap = rec.get(key); // Already exists and is equal

      if (recMap && uint8ArrayEquals(value, recMap)) {
        log("the metadata provided to store is equal to the already stored for ".concat(id, " on ").concat(key));
        return;
      }

      rec.set(key, value);
      this.data.set(id, rec);
      emit && this._emit(peerId, key);
    }
    /**
     * Get the known data of a provided peer.
     *
     * @param {PeerId} peerId
     * @returns {Map<string, Uint8Array>|undefined}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      return this.data.get(peerId.toB58String());
    }
    /**
     * Get specific metadata value, if it exists
     *
     * @param {PeerId} peerId
     * @param {string} key
     * @returns {Uint8Array | undefined}
     */

  }, {
    key: "getValue",
    value: function getValue(peerId, key) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var rec = this.data.get(peerId.toB58String());
      return rec && rec.get(key);
    }
    /**
     * Deletes the provided peer from the book.
     *
     * @param {PeerId} peerId
     * @returns {boolean}
     */

  }, {
    key: "delete",
    value: function _delete(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (!this.data.delete(peerId.toB58String())) {
        return false;
      }

      this._emit(peerId);

      return true;
    }
    /**
     * Deletes the provided peer metadata key from the book.
     *
     * @param {PeerId} peerId
     * @param {string} key
     * @returns {boolean}
     */

  }, {
    key: "deleteValue",
    value: function deleteValue(peerId, key) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var rec = this.data.get(peerId.toB58String());

      if (!rec || !rec.delete(key)) {
        return false;
      }

      this._emit(peerId, key);

      return true;
    }
  }]);

  return MetadataBook;
}(Book);

module.exports = MetadataBook;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","peer-id":"node_modules/peer-id/src/index.js","./book":"node_modules/libp2p/src/peer-store/book.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/peer-store/proto-book.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:peer-store:proto-book'), {
  error: debug('libp2p:peer-store:proto-book:err')
});

var errcode = require('err-code');

var PeerId = require('peer-id');

var Book = require('./book');

var _require = require('../errors'),
    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;
/**
 * @typedef {import('./')} PeerStore
 */

/**
 * @extends {Book}
 *
 * @fires ProtoBook#change:protocols
 */


var ProtoBook = /*#__PURE__*/function (_Book) {
  _inherits(ProtoBook, _Book);

  var _super = _createSuper(ProtoBook);

  /**
   * The ProtoBook is responsible for keeping the known supported
   * protocols of a peer.
   *
   * @class
   * @param {PeerStore} peerStore
   */
  function ProtoBook(peerStore) {
    var _this;

    _classCallCheck(this, ProtoBook);

    /**
     * PeerStore Event emitter, used by the ProtoBook to emit:
     * "change:protocols" - emitted when the known protocols of a peer change.
     */
    _this = _super.call(this, {
      peerStore: peerStore,
      eventName: 'change:protocols',
      eventProperty: 'protocols',
      eventTransformer: function eventTransformer(data) {
        return Array.from(data);
      }
    });
    /**
     * Map known peers to their known protocols.
     *
     * @type {Map<string, Set<string>>}
     */

    _this.data = new Map();
    return _this;
  }
  /**
   * Set known protocols of a provided peer.
   * If the peer was not known before, it will be added.
   *
   * @override
   * @param {PeerId} peerId
   * @param {string[]} protocols
   * @returns {ProtoBook}
   */


  _createClass(ProtoBook, [{
    key: "set",
    value: function set(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (!protocols) {
        log.error('protocols must be provided to store data');
        throw errcode(new Error('protocols must be provided'), ERR_INVALID_PARAMETERS);
      }

      var id = peerId.toB58String();
      var recSet = this.data.get(id);
      var newSet = new Set(protocols);
      /**
       * @param {Set<string>} a
       * @param {Set<string>} b
       */

      var isSetEqual = function isSetEqual(a, b) {
        return a.size === b.size && _toConsumableArray(a).every(function (value) {
          return b.has(value);
        });
      }; // Already knows the peer and the recorded protocols are the same?
      // If yes, no changes needed!


      if (recSet && isSetEqual(recSet, newSet)) {
        log("the protocols provided to store are equal to the already stored for ".concat(id));
        return this;
      }

      this._setData(peerId, newSet);

      log("stored provided protocols for ".concat(id));
      return this;
    }
    /**
     * Adds known protocols of a provided peer.
     * If the peer was not known before, it will be added.
     *
     * @param {PeerId} peerId
     * @param {string[]} protocols
     * @returns {ProtoBook}
     */

  }, {
    key: "add",
    value: function add(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (!protocols) {
        log.error('protocols must be provided to store data');
        throw errcode(new Error('protocols must be provided'), ERR_INVALID_PARAMETERS);
      }

      var id = peerId.toB58String();
      var recSet = this.data.get(id) || new Set();
      var newSet = new Set([].concat(_toConsumableArray(recSet), _toConsumableArray(protocols))); // Set Union
      // Any new protocol added?

      if (recSet.size === newSet.size) {
        log("the protocols provided to store are already stored for ".concat(id));
        return this;
      }

      this._setData(peerId, newSet);

      log("added provided protocols for ".concat(id));
      return this;
    }
    /**
     * Removes known protocols of a provided peer.
     * If the protocols did not exist before, nothing will be done.
     *
     * @param {PeerId} peerId
     * @param {string[]} protocols
     * @returns {ProtoBook}
     */

  }, {
    key: "remove",
    value: function remove(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error('peerId must be an instance of peer-id to store data');
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      if (!protocols) {
        log.error('protocols must be provided to store data');
        throw errcode(new Error('protocols must be provided'), ERR_INVALID_PARAMETERS);
      }

      var id = peerId.toB58String();
      var recSet = this.data.get(id);

      if (recSet) {
        var newSet = new Set(_toConsumableArray(recSet).filter(function (p) {
          return !protocols.includes(p);
        })); // Any protocol removed?

        if (recSet.size === newSet.size) {
          return this;
        }

        this._setData(peerId, newSet);

        log("removed provided protocols for ".concat(id));
      }

      return this;
    }
  }]);

  return ProtoBook;
}(Book);

module.exports = ProtoBook;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","peer-id":"node_modules/peer-id/src/index.js","./book":"node_modules/libp2p/src/peer-store/book.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/peer-store/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var errcode = require('err-code');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var PeerId = require('peer-id');

var AddressBook = require('./address-book');

var KeyBook = require('./key-book');

var MetadataBook = require('./metadata-book');

var ProtoBook = require('./proto-book');

var _require2 = require('../errors'),
    ERR_INVALID_PARAMETERS = _require2.codes.ERR_INVALID_PARAMETERS;
/**
 * @typedef {import('./address-book').Address} Address
 */

/**
 * @extends {EventEmitter}
 *
 * @fires PeerStore#peer Emitted when a new peer is added.
 * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.
 * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.
 * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.
 * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.
 */


var PeerStore = /*#__PURE__*/function (_EventEmitter) {
  _inherits(PeerStore, _EventEmitter);

  var _super = _createSuper(PeerStore);

  /**
   * Peer object
   *
   * @typedef {Object} Peer
   * @property {PeerId} id peer's peer-id instance.
   * @property {Address[]} addresses peer's addresses containing its multiaddrs and metadata.
   * @property {string[]} protocols peer's supported protocols.
   * @property {Map<string, Uint8Array>|undefined} metadata peer's metadata map.
   */

  /**
   * Responsible for managing known peers, as well as their addresses, protocols and metadata.
   *
   * @param {object} options
   * @param {PeerId} options.peerId
   * @class
   */
  function PeerStore(_ref) {
    var _this;

    var peerId = _ref.peerId;

    _classCallCheck(this, PeerStore);

    _this = _super.call(this);
    _this._peerId = peerId;
    /**
     * AddressBook containing a map of peerIdStr to Address.
     */

    _this.addressBook = new AddressBook(_assertThisInitialized(_this));
    /**
     * KeyBook containing a map of peerIdStr to their PeerId with public keys.
     */

    _this.keyBook = new KeyBook(_assertThisInitialized(_this));
    /**
     * MetadataBook containing a map of peerIdStr to their metadata Map.
     */

    _this.metadataBook = new MetadataBook(_assertThisInitialized(_this));
    /**
     * ProtoBook containing a map of peerIdStr to supported protocols.
     */

    _this.protoBook = new ProtoBook(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Start the PeerStore.
   */


  _createClass(PeerStore, [{
    key: "start",
    value: function start() {}
    /**
     * Stop the PeerStore.
     */

  }, {
    key: "stop",
    value: function stop() {}
    /**
     * Get all the stored information of every peer known.
     *
     * @returns {Map<string, Peer>}
     */

  }, {
    key: "peers",
    get: function get() {
      var _this2 = this;

      var storedPeers = new Set([].concat(_toConsumableArray(this.addressBook.data.keys()), _toConsumableArray(this.keyBook.data.keys()), _toConsumableArray(this.protoBook.data.keys()), _toConsumableArray(this.metadataBook.data.keys()))); // Remove self peer if present

      this._peerId && storedPeers.delete(this._peerId.toB58String());
      var peersData = new Map();
      storedPeers.forEach(function (idStr) {
        peersData.set(idStr, _this2.get(PeerId.createFromB58String(idStr)));
      });
      return peersData;
    }
    /**
     * Delete the information of the given peer in every book.
     *
     * @param {PeerId} peerId
     * @returns {boolean} true if found and removed
     */

  }, {
    key: "delete",
    value: function _delete(peerId) {
      var addressesDeleted = this.addressBook.delete(peerId);
      var keyDeleted = this.keyBook.delete(peerId);
      var protocolsDeleted = this.protoBook.delete(peerId);
      var metadataDeleted = this.metadataBook.delete(peerId);
      return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;
    }
    /**
     * Get the stored information of a given peer.
     *
     * @param {PeerId} peerId
     * @returns {Peer|undefined}
     */

  }, {
    key: "get",
    value: function get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);
      }

      var id = this.keyBook.data.get(peerId.toB58String());
      var addresses = this.addressBook.get(peerId);
      var metadata = this.metadataBook.get(peerId);
      var protocols = this.protoBook.get(peerId);

      if (!id && !addresses && !metadata && !protocols) {
        return undefined;
      }

      return {
        id: id || peerId,
        addresses: addresses || [],
        protocols: protocols || [],
        metadata: metadata
      };
    }
  }]);

  return PeerStore;
}(EventEmitter);

module.exports = PeerStore;
},{"err-code":"node_modules/err-code/index.js","events":"node_modules/events/events.js","peer-id":"node_modules/peer-id/src/index.js","./address-book":"node_modules/libp2p/src/peer-store/address-book.js","./key-book":"node_modules/libp2p/src/peer-store/key-book.js","./metadata-book":"node_modules/libp2p/src/peer-store/metadata-book.js","./proto-book":"node_modules/libp2p/src/peer-store/proto-book.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/libp2p/src/pubsub-adapter.js":[function(require,module,exports) {
'use strict'; // Pubsub adapter to keep API with handlers while not removed.

/**
 * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} InMessage
 * @typedef {import('libp2p-interfaces/src/pubsub')} PubsubRouter
 */

/**
 * @param {{new(...args: any[]): PubsubRouter}} PubsubRouter
 * @param {import('.')} libp2p
 * @param {{ enabled: boolean; } & import(".").PubsubLocalOptions & import("libp2p-interfaces/src/pubsub").PubsubOptions} options
 */

function pubsubAdapter(PubsubRouter, libp2p, options) {
  /** @type {PubsubRouter & { _subscribeAdapter: PubsubRouter['subscribe'], _unsubscribeAdapter: PubsubRouter['unsubscribe'] }} */
  // @ts-ignore we set the extra _subscribeAdapter and _unsubscribeAdapter properties afterwards
  var pubsub = new PubsubRouter(libp2p, options);
  pubsub._subscribeAdapter = pubsub.subscribe;
  pubsub._unsubscribeAdapter = pubsub.unsubscribe;
  /**
   * Subscribes to a given topic.
   *
   * @override
   * @param {string} topic
   * @param {(msg: InMessage) => void} [handler]
   * @returns {void}
   */

  function subscribe(topic, handler) {
    // Bind provided handler
    handler && pubsub.on(topic, handler);

    pubsub._subscribeAdapter(topic);
  }
  /**
   * Unsubscribe from the given topic.
   *
   * @override
   * @param {string} topic
   * @param {(msg: InMessage) => void} [handler]
   * @returns {void}
   */


  function unsubscribe(topic, handler) {
    if (!handler) {
      pubsub.removeAllListeners(topic);
    } else {
      pubsub.removeListener(topic, handler);
    }

    if (pubsub.listenerCount(topic) === 0) {
      pubsub._unsubscribeAdapter(topic);
    }
  }

  pubsub.subscribe = subscribe;
  pubsub.unsubscribe = unsubscribe;
  return pubsub;
}

module.exports = pubsubAdapter;
},{}],"node_modules/libp2p/src/peer-store/persistent/consts.js":[function(require,module,exports) {
'use strict';

module.exports.NAMESPACE_COMMON = '/peers/'; // /peers/protos/<b32 peer id no padding>

module.exports.NAMESPACE_ADDRESS = '/peers/addrs/'; // /peers/keys/<b32 peer id no padding>

module.exports.NAMESPACE_KEYS = '/peers/keys/'; // /peers/metadata/<b32 peer id no padding>/<key>

module.exports.NAMESPACE_METADATA = '/peers/metadata/'; // /peers/addrs/<b32 peer id no padding>

module.exports.NAMESPACE_PROTOCOL = '/peers/protos/';
},{}],"node_modules/libp2p/src/peer-store/persistent/pb/address-book.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-address-book"] || ($protobuf.roots["libp2p-address-book"] = {});

$root.Addresses = function () {
  /**
   * Properties of an Addresses.
   * @exports IAddresses
   * @interface IAddresses
   * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs
   * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord
   */

  /**
   * Constructs a new Addresses.
   * @exports Addresses
   * @classdesc Represents an Addresses.
   * @implements IAddresses
   * @constructor
   * @param {IAddresses=} [p] Properties to set
   */
  function Addresses(p) {
    this.addrs = [];
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Addresses addrs.
   * @member {Array.<Addresses.IAddress>} addrs
   * @memberof Addresses
   * @instance
   */


  Addresses.prototype.addrs = $util.emptyArray;
  /**
   * Addresses certifiedRecord.
   * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord
   * @memberof Addresses
   * @instance
   */

  Addresses.prototype.certifiedRecord = null;
  /**
   * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.
   * @function encode
   * @memberof Addresses
   * @static
   * @param {IAddresses} m Addresses message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Addresses.encode = function encode(m, w) {
    if (!w) w = $Writer.create();

    if (m.addrs != null && m.addrs.length) {
      for (var i = 0; i < m.addrs.length; ++i) {
        $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
      }
    }

    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord")) $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  /**
   * Decodes an Addresses message from the specified reader or buffer.
   * @function decode
   * @memberof Addresses
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Addresses} Addresses
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Addresses.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Addresses();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length)) m.addrs = [];
          m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));
          break;

        case 2:
          m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates an Addresses message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Addresses
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Addresses} Addresses
   */


  Addresses.fromObject = function fromObject(d) {
    if (d instanceof $root.Addresses) return d;
    var m = new $root.Addresses();

    if (d.addrs) {
      if (!Array.isArray(d.addrs)) throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];

      for (var i = 0; i < d.addrs.length; ++i) {
        if (_typeof(d.addrs[i]) !== "object") throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);
      }
    }

    if (d.certifiedRecord != null) {
      if (_typeof(d.certifiedRecord) !== "object") throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }

    return m;
  };
  /**
   * Creates a plain object from an Addresses message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Addresses
   * @static
   * @param {Addresses} m Addresses
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Addresses.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.arrays || o.defaults) {
      d.addrs = [];
    }

    if (o.defaults) {
      d.certifiedRecord = null;
    }

    if (m.addrs && m.addrs.length) {
      d.addrs = [];

      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);
      }
    }

    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }

    return d;
  };
  /**
   * Converts this Addresses to JSON.
   * @function toJSON
   * @memberof Addresses
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Addresses.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  Addresses.Address = function () {
    /**
     * Properties of an Address.
     * @memberof Addresses
     * @interface IAddress
     * @property {Uint8Array|null} [multiaddr] Address multiaddr
     * @property {boolean|null} [isCertified] Address isCertified
     */

    /**
     * Constructs a new Address.
     * @memberof Addresses
     * @classdesc Represents an Address.
     * @implements IAddress
     * @constructor
     * @param {Addresses.IAddress=} [p] Properties to set
     */
    function Address(p) {
      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
      }
    }
    /**
     * Address multiaddr.
     * @member {Uint8Array} multiaddr
     * @memberof Addresses.Address
     * @instance
     */


    Address.prototype.multiaddr = $util.newBuffer([]);
    /**
     * Address isCertified.
     * @member {boolean} isCertified
     * @memberof Addresses.Address
     * @instance
     */

    Address.prototype.isCertified = false;
    /**
     * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.
     * @function encode
     * @memberof Addresses.Address
     * @static
     * @param {Addresses.IAddress} m Address message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */

    Address.encode = function encode(m, w) {
      if (!w) w = $Writer.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr")) w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified")) w.uint32(16).bool(m.isCertified);
      return w;
    };
    /**
     * Decodes an Address message from the specified reader or buffer.
     * @function decode
     * @memberof Addresses.Address
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Addresses.Address} Address
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */


    Address.decode = function decode(r, l) {
      if (!(r instanceof $Reader)) r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l,
          m = new $root.Addresses.Address();

      while (r.pos < c) {
        var t = r.uint32();

        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;

          case 2:
            m.isCertified = r.bool();
            break;

          default:
            r.skipType(t & 7);
            break;
        }
      }

      return m;
    };
    /**
     * Creates an Address message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Addresses.Address
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Addresses.Address} Address
     */


    Address.fromObject = function fromObject(d) {
      if (d instanceof $root.Addresses.Address) return d;
      var m = new $root.Addresses.Address();

      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;
      }

      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }

      return m;
    };
    /**
     * Creates a plain object from an Address message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Addresses.Address
     * @static
     * @param {Addresses.Address} m Address
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */


    Address.toObject = function toObject(m, o) {
      if (!o) o = {};
      var d = {};

      if (o.defaults) {
        if (o.bytes === String) d.multiaddr = "";else {
          d.multiaddr = [];
          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);
        }
        d.isCertified = false;
      }

      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }

      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
      }

      return d;
    };
    /**
     * Converts this Address to JSON.
     * @function toJSON
     * @memberof Addresses.Address
     * @instance
     * @returns {Object.<string,*>} JSON object
     */


    Address.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Address;
  }();

  Addresses.CertifiedRecord = function () {
    /**
     * Properties of a CertifiedRecord.
     * @memberof Addresses
     * @interface ICertifiedRecord
     * @property {number|null} [seq] CertifiedRecord seq
     * @property {Uint8Array|null} [raw] CertifiedRecord raw
     */

    /**
     * Constructs a new CertifiedRecord.
     * @memberof Addresses
     * @classdesc Represents a CertifiedRecord.
     * @implements ICertifiedRecord
     * @constructor
     * @param {Addresses.ICertifiedRecord=} [p] Properties to set
     */
    function CertifiedRecord(p) {
      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
      }
    }
    /**
     * CertifiedRecord seq.
     * @member {number} seq
     * @memberof Addresses.CertifiedRecord
     * @instance
     */


    CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CertifiedRecord raw.
     * @member {Uint8Array} raw
     * @memberof Addresses.CertifiedRecord
     * @instance
     */

    CertifiedRecord.prototype.raw = $util.newBuffer([]);
    /**
     * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.
     * @function encode
     * @memberof Addresses.CertifiedRecord
     * @static
     * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */

    CertifiedRecord.encode = function encode(m, w) {
      if (!w) w = $Writer.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq")) w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw")) w.uint32(18).bytes(m.raw);
      return w;
    };
    /**
     * Decodes a CertifiedRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Addresses.CertifiedRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Addresses.CertifiedRecord} CertifiedRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */


    CertifiedRecord.decode = function decode(r, l) {
      if (!(r instanceof $Reader)) r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l,
          m = new $root.Addresses.CertifiedRecord();

      while (r.pos < c) {
        var t = r.uint32();

        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;

          case 2:
            m.raw = r.bytes();
            break;

          default:
            r.skipType(t & 7);
            break;
        }
      }

      return m;
    };
    /**
     * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Addresses.CertifiedRecord
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Addresses.CertifiedRecord} CertifiedRecord
     */


    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root.Addresses.CertifiedRecord) return d;
      var m = new $root.Addresses.CertifiedRecord();

      if (d.seq != null) {
        if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === "string") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === "number") m.seq = d.seq;else if (_typeof(d.seq) === "object") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }

      if (d.raw != null) {
        if (typeof d.raw === "string") $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);else if (d.raw.length) m.raw = d.raw;
      }

      return m;
    };
    /**
     * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Addresses.CertifiedRecord
     * @static
     * @param {Addresses.CertifiedRecord} m CertifiedRecord
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */


    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o) o = {};
      var d = {};

      if (o.defaults) {
        if ($util.Long) {
          var n = new $util.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else d.seq = o.longs === String ? "0" : 0;

        if (o.bytes === String) d.raw = "";else {
          d.raw = [];
          if (o.bytes !== Array) d.raw = $util.newBuffer(d.raw);
        }
      }

      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }

      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }

      return d;
    };
    /**
     * Converts this CertifiedRecord to JSON.
     * @function toJSON
     * @memberof Addresses.CertifiedRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */


    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CertifiedRecord;
  }();

  return Addresses;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-proto-book"] || ($protobuf.roots["libp2p-proto-book"] = {});

$root.Protocols = function () {
  /**
   * Properties of a Protocols.
   * @exports IProtocols
   * @interface IProtocols
   * @property {Array.<string>|null} [protocols] Protocols protocols
   */

  /**
   * Constructs a new Protocols.
   * @exports Protocols
   * @classdesc Represents a Protocols.
   * @implements IProtocols
   * @constructor
   * @param {IProtocols=} [p] Properties to set
   */
  function Protocols(p) {
    this.protocols = [];
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Protocols protocols.
   * @member {Array.<string>} protocols
   * @memberof Protocols
   * @instance
   */


  Protocols.prototype.protocols = $util.emptyArray;
  /**
   * Encodes the specified Protocols message. Does not implicitly {@link Protocols.verify|verify} messages.
   * @function encode
   * @memberof Protocols
   * @static
   * @param {IProtocols} m Protocols message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Protocols.encode = function encode(m, w) {
    if (!w) w = $Writer.create();

    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i) {
        w.uint32(10).string(m.protocols[i]);
      }
    }

    return w;
  };
  /**
   * Decodes a Protocols message from the specified reader or buffer.
   * @function decode
   * @memberof Protocols
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Protocols} Protocols
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Protocols.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Protocols();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length)) m.protocols = [];
          m.protocols.push(r.string());
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a Protocols message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Protocols
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Protocols} Protocols
   */


  Protocols.fromObject = function fromObject(d) {
    if (d instanceof $root.Protocols) return d;
    var m = new $root.Protocols();

    if (d.protocols) {
      if (!Array.isArray(d.protocols)) throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];

      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }

    return m;
  };
  /**
   * Creates a plain object from a Protocols message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Protocols
   * @static
   * @param {Protocols} m Protocols
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Protocols.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.arrays || o.defaults) {
      d.protocols = [];
    }

    if (m.protocols && m.protocols.length) {
      d.protocols = [];

      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }

    return d;
  };
  /**
   * Converts this Protocols to JSON.
   * @function toJSON
   * @memberof Protocols
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Protocols.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return Protocols;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p/src/peer-store/persistent/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var debug = require('debug');

var log = Object.assign(debug('libp2p:persistent-peer-store'), {
  error: debug('libp2p:persistent-peer-store:err')
});

var _require = require('interface-datastore'),
    Key = _require.Key;

var _require2 = require('multiaddr'),
    Multiaddr = _require2.Multiaddr;

var PeerId = require('peer-id');

var _require3 = require('multiformats/bases/base32'),
    base32 = _require3.base32;

var PeerStore = require('..');

var _require4 = require('./consts'),
    NAMESPACE_ADDRESS = _require4.NAMESPACE_ADDRESS,
    NAMESPACE_COMMON = _require4.NAMESPACE_COMMON,
    NAMESPACE_KEYS = _require4.NAMESPACE_KEYS,
    NAMESPACE_METADATA = _require4.NAMESPACE_METADATA,
    NAMESPACE_PROTOCOL = _require4.NAMESPACE_PROTOCOL;

var _require5 = require('./pb/address-book'),
    Addresses = _require5.Addresses;

var _require6 = require('./pb/proto-book'),
    Protocols = _require6.Protocols;
/**
 * @typedef {import('interface-datastore').Batch} Batch
 * @typedef {import('../address-book.js').Address} Address
 */

/**
 * @typedef {Object} PersistentPeerStoreProperties
 * @property {PeerId} peerId
 * @property {import('interface-datastore').Datastore} datastore
 *
 * @typedef {Object} PersistentPeerStoreOptions
 * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.
 */

/**
 * Responsible for managing the persistence of data in the PeerStore.
 */


var PersistentPeerStore = /*#__PURE__*/function (_PeerStore) {
  _inherits(PersistentPeerStore, _PeerStore);

  var _super = _createSuper(PersistentPeerStore);

  /**
   * @class
   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties
   */
  function PersistentPeerStore(_ref) {
    var _this;

    var peerId = _ref.peerId,
        datastore = _ref.datastore,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? 5 : _ref$threshold;

    _classCallCheck(this, PersistentPeerStore);

    _this = _super.call(this, {
      peerId: peerId
    });
    /**
     * Backend datastore used to persist data.
     */

    _this._datastore = datastore;
    /**
     * Peers modified after the latest data persisted.
     */

    _this._dirtyPeers = new Set();
    /**
     * Peers metadata changed mapping peer identifers to metadata changed.
     *
     * @type {Map<string, Set<string>>}
     */

    _this._dirtyMetadata = new Map();
    _this.threshold = threshold;
    _this._addDirtyPeer = _this._addDirtyPeer.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Start Persistent PeerStore.
   *
   * @returns {Promise<void>}
   */


  _createClass(PersistentPeerStore, [{
    key: "start",
    value: function () {
      var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                log('PeerStore is starting'); // Handlers for dirty peers

                this.on('change:protocols', this._addDirtyPeer);
                this.on('change:multiaddrs', this._addDirtyPeer);
                this.on('change:pubkey', this._addDirtyPeerKey);
                this.on('change:metadata', this._addDirtyPeerMetadata); // Load data

                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context.prev = 7;
                _iterator = _asyncIterator(this._datastore.query({
                  prefix: NAMESPACE_COMMON
                }));

              case 9:
                _context.next = 11;
                return _iterator.next();

              case 11:
                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                  _context.next = 18;
                  break;
                }

                entry = _step.value;
                _context.next = 15;
                return this._processDatastoreEntry(entry);

              case 15:
                _iteratorAbruptCompletion = false;
                _context.next = 9;
                break;

              case 18:
                _context.next = 24;
                break;

              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](7);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 24:
                _context.prev = 24;
                _context.prev = 25;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context.next = 29;
                  break;
                }

                _context.next = 29;
                return _iterator.return();

              case 29:
                _context.prev = 29;

                if (!_didIteratorError) {
                  _context.next = 32;
                  break;
                }

                throw _iteratorError;

              case 32:
                return _context.finish(29);

              case 33:
                return _context.finish(24);

              case 34:
                log('PeerStore started');

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 20, 24, 34], [25,, 29, 33]]);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
    /**
     * Stop Persistent PeerStore.
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                log('PeerStore is stopping');
                this.removeAllListeners();
                _context2.next = 4;
                return this._commitData();

              case 4:
                log('PeerStore stopped');

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Add modified peer to the dirty set
     *
     * @private
     * @param {Object} params
     * @param {PeerId} params.peerId
     */

  }, {
    key: "_addDirtyPeer",
    value: function _addDirtyPeer(_ref2) {
      var peerId = _ref2.peerId;
      var peerIdstr = peerId.toB58String();
      log('add dirty peer', peerIdstr);

      this._dirtyPeers.add(peerIdstr);

      if (this._dirtyPeers.size >= this.threshold) {
        // Commit current data
        this._commitData().catch(function (err) {
          log.error('error committing data', err);
        });
      }
    }
    /**
     * Add modified peer key to the dirty set
     *
     * @private
     * @param {Object} params
     * @param {PeerId} params.peerId
     */

  }, {
    key: "_addDirtyPeerKey",
    value: function _addDirtyPeerKey(_ref3) {
      var peerId = _ref3.peerId;

      // Not add if inline key available
      if (peerId.hasInlinePublicKey()) {
        return;
      }

      var peerIdstr = peerId.toB58String();
      log('add dirty peer key', peerIdstr);

      this._dirtyPeers.add(peerIdstr);

      if (this._dirtyPeers.size >= this.threshold) {
        // Commit current data
        this._commitData().catch(function (err) {
          log.error('error committing data', err);
        });
      }
    }
    /**
     * Add modified metadata peer to the set.
     *
     * @private
     * @param {Object} params
     * @param {PeerId} params.peerId
     * @param {string} params.metadata
     */

  }, {
    key: "_addDirtyPeerMetadata",
    value: function _addDirtyPeerMetadata(_ref4) {
      var peerId = _ref4.peerId,
          metadata = _ref4.metadata;
      var peerIdstr = peerId.toB58String();
      log('add dirty metadata peer', peerIdstr);

      this._dirtyPeers.add(peerIdstr); // Add dirty metadata key


      var mData = this._dirtyMetadata.get(peerIdstr) || new Set();
      mData.add(metadata);

      this._dirtyMetadata.set(peerIdstr, mData);

      if (this._dirtyPeers.size >= this.threshold) {
        // Commit current data
        this._commitData().catch(function (err) {
          log.error('error committing data', err);
        });
      }
    }
    /**
     * Add all the peers current data to a datastore batch and commit it.
     *
     * @private
     * @returns {Promise<void>}
     */

  }, {
    key: "_commitData",
    value: function () {
      var _commitData2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var commitPeers, batch, _i, _commitPeers, peerIdStr, peerId;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                commitPeers = Array.from(this._dirtyPeers);

                if (commitPeers.length) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                // Clear Dirty Peers set
                this._dirtyPeers.clear();

                log('create batch commit');
                batch = this._datastore.batch();

                for (_i = 0, _commitPeers = commitPeers; _i < _commitPeers.length; _i++) {
                  peerIdStr = _commitPeers[_i];
                  // PeerId
                  peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr); // Address Book

                  this._batchAddressBook(peerId, batch); // Key Book


                  !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch); // Metadata Book

                  this._batchMetadataBook(peerId, batch); // Proto Book


                  this._batchProtoBook(peerId, batch);
                }

                _context3.next = 9;
                return batch.commit();

              case 9:
                log('batch committed');

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _commitData() {
        return _commitData2.apply(this, arguments);
      }

      return _commitData;
    }()
    /**
     * Add address book data of the peer to the batch.
     *
     * @private
     * @param {PeerId} peerId
     * @param {Batch} batch
     */

  }, {
    key: "_batchAddressBook",
    value: function _batchAddressBook(peerId, batch) {
      var b32key = peerId.toString();
      var key = new Key("".concat(NAMESPACE_ADDRESS).concat(b32key));
      var entry = this.addressBook.data.get(peerId.toB58String());

      try {
        // Deleted from the book
        if (!entry) {
          batch.delete(key);
          return;
        }

        var encodedData = Addresses.encode({
          addrs: entry.addresses.map(function (address) {
            return {
              multiaddr: address.multiaddr.bytes,
              isCertified: address.isCertified
            };
          }),
          certifiedRecord: entry.record ? {
            seq: entry.record.seqNumber,
            raw: entry.record.raw
          } : undefined
        }).finish();
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    /**
     * Add Key book data of the peer to the batch.
     *
     * @private
     * @param {PeerId} peerId
     * @param {Batch} batch
     */

  }, {
    key: "_batchKeyBook",
    value: function _batchKeyBook(peerId, batch) {
      var b32key = peerId.toString();
      var key = new Key("".concat(NAMESPACE_KEYS).concat(b32key));

      try {
        // Deleted from the book
        if (!peerId.pubKey) {
          batch.delete(key);
          return;
        }

        var encodedData = peerId.marshalPubKey();
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    /**
     * Add metadata book data of the peer to the batch.
     *
     * @private
     * @param {PeerId} peerId
     * @param {Batch} batch
     */

  }, {
    key: "_batchMetadataBook",
    value: function _batchMetadataBook(peerId, batch) {
      var _this2 = this;

      var b32key = peerId.toString();
      var dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];

      try {
        dirtyMetada.forEach(function (
        /** @type {string} */
        dirtyKey) {
          var key = new Key("".concat(NAMESPACE_METADATA).concat(b32key, "/").concat(dirtyKey));

          var dirtyValue = _this2.metadataBook.getValue(peerId, dirtyKey);

          if (dirtyValue) {
            batch.put(key, dirtyValue);
          } else {
            batch.delete(key);
          }
        });
      } catch (err) {
        log.error(err);
      }
    }
    /**
     * Add proto book data of the peer to the batch.
     *
     * @private
     * @param {PeerId} peerId
     * @param {Batch} batch
     */

  }, {
    key: "_batchProtoBook",
    value: function _batchProtoBook(peerId, batch) {
      var b32key = peerId.toString();
      var key = new Key("".concat(NAMESPACE_PROTOCOL).concat(b32key));
      var protocols = this.protoBook.get(peerId);

      try {
        // Deleted from the book
        if (!protocols) {
          batch.delete(key);
          return;
        }

        var encodedData = Protocols.encode({
          protocols: protocols
        }).finish();
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    /**
     * Process datastore entry and add its data to the correct book.
     *
     * @private
     * @param {Object} params
     * @param {Key} params.key - datastore key
     * @param {Uint8Array} params.value - datastore value stored
     * @returns {Promise<void>}
     */

  }, {
    key: "_processDatastoreEntry",
    value: function () {
      var _processDatastoreEntry2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref5) {
        var key, value, keyParts, peerId, decoded;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                key = _ref5.key, value = _ref5.value;
                _context4.prev = 1;
                keyParts = key.toString().split('/');
                peerId = PeerId.createFromBytes(base32.decode(keyParts[3]));
                _context4.t0 = keyParts[2];
                _context4.next = _context4.t0 === 'addrs' ? 7 : _context4.t0 === 'keys' ? 10 : _context4.t0 === 'metadata' ? 15 : _context4.t0 === 'protos' ? 17 : 20;
                break;

              case 7:
                decoded = Addresses.decode(value); // @ts-ignore protected function

                this.addressBook._setData(peerId, {
                  addresses: decoded.addrs.map(function (address) {
                    return {
                      multiaddr: new Multiaddr(address.multiaddr),
                      isCertified: Boolean(address.isCertified)
                    };
                  }),
                  record: decoded.certifiedRecord ? {
                    raw: decoded.certifiedRecord.raw,
                    seqNumber: decoded.certifiedRecord.seq
                  } : undefined
                }, {
                  emit: false
                });

                return _context4.abrupt("break", 21);

              case 10:
                _context4.next = 12;
                return PeerId.createFromPubKey(value);

              case 12:
                decoded = _context4.sent;

                // @ts-ignore protected function
                this.keyBook._setData(decoded, decoded, {
                  emit: false
                });

                return _context4.abrupt("break", 21);

              case 15:
                this.metadataBook._setValue(peerId, keyParts[4], value, {
                  emit: false
                });

                return _context4.abrupt("break", 21);

              case 17:
                decoded = Protocols.decode(value); // @ts-ignore protected function

                this.protoBook._setData(peerId, new Set(decoded.protocols), {
                  emit: false
                });

                return _context4.abrupt("break", 21);

              case 20:
                log('invalid data persisted for: ', key.toString());

              case 21:
                _context4.next = 26;
                break;

              case 23:
                _context4.prev = 23;
                _context4.t1 = _context4["catch"](1);
                log.error(_context4.t1);

              case 26:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 23]]);
      }));

      function _processDatastoreEntry(_x) {
        return _processDatastoreEntry2.apply(this, arguments);
      }

      return _processDatastoreEntry;
    }()
  }]);

  return PersistentPeerStore;
}(PeerStore);

module.exports = PersistentPeerStore;
},{"debug":"node_modules/debug/src/browser.js","interface-datastore":"node_modules/interface-datastore/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","peer-id":"node_modules/peer-id/src/index.js","multiformats/bases/base32":"node_modules/multiformats/cjs/src/bases/base32.js","..":"node_modules/libp2p/src/peer-store/index.js","./consts":"node_modules/libp2p/src/peer-store/persistent/consts.js","./pb/address-book":"node_modules/libp2p/src/peer-store/persistent/pb/address-book.js","./pb/proto-book":"node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js"}],"node_modules/libp2p-interfaces/src/topology/index.js":[function(require,module,exports) {
'use strict'

const noop = () => {}
const topologySymbol = Symbol.for('@libp2p/js-interfaces/topology')

/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * @typedef {Object} Options
 * @property {number} [min=0] - minimum needed connections.
 * @property {number} [max=Infinity] - maximum needed connections.
 * @property {Handlers} [handlers]
 *
 * @typedef {Object} Handlers
 * @property {(peerId: PeerId, conn: Connection) => void} [onConnect] - protocol "onConnect" handler
 * @property {(peerId: PeerId, error?:Error) => void} [onDisconnect] - protocol "onDisconnect" handler
 *
 * @typedef {import('../connection/connection')} Connection
 */

class Topology {
  /**
   * @param {Options} options
   */
  constructor ({
    min = 0,
    max = Infinity,
    handlers = {}
  }) {
    this.min = min
    this.max = max

    // Handlers
    this._onConnect = handlers.onConnect || noop
    this._onDisconnect = handlers.onDisconnect || noop

    /**
     * Set of peers that support the protocol.
     *
     * @type {Set<string>}
     */
    this.peers = new Set()
  }

  get [Symbol.toStringTag] () {
    return 'Topology'
  }

  get [topologySymbol] () {
    return true
  }

  /**
   * Checks if the given value is a Topology instance.
   *
   * @param {any} other
   * @returns {other is Topology}
   */
  static isTopology (other) {
    return Boolean(other && other[topologySymbol])
  }

  /**
   * @param {any} registrar
   */
  set registrar (registrar) { // eslint-disable-line
    this._registrar = registrar
  }

  /**
   * Notify about peer disconnected event.
   *
   * @param {PeerId} peerId
   * @returns {void}
   */
  disconnect (peerId) {
    this._onDisconnect(peerId)
  }
}

module.exports = Topology

},{}],"node_modules/libp2p/src/registrar.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:registrar'), {
  error: debug('libp2p:registrar:err')
});

var errcode = require('err-code');

var _require = require('./errors'),
    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;

var Topology = require('libp2p-interfaces/src/topology');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('./peer-store')} PeerStore
 * @typedef {import('./connection-manager')} ConnectionManager
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('./').HandlerProps} HandlerProps
 */

/**
 *
 */

/**
 * Responsible for notifying registered protocols of events in the network.
 */


var Registrar = /*#__PURE__*/function () {
  /**
   * @param {Object} props
   * @param {PeerStore} props.peerStore
   * @param {ConnectionManager} props.connectionManager
   * @class
   */
  function Registrar(_ref) {
    var peerStore = _ref.peerStore,
        connectionManager = _ref.connectionManager;

    _classCallCheck(this, Registrar);

    // Used on topology to listen for protocol changes
    this.peerStore = peerStore;
    this.connectionManager = connectionManager;
    /**
     * Map of topologies
     *
     * @type {Map<string, Topology>}
     */

    this.topologies = new Map();
    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */
    // @ts-ignore handle is not optional

    this._handle = undefined;
    this._onDisconnect = this._onDisconnect.bind(this);
    this.connectionManager.on('peer:disconnect', this._onDisconnect);
  }
  /**
   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}
   */


  _createClass(Registrar, [{
    key: "handle",
    get: function get() {
      return this._handle;
    }
    /**
     * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle
     */
    ,
    set: function set(handle) {
      this._handle = handle;
    }
    /**
     * Get a connection with a peer.
     *
     * @param {PeerId} peerId
     * @returns {Connection | null}
     */

  }, {
    key: "getConnection",
    value: function getConnection(peerId) {
      return this.connectionManager.get(peerId);
    }
    /**
     * Register handlers for a set of multicodecs given
     *
     * @param {Topology} topology - protocol topology
     * @returns {string} registrar identifier
     */

  }, {
    key: "register",
    value: function register(topology) {
      if (!Topology.isTopology(topology)) {
        log.error('topology must be an instance of interfaces/topology');
        throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);
      } // Create topology


      var id = (Math.random() * 1e9).toString(36) + Date.now();
      this.topologies.set(id, topology); // Set registrar

      topology.registrar = this;
      return id;
    }
    /**
     * Unregister topology.
     *
     * @param {string} id - registrar identifier
     * @returns {boolean} unregistered successfully
     */

  }, {
    key: "unregister",
    value: function unregister(id) {
      return this.topologies.delete(id);
    }
    /**
     * Remove a disconnected peer from the record
     *
     * @param {Connection} connection
     * @returns {void}
     */

  }, {
    key: "_onDisconnect",
    value: function _onDisconnect(connection) {
      var _iterator = _createForOfIteratorHelper(this.topologies),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              topology = _step$value[1];

          topology.disconnect(connection.remotePeer);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return Registrar;
}();

module.exports = Registrar;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","./errors":"node_modules/libp2p/src/errors.js","libp2p-interfaces/src/topology":"node_modules/libp2p-interfaces/src/topology/index.js"}],"node_modules/it-buffer/index.js":[function(require,module,exports) {

'use strict'

const { Buffer } = require('buffer')
const BufferList = require('bl/BufferList')

module.exports = async function * (source) {
  for await (const b of source) {
    if (Buffer.isBuffer(b)) {
      yield b
    } else if (BufferList.isBufferList(b)) {
      yield b.slice()
    } else {
      yield Buffer.from(b)
    }
  }
}

module.exports.toBuffer = module.exports

module.exports.toList = async function * (source) {
  for await (const b of source) {
    if (Buffer.isBuffer(b)) {
      yield new BufferList().append(b)
    } else if (BufferList.isBufferList(b)) {
      yield b
    } else {
      yield new BufferList().append(Buffer.from(b))
    }
  }
}

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","bl/BufferList":"node_modules/bl/BufferList.js"}],"node_modules/libp2p/src/ping/constants.js":[function(require,module,exports) {
'use strict';

module.exports = {
  PROTOCOL: '/ipfs/ping/1.0.0',
  // deprecated
  PING_LENGTH: 32,
  PROTOCOL_VERSION: '1.0.0',
  PROTOCOL_NAME: 'ping'
};
},{}],"node_modules/libp2p/src/ping/index.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:ping'), {
  error: debug('libp2p:ping:err')
});

var errCode = require('err-code');

var crypto = require('libp2p-crypto');

var _require = require('it-pipe'),
    pipe = _require.pipe; // @ts-ignore it-buffer has no types exported


var _require2 = require('it-buffer'),
    toBuffer = _require2.toBuffer;

var _require3 = require('streaming-iterables'),
    collect = _require3.collect,
    take = _require3.take;

var equals = require('uint8arrays/equals');

var _require4 = require('./constants'),
    PROTOCOL_NAME = _require4.PROTOCOL_NAME,
    PING_LENGTH = _require4.PING_LENGTH,
    PROTOCOL_VERSION = _require4.PROTOCOL_VERSION;
/**
 * @typedef {import('../')} Libp2p
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 */

/**
 * Ping a given peer and wait for its response, getting the operation latency.
 *
 * @param {Libp2p} node
 * @param {PeerId|Multiaddr} peer
 * @returns {Promise<number>}
 */


function ping(_x, _x2) {
  return _ping.apply(this, arguments);
}
/**
 * Subscribe ping protocol handler.
 *
 * @param {Libp2p} node
 */


function _ping() {
  _ping = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(node, peer) {
    var protocol, connection, _yield$connection$new, stream, start, data, _yield$pipe, _yield$pipe2, result, end;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            protocol = "/".concat(node._config.protocolPrefix, "/").concat(PROTOCOL_NAME, "/").concat(PROTOCOL_VERSION); // @ts-ignore multiaddr might not have toB58String

            log('dialing %s to %s', protocol, peer.toB58String ? peer.toB58String() : peer);
            _context.next = 4;
            return node.dial(peer);

          case 4:
            connection = _context.sent;
            _context.next = 7;
            return connection.newStream(protocol);

          case 7:
            _yield$connection$new = _context.sent;
            stream = _yield$connection$new.stream;
            start = Date.now();
            data = crypto.randomBytes(PING_LENGTH);
            _context.next = 13;
            return pipe([data], stream, function (
            /** @type {MuxedStream} */
            stream) {
              return take(1, stream);
            }, toBuffer, collect);

          case 13:
            _yield$pipe = _context.sent;
            _yield$pipe2 = _slicedToArray(_yield$pipe, 1);
            result = _yield$pipe2[0];
            end = Date.now();

            if (equals(data, result)) {
              _context.next = 19;
              break;
            }

            throw errCode(new Error('Received wrong ping ack'), 'ERR_WRONG_PING_ACK');

          case 19:
            return _context.abrupt("return", end - start);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ping.apply(this, arguments);
}

function mount(node) {
  node.handle("/".concat(node._config.protocolPrefix, "/").concat(PROTOCOL_NAME, "/").concat(PROTOCOL_VERSION), function (_ref) {
    var stream = _ref.stream;
    return pipe(stream, stream);
  });
}
/**
 * Unsubscribe ping protocol handler.
 *
 * @param {Libp2p} node
 */


function unmount(node) {
  node.unhandle("/".concat(node._config.protocolPrefix, "/").concat(PROTOCOL_NAME, "/").concat(PROTOCOL_VERSION));
}

exports = module.exports = ping;
exports.mount = mount;
exports.unmount = unmount;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","libp2p-crypto":"node_modules/libp2p-crypto/src/index.js","it-pipe":"node_modules/it-pipe/index.js","it-buffer":"node_modules/it-buffer/index.js","streaming-iterables":"node_modules/streaming-iterables/dist/index.mjs","uint8arrays/equals":"node_modules/uint8arrays/equals.js","./constants":"node_modules/libp2p/src/ping/constants.js"}],"node_modules/libp2p/src/identify/message.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-identify"] || ($protobuf.roots["libp2p-identify"] = {});

$root.Identify = function () {
  /**
   * Properties of an Identify.
   * @exports IIdentify
   * @interface IIdentify
   * @property {string|null} [protocolVersion] Identify protocolVersion
   * @property {string|null} [agentVersion] Identify agentVersion
   * @property {Uint8Array|null} [publicKey] Identify publicKey
   * @property {Array.<Uint8Array>|null} [listenAddrs] Identify listenAddrs
   * @property {Uint8Array|null} [observedAddr] Identify observedAddr
   * @property {Array.<string>|null} [protocols] Identify protocols
   * @property {Uint8Array|null} [signedPeerRecord] Identify signedPeerRecord
   */

  /**
   * Constructs a new Identify.
   * @exports Identify
   * @classdesc Represents an Identify.
   * @implements IIdentify
   * @constructor
   * @param {IIdentify=} [p] Properties to set
   */
  function Identify(p) {
    this.listenAddrs = [];
    this.protocols = [];
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Identify protocolVersion.
   * @member {string} protocolVersion
   * @memberof Identify
   * @instance
   */


  Identify.prototype.protocolVersion = "";
  /**
   * Identify agentVersion.
   * @member {string} agentVersion
   * @memberof Identify
   * @instance
   */

  Identify.prototype.agentVersion = "";
  /**
   * Identify publicKey.
   * @member {Uint8Array} publicKey
   * @memberof Identify
   * @instance
   */

  Identify.prototype.publicKey = $util.newBuffer([]);
  /**
   * Identify listenAddrs.
   * @member {Array.<Uint8Array>} listenAddrs
   * @memberof Identify
   * @instance
   */

  Identify.prototype.listenAddrs = $util.emptyArray;
  /**
   * Identify observedAddr.
   * @member {Uint8Array} observedAddr
   * @memberof Identify
   * @instance
   */

  Identify.prototype.observedAddr = $util.newBuffer([]);
  /**
   * Identify protocols.
   * @member {Array.<string>} protocols
   * @memberof Identify
   * @instance
   */

  Identify.prototype.protocols = $util.emptyArray;
  /**
   * Identify signedPeerRecord.
   * @member {Uint8Array} signedPeerRecord
   * @memberof Identify
   * @instance
   */

  Identify.prototype.signedPeerRecord = $util.newBuffer([]);
  /**
   * Encodes the specified Identify message. Does not implicitly {@link Identify.verify|verify} messages.
   * @function encode
   * @memberof Identify
   * @static
   * @param {IIdentify} m Identify message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Identify.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey")) w.uint32(10).bytes(m.publicKey);

    if (m.listenAddrs != null && m.listenAddrs.length) {
      for (var i = 0; i < m.listenAddrs.length; ++i) {
        w.uint32(18).bytes(m.listenAddrs[i]);
      }
    }

    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i) {
        w.uint32(26).string(m.protocols[i]);
      }
    }

    if (m.observedAddr != null && Object.hasOwnProperty.call(m, "observedAddr")) w.uint32(34).bytes(m.observedAddr);
    if (m.protocolVersion != null && Object.hasOwnProperty.call(m, "protocolVersion")) w.uint32(42).string(m.protocolVersion);
    if (m.agentVersion != null && Object.hasOwnProperty.call(m, "agentVersion")) w.uint32(50).string(m.agentVersion);
    if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord")) w.uint32(66).bytes(m.signedPeerRecord);
    return w;
  };
  /**
   * Decodes an Identify message from the specified reader or buffer.
   * @function decode
   * @memberof Identify
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Identify} Identify
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Identify.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Identify();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 5:
          m.protocolVersion = r.string();
          break;

        case 6:
          m.agentVersion = r.string();
          break;

        case 1:
          m.publicKey = r.bytes();
          break;

        case 2:
          if (!(m.listenAddrs && m.listenAddrs.length)) m.listenAddrs = [];
          m.listenAddrs.push(r.bytes());
          break;

        case 4:
          m.observedAddr = r.bytes();
          break;

        case 3:
          if (!(m.protocols && m.protocols.length)) m.protocols = [];
          m.protocols.push(r.string());
          break;

        case 8:
          m.signedPeerRecord = r.bytes();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates an Identify message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Identify
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Identify} Identify
   */


  Identify.fromObject = function fromObject(d) {
    if (d instanceof $root.Identify) return d;
    var m = new $root.Identify();

    if (d.protocolVersion != null) {
      m.protocolVersion = String(d.protocolVersion);
    }

    if (d.agentVersion != null) {
      m.agentVersion = String(d.agentVersion);
    }

    if (d.publicKey != null) {
      if (typeof d.publicKey === "string") $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);else if (d.publicKey.length) m.publicKey = d.publicKey;
    }

    if (d.listenAddrs) {
      if (!Array.isArray(d.listenAddrs)) throw TypeError(".Identify.listenAddrs: array expected");
      m.listenAddrs = [];

      for (var i = 0; i < d.listenAddrs.length; ++i) {
        if (typeof d.listenAddrs[i] === "string") $util.base64.decode(d.listenAddrs[i], m.listenAddrs[i] = $util.newBuffer($util.base64.length(d.listenAddrs[i])), 0);else if (d.listenAddrs[i].length) m.listenAddrs[i] = d.listenAddrs[i];
      }
    }

    if (d.observedAddr != null) {
      if (typeof d.observedAddr === "string") $util.base64.decode(d.observedAddr, m.observedAddr = $util.newBuffer($util.base64.length(d.observedAddr)), 0);else if (d.observedAddr.length) m.observedAddr = d.observedAddr;
    }

    if (d.protocols) {
      if (!Array.isArray(d.protocols)) throw TypeError(".Identify.protocols: array expected");
      m.protocols = [];

      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }

    if (d.signedPeerRecord != null) {
      if (typeof d.signedPeerRecord === "string") $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);else if (d.signedPeerRecord.length) m.signedPeerRecord = d.signedPeerRecord;
    }

    return m;
  };
  /**
   * Creates a plain object from an Identify message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Identify
   * @static
   * @param {Identify} m Identify
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Identify.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.arrays || o.defaults) {
      d.listenAddrs = [];
      d.protocols = [];
    }

    if (o.defaults) {
      if (o.bytes === String) d.publicKey = "";else {
        d.publicKey = [];
        if (o.bytes !== Array) d.publicKey = $util.newBuffer(d.publicKey);
      }
      if (o.bytes === String) d.observedAddr = "";else {
        d.observedAddr = [];
        if (o.bytes !== Array) d.observedAddr = $util.newBuffer(d.observedAddr);
      }
      d.protocolVersion = "";
      d.agentVersion = "";
      if (o.bytes === String) d.signedPeerRecord = "";else {
        d.signedPeerRecord = [];
        if (o.bytes !== Array) d.signedPeerRecord = $util.newBuffer(d.signedPeerRecord);
      }
    }

    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }

    if (m.listenAddrs && m.listenAddrs.length) {
      d.listenAddrs = [];

      for (var j = 0; j < m.listenAddrs.length; ++j) {
        d.listenAddrs[j] = o.bytes === String ? $util.base64.encode(m.listenAddrs[j], 0, m.listenAddrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.listenAddrs[j]) : m.listenAddrs[j];
      }
    }

    if (m.protocols && m.protocols.length) {
      d.protocols = [];

      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }

    if (m.observedAddr != null && m.hasOwnProperty("observedAddr")) {
      d.observedAddr = o.bytes === String ? $util.base64.encode(m.observedAddr, 0, m.observedAddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.observedAddr) : m.observedAddr;
    }

    if (m.protocolVersion != null && m.hasOwnProperty("protocolVersion")) {
      d.protocolVersion = m.protocolVersion;
    }

    if (m.agentVersion != null && m.hasOwnProperty("agentVersion")) {
      d.agentVersion = m.agentVersion;
    }

    if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
      d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
    }

    return d;
  };
  /**
   * Converts this Identify to JSON.
   * @function toJSON
   * @memberof Identify
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Identify.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return Identify;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p/src/identify/index.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = Object.assign(debug('libp2p:identify'), {
  error: debug('libp2p:identify:err')
});

var errCode = require('err-code');

var lp = require('it-length-prefixed');

var _require = require('it-pipe'),
    pipe = _require.pipe;

var _require2 = require('streaming-iterables'),
    collect = _require2.collect,
    take = _require2.take,
    consume = _require2.consume;

var uint8ArrayFromString = require('uint8arrays/from-string');

var PeerId = require('peer-id');

var _require3 = require('multiaddr'),
    Multiaddr = _require3.Multiaddr; // @ts-ignore it-buffer does not have types


var _require4 = require('it-buffer'),
    toBuffer = _require4.toBuffer;

var Message = require('./message');

var Envelope = require('../record/envelope');

var PeerRecord = require('../record/peer-record');

var _require5 = require('./consts'),
    MULTICODEC_IDENTIFY = _require5.MULTICODEC_IDENTIFY,
    MULTICODEC_IDENTIFY_PUSH = _require5.MULTICODEC_IDENTIFY_PUSH,
    IDENTIFY_PROTOCOL_VERSION = _require5.IDENTIFY_PROTOCOL_VERSION,
    MULTICODEC_IDENTIFY_PROTOCOL_NAME = _require5.MULTICODEC_IDENTIFY_PROTOCOL_NAME,
    MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = _require5.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,
    MULTICODEC_IDENTIFY_PROTOCOL_VERSION = _require5.MULTICODEC_IDENTIFY_PROTOCOL_VERSION,
    MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = _require5.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION;

var _require6 = require('../errors'),
    codes = _require6.codes;
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 */

/**
 * @typedef {Object} HostProperties
 * @property {string} agentVersion
 */


var IdentifyService = /*#__PURE__*/function () {
  /**
   * @class
   * @param {Object} options
   * @param {import('../')} options.libp2p
   */
  function IdentifyService(_ref) {
    var _this = this;

    var libp2p = _ref.libp2p;

    _classCallCheck(this, IdentifyService);

    this._libp2p = libp2p;
    this.peerStore = libp2p.peerStore;
    this.addressManager = libp2p.addressManager;
    this.connectionManager = libp2p.connectionManager;
    this.peerId = libp2p.peerId;
    this.handleMessage = this.handleMessage.bind(this);
    var protocolStr = IdentifyService.getProtocolStr(libp2p);
    this.identifyProtocolStr = protocolStr.identifyProtocolStr;
    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr; // Store self host metadata

    this._host = _objectSpread({
      protocolVersion: "".concat(libp2p._config.protocolPrefix, "/").concat(IDENTIFY_PROTOCOL_VERSION)
    }, libp2p._options.host);
    this.peerStore.metadataBook.set(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion));
    this.peerStore.metadataBook.set(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion)); // When a new connection happens, trigger identify

    this.connectionManager.on('peer:connect', function (connection) {
      _this.identify(connection).catch(log.error);
    }); // When self multiaddrs change, trigger identify-push

    this.peerStore.on('change:multiaddrs', function (_ref2) {
      var peerId = _ref2.peerId;

      if (peerId.toString() === _this.peerId.toString()) {
        _this.pushToPeerStore();
      }
    }); // When self protocols change, trigger identify-push

    this.peerStore.on('change:protocols', function (_ref3) {
      var peerId = _ref3.peerId;

      if (peerId.toString() === _this.peerId.toString()) {
        _this.pushToPeerStore();
      }
    });
  }
  /**
   * Send an Identify Push update to the list of connections
   *
   * @param {Connection[]} connections
   * @returns {Promise<void[]>}
   */


  _createClass(IdentifyService, [{
    key: "push",
    value: function () {
      var _push = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(connections) {
        var _this2 = this;

        var signedPeerRecord, listenAddrs, protocols, pushes;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.peerStore.addressBook.getRawEnvelope(this.peerId);

              case 2:
                signedPeerRecord = _context2.sent;
                listenAddrs = this._libp2p.multiaddrs.map(function (ma) {
                  return ma.bytes;
                });
                protocols = this.peerStore.protoBook.get(this.peerId) || [];
                pushes = connections.map( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(connection) {
                    var _yield$connection$new, stream;

                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.prev = 0;
                            _context.next = 3;
                            return connection.newStream(_this2.identifyPushProtocolStr);

                          case 3:
                            _yield$connection$new = _context.sent;
                            stream = _yield$connection$new.stream;
                            _context.next = 7;
                            return pipe([Message.Identify.encode({
                              listenAddrs: listenAddrs,
                              signedPeerRecord: signedPeerRecord,
                              protocols: protocols
                            }).finish()], lp.encode(), stream, consume);

                          case 7:
                            _context.next = 12;
                            break;

                          case 9:
                            _context.prev = 9;
                            _context.t0 = _context["catch"](0);
                            // Just log errors
                            log.error('could not push identify update to peer', _context.t0);

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, null, [[0, 9]]);
                  }));

                  return function (_x2) {
                    return _ref4.apply(this, arguments);
                  };
                }());
                return _context2.abrupt("return", Promise.all(pushes));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function push(_x) {
        return _push.apply(this, arguments);
      }

      return push;
    }()
    /**
     * Calls `push` for all peers in the `peerStore` that are connected
     *
     * @returns {void}
     */

  }, {
    key: "pushToPeerStore",
    value: function pushToPeerStore() {
      // Do not try to push if libp2p node is not running
      if (!this._libp2p.isStarted()) {
        return;
      }

      var connections = [];
      var connection;

      var _iterator = _createForOfIteratorHelper(this.peerStore.peers.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var peer = _step.value;

          if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {
            connections.push(connection);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.push(connections);
    }
    /**
     * Requests the `Identify` message from peer associated with the given `connection`.
     * If the identified peer does not match the `PeerId` associated with the connection,
     * an error will be thrown.
     *
     * @async
     * @param {Connection} connection
     * @returns {Promise<void>}
     */

  }, {
    key: "identify",
    value: function () {
      var _identify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(connection) {
        var _yield$connection$new2, stream, _yield$pipe, _yield$pipe2, data, message, _message, publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, id, cleanObservedAddr, envelope;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return connection.newStream(this.identifyProtocolStr);

              case 2:
                _yield$connection$new2 = _context3.sent;
                stream = _yield$connection$new2.stream;
                _context3.next = 6;
                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);

              case 6:
                _yield$pipe = _context3.sent;
                _yield$pipe2 = _slicedToArray(_yield$pipe, 1);
                data = _yield$pipe2[0];

                if (data) {
                  _context3.next = 11;
                  break;
                }

                throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);

              case 11:
                _context3.prev = 11;
                message = Message.Identify.decode(data);
                _context3.next = 18;
                break;

              case 15:
                _context3.prev = 15;
                _context3.t0 = _context3["catch"](11);
                throw errCode(_context3.t0, codes.ERR_INVALID_MESSAGE);

              case 18:
                _message = message, publicKey = _message.publicKey, listenAddrs = _message.listenAddrs, protocols = _message.protocols, observedAddr = _message.observedAddr, signedPeerRecord = _message.signedPeerRecord;
                _context3.next = 21;
                return PeerId.createFromPubKey(publicKey);

              case 21:
                id = _context3.sent;

                if (!(connection.remotePeer.toB58String() !== id.toB58String())) {
                  _context3.next = 24;
                  break;
                }

                throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);

              case 24:
                // Get the observedAddr if there is one
                cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
                _context3.prev = 25;
                _context3.next = 28;
                return Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);

              case 28:
                envelope = _context3.sent;

                if (!this.peerStore.addressBook.consumePeerRecord(envelope)) {
                  _context3.next = 34;
                  break;
                }

                this.peerStore.protoBook.set(id, protocols);
                this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));
                this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion));
                return _context3.abrupt("return");

              case 34:
                _context3.next = 39;
                break;

              case 36:
                _context3.prev = 36;
                _context3.t1 = _context3["catch"](25);
                log('received invalid envelope, discard it and fallback to listenAddrs is available', _context3.t1);

              case 39:
                // LEGACY: Update peers data in PeerStore
                try {
                  this.peerStore.addressBook.set(id, listenAddrs.map(function (addr) {
                    return new Multiaddr(addr);
                  }));
                } catch (err) {
                  log.error('received invalid addrs', err);
                }

                this.peerStore.protoBook.set(id, protocols);
                this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));
                this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion)); // TODO: Add and score our observed addr

                log('received observed address of %s', cleanObservedAddr); // this.addressManager.addObservedAddr(observedAddr)

              case 44:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[11, 15], [25, 36]]);
      }));

      function identify(_x3) {
        return _identify.apply(this, arguments);
      }

      return identify;
    }()
    /**
     * A handler to register with Libp2p to process identify messages.
     *
     * @param {Object} options
     * @param {Connection} options.connection
     * @param {MuxedStream} options.stream
     * @param {string} options.protocol
     * @returns {Promise<void>|undefined}
     */

  }, {
    key: "handleMessage",
    value: function handleMessage(_ref5) {
      var connection = _ref5.connection,
          stream = _ref5.stream,
          protocol = _ref5.protocol;

      switch (protocol) {
        case this.identifyProtocolStr:
          return this._handleIdentify({
            connection: connection,
            stream: stream
          });

        case this.identifyPushProtocolStr:
          return this._handlePush({
            connection: connection,
            stream: stream
          });

        default:
          log.error('cannot handle unknown protocol %s', protocol);
      }
    }
    /**
     * Sends the `Identify` response with the Signed Peer Record
     * to the requesting peer over the given `connection`
     *
     * @private
     * @param {Object} options
     * @param {MuxedStream} options.stream
     * @param {Connection} options.connection
     * @returns {Promise<void>}
     */

  }, {
    key: "_handleIdentify",
    value: function () {
      var _handleIdentify2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref6) {
        var connection, stream, publicKey, signedPeerRecord, protocols, message;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                connection = _ref6.connection, stream = _ref6.stream;
                publicKey = new Uint8Array(0);

                if (this.peerId.pubKey) {
                  publicKey = this.peerId.pubKey.bytes;
                }

                _context4.next = 5;
                return this.peerStore.addressBook.getRawEnvelope(this.peerId);

              case 5:
                signedPeerRecord = _context4.sent;
                protocols = this.peerStore.protoBook.get(this.peerId) || [];
                message = Message.Identify.encode({
                  protocolVersion: this._host.protocolVersion,
                  agentVersion: this._host.agentVersion,
                  publicKey: publicKey,
                  listenAddrs: this._libp2p.multiaddrs.map(function (ma) {
                    return ma.bytes;
                  }),
                  signedPeerRecord: signedPeerRecord,
                  observedAddr: connection.remoteAddr.bytes,
                  protocols: protocols
                }).finish();
                _context4.prev = 8;
                _context4.next = 11;
                return pipe([message], lp.encode(), stream, consume);

              case 11:
                _context4.next = 16;
                break;

              case 13:
                _context4.prev = 13;
                _context4.t0 = _context4["catch"](8);
                log.error('could not respond to identify request', _context4.t0);

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[8, 13]]);
      }));

      function _handleIdentify(_x4) {
        return _handleIdentify2.apply(this, arguments);
      }

      return _handleIdentify;
    }()
    /**
     * Reads the Identify Push message from the given `connection`
     *
     * @private
     * @param {object} options
     * @param {MuxedStream} options.stream
     * @param {Connection} options.connection
     * @returns {Promise<void>}
     */

  }, {
    key: "_handlePush",
    value: function () {
      var _handlePush2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref7) {
        var connection, stream, message, _yield$pipe3, _yield$pipe4, data, id, envelope;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                connection = _ref7.connection, stream = _ref7.stream;
                _context5.prev = 1;
                _context5.next = 4;
                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);

              case 4:
                _yield$pipe3 = _context5.sent;
                _yield$pipe4 = _slicedToArray(_yield$pipe3, 1);
                data = _yield$pipe4[0];
                message = Message.Identify.decode(data);
                _context5.next = 13;
                break;

              case 10:
                _context5.prev = 10;
                _context5.t0 = _context5["catch"](1);
                return _context5.abrupt("return", log.error('received invalid message', _context5.t0));

              case 13:
                id = connection.remotePeer;
                _context5.prev = 14;
                _context5.next = 17;
                return Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);

              case 17:
                envelope = _context5.sent;

                if (!this.peerStore.addressBook.consumePeerRecord(envelope)) {
                  _context5.next = 21;
                  break;
                }

                this.peerStore.protoBook.set(id, message.protocols);
                return _context5.abrupt("return");

              case 21:
                _context5.next = 26;
                break;

              case 23:
                _context5.prev = 23;
                _context5.t1 = _context5["catch"](14);
                log('received invalid envelope, discard it and fallback to listenAddrs is available', _context5.t1);

              case 26:
                // LEGACY: Update peers data in PeerStore
                try {
                  this.peerStore.addressBook.set(id, message.listenAddrs.map(function (addr) {
                    return new Multiaddr(addr);
                  }));
                } catch (err) {
                  log.error('received invalid addrs', err);
                } // Update the protocols


                this.peerStore.protoBook.set(id, message.protocols);

              case 28:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[1, 10], [14, 23]]);
      }));

      function _handlePush(_x5) {
        return _handlePush2.apply(this, arguments);
      }

      return _handlePush;
    }()
    /**
     * Takes the `addr` and converts it to a Multiaddr if possible
     *
     * @param {Uint8Array | string} addr
     * @returns {Multiaddr|null}
     */

  }], [{
    key: "getProtocolStr",
    value:
    /**
     * @param {import('../')} libp2p
     */
    function getProtocolStr(libp2p) {
      return {
        identifyProtocolStr: "/".concat(libp2p._config.protocolPrefix, "/").concat(MULTICODEC_IDENTIFY_PROTOCOL_NAME, "/").concat(MULTICODEC_IDENTIFY_PROTOCOL_VERSION),
        identifyPushProtocolStr: "/".concat(libp2p._config.protocolPrefix, "/").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, "/").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION)
      };
    }
  }, {
    key: "getCleanMultiaddr",
    value: function getCleanMultiaddr(addr) {
      if (addr && addr.length > 0) {
        try {
          return new Multiaddr(addr);
        } catch (_) {
          return null;
        }
      }

      return null;
    }
  }]);

  return IdentifyService;
}();
/**
 * The protocols the IdentifyService supports
 *
 * @property multicodecs
 */


var multicodecs = {
  IDENTIFY: MULTICODEC_IDENTIFY,
  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
};
IdentifyService.multicodecs = multicodecs;
IdentifyService.Messsage = Message;
module.exports = IdentifyService;
},{"debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","it-pipe":"node_modules/it-pipe/index.js","streaming-iterables":"node_modules/streaming-iterables/dist/index.mjs","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","it-buffer":"node_modules/it-buffer/index.js","./message":"node_modules/libp2p/src/identify/message.js","../record/envelope":"node_modules/libp2p/src/record/envelope/index.js","../record/peer-record":"node_modules/libp2p/src/record/peer-record/index.js","./consts":"node_modules/libp2p/src/identify/consts.js","../errors":"node_modules/libp2p/src/errors.js"}],"node_modules/es6-promisify/dist/promisify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify = promisify;
// Symbols is a better way to do this, but not all browsers have good support,
// so instead we'll just make do with a very unlikely string.
var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
/**
 * promisify()
 * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) --
 * into an ES6-compatible Promise. Promisify provides a default callback of the
 * form (error, result) and rejects when `error` is truthy.
 *
 * @param {function} original - The function to promisify
 * @return {function} A promisified version of `original`
 */

function promisify(original) {
  // Ensure the argument is a function
  if (typeof original !== "function") {
    throw new TypeError("Argument to promisify must be a function");
  } // If the user has asked us to decode argument names for them, honour that


  var argumentNames = original[customArgumentsToken]; // If the user has supplied a custom Promise implementation, use it.
  // Otherwise fall back to whatever we can find on the global object.

  var ES6Promise = promisify.Promise || Promise; // If we can find no Promise implemention, then fail now.

  if (typeof ES6Promise !== "function") {
    throw new Error("No Promise implementation found; do you need a polyfill?");
  }

  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new ES6Promise(function (resolve, reject) {
      // Append the callback bound to the context
      args.push(function callback(err) {
        if (err) {
          return reject(err);
        }

        for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          values[_key2 - 1] = arguments[_key2];
        }

        if (values.length === 1 || !argumentNames) {
          return resolve(values[0]);
        }

        var o = {};
        values.forEach(function (value, index) {
          var name = argumentNames[index];

          if (name) {
            o[name] = value;
          }
        });
        resolve(o);
      }); // Call the function.

      original.apply(_this, args);
    });
  };
} // Attach this symbol to the exported function, so users can use it


promisify.argumentNames = customArgumentsToken;
promisify.Promise = undefined; // Export the public API
},{}],"node_modules/is-electron/index.js":[function(require,module,exports) {
var process = require("process");
// https://github.com/electron/electron/issues/2288
function isElectron() {
    // Renderer process
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
        return true;
    }

    // Main process
    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
        return true;
    }

    // Detect the user agent when the `nodeIntegration` option is set to true
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
        return true;
    }

    return false;
}

module.exports = isElectron;

},{"process":"node_modules/process/browser.js"}],"node_modules/wherearewe/src/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';
/** @type {() => boolean} */
// @ts-ignore

const isElectron = require('is-electron');

const IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9;
const IS_ELECTRON = isElectron();
const IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
const IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
const IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
const IS_NODE = typeof require === 'function' && typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node' && !IS_ELECTRON; // @ts-ignore
// eslint-disable-next-line no-undef

const IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
const IS_TEST = typeof process !== 'undefined' && typeof process.env !== 'undefined' && "development" === 'test';
module.exports = {
  isTest: IS_TEST,
  isElectron: IS_ELECTRON,
  isElectronMain: IS_ELECTRON_MAIN,
  isElectronRenderer: IS_ELECTRON_RENDERER,
  isNode: IS_NODE,

  /**
   * Detects browser main thread  **NOT** web worker or service worker
   */
  isBrowser: IS_BROWSER,
  isWebWorker: IS_WEBWORKER,
  isEnvWithDom: IS_ENV_WITH_DOM
};
},{"is-electron":"node_modules/is-electron/index.js","process":"node_modules/process/browser.js"}],"node_modules/retry/lib/retry_operation.js":[function(require,module,exports) {
function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = {
      forever: options
    };
  }

  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}

module.exports = RetryOperation;

RetryOperation.prototype.reset = function () {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};

RetryOperation.prototype.stop = function () {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (this._timer) {
    clearTimeout(this._timer);
  }

  this._timeouts = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function (err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }

  var currentTime = new Date().getTime();

  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);

    this._errors.unshift(new Error('RetryOperation timeout occurred'));

    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();

  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(0, this._errors.length - 1);

      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }

  var self = this;
  this._timer = setTimeout(function () {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function () {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (self._options.unref) {
        self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
    this._timer.unref();
  }

  return true;
};

RetryOperation.prototype.attempt = function (fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }

    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;

  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function () {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._operationStart = new Date().getTime();

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function (fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function (fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function () {
  return this._errors;
};

RetryOperation.prototype.attempts = function () {
  return this._attempts;
};

RetryOperation.prototype.mainError = function () {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;
    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};
},{}],"node_modules/retry/lib/retry.js":[function(require,module,exports) {
var RetryOperation = require('./retry_operation');

exports.operation = function (options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
    forever: options && (options.forever || options.retries === Infinity),
    unref: options && options.unref,
    maxRetryTime: options && options.maxRetryTime
  });
};

exports.timeouts = function (options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };

  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout > opts.maxTimeout) {
    throw new Error('minTimeout is greater than maxTimeout');
  }

  var timeouts = [];

  for (var i = 0; i < opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options && options.forever && !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  } // sort the array numerically ascending


  timeouts.sort(function (a, b) {
    return a - b;
  });
  return timeouts;
};

exports.createTimeout = function (attempt, opts) {
  var random = opts.randomize ? Math.random() + 1 : 1;
  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);
  return timeout;
};

exports.wrap = function (obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];

    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i < methods.length; i++) {
    var method = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper(original) {
      var op = exports.operation(options);
      var args = Array.prototype.slice.call(arguments, 1);
      var callback = args.pop();
      args.push(function (err) {
        if (op.retry(err)) {
          return;
        }

        if (err) {
          arguments[0] = op.mainError();
        }

        callback.apply(this, arguments);
      });
      op.attempt(function () {
        original.apply(obj, args);
      });
    }.bind(obj, original);

    obj[method].options = options;
  }
};
},{"./retry_operation":"node_modules/retry/lib/retry_operation.js"}],"node_modules/retry/index.js":[function(require,module,exports) {
module.exports = require('./lib/retry');
},{"./lib/retry":"node_modules/retry/lib/retry.js"}],"node_modules/p-retry/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var retry = require('retry');

var networkErrorMsgs = ['Failed to fetch', // Chrome
'NetworkError when attempting to fetch resource.', // Firefox
'The Internet connection appears to be offline.', // Safari
'Network request failed' // `cross-fetch`
];

var AbortError = /*#__PURE__*/function (_Error) {
  _inherits(AbortError, _Error);

  var _super = _createSuper(AbortError);

  function AbortError(message) {
    var _this;

    _classCallCheck(this, AbortError);

    _this = _super.call(this);

    if (message instanceof Error) {
      _this.originalError = message;
      var _message = message;
      message = _message.message;
    } else {
      _this.originalError = new Error(message);
      _this.originalError.stack = _this.stack;
    }

    _this.name = 'AbortError';
    _this.message = message;
    return _this;
  }

  return AbortError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var decorateErrorWithCounts = function decorateErrorWithCounts(error, attemptNumber, options) {
  // Minus 1 from attemptNumber because the first attempt does not count as a retry
  var retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};

var isNetworkError = function isNetworkError(errorMessage) {
  return networkErrorMsgs.includes(errorMessage);
};

var pRetry = function pRetry(input, options) {
  return new Promise(function (resolve, reject) {
    options = {
      onFailedAttempt: function onFailedAttempt() {},
      retries: 10,
      ...options
    };
    var operation = retry.operation(options);
    operation.attempt( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(attemptNumber) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.t0 = resolve;
                _context.next = 4;
                return input(attemptNumber);

              case 4:
                _context.t1 = _context.sent;
                (0, _context.t0)(_context.t1);
                _context.next = 34;
                break;

              case 8:
                _context.prev = 8;
                _context.t2 = _context["catch"](0);

                if (_context.t2 instanceof Error) {
                  _context.next = 13;
                  break;
                }

                reject(new TypeError("Non-error was thrown: \"".concat(_context.t2, "\". You should only throw errors.")));
                return _context.abrupt("return");

              case 13:
                if (!(_context.t2 instanceof AbortError)) {
                  _context.next = 18;
                  break;
                }

                operation.stop();
                reject(_context.t2.originalError);
                _context.next = 34;
                break;

              case 18:
                if (!(_context.t2 instanceof TypeError && !isNetworkError(_context.t2.message))) {
                  _context.next = 23;
                  break;
                }

                operation.stop();
                reject(_context.t2);
                _context.next = 34;
                break;

              case 23:
                decorateErrorWithCounts(_context.t2, attemptNumber, options);
                _context.prev = 24;
                _context.next = 27;
                return options.onFailedAttempt(_context.t2);

              case 27:
                _context.next = 33;
                break;

              case 29:
                _context.prev = 29;
                _context.t3 = _context["catch"](24);
                reject(_context.t3);
                return _context.abrupt("return");

              case 33:
                if (!operation.retry(_context.t2)) {
                  reject(operation.mainError());
                }

              case 34:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 8], [24, 29]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
};

module.exports = pRetry; // TODO: remove this in the next major version

module.exports.default = pRetry;
module.exports.AbortError = AbortError;
},{"retry":"node_modules/retry/index.js"}],"node_modules/is-loopback-addr/index.js":[function(require,module,exports) {
'use strict'

/**
 * Check if a given ip address is a loopback address
 *
 * @param {string} ip - ip address to check
 * @returns {boolean}
 */
function isLoopbackAddr (ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) ||
    /^::1$/.test(ip)
}

module.exports = isLoopbackAddr

},{}],"node_modules/libp2p-utils/src/multiaddr/is-loopback.js":[function(require,module,exports) {
'use strict'

// @ts-ignore is-loopback-addr does not publish types
const isLoopbackAddr = require('is-loopback-addr')

/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * Check if a given multiaddr is a loopback address.
 *
 * @param {Multiaddr} ma
 * @returns {boolean}
 */
function isLoopback (ma) {
  const { address } = ma.nodeAddress()

  return isLoopbackAddr(address)
}

module.exports = isLoopback

},{"is-loopback-addr":"node_modules/is-loopback-addr/index.js"}],"node_modules/libp2p/src/nat-manager.js":[function(require,module,exports) {
'use strict'; // @ts-ignore nat-api does not export types

var _excluded = ["peerId", "addressManager", "transportManager"];

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var NatAPI = require('@motrix/nat-api');

var debug = require('debug');

var _require = require('es6-promisify'),
    promisify = _require.promisify;

var _require2 = require('multiaddr'),
    Multiaddr = _require2.Multiaddr;

var log = Object.assign(debug('libp2p:nat'), {
  error: debug('libp2p:nat:err')
});

var _require3 = require('wherearewe'),
    isBrowser = _require3.isBrowser;

var retry = require('p-retry'); // @ts-ignore private-api does not export types


var isPrivateIp = require('private-ip');

var pkg = require('../package.json');

var errcode = require('err-code');

var _require4 = require('./errors'),
    ERR_INVALID_PARAMETERS = _require4.codes.ERR_INVALID_PARAMETERS;

var isLoopback = require('libp2p-utils/src/multiaddr/is-loopback');

var DEFAULT_TTL = 7200;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('./transport-manager')} TransportManager
 * @typedef {import('./address-manager')} AddressManager
 */

/**
 * @typedef {Object} NatManagerProperties
 * @property {PeerId} peerId - The peer ID of the current node
 * @property {TransportManager} transportManager - A transport manager
 * @property {AddressManager} addressManager - An address manager
 *
 * @typedef {Object} NatManagerOptions
 * @property {boolean} enabled - Whether to enable the NAT manager
 * @property {string} [externalIp] - Pass a value to use instead of auto-detection
 * @property {string} [description] - A string value to use for the port mapping description on the gateway
 * @property {number} [ttl = DEFAULT_TTL] - How long UPnP port mappings should last for in seconds (minimum 1200)
 * @property {boolean} [keepAlive] - Whether to automatically refresh UPnP port mappings when their TTL is reached
 * @property {string} [gateway] - Pass a value to use instead of auto-detection
 * @property {object} [pmp] - PMP options
 * @property {boolean} [pmp.enabled] - Whether to enable PMP as well as UPnP
 */

function highPort() {
  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 65535;
  return Math.floor(Math.random() * (max - min + 1) + min);
}

var NatManager = /*#__PURE__*/function () {
  /**
   * @class
   * @param {NatManagerProperties & NatManagerOptions} options
   */
  function NatManager(_ref) {
    var peerId = _ref.peerId,
        addressManager = _ref.addressManager,
        transportManager = _ref.transportManager,
        options = _objectWithoutProperties(_ref, _excluded);

    _classCallCheck(this, NatManager);

    this._peerId = peerId;
    this._addressManager = addressManager;
    this._transportManager = transportManager;
    this._enabled = options.enabled;
    this._externalIp = options.externalIp;
    this._options = {
      description: options.description || "".concat(pkg.name, "@").concat(pkg.version, " ").concat(this._peerId),
      ttl: options.ttl || DEFAULT_TTL,
      autoUpdate: options.keepAlive || true,
      gateway: options.gateway,
      enablePMP: Boolean(options.pmp && options.pmp.enabled)
    };

    if (this._options.ttl < DEFAULT_TTL) {
      throw errcode(new Error("NatManager ttl should be at least ".concat(DEFAULT_TTL, " seconds")), ERR_INVALID_PARAMETERS);
    }
  }
  /**
   * Starts the NAT manager
   */


  _createClass(NatManager, [{
    key: "start",
    value: function start() {
      if (isBrowser || !this._enabled) {
        return;
      } // done async to not slow down startup


      this._start().catch(function (err) {
        // hole punching errors are non-fatal
        log.error(err);
      });
    }
  }, {
    key: "_start",
    value: function () {
      var _start2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var addrs, _iterator, _step, addr, _addr$toOptions, family, host, port, transport, client, publicIp, publicPort;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                addrs = this._transportManager.getAddrs();
                _iterator = _createForOfIteratorHelper(addrs);
                _context.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context.next = 29;
                  break;
                }

                addr = _step.value;
                // try to open uPnP ports for each thin waist address
                _addr$toOptions = addr.toOptions(), family = _addr$toOptions.family, host = _addr$toOptions.host, port = _addr$toOptions.port, transport = _addr$toOptions.transport;

                if (!(!addr.isThinWaistAddress() || transport !== 'tcp')) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("continue", 27);

              case 9:
                if (!isLoopback(addr)) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("continue", 27);

              case 11:
                if (!(family !== 4)) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("continue", 27);

              case 13:
                client = this._getClient();
                _context.t0 = this._externalIp;

                if (_context.t0) {
                  _context.next = 19;
                  break;
                }

                _context.next = 18;
                return client.externalIp();

              case 18:
                _context.t0 = _context.sent;

              case 19:
                publicIp = _context.t0;

                if (!isPrivateIp(publicIp)) {
                  _context.next = 22;
                  break;
                }

                throw new Error("".concat(publicIp, " is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT"));

              case 22:
                publicPort = highPort();
                log("opening uPnP connection from ".concat(publicIp, ":").concat(publicPort, " to ").concat(host, ":").concat(port));
                _context.next = 26;
                return client.map({
                  publicPort: publicPort,
                  privatePort: port,
                  protocol: transport.toUpperCase()
                });

              case 26:
                this._addressManager.addObservedAddr(Multiaddr.fromNodeAddress({
                  family: 4,
                  address: publicIp,
                  port: publicPort
                }, transport));

              case 27:
                _context.next = 4;
                break;

              case 29:
                _context.next = 34;
                break;

              case 31:
                _context.prev = 31;
                _context.t1 = _context["catch"](2);

                _iterator.e(_context.t1);

              case 34:
                _context.prev = 34;

                _iterator.f();

                return _context.finish(34);

              case 37:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 31, 34, 37]]);
      }));

      function _start() {
        return _start2.apply(this, arguments);
      }

      return _start;
    }()
  }, {
    key: "_getClient",
    value: function _getClient() {
      if (this._client) {
        return this._client;
      }

      var client = new NatAPI(this._options);
      /** @type {(...any: any) => any} */

      var _map = promisify(client.map.bind(client));
      /** @type {(...any: any) => any} */


      var _destroy = promisify(client.destroy.bind(client));
      /** @type {(...any: any) => any} */


      var _externalIp = promisify(client.externalIp.bind(client)); // these are all network operations so add a retry


      this._client = {
        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        map: function map() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return retry(function () {
            return _map.apply(void 0, args);
          }, {
            onFailedAttempt: log.error,
            unref: true
          });
        },

        /**
         * @param  {...any} args
         * @returns {Promise<void>}
         */
        destroy: function destroy() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return retry(function () {
            return _destroy.apply(void 0, args);
          }, {
            onFailedAttempt: log.error,
            unref: true
          });
        },

        /**
         * @param  {...any} args
         * @returns {Promise<string>}
         */
        externalIp: function externalIp() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return retry(function () {
            return _externalIp.apply(void 0, args);
          }, {
            onFailedAttempt: log.error,
            unref: true
          });
        }
      };
      return this._client;
    }
    /**
     * Stops the NAT manager
     *
     * @async
     */

  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(isBrowser || !this._client)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this._client.destroy();

              case 5:
                this._client = null;
                _context2.next = 11;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);
                log.error(_context2.t0);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }]);

  return NatManager;
}();

module.exports = NatManager;
},{"@motrix/nat-api":"node_modules/parcel-bundler/src/builtins/_empty.js","debug":"node_modules/debug/src/browser.js","es6-promisify":"node_modules/es6-promisify/dist/promisify.js","multiaddr":"node_modules/multiaddr/src/index.js","wherearewe":"node_modules/wherearewe/src/index.js","p-retry":"node_modules/p-retry/index.js","private-ip":"node_modules/private-ip/index.js","../package.json":"node_modules/libp2p/package.json","err-code":"node_modules/err-code/index.js","./errors":"node_modules/libp2p/src/errors.js","libp2p-utils/src/multiaddr/is-loopback":"node_modules/libp2p-utils/src/multiaddr/is-loopback.js"}],"node_modules/libp2p/src/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debug = require('debug');

var log = Object.assign(debug('libp2p'), {
  error: debug('libp2p:err')
});

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var errCode = require('err-code');

var PeerId = require('peer-id');

var _require2 = require('multiaddr'),
    Multiaddr = _require2.Multiaddr;

var PeerRouting = require('./peer-routing');

var ContentRouting = require('./content-routing');

var getPeer = require('./get-peer');

var _require3 = require('./config'),
    validateConfig = _require3.validate;

var _require4 = require('./errors'),
    codes = _require4.codes,
    messages = _require4.messages;

var AddressManager = require('./address-manager');

var ConnectionManager = require('./connection-manager');

var Circuit = require('./circuit/transport');

var Relay = require('./circuit');

var Dialer = require('./dialer');

var Keychain = require('./keychain');

var Metrics = require('./metrics');

var TransportManager = require('./transport-manager');

var Upgrader = require('./upgrader');

var PeerStore = require('./peer-store');

var PubsubAdapter = require('./pubsub-adapter');

var PersistentPeerStore = require('./peer-store/persistent');

var Registrar = require('./registrar');

var _ping = require('./ping');

var IdentifyService = require('./identify');

var NatManager = require('./nat-manager');

var _require5 = require('./record/utils'),
    updateSelfPeerRecord = _require5.updateSelfPeerRecord;
/**
 * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory
 * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule
 * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory
 * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule
 * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto
 * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub
 * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {import('./pnet')} Protector
 */

/**
 * @typedef {Object} HandlerProps
 * @property {Connection} connection
 * @property {MuxedStream} stream
 * @property {string} protocol
 *
 * @typedef {Object} RandomWalkOptions
 * @property {boolean} [enabled = false]
 * @property {number} [queriesPerPeriod = 1]
 * @property {number} [interval = 300e3]
 * @property {number} [timeout = 10e3]
 *
 * @typedef {Object} DhtOptions
 * @property {boolean} [enabled = false]
 * @property {number} [kBucketSize = 20]
 * @property {RandomWalkOptions} [randomWalk]
 * @property {boolean} [clientMode]
 * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]
 * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]
 *
 * @typedef {Object} KeychainOptions
 * @property {Datastore} [datastore]
 *
 * @typedef {Object} PeerStoreOptions
 * @property {boolean} persistence
 *
 * @typedef {Object} PubsubLocalOptions
 * @property {boolean} enabled
 *
 * @typedef {Object} MetricsOptions
 * @property {boolean} enabled
 *
 * @typedef {Object} RelayOptions
 * @property {boolean} [enabled = true]
 * @property {import('./circuit').RelayAdvertiseOptions} [advertise]
 * @property {import('./circuit').HopOptions} [hop]
 * @property {import('./circuit').AutoRelayOptions} [autoRelay]
 *
 * @typedef {Object} Libp2pConfig
 * @property {DhtOptions} [dht] dht module options
 * @property {import('./nat-manager').NatManagerOptions} [nat]
 * @property {Record<string, Object|boolean>} [peerDiscovery]
 * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options
 * @property {RelayOptions} [relay]
 * @property {Record<string, Object>} [transport] transport options indexed by transport key
 *
 * @typedef {Object} Libp2pModules
 * @property {TransportFactory[]} transport
 * @property {MuxerFactory[]} streamMuxer
 * @property {Crypto[]} connEncryption
 * @property {PeerDiscoveryFactory[]} [peerDiscovery]
 * @property {PeerRoutingModule[]} [peerRouting]
 * @property {ContentRoutingModule[]} [contentRouting]
 * @property {Object} [dht]
 * @property {{new(...args: any[]): Pubsub}} [pubsub]
 * @property {Protector} [connProtector]
 *
 * @typedef {Object} Libp2pOptions
 * @property {Libp2pModules} modules libp2p modules to use
 * @property {import('./address-manager').AddressManagerOptions} [addresses]
 * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]
 * @property {Datastore} [datastore]
 * @property {import('./dialer').DialerOptions} [dialer]
 * @property {import('./identify/index').HostProperties} [host] libp2p host
 * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]
 * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]
 * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]
 * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]
 * @property {import('./transport-manager').TransportManagerOptions} [transportManager]
 * @property {Libp2pConfig} [config]
 *
 * @typedef {Object} constructorOptions
 * @property {PeerId} peerId
 *
 * @typedef {Object} CreateOptions
 * @property {PeerId} [peerId]
 *
 * @extends {EventEmitter}
 * @fires Libp2p#error Emitted when an error occurs
 * @fires Libp2p#peer:discovery Emitted when a peer is discovered
 */


var Libp2p = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Libp2p, _EventEmitter);

  var _super = _createSuper(Libp2p);

  /**
   * Libp2p node.
   *
   * @class
   * @param {Libp2pOptions & constructorOptions} _options
   */
  function Libp2p(_options) {
    var _this;

    _classCallCheck(this, Libp2p);

    _this = _super.call(this); // validateConfig will ensure the config is correct,
    // and add default values where appropriate

    _this._options = validateConfig(_options);
    /** @type {PeerId} */

    _this.peerId = _this._options.peerId;
    _this.datastore = _this._options.datastore;
    _this.peerStore = _this.datastore && _this._options.peerStore.persistence ? new PersistentPeerStore(_objectSpread({
      peerId: _this.peerId,
      datastore: _this.datastore
    }, _this._options.peerStore)) : new PeerStore({
      peerId: _this.peerId
    }); // Addresses {listen, announce, noAnnounce}

    _this.addresses = _this._options.addresses;
    _this.addressManager = new AddressManager(_this.peerId, _this._options.addresses); // when addresses change, update our peer record

    _this.addressManager.on('change:addresses', function () {
      updateSelfPeerRecord(_assertThisInitialized(_this)).catch(function (err) {
        log.error('Error updating self peer record', err);
      });
    });

    _this._modules = _this._options.modules;
    _this._config = _this._options.config;
    _this._transport = []; // Transport instances/references

    _this._discovery = new Map(); // Discovery service instances/references
    // Create the Connection Manager

    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_this), _objectSpread({
      autoDial: _this._config.peerDiscovery.autoDial
    }, _this._options.connectionManager)); // Create Metrics

    if (_this._options.metrics.enabled) {
      _this.metrics = new Metrics(_objectSpread(_objectSpread({}, _this._options.metrics), {}, {
        connectionManager: _this.connectionManager
      }));
    } // Create keychain


    if (_this._options.keychain && _this._options.keychain.datastore) {
      log('creating keychain');
      var keychainOpts = Keychain.generateOptions();
      _this.keychain = new Keychain(_this._options.keychain.datastore, _objectSpread(_objectSpread({}, keychainOpts), _this._options.keychain));
      log('keychain constructed');
    } // Setup the Upgrader


    _this.upgrader = new Upgrader({
      localPeer: _this.peerId,
      metrics: _this.metrics,
      onConnection: function onConnection(connection) {
        return _this.connectionManager.onConnect(connection);
      },
      onConnectionEnd: function onConnectionEnd(connection) {
        return _this.connectionManager.onDisconnect(connection);
      }
    }); // Setup the transport manager

    _this.transportManager = new TransportManager({
      libp2p: _assertThisInitialized(_this),
      upgrader: _this.upgrader,
      faultTolerance: _this._options.transportManager.faultTolerance
    }); // Create the Nat Manager

    _this.natManager = new NatManager(_objectSpread({
      peerId: _this.peerId,
      addressManager: _this.addressManager,
      transportManager: _this.transportManager
    }, _this._options.config.nat)); // Create the Registrar

    _this.registrar = new Registrar({
      peerStore: _this.peerStore,
      connectionManager: _this.connectionManager
    });
    _this.handle = _this.handle.bind(_assertThisInitialized(_this));
    _this.registrar.handle = _this.handle; // Attach crypto channels

    if (!_this._modules.connEncryption || !_this._modules.connEncryption.length) {
      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
    }

    var cryptos = _this._modules.connEncryption;
    cryptos.forEach(function (crypto) {
      _this.upgrader.cryptos.set(crypto.protocol, crypto);
    });
    _this.dialer = new Dialer(_objectSpread({
      transportManager: _this.transportManager,
      peerStore: _this.peerStore
    }, _this._options.dialer));

    _this._modules.transport.forEach(function (Transport) {
      var key = Transport.prototype[Symbol.toStringTag];
      var transportOptions = _this._config.transport[key];

      _this.transportManager.add(key, Transport, transportOptions);
    });

    if (_this._config.relay.enabled) {
      // @ts-ignore Circuit prototype
      _this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);

      _this.relay = new Relay(_assertThisInitialized(_this));
    } // Attach stream multiplexers


    if (_this._modules.streamMuxer) {
      var muxers = _this._modules.streamMuxer;
      muxers.forEach(function (muxer) {
        _this.upgrader.muxers.set(muxer.multicodec, muxer);
      }); // Add the identify service since we can multiplex

      _this.identifyService = new IdentifyService({
        libp2p: _assertThisInitialized(_this)
      });

      _this.handle(Object.values(IdentifyService.getProtocolStr(_assertThisInitialized(_this))), _this.identifyService.handleMessage);
    } // Attach private network protector


    if (_this._modules.connProtector) {
      _this.upgrader.protector = _this._modules.connProtector;
    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {
      // eslint-disable-line no-undef
      throw new Error('Private network is enforced, but no protector was provided');
    } // dht provided components (peerRouting, contentRouting, dht)


    if (_this._modules.dht) {
      var DHT = _this._modules.dht; // @ts-ignore Object is not constructable

      _this._dht = new DHT(_objectSpread({
        libp2p: _assertThisInitialized(_this),
        dialer: _this.dialer,
        peerId: _this.peerId,
        peerStore: _this.peerStore,
        registrar: _this.registrar,
        datastore: _this.datastore
      }, _this._config.dht));
    } // Create pubsub if provided


    if (_this._modules.pubsub) {
      var Pubsub = _this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality

      /** @type {Pubsub} */

      _this.pubsub = PubsubAdapter(Pubsub, _assertThisInitialized(_this), _this._config.pubsub);
    } // Attach remaining APIs
    // peer and content routing will automatically get modules from _modules and _dht


    _this.peerRouting = new PeerRouting(_assertThisInitialized(_this));
    _this.contentRouting = new ContentRouting(_assertThisInitialized(_this)); // Mount default protocols

    _ping.mount(_assertThisInitialized(_this));

    _this._onDiscoveryPeer = _this._onDiscoveryPeer.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Overrides EventEmitter.emit to conditionally emit errors
   * if there is a handler. If not, errors will be logged.
   *
   * @param {string} eventName
   * @param  {...any} args
   * @returns {boolean}
   */


  _createClass(Libp2p, [{
    key: "emit",
    value: function emit(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // TODO: do we still need this?
      // @ts-ignore _events does not exist in libp2p
      if (eventName === 'error' && !this._events.error) {
        log.error(args);
        return false;
      } else {
        var _get2;

        return (_get2 = _get(_getPrototypeOf(Libp2p.prototype), "emit", this)).call.apply(_get2, [this, eventName].concat(args));
      }
    }
    /**
     * Starts the libp2p node and all its subsystems
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "start",
    value: function () {
      var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                log('libp2p is starting');
                _context.prev = 1;
                _context.next = 4;
                return this._onStarting();

              case 4:
                _context.next = 6;
                return this._onDidStart();

              case 6:
                log('libp2p has started');
                _context.next = 16;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](1);
                this.emit('error', _context.t0);
                log.error('An error occurred starting libp2p', _context.t0);
                _context.next = 15;
                return this.stop();

              case 15:
                throw _context.t0;

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 9]]);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
    /**
     * Stop the libp2p node by closing its listeners and open connections
     *
     * @async
     * @returns {Promise<void>}
     */

  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _iterator, _step, service;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                log('libp2p is stopping');
                _context2.prev = 1;
                this._isStarted = false;
                this.relay && this.relay.stop();
                this.peerRouting.stop();
                _iterator = _createForOfIteratorHelper(this._discovery.values());

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    service = _step.value;
                    service.removeListener('peer', this._onDiscoveryPeer);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                _context2.next = 9;
                return Promise.all(Array.from(this._discovery.values(), function (s) {
                  return s.stop();
                }));

              case 9:
                this._discovery = new Map();
                _context2.next = 12;
                return this.peerStore.stop();

              case 12:
                _context2.next = 14;
                return this.connectionManager.stop();

              case 14:
                _context2.next = 16;
                return Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);

              case 16:
                _context2.next = 18;
                return this.natManager.stop();

              case 18:
                _context2.next = 20;
                return this.transportManager.close();

              case 20:
                _ping.unmount(this);

                this.dialer.destroy();
                _context2.next = 27;
                break;

              case 24:
                _context2.prev = 24;
                _context2.t0 = _context2["catch"](1);

                if (_context2.t0) {
                  log.error(_context2.t0);
                  this.emit('error', _context2.t0);
                }

              case 27:
                log('libp2p has stopped');

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 24]]);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Load keychain keys from the datastore.
     * Imports the private key as 'self', if needed.
     *
     * @async
     * @returns {Promise<void>}
     */

  }, {
    key: "loadKeychain",
    value: function () {
      var _loadKeychain = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.keychain) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                _context3.prev = 2;
                _context3.next = 5;
                return this.keychain.findKeyByName('self');

              case 5:
                _context3.next = 11;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](2);
                _context3.next = 11;
                return this.keychain.importPeer('self', this.peerId);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 7]]);
      }));

      function loadKeychain() {
        return _loadKeychain.apply(this, arguments);
      }

      return loadKeychain;
    }()
  }, {
    key: "isStarted",
    value: function isStarted() {
      return this._isStarted;
    }
    /**
     * Gets a Map of the current connections. The keys are the stringified
     * `PeerId` of the peer. The value is an array of Connections to that peer.
     *
     * @returns {Map<string, Connection[]>}
     */

  }, {
    key: "connections",
    get: function get() {
      return this.connectionManager.connections;
    }
    /**
     * Dials to the provided peer. If successful, the known metadata of the
     * peer will be added to the nodes `peerStore`
     *
     * @param {PeerId|Multiaddr|string} peer - The peer to dial
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @returns {Promise<Connection>}
     */

  }, {
    key: "dial",
    value: function dial(peer, options) {
      return this._dial(peer, options);
    }
    /**
     * Dials to the provided peer and tries to handshake with the given protocols in order.
     * If successful, the known metadata of the peer will be added to the nodes `peerStore`,
     * and the `MuxedStream` will be returned together with the successful negotiated protocol.
     *
     * @async
     * @param {PeerId|Multiaddr|string} peer - The peer to dial
     * @param {string[]|string} protocols
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */

  }, {
    key: "dialProtocol",
    value: function () {
      var _dialProtocol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peer, protocols, options) {
        var connection;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(!protocols || !protocols.length)) {
                  _context4.next = 2;
                  break;
                }

                throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);

              case 2:
                _context4.next = 4;
                return this._dial(peer, options);

              case 4:
                connection = _context4.sent;
                return _context4.abrupt("return", connection.newStream(protocols));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function dialProtocol(_x, _x2, _x3) {
        return _dialProtocol.apply(this, arguments);
      }

      return dialProtocol;
    }()
    /**
     * @async
     * @param {PeerId|Multiaddr|string} peer - The peer to dial
     * @param {object} [options]
     * @returns {Promise<Connection>}
     */

  }, {
    key: "_dial",
    value: function () {
      var _dial2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(peer, options) {
        var _getPeer, id, multiaddrs, connection;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _getPeer = getPeer(peer), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;

                if (!id.equals(this.peerId)) {
                  _context5.next = 3;
                  break;
                }

                throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);

              case 3:
                connection = this.connectionManager.get(id);

                if (connection) {
                  _context5.next = 10;
                  break;
                }

                _context5.next = 7;
                return this.dialer.connectToPeer(peer, options);

              case 7:
                connection = _context5.sent;
                _context5.next = 11;
                break;

              case 10:
                if (multiaddrs) {
                  this.peerStore.addressBook.add(id, multiaddrs);
                }

              case 11:
                return _context5.abrupt("return", connection);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _dial(_x4, _x5) {
        return _dial2.apply(this, arguments);
      }

      return _dial;
    }()
    /**
     * Get a deduplicated list of peer advertising multiaddrs by concatenating
     * the listen addresses used by transports with any configured
     * announce addresses as well as observed addresses reported by peers.
     *
     * If Announce addrs are specified, configured listen addresses will be
     * ignored though observed addresses will still be included.
     *
     * @returns {Multiaddr[]}
     */

  }, {
    key: "multiaddrs",
    get: function get() {
      var addrs = this.addressManager.getAnnounceAddrs().map(function (ma) {
        return ma.toString();
      });

      if (!addrs.length) {
        // no configured announce addrs, add configured listen addresses
        addrs = this.transportManager.getAddrs().map(function (ma) {
          return ma.toString();
        });
      }

      addrs = addrs.concat(this.addressManager.getObservedAddrs().map(function (ma) {
        return ma.toString();
      }));
      var announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs

      var addrSet = new Set(addrs); // Create advertising list

      return announceFilter(Array.from(addrSet).map(function (str) {
        return new Multiaddr(str);
      }));
    }
    /**
     * Disconnects all connections to the given `peer`
     *
     * @param {PeerId|Multiaddr|string} peer - the peer to close connections to
     * @returns {Promise<void>}
     */

  }, {
    key: "hangUp",
    value: function () {
      var _hangUp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(peer) {
        var _getPeer2, id, connections;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _getPeer2 = getPeer(peer), id = _getPeer2.id;
                connections = this.connectionManager.connections.get(id.toB58String());

                if (connections) {
                  _context6.next = 4;
                  break;
                }

                return _context6.abrupt("return");

              case 4:
                _context6.next = 6;
                return Promise.all(connections.map(function (connection) {
                  return connection.close();
                }));

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function hangUp(_x6) {
        return _hangUp.apply(this, arguments);
      }

      return hangUp;
    }()
    /**
     * Pings the given peer in order to obtain the operation latency.
     *
     * @param {PeerId|Multiaddr|string} peer - The peer to ping
     * @returns {Promise<number>}
     */

  }, {
    key: "ping",
    value: function ping(peer) {
      var _getPeer3 = getPeer(peer),
          id = _getPeer3.id,
          multiaddrs = _getPeer3.multiaddrs; // If received multiaddr, ping it


      if (multiaddrs) {
        return _ping(this, multiaddrs[0]);
      }

      return _ping(this, id);
    }
    /**
     * Registers the `handler` for each protocol
     *
     * @param {string[]|string} protocols
     * @param {(props: HandlerProps) => void} handler
     */

  }, {
    key: "handle",
    value: function handle(protocols, handler) {
      var _this2 = this;

      protocols = Array.isArray(protocols) ? protocols : [protocols];
      protocols.forEach(function (protocol) {
        _this2.upgrader.protocols.set(protocol, handler);
      }); // Add new protocols to self protocols in the Protobook

      this.peerStore.protoBook.add(this.peerId, protocols);
    }
    /**
     * Removes the handler for each protocol. The protocol
     * will no longer be supported on streams.
     *
     * @param {string[]|string} protocols
     */

  }, {
    key: "unhandle",
    value: function unhandle(protocols) {
      var _this3 = this;

      protocols = Array.isArray(protocols) ? protocols : [protocols];
      protocols.forEach(function (protocol) {
        _this3.upgrader.protocols.delete(protocol);
      }); // Remove protocols from self protocols in the Protobook

      this.peerStore.protoBook.remove(this.peerId, protocols);
    }
  }, {
    key: "_onStarting",
    value: function () {
      var _onStarting2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var addrs;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                // Listen on the provided transports for the provided addresses
                addrs = this.addressManager.getListenAddrs();
                _context7.next = 3;
                return this.transportManager.listen(addrs);

              case 3:
                // Manage your NATs
                this.natManager.start(); // Start PeerStore

                _context7.next = 6;
                return this.peerStore.start();

              case 6:
                if (this._config.pubsub.enabled) {
                  this.pubsub && this.pubsub.start();
                } // DHT subsystem


                if (this._config.dht.enabled) {
                  this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as
                  // the other discovery modules

                  this._dht.on('peer', this._onDiscoveryPeer);
                } // Start metrics if present


                this.metrics && this.metrics.start();

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _onStarting() {
        return _onStarting2.apply(this, arguments);
      }

      return _onStarting;
    }()
    /**
     * Called when libp2p has started and before it returns
     *
     * @private
     */

  }, {
    key: "_onDidStart",
    value: function () {
      var _onDidStart2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var _this4 = this;

        var _iterator2, _step2, peer;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._isStarted = true;
                this.peerStore.on('peer', function (peerId) {
                  _this4.emit('peer:discovery', peerId);

                  _this4._maybeConnect(peerId);
                }); // Once we start, emit any peers we may have already discovered
                // TODO: this should be removed, as we already discovered these peers in the past

                _iterator2 = _createForOfIteratorHelper(this.peerStore.peers.values());

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    peer = _step2.value;
                    this.emit('peer:discovery', peer.id);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                this.connectionManager.start(); // Peer discovery

                _context8.next = 7;
                return this._setupPeerDiscovery();

              case 7:
                // Relay
                this.relay && this.relay.start();
                this.peerRouting.start();

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _onDidStart() {
        return _onDidStart2.apply(this, arguments);
      }

      return _onDidStart;
    }()
    /**
     * Called whenever peer discovery services emit `peer` events.
     * Known peers may be emitted.
     *
     * @private
     * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer
     */

  }, {
    key: "_onDiscoveryPeer",
    value: function _onDiscoveryPeer(peer) {
      if (peer.id.toB58String() === this.peerId.toB58String()) {
        log.error(new Error(codes.ERR_DISCOVERED_SELF));
        return;
      }

      peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);
      peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);
    }
    /**
     * Will dial to the given `peerId` if the current number of
     * connected peers is less than the configured `ConnectionManager`
     * minConnections.
     *
     * @private
     * @param {PeerId} peerId
     */

  }, {
    key: "_maybeConnect",
    value: function () {
      var _maybeConnect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(peerId) {
        var minConnections;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId))) {
                  _context9.next = 12;
                  break;
                }

                minConnections = this._options.connectionManager.minConnections || 0;

                if (!(minConnections > this.connectionManager.size)) {
                  _context9.next = 12;
                  break;
                }

                log('connecting to discovered peer %s', peerId.toB58String());
                _context9.prev = 4;
                _context9.next = 7;
                return this.dialer.connectToPeer(peerId);

              case 7:
                _context9.next = 12;
                break;

              case 9:
                _context9.prev = 9;
                _context9.t0 = _context9["catch"](4);
                log.error("could not connect to discovered peer ".concat(peerId.toB58String(), " with ").concat(_context9.t0));

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[4, 9]]);
      }));

      function _maybeConnect(_x7) {
        return _maybeConnect2.apply(this, arguments);
      }

      return _maybeConnect;
    }()
    /**
     * Initializes and starts peer discovery services
     *
     * @async
     * @private
     */

  }, {
    key: "_setupPeerDiscovery",
    value: function () {
      var _setupPeerDiscovery2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var _this5 = this;

        var setupService, _iterator3, _step3, DiscoveryService, _iterator4, _step4, Transport;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                /**
                 * @param {PeerDiscoveryFactory} DiscoveryService
                 */
                setupService = function setupService(DiscoveryService) {
                  var config = {
                    enabled: true // on by default

                  };

                  if (DiscoveryService.tag && _this5._config.peerDiscovery && _this5._config.peerDiscovery[DiscoveryService.tag]) {
                    // @ts-ignore PeerDiscovery not understood as an Object for spread
                    config = _objectSpread(_objectSpread({}, config), _this5._config.peerDiscovery[DiscoveryService.tag]);
                  }

                  if (config.enabled && !_this5._discovery.has(DiscoveryService.tag)) {
                    // not already added
                    var discoveryService;

                    if (typeof DiscoveryService === 'function') {
                      // @ts-ignore DiscoveryService has no constructor type inferred
                      discoveryService = new DiscoveryService(Object.assign({}, config, {
                        peerId: _this5.peerId,
                        libp2p: _this5
                      }));
                    } else {
                      discoveryService = DiscoveryService;
                    }

                    discoveryService.on('peer', _this5._onDiscoveryPeer);

                    _this5._discovery.set(DiscoveryService.tag, discoveryService);
                  }
                }; // Discovery modules


                _iterator3 = _createForOfIteratorHelper(this._modules.peerDiscovery || []);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    DiscoveryService = _step3.value;
                    setupService(DiscoveryService);
                  } // Transport modules with discovery

                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                _iterator4 = _createForOfIteratorHelper(this.transportManager.getTransports());

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    Transport = _step4.value;

                    // @ts-ignore Transport interface does not include discovery
                    if (Transport.discovery) {
                      // @ts-ignore Transport interface does not include discovery
                      setupService(Transport.discovery);
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }

                _context10.next = 7;
                return Promise.all(Array.from(this._discovery.values(), function (d) {
                  return d.start();
                }));

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _setupPeerDiscovery() {
        return _setupPeerDiscovery2.apply(this, arguments);
      }

      return _setupPeerDiscovery;
    }()
  }], [{
    key: "create",
    value:
    /**
     * Like `new Libp2p(options)` except it will create a `PeerId`
     * instance if one is not provided in options.
     *
     * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options
     * @returns {Promise<Libp2p>}
     */
    function () {
      var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(options) {
        var peerId;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!options.peerId) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", new Libp2p(options));

              case 2:
                _context11.next = 4;
                return PeerId.create();

              case 4:
                peerId = _context11.sent;
                options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'

                return _context11.abrupt("return", new Libp2p(options));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      function create(_x8) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }]);

  return Libp2p;
}(EventEmitter);

module.exports = Libp2p;
},{"debug":"node_modules/debug/src/browser.js","events":"node_modules/events/events.js","err-code":"node_modules/err-code/index.js","peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","./peer-routing":"node_modules/libp2p/src/peer-routing.js","./content-routing":"node_modules/libp2p/src/content-routing/index.js","./get-peer":"node_modules/libp2p/src/get-peer.js","./config":"node_modules/libp2p/src/config.js","./errors":"node_modules/libp2p/src/errors.js","./address-manager":"node_modules/libp2p/src/address-manager/index.js","./connection-manager":"node_modules/libp2p/src/connection-manager/index.js","./circuit/transport":"node_modules/libp2p/src/circuit/transport.js","./circuit":"node_modules/libp2p/src/circuit/index.js","./dialer":"node_modules/libp2p/src/dialer/index.js","./keychain":"node_modules/libp2p/src/keychain/index.js","./metrics":"node_modules/libp2p/src/metrics/index.js","./transport-manager":"node_modules/libp2p/src/transport-manager.js","./upgrader":"node_modules/libp2p/src/upgrader.js","./peer-store":"node_modules/libp2p/src/peer-store/index.js","./pubsub-adapter":"node_modules/libp2p/src/pubsub-adapter.js","./peer-store/persistent":"node_modules/libp2p/src/peer-store/persistent/index.js","./registrar":"node_modules/libp2p/src/registrar.js","./ping":"node_modules/libp2p/src/ping/index.js","./identify":"node_modules/libp2p/src/identify/index.js","./nat-manager":"node_modules/libp2p/src/nat-manager.js","./record/utils":"node_modules/libp2p/src/record/utils.js"}],"node_modules/it-ws/web-socket.js":[function(require,module,exports) {
/* eslint-env browser */
module.exports = typeof WebSocket === 'undefined' ? require('ws') : WebSocket

},{"ws":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/event-iterator/lib/event-iterator.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class EventQueue {
    constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
    }
    push(value) {
        if (this.isStopped)
            return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
                placeholder.resolve(resolution);
        }
        else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== undefined &&
                this.pushQueue.length >= this.highWaterMark &&
                !this.isPaused) {
                this.isPaused = true;
                if (this.eventHandlers.highWater) {
                    this.eventHandlers.highWater();
                }
                else if (console) {
                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
                }
            }
        }
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: undefined, done: true });
        }
        this.pullQueue.length = 0;
    }
    fail(error) {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
                placeholder.reject(error);
            }
            this.pullQueue.length = 0;
        }
        else {
            const rejection = Promise.reject(error);
            /* Attach error handler to avoid leaking an unhandled promise rejection. */
            rejection.catch(() => { });
            this.pushQueue.push(rejection);
        }
    }
    remove() {
        Promise.resolve().then(() => {
            if (this.removeCallback)
                this.removeCallback();
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: (value) => {
                const result = this.pushQueue.shift();
                if (result) {
                    if (this.lowWaterMark !== undefined &&
                        this.pushQueue.length <= this.lowWaterMark &&
                        this.isPaused) {
                        this.isPaused = false;
                        if (this.eventHandlers.lowWater) {
                            this.eventHandlers.lowWater();
                        }
                    }
                    return result;
                }
                else if (this.isStopped) {
                    return Promise.resolve({ value: undefined, done: true });
                }
                else {
                    return new Promise((resolve, reject) => {
                        this.pullQueue.push({ resolve, reject });
                    });
                }
            },
            return: () => {
                this.isStopped = true;
                this.pushQueue.length = 0;
                this.remove();
                return Promise.resolve({ value: undefined, done: true });
            },
        };
    }
}
class EventIterator {
    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback =
            listen({
                push: value => queue.push(value),
                stop: () => queue.stop(),
                fail: error => queue.fail(error),
                on: (event, fn) => {
                    queue.eventHandlers[event] = fn;
                },
            }) || (() => { });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
    }
}
exports.EventIterator = EventIterator;
exports.default = EventIterator;

},{}],"node_modules/event-iterator/lib/dom.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const event_iterator_1 = require("./event-iterator");
exports.EventIterator = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
    }, evOptions);
}
exports.subscribe = subscribe;
exports.default = event_iterator_1.EventIterator;

},{"./event-iterator":"node_modules/event-iterator/lib/event-iterator.js"}],"node_modules/it-ws/source.js":[function(require,module,exports) {

const { Buffer } = require('buffer')
const { EventIterator } = require('event-iterator')

// copied from github.com/feross/buffer
// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

module.exports = socket => {
  const removeListener = socket.removeEventListener || socket.removeListener

  const source = (async function * () {
    const messages = new EventIterator(
      ({ push, stop, fail }) => {
        socket.addEventListener('message', push)
        socket.addEventListener('error', fail)
        socket.addEventListener('close', stop)

        return () => {
          removeListener.call(socket, 'message', push)
          removeListener.call(socket, 'error', fail)
          removeListener.call(socket, 'close', stop)
        }
      },
      { highWaterMark: Infinity }
    )

    for await (const { data } of messages) {
      yield isArrayBuffer(data) ? Buffer.from(data) : data
    }
  })()

  let connected = socket.readyState === 1
  let connError

  socket.addEventListener('open', () => {
    connected = true
    connError = null
  })

  socket.addEventListener('close', () => {
    connected = false
    connError = null
  })

  socket.addEventListener('error', err => {
    if (!connected) connError = err
  })

  source.connected = () => new Promise((resolve, reject) => {
    if (connected) return resolve()
    if (connError) return reject(connError)

    const cleanUp = cont => {
      removeListener.call(socket, 'open', onOpen)
      removeListener.call(socket, 'error', onError)
      cont()
    }

    const onOpen = () => cleanUp(resolve)
    const onError = err => cleanUp(() => reject(err))

    socket.addEventListener('open', onOpen)
    socket.addEventListener('error', onError)
  })

  return source
}

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","event-iterator":"node_modules/event-iterator/lib/dom.js"}],"node_modules/it-ws/ready.js":[function(require,module,exports) {
module.exports = async socket => {
  // if the socket is closing or closed, return end
  if (socket.readyState >= 2) {
    throw new Error('socket closed')
  }

  // if open, return
  if (socket.readyState === 1) {
    return
  }

  return new Promise((resolve, reject) => {
    const remove = socket && (socket.removeEventListener || socket.removeListener)

    function cleanup () {
      if (typeof remove === 'function') {
        remove.call(socket, 'open', handleOpen)
        remove.call(socket, 'error', handleErr)
      }
    }

    function handleOpen () {
      cleanup(); resolve()
    }

    function handleErr (evt) {
      cleanup(); reject(evt)
    }

    socket.addEventListener('open', handleOpen)
    socket.addEventListener('error', handleErr)
  })
}

},{}],"node_modules/it-ws/sink.js":[function(require,module,exports) {
const ready = require('./ready')

module.exports = (socket, options) => {
  options = options || {}
  options.closeOnEnd = options.closeOnEnd !== false

  return async source => {
    for await (const data of source) {
      try {
        await ready(socket)
      } catch (err) {
        if (err.message === 'socket closed') break
        throw err
      }

      socket.send(data)
    }

    if (options.closeOnEnd && socket.readyState <= 1) {
      return new Promise((resolve, reject) => {
        socket.addEventListener('close', event => {
          if (event.wasClean || event.code === 1006) {
            resolve()
          } else {
            const err = Object.assign(new Error('ws error'), { event })
            reject(err)
          }
        })

        setTimeout(() => socket.close())
      })
    }
  }
}

},{"./ready":"node_modules/it-ws/ready.js"}],"node_modules/it-ws/duplex.js":[function(require,module,exports) {
const source = require('./source')
const sink = require('./sink')

module.exports = (socket, options) => {
  options = options || {}

  if (options.binaryType) {
    socket.binaryType = options.binaryType
  } else if (options.binary) {
    socket.binaryType = 'arraybuffer'
  }

  const duplex = {
    sink: sink(socket, options),
    source: source(socket, options),
    connected: () => duplex.source.connected()
  }

  return duplex
}

},{"./source":"node_modules/it-ws/source.js","./sink":"node_modules/it-ws/sink.js"}],"node_modules/iso-url/src/url-browser.js":[function(require,module,exports) {
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

function getDefaultBase() {
  if (isReactNative) {
    return 'http://localhost';
  }

  return self.location.protocol + '//' + self.location.host;
}

var URL = self.URL;
var defaultBase = getDefaultBase();

var URLWithLegacySupport = /*#__PURE__*/function () {
  function URLWithLegacySupport() {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultBase;

    _classCallCheck(this, URLWithLegacySupport);

    this.super = new URL(url, base);
    this.path = this.pathname + this.search;
    this.auth = this.username && this.password ? this.username + ':' + this.password : null;
    this.query = this.search && this.search.startsWith('?') ? this.search.slice(1) : null;
  }

  _createClass(URLWithLegacySupport, [{
    key: "hash",
    get: function get() {
      return this.super.hash;
    },
    set: function set(hash) {
      this.super.hash = hash;
    }
  }, {
    key: "host",
    get: function get() {
      return this.super.host;
    },
    set: function set(host) {
      this.super.host = host;
    }
  }, {
    key: "hostname",
    get: function get() {
      return this.super.hostname;
    },
    set: function set(hostname) {
      this.super.hostname = hostname;
    }
  }, {
    key: "href",
    get: function get() {
      return this.super.href;
    },
    set: function set(href) {
      this.super.href = href;
    }
  }, {
    key: "origin",
    get: function get() {
      return this.super.origin;
    }
  }, {
    key: "password",
    get: function get() {
      return this.super.password;
    },
    set: function set(password) {
      this.super.password = password;
    }
  }, {
    key: "pathname",
    get: function get() {
      return this.super.pathname;
    },
    set: function set(pathname) {
      this.super.pathname = pathname;
    }
  }, {
    key: "port",
    get: function get() {
      return this.super.port;
    },
    set: function set(port) {
      this.super.port = port;
    }
  }, {
    key: "protocol",
    get: function get() {
      return this.super.protocol;
    },
    set: function set(protocol) {
      this.super.protocol = protocol;
    }
  }, {
    key: "search",
    get: function get() {
      return this.super.search;
    },
    set: function set(search) {
      this.super.search = search;
    }
  }, {
    key: "searchParams",
    get: function get() {
      return this.super.searchParams;
    }
  }, {
    key: "username",
    get: function get() {
      return this.super.username;
    },
    set: function set(username) {
      this.super.username = username;
    }
    /**
     * @param {any} o
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.super.toJSON();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.super.toString();
    }
  }, {
    key: "format",
    value: function format() {
      return this.toString();
    }
  }], [{
    key: "createObjectURL",
    value: function createObjectURL(o) {
      return URL.createObjectURL(o);
    }
    /**
     * @param {string} o
     */

  }, {
    key: "revokeObjectURL",
    value: function revokeObjectURL(o) {
      URL.revokeObjectURL(o);
    }
  }]);

  return URLWithLegacySupport;
}();
/**
 * @param {string | import('url').UrlObject} obj
 */


function format(obj) {
  if (typeof obj === 'string') {
    var url = new URL(obj);
    return url.toString();
  }

  if (!(obj instanceof URL)) {
    var userPass = // @ts-ignore its not supported in node but we normalise
    obj.username && obj.password // @ts-ignore its not supported in node but we normalise
    ? "".concat(obj.username, ":").concat(obj.password, "@") : '';
    var auth = obj.auth ? obj.auth + '@' : '';
    var port = obj.port ? ':' + obj.port : '';
    var protocol = obj.protocol ? obj.protocol + '//' : '';
    var host = obj.host || '';
    var hostname = obj.hostname || '';
    var search = obj.search || (obj.query ? '?' + obj.query : '');
    var hash = obj.hash || '';
    var pathname = obj.pathname || ''; // @ts-ignore - path is not supported in node but we normalise

    var path = obj.path || pathname + search;
    return "".concat(protocol).concat(userPass || auth).concat(host || hostname + port).concat(path).concat(hash);
  }
}

module.exports = {
  URLWithLegacySupport: URLWithLegacySupport,
  URLSearchParams: self.URLSearchParams,
  defaultBase: defaultBase,
  format: format
};
},{}],"node_modules/iso-url/src/relative.js":[function(require,module,exports) {
'use strict';

var _require = require('./url'),
    URLWithLegacySupport = _require.URLWithLegacySupport,
    format = _require.format;
/**
 * @param {string | undefined} url
 * @param {any} [location]
 * @param {any} [protocolMap]
 * @param {any} [defaultProtocol]
 */


module.exports = function (url) {
  var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var protocolMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var defaultProtocol = arguments.length > 3 ? arguments[3] : undefined;
  var protocol = location.protocol ? location.protocol.replace(':', '') : 'http'; // Check protocol map

  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
  var urlParsed;

  try {
    urlParsed = new URLWithLegacySupport(url);
  } catch (err) {
    urlParsed = {};
  }

  var base = Object.assign({}, location, {
    protocol: protocol || urlParsed.protocol,
    host: location.host || urlParsed.host
  });
  return new URLWithLegacySupport(url, format(base)).toString();
};
},{"./url":"node_modules/iso-url/src/url-browser.js"}],"node_modules/iso-url/index.js":[function(require,module,exports) {
'use strict';

var _require = require('./src/url'),
    URLWithLegacySupport = _require.URLWithLegacySupport,
    format = _require.format,
    URLSearchParams = _require.URLSearchParams,
    defaultBase = _require.defaultBase;

var relative = require('./src/relative');

module.exports = {
  URL: URLWithLegacySupport,
  URLSearchParams: URLSearchParams,
  format: format,
  relative: relative,
  defaultBase: defaultBase
};
},{"./src/url":"node_modules/iso-url/src/url-browser.js","./src/relative":"node_modules/iso-url/src/relative.js"}],"node_modules/it-ws/ws-url.js":[function(require,module,exports) {
const { relative } = require('iso-url')
const map = { http: 'ws', https: 'wss' }
const def = 'ws'

module.exports = (url, location) => relative(url, location, map, def)

},{"iso-url":"node_modules/iso-url/index.js"}],"node_modules/it-ws/client.js":[function(require,module,exports) {
'use strict'

// load websocket library if we are not in the browser
var WebSocket = require('./web-socket')
var duplex = require('./duplex')
var wsurl = require('./ws-url')

module.exports = function (addr, opts = {}) {
  const location = typeof window === 'undefined' ? {} : window.location

  const url = wsurl(addr, location)
  const socket = new WebSocket(url, opts.websocket)

  const stream = duplex(socket, opts)
  stream.remoteAddress = url
  stream.close = () => new Promise((resolve, reject) => {
    socket.addEventListener('close', resolve)
    socket.close()
  })
  stream.destroy = () => {
    if (socket.terminate) {
      socket.terminate()
    } else {
      socket.close()
    }
  }
  stream.socket = socket

  return stream
}

module.exports.connect = module.exports

},{"./web-socket":"node_modules/it-ws/web-socket.js","./duplex":"node_modules/it-ws/duplex.js","./ws-url":"node_modules/it-ws/ws-url.js"}],"node_modules/multiaddr-to-uri/index.js":[function(require,module,exports) {
const { Multiaddr } = require('multiaddr')

const reduceValue = (_, v) => v
const tcpUri = (str, port, parts, opts) => {
  // return tcp when explicitly requested
  if (opts && opts.assumeHttp === false) return `tcp://${str}:${port}`
  // check if tcp is the last protocol in multiaddr
  let protocol = 'tcp'
  let explicitPort = `:${port}`
  const last = parts[parts.length - 1]
  if (last.protocol === 'tcp') {
    // assume http and produce clean urls
    protocol = port === '443' ? 'https' : 'http'
    explicitPort = port === '443' || port === '80' ? '' : explicitPort
  }
  return `${protocol}://${str}${explicitPort}`
}

const Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i, parts) => (
    parts.length === 1 && parts[0].protocol === 'ip6'
      ? content
      : `[${content}]`
  ),
  tcp: (str, content, i, parts, opts) => (
    parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))
      ? `${str}:${content}`
      : tcpUri(str, content, parts, opts)
  ),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: str => `http://${str}`,
  https: str => `https://${str}`,
  ws: str => `ws://${str}`,
  wss: str => `wss://${str}`,
  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,
  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,
  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`
}

module.exports = (multiaddr, opts) => {
  const ma = new Multiaddr(multiaddr)
  const parts = multiaddr.toString().split('/').slice(1)
  return ma
    .tuples()
    .map(tuple => ({
      protocol: parts.shift(),
      content: tuple[1] ? parts.shift() : null
    }))
    .reduce((str, part, i, parts) => {
      const reduce = Reducers[part.protocol]
      if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`)
      return reduce(str, part.content, i, parts, opts)
    }, '')
}

},{"multiaddr":"node_modules/multiaddr/src/index.js"}],"node_modules/ipfs-utils/src/env.js":[function(require,module,exports) {
var process = require("process");
'use strict';

const isElectron = require('is-electron');

const IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9; // @ts-ignore

const IS_ELECTRON = isElectron();
const IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
const IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
const IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
const IS_NODE = typeof require === 'function' && typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node' && !IS_ELECTRON; // @ts-ignore - we either ignore worker scope or dom scope

const IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
const IS_TEST = typeof process !== 'undefined' && typeof process.env !== 'undefined' && "development" === 'test';
const IS_REACT_NATIVE = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
module.exports = {
  isTest: IS_TEST,
  isElectron: IS_ELECTRON,
  isElectronMain: IS_ELECTRON_MAIN,
  isElectronRenderer: IS_ELECTRON_RENDERER,
  isNode: IS_NODE,

  /**
   * Detects browser main thread  **NOT** web worker or service worker
   */
  isBrowser: IS_BROWSER,
  isWebWorker: IS_WEBWORKER,
  isEnvWithDom: IS_ENV_WITH_DOM,
  isReactNative: IS_REACT_NATIVE
};
},{"is-electron":"node_modules/is-electron/index.js","process":"node_modules/process/browser.js"}],"node_modules/libp2p-websockets/src/listener.browser.js":[function(require,module,exports) {
'use strict'

module.exports = function () {
  throw new Error('WebSocket Servers can not be created in the browser!')
}

},{}],"node_modules/libp2p-websockets/src/constants.js":[function(require,module,exports) {
'use strict'

// p2p multi-address code
exports.CODE_P2P = 421
exports.CODE_CIRCUIT = 290

exports.CODE_TCP = 6
exports.CODE_WS = 477
exports.CODE_WSS = 478

// Time to wait for a connection to close gracefully before destroying it manually
exports.CLOSE_TIMEOUT = 2000

},{}],"node_modules/ip-address/dist/esm/lib/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInSubnet = isInSubnet;
exports.isCorrect = isCorrect;

function isInSubnet(address) {
  if (this.subnetMask < address.subnetMask) {
    return false;
  }

  if (this.mask(address.subnetMask) === address.mask()) {
    return true;
  }

  return false;
}

function isCorrect(defaultBits) {
  return function () {
    if (this.addressMinusSuffix !== this.correctForm()) {
      return false;
    }

    if (this.subnetMask === defaultBits && !this.parsedSubnet) {
      return true;
    }

    return this.parsedSubnet === String(this.subnetMask);
  };
}
},{}],"node_modules/ip-address/dist/esm/lib/v4/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;
var BITS = 32;
exports.BITS = BITS;
var GROUPS = 4;
exports.GROUPS = GROUPS;
var RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
exports.RE_ADDRESS = RE_ADDRESS;
var RE_SUBNET_STRING = /\/\d{1,2}$/;
exports.RE_SUBNET_STRING = RE_SUBNET_STRING;
},{}],"node_modules/ip-address/dist/esm/lib/address-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddressError = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AddressError = /*#__PURE__*/function (_Error) {
  _inherits(AddressError, _Error);

  var _super = _createSuper(AddressError);

  function AddressError(message, parseMessage) {
    var _this;

    _classCallCheck(this, AddressError);

    _this = _super.call(this, message);
    _this.name = 'AddressError';

    if (parseMessage !== null) {
      _this.parseMessage = parseMessage;
    }

    return _this;
  }

  return AddressError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.AddressError = AddressError;
},{}],"node_modules/jsbn/index.js":[function(require,module,exports) {
(function(){

    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+this.DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))    // force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {    // ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // Expose the Barrett function
    BigInteger.prototype.Barrett = Barrett

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)

    // Random number generator - requires a PRNG backend, e.g. prng4.js

    // For best results, put code like
    // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
    // in your main HTML document.

    var rng_state;
    var rng_pool;
    var rng_pptr;

    // Mix in a 32-bit integer into the pool
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= (x >> 8) & 255;
      rng_pool[rng_pptr++] ^= (x >> 16) & 255;
      rng_pool[rng_pptr++] ^= (x >> 24) & 255;
      if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
    }

    // Mix in the current time (w/milliseconds) into the pool
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }

    // Initialize the pool with junk if needed.
    if(rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t;
      if(typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          // Use webcrypto if available
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for(t = 0; t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        }
        else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
          // Extract entropy (256 bits) from NS4 RNG if available
          var z = window.crypto.random(32);
          for(t = 0; t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
      //rng_seed_int(window.screenX);
      //rng_seed_int(window.screenY);
    }

    function rng_get_byte() {
      if(rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
        //rng_pool = null;
      }
      // TODO: allow reseeding after first request
      return rng_state.next();
    }

    function rng_get_bytes(ba) {
      var i;
      for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
    }

    function SecureRandom() {}

    SecureRandom.prototype.nextBytes = rng_get_bytes;

    // prng4.js - uses Arcfour as a PRNG

    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }

    // Initialize arcfour context from key, an array of ints, each from [0..255]
    function ARC4init(key) {
      var i, j, t;
      for(i = 0; i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for(i = 0; i < 256; ++i) {
        j = (j + this.S[i] + key[i % key.length]) & 255;
        t = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t;
      }
      this.i = 0;
      this.j = 0;
    }

    function ARC4next() {
      var t;
      this.i = (this.i + 1) & 255;
      this.j = (this.j + this.S[this.i]) & 255;
      t = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t;
      return this.S[(t + this.S[this.i]) & 255];
    }

    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;

    // Plug in your RNG constructor here
    function prng_newstate() {
      return new Arcfour();
    }

    // Pool size must be a multiple of 4 and greater than 32.
    // An array of bytes the size of the pool will be passed to init()
    var rng_psize = 256;

    if (typeof exports !== 'undefined') {
        exports = module.exports = {
            default: BigInteger,
            BigInteger: BigInteger,
            SecureRandom: SecureRandom,
        };
    } else {
        this.jsbn = {
          BigInteger: BigInteger,
          SecureRandom: SecureRandom
        };
    }

}).call(this);

},{}],"node_modules/sprintf-js/src/sprintf.js":[function(require,module,exports) {
var define;
/* global window, exports, define */

!function() {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== 'undefined') {
        exports['sprintf'] = sprintf
        exports['vsprintf'] = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (typeof define === 'function' && define['amd']) {
            define(function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            })
        }
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line

},{}],"node_modules/ip-address/dist/esm/lib/ipv4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Address4 = void 0;

var common = _interopRequireWildcard(require("./common"));

var constants = _interopRequireWildcard(require("./v4/constants"));

var _addressError = require("./address-error");

var _jsbn = require("jsbn");

var _sprintfJs = require("sprintf-js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Represents an IPv4 address
 * @class Address4
 * @param {string} address - An IPv4 address string
 */
var Address4 = /*#__PURE__*/function () {
  function Address4(address) {
    _classCallCheck(this, Address4);

    this.groups = constants.GROUPS;
    this.parsedAddress = [];
    this.parsedSubnet = '';
    this.subnet = '/32';
    this.subnetMask = 32;
    this.v4 = true;
    /**
     * Returns true if the address is correct, false otherwise
     * @memberof Address4
     * @instance
     * @returns {Boolean}
     */

    this.isCorrect = common.isCorrect(constants.BITS);
    /**
     * Returns true if the given address is in the subnet of the current address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */

    this.isInSubnet = common.isInSubnet;
    this.address = address;
    var subnet = constants.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = "/".concat(this.subnetMask);

      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
        throw new _addressError.AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants.RE_SUBNET_STRING, '');
    }

    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(address);
  }

  _createClass(Address4, [{
    key: "parse",
    value:
    /*
     * Parses a v4 address
     */
    function parse(address) {
      var groups = address.split('.');

      if (!address.match(constants.RE_ADDRESS)) {
        throw new _addressError.AddressError('Invalid IPv4 address.');
      }

      return groups;
    }
    /**
     * Returns the correct form of an address
     * @memberof Address4
     * @instance
     * @returns {String}
     */

  }, {
    key: "correctForm",
    value: function correctForm() {
      return this.parsedAddress.map(function (part) {
        return parseInt(part, 10);
      }).join('.');
    }
    /**
     * Converts a hex string to an IPv4 address object
     * @memberof Address4
     * @static
     * @param {string} hex - a hex string to convert
     * @returns {Address4}
     */

  }, {
    key: "toHex",
    value:
    /**
     * Converts an IPv4 address object to a hex string
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    function toHex() {
      return this.parsedAddress.map(function (part) {
        return (0, _sprintfJs.sprintf)('%02x', parseInt(part, 10));
      }).join(':');
    }
    /**
     * Converts an IPv4 address object to an array of bytes
     * @memberof Address4
     * @instance
     * @returns {Array}
     */

  }, {
    key: "toArray",
    value: function toArray() {
      return this.parsedAddress.map(function (part) {
        return parseInt(part, 10);
      });
    }
    /**
     * Converts an IPv4 address object to an IPv6 address group
     * @memberof Address4
     * @instance
     * @returns {String}
     */

  }, {
    key: "toGroup6",
    value: function toGroup6() {
      var output = [];
      var i;

      for (i = 0; i < constants.GROUPS; i += 2) {
        var hex = (0, _sprintfJs.sprintf)('%02x%02x', parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
        output.push((0, _sprintfJs.sprintf)('%x', parseInt(hex, 16)));
      }

      return output.join(':');
    }
    /**
     * Returns the address as a BigInteger
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "bigInteger",
    value: function bigInteger() {
      return new _jsbn.BigInteger(this.parsedAddress.map(function (n) {
        return (0, _sprintfJs.sprintf)('%02x', parseInt(n, 10));
      }).join(''), 16);
    }
    /**
     * Helper function getting start address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_startAddress",
    value: function _startAddress() {
      return new _jsbn.BigInteger(this.mask() + '0'.repeat(constants.BITS - this.subnetMask), 2);
    }
    /**
     * The first address in the range given by this address' subnet.
     * Often referred to as the Network Address.
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "startAddress",
    value: function startAddress() {
      return Address4.fromBigInteger(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "startAddressExclusive",
    value: function startAddressExclusive() {
      var adjust = new _jsbn.BigInteger('1');
      return Address4.fromBigInteger(this._startAddress().add(adjust));
    }
    /**
     * Helper function getting end address.
     * @memberof Address4
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_endAddress",
    value: function _endAddress() {
      return new _jsbn.BigInteger(this.mask() + '1'.repeat(constants.BITS - this.subnetMask), 2);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "endAddress",
    value: function endAddress() {
      return Address4.fromBigInteger(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */

  }, {
    key: "endAddressExclusive",
    value: function endAddressExclusive() {
      var adjust = new _jsbn.BigInteger('1');
      return Address4.fromBigInteger(this._endAddress().subtract(adjust));
    }
    /**
     * Converts a BigInteger to a v4 address object
     * @memberof Address4
     * @static
     * @param {BigInteger} bigInteger - a BigInteger to convert
     * @returns {Address4}
     */

  }, {
    key: "mask",
    value:
    /**
     * Returns the first n bits of the address, defaulting to the
     * subnet mask
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    function mask(_mask) {
      if (_mask === undefined) {
        _mask = this.subnetMask;
      }

      return this.getBitsBase2(0, _mask);
    }
    /**
     * Returns the bits in the given range as a base-2 string
     * @memberof Address4
     * @instance
     * @returns {string}
     */

  }, {
    key: "getBitsBase2",
    value: function getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address4
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
     * @instance
     * @returns {String}
     */

  }, {
    key: "reverseForm",
    value: function reverseForm(options) {
      if (!options) {
        options = {};
      }

      var reversed = this.correctForm().split('.').reverse().join('.');

      if (options.omitSuffix) {
        return reversed;
      }

      return (0, _sprintfJs.sprintf)('%s.in-addr.arpa.', reversed);
    }
    /**
     * Returns true if the given address is a multicast address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isMulticast",
    value: function isMulticast() {
      return this.isInSubnet(new Address4('224.0.0.0/4'));
    }
    /**
     * Returns a zero-padded base-2 string representation of the address
     * @memberof Address4
     * @instance
     * @returns {string}
     */

  }, {
    key: "binaryZeroPad",
    value: function binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants.BITS, '0');
    }
    /**
     * Groups an IPv4 address for inclusion at the end of an IPv6 address
     * @returns {String}
     */

  }, {
    key: "groupForV6",
    value: function groupForV6() {
      var segments = this.parsedAddress;
      return this.address.replace(constants.RE_ADDRESS, (0, _sprintfJs.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join('.'), segments.slice(2, 4).join('.')));
    }
  }], [{
    key: "isValid",
    value: function isValid(address) {
      try {
        // eslint-disable-next-line no-new
        new Address4(address);
        return true;
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var padded = hex.replace(/:/g, '').padStart(8, '0');
      var groups = [];
      var i;

      for (i = 0; i < 8; i += 2) {
        var h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }

      return new Address4(groups.join('.'));
    }
    /**
     * Converts an integer into a IPv4 address object
     * @memberof Address4
     * @static
     * @param {integer} integer - a number to convert
     * @returns {Address4}
     */

  }, {
    key: "fromInteger",
    value: function fromInteger(integer) {
      return Address4.fromHex(integer.toString(16));
    }
    /**
     * Return an address from in-addr.arpa form
     * @memberof Address4
     * @static
     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
     * @returns {Adress4}
     * @example
     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
     * address.correctForm(); // '192.0.2.42'
     */

  }, {
    key: "fromArpa",
    value: function fromArpa(arpaFormAddress) {
      // remove ending ".in-addr.arpa." or just "."
      var leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, '');
      var address = leader.split('.').reverse().join('.');
      return new Address4(address);
    }
  }, {
    key: "fromBigInteger",
    value: function fromBigInteger(bigInteger) {
      return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
    }
  }]);

  return Address4;
}();

exports.Address4 = Address4;
},{"./common":"node_modules/ip-address/dist/esm/lib/common.js","./v4/constants":"node_modules/ip-address/dist/esm/lib/v4/constants.js","./address-error":"node_modules/ip-address/dist/esm/lib/address-error.js","jsbn":"node_modules/jsbn/index.js","sprintf-js":"node_modules/sprintf-js/src/sprintf.js"}],"node_modules/ip-address/dist/esm/lib/v6/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;
var BITS = 128;
exports.BITS = BITS;
var GROUPS = 8;
/**
 * Represents IPv6 address scopes
 * @memberof Address6
 * @static
 */

exports.GROUPS = GROUPS;
var SCOPES = {
  0: 'Reserved',
  1: 'Interface local',
  2: 'Link local',
  4: 'Admin local',
  5: 'Site local',
  8: 'Organization local',
  14: 'Global',
  15: 'Reserved'
};
/**
 * Represents IPv6 address types
 * @memberof Address6
 * @static
 */

exports.SCOPES = SCOPES;
var TYPES = {
  'ff01::1/128': 'Multicast (All nodes on this interface)',
  'ff01::2/128': 'Multicast (All routers on this interface)',
  'ff02::1/128': 'Multicast (All nodes on this link)',
  'ff02::2/128': 'Multicast (All routers on this link)',
  'ff05::2/128': 'Multicast (All routers in this site)',
  'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',
  'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',
  'ff02::9/128': 'Multicast (RIP routers)',
  'ff02::a/128': 'Multicast (EIGRP routers)',
  'ff02::d/128': 'Multicast (PIM routers)',
  'ff02::16/128': 'Multicast (MLDv2 reports)',
  'ff01::fb/128': 'Multicast (mDNSv6)',
  'ff02::fb/128': 'Multicast (mDNSv6)',
  'ff05::fb/128': 'Multicast (mDNSv6)',
  'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',
  'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',
  'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',
  'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',
  '::/128': 'Unspecified',
  '::1/128': 'Loopback',
  'ff00::/8': 'Multicast',
  'fe80::/10': 'Link-local unicast'
};
/**
 * A regular expression that matches bad characters in an IPv6 address
 * @memberof Address6
 * @static
 */

exports.TYPES = TYPES;
var RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
/**
 * A regular expression that matches an incorrect IPv6 address
 * @memberof Address6
 * @static
 */

exports.RE_BAD_CHARACTERS = RE_BAD_CHARACTERS;
var RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
/**
 * A regular expression that matches an IPv6 subnet
 * @memberof Address6
 * @static
 */

exports.RE_BAD_ADDRESS = RE_BAD_ADDRESS;
var RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
/**
 * A regular expression that matches an IPv6 zone
 * @memberof Address6
 * @static
 */

exports.RE_SUBNET_STRING = RE_SUBNET_STRING;
var RE_ZONE_STRING = /%.*$/;
exports.RE_ZONE_STRING = RE_ZONE_STRING;
var RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
exports.RE_URL = RE_URL;
var RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
exports.RE_URL_WITH_PORT = RE_URL_WITH_PORT;
},{}],"node_modules/ip-address/dist/esm/lib/v6/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spanAllZeroes = spanAllZeroes;
exports.spanAll = spanAll;
exports.spanLeadingZeroes = spanLeadingZeroes;
exports.simpleGroup = simpleGroup;

var _sprintfJs = require("sprintf-js");

/**
 * @returns {String} the string with all zeroes contained in a <span>
 */
function spanAllZeroes(s) {
  return s.replace(/(0+)/g, '<span class="zero">$1</span>');
}
/**
 * @returns {String} the string with each character contained in a <span>
 */


function spanAll(s) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var letters = s.split('');
  return letters.map(function (n, i) {
    return (0, _sprintfJs.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n));
  } // XXX Use #base-2 .value-0 instead?
  ).join('');
}

function spanLeadingZeroesSimple(group) {
  return group.replace(/^(0+)/, '<span class="zero">$1</span>');
}
/**
 * @returns {String} the string with leading zeroes contained in a <span>
 */


function spanLeadingZeroes(address) {
  var groups = address.split(':');
  return groups.map(function (g) {
    return spanLeadingZeroesSimple(g);
  }).join(':');
}
/**
 * Groups an address
 * @returns {String} a grouped address
 */


function simpleGroup(addressString) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var groups = addressString.split(':');
  return groups.map(function (g, i) {
    if (/group-v4/.test(g)) {
      return g;
    }

    return (0, _sprintfJs.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
  });
}
},{"sprintf-js":"node_modules/sprintf-js/src/sprintf.js"}],"node_modules/ip-address/dist/esm/lib/v6/regular-expressions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.groupPossibilities = groupPossibilities;
exports.padGroup = padGroup;
exports.simpleRegularExpression = simpleRegularExpression;
exports.possibleElisions = possibleElisions;
exports.ADDRESS_BOUNDARY = void 0;

var v6 = _interopRequireWildcard(require("./constants"));

var _sprintfJs = require("sprintf-js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function groupPossibilities(possibilities) {
  return (0, _sprintfJs.sprintf)('(%s)', possibilities.join('|'));
}

function padGroup(group) {
  if (group.length < 4) {
    return (0, _sprintfJs.sprintf)('0{0,%d}%s', 4 - group.length, group);
  }

  return group;
}

var ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';
exports.ADDRESS_BOUNDARY = ADDRESS_BOUNDARY;

function simpleRegularExpression(groups) {
  var zeroIndexes = [];
  groups.forEach(function (group, i) {
    var groupInteger = parseInt(group, 16);

    if (groupInteger === 0) {
      zeroIndexes.push(i);
    }
  }); // You can technically elide a single 0, this creates the regular expressions
  // to match that eventuality

  var possibilities = zeroIndexes.map(function (zeroIndex) {
    return groups.map(function (group, i) {
      if (i === zeroIndex) {
        var elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';
        return groupPossibilities([padGroup(group), elision]);
      }

      return padGroup(group);
    }).join(':');
  }); // The simplest case

  possibilities.push(groups.map(padGroup).join(':'));
  return groupPossibilities(possibilities);
}

function possibleElisions(elidedGroups, moreLeft, moreRight) {
  var left = moreLeft ? '' : ':';
  var right = moreRight ? '' : ':';
  var possibilities = []; // 1. elision of everything (::)

  if (!moreLeft && !moreRight) {
    possibilities.push('::');
  } // 2. complete elision of the middle


  if (moreLeft && moreRight) {
    possibilities.push('');
  }

  if (moreRight && !moreLeft || !moreRight && moreLeft) {
    // 3. complete elision of one side
    possibilities.push(':');
  } // 4. elision from the left side


  possibilities.push((0, _sprintfJs.sprintf)('%s(:0{1,4}){1,%d}', left, elidedGroups - 1)); // 5. elision from the right side

  possibilities.push((0, _sprintfJs.sprintf)('(0{1,4}:){1,%d}%s', elidedGroups - 1, right)); // 6. no elision

  possibilities.push((0, _sprintfJs.sprintf)('(0{1,4}:){%d}0{1,4}', elidedGroups - 1)); // 7. elision (including sloppy elision) from the middle

  for (var groups = 1; groups < elidedGroups - 1; groups++) {
    for (var position = 1; position < elidedGroups - groups; position++) {
      possibilities.push((0, _sprintfJs.sprintf)('(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}', position, elidedGroups - position - groups - 1));
    }
  }

  return groupPossibilities(possibilities);
}
},{"./constants":"node_modules/ip-address/dist/esm/lib/v6/constants.js","sprintf-js":"node_modules/sprintf-js/src/sprintf.js"}],"node_modules/ip-address/dist/esm/lib/ipv6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Address6 = void 0;

var common = _interopRequireWildcard(require("./common"));

var constants4 = _interopRequireWildcard(require("./v4/constants"));

var constants6 = _interopRequireWildcard(require("./v6/constants"));

var helpers = _interopRequireWildcard(require("./v6/helpers"));

var _ipv = require("./ipv4");

var _regularExpressions = require("./v6/regular-expressions");

var _addressError = require("./address-error");

var _jsbn = require("jsbn");

var _sprintfJs = require("sprintf-js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function assert(condition) {
  if (!condition) {
    throw new Error('Assertion failed.');
  }
}

function addCommas(number) {
  var r = /(\d+)(\d{3})/;

  while (r.test(number)) {
    number = number.replace(r, '$1,$2');
  }

  return number;
}

function spanLeadingZeroes4(n) {
  n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
  n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
  return n;
}
/*
 * A helper function to compact an array
 */


function compact(address, slice) {
  var s1 = [];
  var s2 = [];
  var i;

  for (i = 0; i < address.length; i++) {
    if (i < slice[0]) {
      s1.push(address[i]);
    } else if (i > slice[1]) {
      s2.push(address[i]);
    }
  }

  return s1.concat(['compact']).concat(s2);
}

function paddedHex(octet) {
  return (0, _sprintfJs.sprintf)('%04x', parseInt(octet, 16));
}

function unsignByte(b) {
  // eslint-disable-next-line no-bitwise
  return b & 0xff;
}
/**
 * Represents an IPv6 address
 * @class Address6
 * @param {string} address - An IPv6 address string
 * @param {number} [groups=8] - How many octets to parse
 * @example
 * var address = new Address6('2001::/32');
 */


var Address6 = /*#__PURE__*/function () {
  function Address6(address, optionalGroups) {
    _classCallCheck(this, Address6);

    this.addressMinusSuffix = '';
    this.parsedSubnet = '';
    this.subnet = '/128';
    this.subnetMask = 128;
    this.v4 = false;
    this.zone = ''; // #region Attributes

    /**
     * Returns true if the given address is in the subnet of the current address
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

    this.isInSubnet = common.isInSubnet;
    /**
     * Returns true if the address is correct, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

    this.isCorrect = common.isCorrect(constants6.BITS);

    if (optionalGroups === undefined) {
      this.groups = constants6.GROUPS;
    } else {
      this.groups = optionalGroups;
    }

    this.address = address;
    var subnet = constants6.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = "/".concat(this.subnetMask);

      if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
        throw new _addressError.AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants6.RE_SUBNET_STRING, '');
    } else if (/\//.test(address)) {
      throw new _addressError.AddressError('Invalid subnet mask.');
    }

    var zone = constants6.RE_ZONE_STRING.exec(address);

    if (zone) {
      this.zone = zone[0];
      address = address.replace(constants6.RE_ZONE_STRING, '');
    }

    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(this.addressMinusSuffix);
  }

  _createClass(Address6, [{
    key: "microsoftTranscription",
    value:
    /**
     * Return the Microsoft UNC transcription of the address
     * @memberof Address6
     * @instance
     * @returns {String} the Microsoft UNC transcription of the address
     */
    function microsoftTranscription() {
      return (0, _sprintfJs.sprintf)('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'));
    }
    /**
     * Return the first n bits of the address, defaulting to the subnet mask
     * @memberof Address6
     * @instance
     * @param {number} [mask=subnet] - the number of bits to mask
     * @returns {String} the first n bits of the address as a string
     */

  }, {
    key: "mask",
    value: function mask() {
      var _mask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.subnetMask;

      return this.getBitsBase2(0, _mask);
    }
    /**
     * Return the number of possible subnets of a given size in the address
     * @memberof Address6
     * @instance
     * @param {number} [size=128] - the subnet size
     * @returns {String}
     */
    // TODO: probably useful to have a numeric version of this too

  }, {
    key: "possibleSubnets",
    value: function possibleSubnets() {
      var subnetSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;
      var availableBits = constants6.BITS - this.subnetMask;
      var subnetBits = Math.abs(subnetSize - constants6.BITS);
      var subnetPowers = availableBits - subnetBits;

      if (subnetPowers < 0) {
        return '0';
      }

      return addCommas(new _jsbn.BigInteger('2', 10).pow(subnetPowers).toString(10));
    }
    /**
     * Helper function getting start address.
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_startAddress",
    value: function _startAddress() {
      return new _jsbn.BigInteger(this.mask() + '0'.repeat(constants6.BITS - this.subnetMask), 2);
    }
    /**
     * The first address in the range given by this address' subnet
     * Often referred to as the Network Address.
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */

  }, {
    key: "startAddress",
    value: function startAddress() {
      return Address6.fromBigInteger(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */

  }, {
    key: "startAddressExclusive",
    value: function startAddressExclusive() {
      var adjust = new _jsbn.BigInteger('1');
      return Address6.fromBigInteger(this._startAddress().add(adjust));
    }
    /**
     * Helper function getting end address.
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "_endAddress",
    value: function _endAddress() {
      return new _jsbn.BigInteger(this.mask() + '1'.repeat(constants6.BITS - this.subnetMask), 2);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */

  }, {
    key: "endAddress",
    value: function endAddress() {
      return Address6.fromBigInteger(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */

  }, {
    key: "endAddressExclusive",
    value: function endAddressExclusive() {
      var adjust = new _jsbn.BigInteger('1');
      return Address6.fromBigInteger(this._endAddress().subtract(adjust));
    }
    /**
     * Return the scope of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "getScope",
    value: function getScope() {
      var scope = constants6.SCOPES[this.getBits(12, 16).intValue()];

      if (this.getType() === 'Global unicast' && scope !== 'Link local') {
        scope = 'Global';
      }

      return scope || 'Unknown';
    }
    /**
     * Return the type of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "getType",
    value: function getType() {
      for (var _i = 0, _Object$keys = Object.keys(constants6.TYPES); _i < _Object$keys.length; _i++) {
        var subnet = _Object$keys[_i];

        if (this.isInSubnet(new Address6(subnet))) {
          return constants6.TYPES[subnet];
        }
      }

      return 'Global unicast';
    }
    /**
     * Return the bits in the given range as a BigInteger
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "getBits",
    value: function getBits(start, end) {
      return new _jsbn.BigInteger(this.getBitsBase2(start, end), 2);
    }
    /**
     * Return the bits in the given range as a base-2 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "getBitsBase2",
    value: function getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    /**
     * Return the bits in the given range as a base-16 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "getBitsBase16",
    value: function getBitsBase16(start, end) {
      var length = end - start;

      if (length % 4 !== 0) {
        throw new Error('Length of bits to retrieve must be divisible by four');
      }

      return this.getBits(start, end).toString(16).padStart(length / 4, '0');
    }
    /**
     * Return the bits that are set past the subnet mask length
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "getBitsPastSubnet",
    value: function getBitsPastSubnet() {
      return this.getBitsBase2(this.subnetMask, constants6.BITS);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address6
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
     * @instance
     * @returns {String}
     */

  }, {
    key: "reverseForm",
    value: function reverseForm(options) {
      if (!options) {
        options = {};
      }

      var characters = Math.floor(this.subnetMask / 4);
      var reversed = this.canonicalForm().replace(/:/g, '').split('').slice(0, characters).reverse().join('.');

      if (characters > 0) {
        if (options.omitSuffix) {
          return reversed;
        }

        return (0, _sprintfJs.sprintf)('%s.ip6.arpa.', reversed);
      }

      if (options.omitSuffix) {
        return '';
      }

      return 'ip6.arpa.';
    }
    /**
     * Return the correct form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "correctForm",
    value: function correctForm() {
      var i;
      var groups = [];
      var zeroCounter = 0;
      var zeroes = [];

      for (i = 0; i < this.parsedAddress.length; i++) {
        var value = parseInt(this.parsedAddress[i], 16);

        if (value === 0) {
          zeroCounter++;
        }

        if (value !== 0 && zeroCounter > 0) {
          if (zeroCounter > 1) {
            zeroes.push([i - zeroCounter, i - 1]);
          }

          zeroCounter = 0;
        }
      } // Do we end with a string of zeroes?


      if (zeroCounter > 1) {
        zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
      }

      var zeroLengths = zeroes.map(function (n) {
        return n[1] - n[0] + 1;
      });

      if (zeroes.length > 0) {
        var index = zeroLengths.indexOf(Math.max.apply(Math, _toConsumableArray(zeroLengths)));
        groups = compact(this.parsedAddress, zeroes[index]);
      } else {
        groups = this.parsedAddress;
      }

      for (i = 0; i < groups.length; i++) {
        if (groups[i] !== 'compact') {
          groups[i] = parseInt(groups[i], 16).toString(16);
        }
      }

      var correct = groups.join(':');
      correct = correct.replace(/^compact$/, '::');
      correct = correct.replace(/^compact|compact$/, ':');
      correct = correct.replace(/compact/, '');
      return correct;
    }
    /**
     * Return a zero-padded base-2 string representation of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     * @example
     * var address = new Address6('2001:4860:4001:803::1011');
     * address.binaryZeroPad();
     * // '0010000000000001010010000110000001000000000000010000100000000011
     * //  0000000000000000000000000000000000000000000000000001000000010001'
     */

  }, {
    key: "binaryZeroPad",
    value: function binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants6.BITS, '0');
    } // TODO: Improve the semantics of this helper function

  }, {
    key: "parse4in6",
    value: function parse4in6(address) {
      var groups = address.split(':');
      var lastGroup = groups.slice(-1)[0];
      var address4 = lastGroup.match(constants4.RE_ADDRESS);

      if (address4) {
        this.parsedAddress4 = address4[0];
        this.address4 = new _ipv.Address4(this.parsedAddress4);

        for (var i = 0; i < this.address4.groups; i++) {
          if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
            throw new _addressError.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));
          }
        }

        this.v4 = true;
        groups[groups.length - 1] = this.address4.toGroup6();
        address = groups.join(':');
      }

      return address;
    } // TODO: Make private?

  }, {
    key: "parse",
    value: function parse(address) {
      address = this.parse4in6(address);
      var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);

      if (badCharacters) {
        throw new _addressError.AddressError((0, _sprintfJs.sprintf)('Bad character%s detected in address: %s', badCharacters.length > 1 ? 's' : '', badCharacters.join('')), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
      }

      var badAddress = address.match(constants6.RE_BAD_ADDRESS);

      if (badAddress) {
        throw new _addressError.AddressError((0, _sprintfJs.sprintf)('Address failed regex: %s', badAddress.join('')), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
      }

      var groups = [];
      var halves = address.split('::');

      if (halves.length === 2) {
        var first = halves[0].split(':');
        var last = halves[1].split(':');

        if (first.length === 1 && first[0] === '') {
          first = [];
        }

        if (last.length === 1 && last[0] === '') {
          last = [];
        }

        var remaining = this.groups - (first.length + last.length);

        if (!remaining) {
          throw new _addressError.AddressError('Error parsing groups');
        }

        this.elidedGroups = remaining;
        this.elisionBegin = first.length;
        this.elisionEnd = first.length + this.elidedGroups;
        groups = groups.concat(first);

        for (var i = 0; i < remaining; i++) {
          groups.push('0');
        }

        groups = groups.concat(last);
      } else if (halves.length === 1) {
        groups = address.split(':');
        this.elidedGroups = 0;
      } else {
        throw new _addressError.AddressError('Too many :: groups found');
      }

      groups = groups.map(function (group) {
        return (0, _sprintfJs.sprintf)('%x', parseInt(group, 16));
      });

      if (groups.length !== this.groups) {
        throw new _addressError.AddressError('Incorrect number of groups found');
      }

      return groups;
    }
    /**
     * Return the canonical form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "canonicalForm",
    value: function canonicalForm() {
      return this.parsedAddress.map(paddedHex).join(':');
    }
    /**
     * Return the decimal form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "decimal",
    value: function decimal() {
      return this.parsedAddress.map(function (n) {
        return (0, _sprintfJs.sprintf)('%05d', parseInt(n, 16));
      }).join(':');
    }
    /**
     * Return the address as a BigInteger
     * @memberof Address6
     * @instance
     * @returns {BigInteger}
     */

  }, {
    key: "bigInteger",
    value: function bigInteger() {
      return new _jsbn.BigInteger(this.parsedAddress.map(paddedHex).join(''), 16);
    }
    /**
     * Return the last two groups of this address as an IPv4 address string
     * @memberof Address6
     * @instance
     * @returns {Address4}
     * @example
     * var address = new Address6('2001:4860:4001::1825:bf11');
     * address.to4().correctForm(); // '24.37.191.17'
     */

  }, {
    key: "to4",
    value: function to4() {
      var binary = this.binaryZeroPad().split('');
      return _ipv.Address4.fromHex(new _jsbn.BigInteger(binary.slice(96, 128).join(''), 2).toString(16));
    }
    /**
     * Return the v4-in-v6 form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */

  }, {
    key: "to4in6",
    value: function to4in6() {
      var address4 = this.to4();
      var address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);
      var correct = address6.correctForm();
      var infix = '';

      if (!/:$/.test(correct)) {
        infix = ':';
      }

      return correct + infix + address4.address;
    }
    /**
     * Return an object containing the Teredo properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */

  }, {
    key: "inspectTeredo",
    value: function inspectTeredo() {
      /*
      - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).
      - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that
        is used.
      - Bits 64 to 79 can be used to define some flags. Currently only the
        higher order bit is used; it is set to 1 if the Teredo client is
        located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista
        and Windows Server 2008 implementations, more bits are used. In those
        implementations, the format for these 16 bits is "CRAAAAUG AAAAAAAA",
        where "C" remains the "Cone" flag. The "R" bit is reserved for future
        use. The "U" bit is for the Universal/Local flag (set to 0). The "G" bit
        is Individual/Group flag (set to 0). The A bits are set to a 12-bit
        randomly generated number chosen by the Teredo client to introduce
        additional protection for the Teredo node against IPv6-based scanning
        attacks.
      - Bits 80 to 95 contains the obfuscated UDP port number. This is the
        port number that is mapped by the NAT to the Teredo client with all
        bits inverted.
      - Bits 96 to 127 contains the obfuscated IPv4 address. This is the
        public IPv4 address of the NAT with all bits inverted.
      */
      var prefix = this.getBitsBase16(0, 32);
      var udpPort = this.getBits(80, 96).xor(new _jsbn.BigInteger('ffff', 16)).toString();

      var server4 = _ipv.Address4.fromHex(this.getBitsBase16(32, 64));

      var client4 = _ipv.Address4.fromHex(this.getBits(96, 128).xor(new _jsbn.BigInteger('ffffffff', 16)).toString(16));

      var flags = this.getBits(64, 80);
      var flagsBase2 = this.getBitsBase2(64, 80);
      var coneNat = flags.testBit(15);
      var reserved = flags.testBit(14);
      var groupIndividual = flags.testBit(8);
      var universalLocal = flags.testBit(9);
      var nonce = new _jsbn.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
      return {
        prefix: (0, _sprintfJs.sprintf)('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),
        server4: server4.address,
        client4: client4.address,
        flags: flagsBase2,
        coneNat: coneNat,
        microsoft: {
          reserved: reserved,
          universalLocal: universalLocal,
          groupIndividual: groupIndividual,
          nonce: nonce
        },
        udpPort: udpPort
      };
    }
    /**
     * Return an object containing the 6to4 properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */

  }, {
    key: "inspect6to4",
    value: function inspect6to4() {
      /*
      - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).
      - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.
      */
      var prefix = this.getBitsBase16(0, 16);

      var gateway = _ipv.Address4.fromHex(this.getBitsBase16(16, 48));

      return {
        prefix: (0, _sprintfJs.sprintf)('%s', prefix.slice(0, 4)),
        gateway: gateway.address
      };
    }
    /**
     * Return a v6 6to4 address from a v6 v4inv6 address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */

  }, {
    key: "to6to4",
    value: function to6to4() {
      if (!this.is4()) {
        return null;
      }

      var addr6to4 = ['2002', this.getBitsBase16(96, 112), this.getBitsBase16(112, 128), '', '/16'].join(':');
      return new Address6(addr6to4);
    }
    /**
     * Return a byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */

  }, {
    key: "toByteArray",
    value: function toByteArray() {
      var byteArray = this.bigInteger().toByteArray(); // work around issue where `toByteArray` returns a leading 0 element

      if (byteArray.length === 17 && byteArray[0] === 0) {
        return byteArray.slice(1);
      }

      return byteArray;
    }
    /**
     * Return an unsigned byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */

  }, {
    key: "toUnsignedByteArray",
    value: function toUnsignedByteArray() {
      return this.toByteArray().map(unsignByte);
    }
    /**
     * Convert a byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */

  }, {
    key: "isCanonical",
    value:
    /**
     * Returns true if the address is in the canonical form, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    function isCanonical() {
      return this.addressMinusSuffix === this.canonicalForm();
    }
    /**
     * Returns true if the address is a link local address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isLinkLocal",
    value: function isLinkLocal() {
      // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'
      if (this.getBitsBase2(0, 64) === '1111111010000000000000000000000000000000000000000000000000000000') {
        return true;
      }

      return false;
    }
    /**
     * Returns true if the address is a multicast address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isMulticast",
    value: function isMulticast() {
      return this.getType() === 'Multicast';
    }
    /**
     * Returns true if the address is a v4-in-v6 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "is4",
    value: function is4() {
      return this.v4;
    }
    /**
     * Returns true if the address is a Teredo address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isTeredo",
    value: function isTeredo() {
      return this.isInSubnet(new Address6('2001::/32'));
    }
    /**
     * Returns true if the address is a 6to4 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "is6to4",
    value: function is6to4() {
      return this.isInSubnet(new Address6('2002::/16'));
    }
    /**
     * Returns true if the address is a loopback address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */

  }, {
    key: "isLoopback",
    value: function isLoopback() {
      return this.getType() === 'Loopback';
    } // #endregion
    // #region HTML

    /**
     * @returns {String} the address in link form with a default port of 80
     */

  }, {
    key: "href",
    value: function href(optionalPort) {
      if (optionalPort === undefined) {
        optionalPort = '';
      } else {
        optionalPort = (0, _sprintfJs.sprintf)(':%s', optionalPort);
      }

      return (0, _sprintfJs.sprintf)('http://[%s]%s/', this.correctForm(), optionalPort);
    }
    /**
     * @returns {String} a link suitable for conveying the address via a URL hash
     */

  }, {
    key: "link",
    value: function link(options) {
      if (!options) {
        options = {};
      }

      if (options.className === undefined) {
        options.className = '';
      }

      if (options.prefix === undefined) {
        options.prefix = '/#address=';
      }

      if (options.v4 === undefined) {
        options.v4 = false;
      }

      var formFunction = this.correctForm;

      if (options.v4) {
        formFunction = this.to4in6;
      }

      if (options.className) {
        return (0, _sprintfJs.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
      }

      return (0, _sprintfJs.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
    }
    /**
     * Groups an address
     * @returns {String}
     */

  }, {
    key: "group",
    value: function group() {
      if (this.elidedGroups === 0) {
        // The simple case
        return helpers.simpleGroup(this.address).join(':');
      }

      assert(typeof this.elidedGroups === 'number');
      assert(typeof this.elisionBegin === 'number'); // The elided case

      var output = [];

      var _this$address$split = this.address.split('::'),
          _this$address$split2 = _slicedToArray(_this$address$split, 2),
          left = _this$address$split2[0],
          right = _this$address$split2[1];

      if (left.length) {
        output.push.apply(output, _toConsumableArray(helpers.simpleGroup(left)));
      } else {
        output.push('');
      }

      var classes = ['hover-group'];

      for (var i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
        classes.push((0, _sprintfJs.sprintf)('group-%d', i));
      }

      output.push((0, _sprintfJs.sprintf)('<span class="%s"></span>', classes.join(' ')));

      if (right.length) {
        output.push.apply(output, _toConsumableArray(helpers.simpleGroup(right, this.elisionEnd)));
      } else {
        output.push('');
      }

      if (this.is4()) {
        assert(this.address4 instanceof _ipv.Address4);
        output.pop();
        output.push(this.address4.groupForV6());
      }

      return output.join(':');
    } // #endregion
    // #region Regular expressions

    /**
     * Generate a regular expression string that can be used to find or validate
     * all variations of this address
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {string}
     */

  }, {
    key: "regularExpressionString",
    value: function regularExpressionString() {
      var substringSearch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var output = []; // TODO: revisit why this is necessary

      var address6 = new Address6(this.correctForm());

      if (address6.elidedGroups === 0) {
        // The simple case
        output.push((0, _regularExpressions.simpleRegularExpression)(address6.parsedAddress));
      } else if (address6.elidedGroups === constants6.GROUPS) {
        // A completely elided address
        output.push((0, _regularExpressions.possibleElisions)(constants6.GROUPS));
      } else {
        // A partially elided address
        var halves = address6.address.split('::');

        if (halves[0].length) {
          output.push((0, _regularExpressions.simpleRegularExpression)(halves[0].split(':')));
        }

        assert(typeof address6.elidedGroups === 'number');
        output.push((0, _regularExpressions.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));

        if (halves[1].length) {
          output.push((0, _regularExpressions.simpleRegularExpression)(halves[1].split(':')));
        }

        output = [output.join(':')];
      }

      if (!substringSearch) {
        output = ['(?=^|', _regularExpressions.ADDRESS_BOUNDARY, '|[^\\w\\:])('].concat(_toConsumableArray(output), [')(?=[^\\w\\:]|', _regularExpressions.ADDRESS_BOUNDARY, '|$)']);
      }

      return output.join('');
    }
    /**
     * Generate a regular expression that can be used to find or validate all
     * variations of this address.
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {RegExp}
     */

  }, {
    key: "regularExpression",
    value: function regularExpression() {
      var substringSearch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new RegExp(this.regularExpressionString(substringSearch), 'i');
    }
  }], [{
    key: "isValid",
    value: function isValid(address) {
      try {
        // eslint-disable-next-line no-new
        new Address6(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    /**
     * Convert a BigInteger to a v6 address object
     * @memberof Address6
     * @static
     * @param {BigInteger} bigInteger - a BigInteger to convert
     * @returns {Address6}
     * @example
     * var bigInteger = new BigInteger('1000000000000');
     * var address = Address6.fromBigInteger(bigInteger);
     * address.correctForm(); // '::e8:d4a5:1000'
     */

  }, {
    key: "fromBigInteger",
    value: function fromBigInteger(bigInteger) {
      var hex = bigInteger.toString(16).padStart(32, '0');
      var groups = [];
      var i;

      for (i = 0; i < constants6.GROUPS; i++) {
        groups.push(hex.slice(i * 4, (i + 1) * 4));
      }

      return new Address6(groups.join(':'));
    }
    /**
     * Convert a URL (with optional port number) to an address object
     * @memberof Address6
     * @static
     * @param {string} url - a URL with optional port number
     * @example
     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
     * addressAndPort.address.correctForm(); // 'ffff::'
     * addressAndPort.port; // 8080
     */

  }, {
    key: "fromURL",
    value: function fromURL(url) {
      var host;
      var port = null;
      var result; // If we have brackets parse them and find a port

      if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {
        result = constants6.RE_URL_WITH_PORT.exec(url);

        if (result === null) {
          return {
            error: 'failed to parse address with port',
            address: null,
            port: null
          };
        }

        host = result[1];
        port = result[2]; // If there's a URL extract the address
      } else if (url.indexOf('/') !== -1) {
        // Remove the protocol prefix
        url = url.replace(/^[a-z0-9]+:\/\//, ''); // Parse the address

        result = constants6.RE_URL.exec(url);

        if (result === null) {
          return {
            error: 'failed to parse address from URL',
            address: null,
            port: null
          };
        }

        host = result[1]; // Otherwise just assign the URL to the host and let the library parse it
      } else {
        host = url;
      } // If there's a port convert it to an integer


      if (port) {
        port = parseInt(port, 10); // squelch out of range ports

        if (port < 0 || port > 65536) {
          port = null;
        }
      } else {
        // Standardize `undefined` to `null`
        port = null;
      }

      return {
        address: new Address6(host),
        port: port
      };
    }
    /**
     * Create an IPv6-mapped address given an IPv4 address
     * @memberof Address6
     * @static
     * @param {string} address - An IPv4 address string
     * @returns {Address6}
     * @example
     * var address = Address6.fromAddress4('192.168.0.1');
     * address.correctForm(); // '::ffff:c0a8:1'
     * address.to4in6(); // '::ffff:192.168.0.1'
     */

  }, {
    key: "fromAddress4",
    value: function fromAddress4(address) {
      var address4 = new _ipv.Address4(address);
      var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
      return new Address6("::ffff:".concat(address4.correctForm(), "/").concat(mask6));
    }
    /**
     * Return an address from ip6.arpa form
     * @memberof Address6
     * @static
     * @param {string} arpaFormAddress - an 'ip6.arpa' form address
     * @returns {Adress6}
     * @example
     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
     */

  }, {
    key: "fromArpa",
    value: function fromArpa(arpaFormAddress) {
      // remove ending ".ip6.arpa." or just "."
      var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, '');
      var semicolonAmount = 7; // correct ip6.arpa form with ending removed will be 63 characters

      if (address.length !== 63) {
        throw new _addressError.AddressError("Invalid 'ip6.arpa' form.");
      }

      var parts = address.split('.').reverse();

      for (var i = semicolonAmount; i > 0; i--) {
        var insertIndex = i * 4;
        parts.splice(insertIndex, 0, ':');
      }

      address = parts.join('');
      return new Address6(address);
    }
  }, {
    key: "fromByteArray",
    value: function fromByteArray(bytes) {
      return this.fromUnsignedByteArray(bytes.map(unsignByte));
    }
    /**
     * Convert an unsigned byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */

  }, {
    key: "fromUnsignedByteArray",
    value: function fromUnsignedByteArray(bytes) {
      var BYTE_MAX = new _jsbn.BigInteger('256', 10);
      var result = new _jsbn.BigInteger('0', 10);
      var multiplier = new _jsbn.BigInteger('1', 10);

      for (var i = bytes.length - 1; i >= 0; i--) {
        result = result.add(multiplier.multiply(new _jsbn.BigInteger(bytes[i].toString(10), 10)));
        multiplier = multiplier.multiply(BYTE_MAX);
      }

      return Address6.fromBigInteger(result);
    }
  }]);

  return Address6;
}();

exports.Address6 = Address6;
},{"./common":"node_modules/ip-address/dist/esm/lib/common.js","./v4/constants":"node_modules/ip-address/dist/esm/lib/v4/constants.js","./v6/constants":"node_modules/ip-address/dist/esm/lib/v6/constants.js","./v6/helpers":"node_modules/ip-address/dist/esm/lib/v6/helpers.js","./ipv4":"node_modules/ip-address/dist/esm/lib/ipv4.js","./v6/regular-expressions":"node_modules/ip-address/dist/esm/lib/v6/regular-expressions.js","./address-error":"node_modules/ip-address/dist/esm/lib/address-error.js","jsbn":"node_modules/jsbn/index.js","sprintf-js":"node_modules/sprintf-js/src/sprintf.js"}],"node_modules/ip-address/dist/esm/ip-address.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Address4", {
  enumerable: true,
  get: function () {
    return _ipv.Address4;
  }
});
Object.defineProperty(exports, "Address6", {
  enumerable: true,
  get: function () {
    return _ipv2.Address6;
  }
});
Object.defineProperty(exports, "AddressError", {
  enumerable: true,
  get: function () {
    return _addressError.AddressError;
  }
});
exports.v6 = void 0;

var _ipv = require("./lib/ipv4");

var _ipv2 = require("./lib/ipv6");

var _addressError = require("./lib/address-error");

var helpers = _interopRequireWildcard(require("./lib/v6/helpers"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var v6 = {
  helpers: helpers
};
exports.v6 = v6;
},{"./lib/ipv4":"node_modules/ip-address/dist/esm/lib/ipv4.js","./lib/ipv6":"node_modules/ip-address/dist/esm/lib/ipv6.js","./lib/address-error":"node_modules/ip-address/dist/esm/lib/address-error.js","./lib/v6/helpers":"node_modules/ip-address/dist/esm/lib/v6/helpers.js"}],"node_modules/libp2p-utils/src/ip-port-to-multiaddr.js":[function(require,module,exports) {
'use strict'

const debug = require('debug')
const log = Object.assign(debug('libp2p:ip-port-to-multiaddr'), {
  error: debug('libp2p:ip-port-to-multiaddr:err')
})
const { Multiaddr } = require('multiaddr')
const errCode = require('err-code')
const { Address4, Address6 } = require('ip-address')

const errors = {
  ERR_INVALID_IP_PARAMETER: 'ERR_INVALID_IP_PARAMETER',
  ERR_INVALID_PORT_PARAMETER: 'ERR_INVALID_PORT_PARAMETER',
  ERR_INVALID_IP: 'ERR_INVALID_IP'
}

/**
 * Transform an IP, Port pair into a multiaddr
 *
 * @param {string} ip
 * @param {number|string} port
 */
function ipPortToMultiaddr (ip, port) {
  if (typeof ip !== 'string') {
    throw errCode(new Error(`invalid ip provided: ${ip}`), errors.ERR_INVALID_IP_PARAMETER)
  }

  if (typeof port === 'string') {
    port = parseInt(port)
  }

  if (isNaN(port)) {
    throw errCode(new Error(`invalid port provided: ${port}`), errors.ERR_INVALID_PORT_PARAMETER)
  }

  try {
    // Test valid IPv4
    new Address4(ip) // eslint-disable-line no-new
    return new Multiaddr(`/ip4/${ip}/tcp/${port}`)
  } catch {}

  try {
    // Test valid IPv6
    const ip6 = new Address6(ip)
    return ip6.is4()
      ? new Multiaddr(`/ip4/${ip6.to4().correctForm()}/tcp/${port}`)
      : new Multiaddr(`/ip6/${ip}/tcp/${port}`)
  } catch (err) {
    const errMsg = `invalid ip:port for creating a multiaddr: ${ip}:${port}`
    log.error(errMsg)
    throw errCode(new Error(errMsg), errors.ERR_INVALID_IP)
  }
}

module.exports = ipPortToMultiaddr

module.exports.Errors = errors

},{"debug":"node_modules/debug/src/browser.js","multiaddr":"node_modules/multiaddr/src/index.js","err-code":"node_modules/err-code/index.js","ip-address":"node_modules/ip-address/dist/esm/ip-address.js"}],"node_modules/p-timeout/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TimeoutError = /*#__PURE__*/function (_Error) {
  _inherits(TimeoutError, _Error);

  var _super = _createSuper(TimeoutError);

  function TimeoutError(message) {
    var _this;

    _classCallCheck(this, TimeoutError);

    _this = _super.call(this, message);
    _this.name = 'TimeoutError';
    return _this;
  }

  return TimeoutError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var pTimeout = function pTimeout(promise, milliseconds, fallback, options) {
  var timer;
  var cancelablePromise = new Promise(function (resolve, reject) {
    if (typeof milliseconds !== 'number' || milliseconds < 0) {
      throw new TypeError('Expected `milliseconds` to be a positive number');
    }

    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }

    options = _objectSpread({
      customTimers: {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout
      }
    }, options);
    timer = options.customTimers.setTimeout.call(undefined, function () {
      if (typeof fallback === 'function') {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }

        return;
      }

      var message = typeof fallback === 'string' ? fallback : "Promise timed out after ".concat(milliseconds, " milliseconds");
      var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);

      if (typeof promise.cancel === 'function') {
        promise.cancel();
      }

      reject(timeoutError);
    }, milliseconds);

    _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = resolve;
              _context.next = 4;
              return promise;

            case 4:
              _context.t1 = _context.sent;
              (0, _context.t0)(_context.t1);
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t2 = _context["catch"](0);
              reject(_context.t2);

            case 11:
              _context.prev = 11;
              options.customTimers.clearTimeout.call(undefined, timer);
              return _context.finish(11);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 8, 11, 14]]);
    }))();
  });

  cancelablePromise.clear = function () {
    clearTimeout(timer);
    timer = undefined;
  };

  return cancelablePromise;
};

module.exports = pTimeout; // TODO: Remove this for the next major release

module.exports.default = pTimeout;
module.exports.TimeoutError = TimeoutError;
},{}],"node_modules/libp2p-websockets/src/socket-to-conn.js":[function(require,module,exports) {
'use strict'

const abortable = require('abortable-iterator')
const { CLOSE_TIMEOUT } = require('./constants')
const toMultiaddr = require('libp2p-utils/src/ip-port-to-multiaddr')

const pTimeout = require('p-timeout')

const debug = require('debug')
const log = debug('libp2p:websockets:socket')
log.error = debug('libp2p:websockets:socket:error')

// Convert a stream into a MultiaddrConnection
// https://github.com/libp2p/interface-transport#multiaddrconnection
module.exports = (stream, options = {}) => {
  const maConn = {
    async sink (source) {
      if (options.signal) {
        source = abortable(source, options.signal)
      }

      try {
        await stream.sink((async function * () {
          for await (const chunk of source) {
            // Convert BufferList to Buffer
            yield chunk instanceof Uint8Array ? chunk : chunk.slice()
          }
        })())
      } catch (err) {
        if (err.type !== 'aborted') {
          log.error(err)
        }
      }
    },

    source: options.signal ? abortable(stream.source, options.signal) : stream.source,

    conn: stream,

    localAddr: options.localAddr || (stream.localAddress && stream.localPort
      ? toMultiaddr(stream.localAddress, stream.localPort)
      : undefined),

    // If the remote address was passed, use it - it may have the peer ID encapsulated
    remoteAddr: options.remoteAddr || toMultiaddr(stream.remoteAddress, stream.remotePort),

    timeline: { open: Date.now() },

    async close () {
      const start = Date.now()

      try {
        await pTimeout(stream.close(), CLOSE_TIMEOUT)
      } catch (err) {
        const { host, port } = maConn.remoteAddr.toOptions()
        log('timeout closing stream to %s:%s after %dms, destroying it manually',
          host, port, Date.now() - start)

        stream.destroy()
      } finally {
        maConn.timeline.close = Date.now()
      }
    }
  }

  stream.socket.once && stream.socket.once('close', () => {
    // In instances where `close` was not explicitly called,
    // such as an iterable stream ending, ensure we have set the close
    // timeline
    if (!maConn.timeline.close) {
      maConn.timeline.close = Date.now()
    }
  })

  return maConn
}

},{"abortable-iterator":"node_modules/abortable-iterator/index.js","./constants":"node_modules/libp2p-websockets/src/constants.js","libp2p-utils/src/ip-port-to-multiaddr":"node_modules/libp2p-utils/src/ip-port-to-multiaddr.js","p-timeout":"node_modules/p-timeout/index.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/libp2p-websockets/src/filters.js":[function(require,module,exports) {
'use strict'

const mafmt = require('mafmt')
const {
  CODE_CIRCUIT,
  CODE_P2P,
  CODE_TCP,
  CODE_WS,
  CODE_WSS
} = require('./constants')

module.exports = {
  all: (multiaddrs) => multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false
    }

    const testMa = ma.decapsulateCode(CODE_P2P)

    return mafmt.WebSockets.matches(testMa) ||
      mafmt.WebSocketsSecure.matches(testMa)
  }),
  dnsWss: (multiaddrs) => multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false
    }

    const testMa = ma.decapsulateCode(CODE_P2P)

    return mafmt.WebSocketsSecure.matches(testMa) &&
      mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS))
  }),
  dnsWsOrWss: (multiaddrs) => multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false
    }

    const testMa = ma.decapsulateCode(CODE_P2P)

    // WS
    if (mafmt.WebSockets.matches(testMa)) {
      return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS))
    }

    // WSS
    return mafmt.WebSocketsSecure.matches(testMa) &&
      mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS))
  })
}

},{"mafmt":"node_modules/mafmt/src/index.js","./constants":"node_modules/libp2p-websockets/src/constants.js"}],"node_modules/libp2p-websockets/src/index.js":[function(require,module,exports) {
'use strict'

const connect = require('it-ws/client')
const withIs = require('class-is')
const toUri = require('multiaddr-to-uri')
const { AbortError } = require('abortable-iterator')
const pDefer = require('p-defer')

const debug = require('debug')
const log = debug('libp2p:websockets')
log.error = debug('libp2p:websockets:error')
const env = require('ipfs-utils/src/env')

const createListener = require('./listener')
const toConnection = require('./socket-to-conn')
const filters = require('./filters')

/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @class WebSockets
 */
class WebSockets {
  /**
   * @class
   * @param {object} options
   * @param {Upgrader} options.upgrader
   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter
   */
  constructor ({ upgrader, filter }) {
    if (!upgrader) {
      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')
    }
    this._upgrader = upgrader
    this._filter = filter
  }

  /**
   * @async
   * @param {Multiaddr} ma
   * @param {object} [options]
   * @param {AbortSignal} [options.signal] - Used to abort dial requests
   * @returns {Connection} An upgraded Connection
   */
  async dial (ma, options = {}) {
    log('dialing %s', ma)

    const socket = await this._connect(ma, options)
    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })
    log('new outbound connection %s', maConn.remoteAddr)

    const conn = await this._upgrader.upgradeOutbound(maConn)
    log('outbound connection %s upgraded', maConn.remoteAddr)
    return conn
  }

  /**
   * @private
   * @param {Multiaddr} ma
   * @param {object} [options]
   * @param {AbortSignal} [options.signal] - Used to abort dial requests
   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket
   */
  async _connect (ma, options = {}) {
    if (options.signal && options.signal.aborted) {
      throw new AbortError()
    }
    const cOpts = ma.toOptions()
    log('dialing %s:%s', cOpts.host, cOpts.port)

    const errorPromise = pDefer()
    const errfn = (err) => {
      const msg = `connection error: ${err.message}`
      log.error(msg)

      errorPromise.reject(err)
    }

    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))

    if (rawSocket.socket.on) {
      rawSocket.socket.on('error', errfn)
    } else {
      rawSocket.socket.onerror = errfn
    }

    if (!options.signal) {
      await Promise.race([rawSocket.connected(), errorPromise.promise])

      log('connected %s', ma)
      return rawSocket
    }

    // Allow abort via signal during connect
    let onAbort
    const abort = new Promise((resolve, reject) => {
      onAbort = () => {
        reject(new AbortError())
        // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121
        setTimeout(() => {
          rawSocket.close()
        })
      }

      // Already aborted?
      if (options.signal.aborted) return onAbort()
      options.signal.addEventListener('abort', onAbort)
    })

    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])
    } finally {
      options.signal.removeEventListener('abort', onAbort)
    }

    log('connected %s', ma)
    return rawSocket
  }

  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`.
   *
   * @param {object} [options]
   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.
   * @param {function (Connection)} handler
   * @returns {Listener} A Websockets listener
   */
  createListener (options = {}, handler) {
    if (typeof options === 'function') {
      handler = options
      options = {}
    }

    return createListener({ handler, upgrader: this._upgrader }, options)
  }

  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   *
   * @param {Multiaddr[]} multiaddrs
   * @returns {Multiaddr[]} Valid Websockets multiaddrs
   */
  filter (multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]

    if (this._filter) {
      return this._filter(multiaddrs)
    }

    // Browser
    if (env.isBrowser || env.isWebWorker) {
      return filters.dnsWss(multiaddrs)
    }

    return filters.all(multiaddrs)
  }
}

module.exports = withIs(WebSockets, {
  className: 'WebSockets',
  symbolName: '@libp2p/js-libp2p-websockets/websockets'
})

},{"it-ws/client":"node_modules/it-ws/client.js","class-is":"node_modules/class-is/index.js","multiaddr-to-uri":"node_modules/multiaddr-to-uri/index.js","abortable-iterator":"node_modules/abortable-iterator/index.js","p-defer":"node_modules/p-defer/index.js","debug":"node_modules/debug/src/browser.js","ipfs-utils/src/env":"node_modules/ipfs-utils/src/env.js","./listener":"node_modules/libp2p-websockets/src/listener.browser.js","./socket-to-conn":"node_modules/libp2p-websockets/src/socket-to-conn.js","./filters":"node_modules/libp2p-websockets/src/filters.js"}],"node_modules/get-browser-rtc/index.js":[function(require,module,exports) {
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof globalThis === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],"node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/randombytes/browser.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

},{"safe-buffer":"node_modules/safe-buffer/index.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":"node_modules/events/events.js"}],"node_modules/readable-stream/lib/internal/streams/buffer_list.js":[function(require,module,exports) {

'use strict';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
var process = require("process");
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
},{"process":"node_modules/process/browser.js"}],"node_modules/readable-stream/errors-browser.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],"node_modules/readable-stream/lib/internal/streams/state.js":[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":"node_modules/readable-stream/errors-browser.js"}],"node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":"node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/readable-stream/lib/_stream_writable.js","inherits":"node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/string_decoder/node_modules/safe-buffer/index.js":[function(require,module,exports) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/string_decoder/node_modules/safe-buffer/index.js"}],"node_modules/readable-stream/lib/internal/streams/end-of-stream.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":"node_modules/readable-stream/errors-browser.js"}],"node_modules/readable-stream/lib/internal/streams/async_iterator.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":"node_modules/readable-stream/lib/internal/streams/end-of-stream.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/internal/streams/from-browser.js":[function(require,module,exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};
},{}],"node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
},{"events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/buffer_list":"node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/string_decoder/lib/string_decoder.js","./internal/streams/async_iterator":"node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/from":"node_modules/readable-stream/lib/internal/streams/from-browser.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":"node_modules/readable-stream/errors-browser.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/readable-stream/lib/_stream_transform.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/lib/internal/streams/pipeline.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":"node_modules/readable-stream/errors-browser.js","./end-of-stream":"node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}],"node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":"node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/readable-stream/lib/_stream_passthrough.js","./lib/internal/streams/end-of-stream.js":"node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"node_modules/readable-stream/lib/internal/streams/pipeline.js"}],"node_modules/queue-microtask/index.js":[function(require,module,exports) {
var global = arguments[3];
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

},{}],"node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js":[function(require,module,exports) {
'use strict';

function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = undefined;
    }

    if (code != null) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        return assign(new ErrClass(), props);
    }
}

module.exports = createError;

},{}],"node_modules/libp2p-webrtc-peer/index.js":[function(require,module,exports) {
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var randombytes = require('randombytes')
var stream = require('readable-stream')
var queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported
var errCode = require('err-code')

var MAX_BUFFERED_AMOUNT = 64 * 1024
var ICECOMPLETE_TIMEOUT = 5 * 1000
var CHANNEL_CLOSING_TIMEOUT = 5 * 1000

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function warn (message) {
  console.warn(message)
}

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
class Peer extends stream.Duplex {
  constructor (opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts)

    super(opts)

    this._id = randombytes(4).toString('hex').slice(0, 7)
    this._debug('new peer %o', opts)

    this.channelName = opts.initiator
      ? opts.channelName || randombytes(20).toString('hex')
      : null

    this.initiator = opts.initiator || false
    this.channelConfig = opts.channelConfig || Peer.channelConfig
    this.negotiated = this.channelConfig.negotiated
    this.config = Object.assign({}, Peer.config, opts.config)
    this.offerOptions = opts.offerOptions || {}
    this.answerOptions = opts.answerOptions || {}
    this.sdpTransform = opts.sdpTransform || (sdp => sdp)
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
    this.trickle = opts.trickle !== undefined ? opts.trickle : true
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

    this._connected = false

    this.remoteAddress = undefined
    this.remoteFamily = undefined
    this.remotePort = undefined
    this.localAddress = undefined
    this.localFamily = undefined
    this.localPort = undefined

    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
      ? opts.wrtc
      : getBrowserRTC()

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
      }
    }

    this._pcReady = false
    this._channelReady = false
    this._iceComplete = false // ice candidate trickle done (got null candidate)
    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
    this._channel = null
    this._pendingCandidates = []

    this._isNegotiating = this.negotiated ? false : !this.initiator // is this peer waiting for negotiation to complete?
    this._batchedNegotiation = false // batch synchronous negotiations
    this._queuedNegotiation = false // is there a queued negotiation request?
    this._sendersAwaitingStable = []
    this._senderMap = new Map()
    this._firstStable = true
    this._closingInterval = null

    this._remoteTracks = []
    this._remoteStreams = []

    this._chunk = null
    this._cb = null
    this._interval = null

    try {
      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)
    } catch (err) {
      queueMicrotask(() => this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR')))
      return
    }

    // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange()
    }
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange()
    }
    this._pc.onicecandidate = event => {
      this._onIceCandidate(event)
    }

    // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded

    if (this.initiator || this.negotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      })
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event)
      }
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream)
      })
    }
    this._pc.ontrack = event => {
      this._onTrack(event)
    }

    if (this.initiator) {
      this._needsNegotiation()
    }

    this._onFinishBound = () => {
      this._onFinish()
    }
    this.once('finish', this._onFinishBound)
  }

  get bufferSize () {
    return (this._channel && this._channel.bufferedAmount) || 0
  }

  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected () {
    return (this._connected && this._channel.readyState === 'open')
  }

  address () {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress }
  }

  signal (data) {
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_SIGNALING')
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data)
      } catch (err) {
        data = {}
      }
    }
    this._debug('signal()')

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate')
      this._needsNegotiation()
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver')
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate)
      } else {
        this._pendingCandidates.push(data.candidate)
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))
        .then(() => {
          if (this.destroyed) return

          this._pendingCandidates.forEach(candidate => {
            this._addIceCandidate(candidate)
          })
          this._pendingCandidates = []

          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()
        })
        .catch(err => {
          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))
        })
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
    }
  }

  _addIceCandidate (candidate) {
    var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)
    this._pc.addIceCandidate(iceCandidateObj)
      .catch(err => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
          warn('Ignoring unsupported ICE candidate.')
        } else {
          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))
        }
      })
  }

  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send (chunk) {
    this._channel.send(chunk)
  }

  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver (kind, init) {
    this._debug('addTransceiver()')

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init)
        this._needsNegotiation()
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))
      }
    } else {
      this.emit('signal', { // request initiator to renegotiate
        transceiverRequest: { kind, init }
      })
    }
  }

  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream (stream) {
    this._debug('addStream()')

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream)
    })
  }

  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack (track, stream) {
    this._debug('addTrack()')

    var submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
    var sender = submap.get(stream)
    if (!sender) {
      sender = this._pc.addTrack(track, stream)
      submap.set(stream, sender)
      this._senderMap.set(track, submap)
      this._needsNegotiation()
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
    }
  }

  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack (oldTrack, newTrack, stream) {
    this._debug('replaceTrack()')

    var submap = this._senderMap.get(oldTrack)
    var sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    if (newTrack) this._senderMap.set(newTrack, submap)

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack)
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))
    }
  }

  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack (track, stream) {
    this._debug('removeSender()')

    var submap = this._senderMap.get(track)
    var sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    try {
      sender.removed = true
      this._pc.removeTrack(sender)
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))
      }
    }
    this._needsNegotiation()
  }

  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream (stream) {
    this._debug('removeSenders()')

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream)
    })
  }

  _needsNegotiation () {
    this._debug('_needsNegotiation')
    if (this._batchedNegotiation) return // batch synchronous renegotiations
    this._batchedNegotiation = true
    queueMicrotask(() => {
      this._batchedNegotiation = false
      this._debug('starting batched negotiation')
      this.negotiate()
    })
  }

  negotiate () {
    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('start negotiation')
        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer()
        }, 0)
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('requesting negotiation from initiator')
        this.emit('signal', { // request initiator to renegotiate
          renegotiate: true
        })
      }
    }
    this._isNegotiating = true
  }

  _destroy (err, cb) {
    this._debug('destroy (error: %s)', err && (err.message || err))

    this.readable = this.writable = false

    if (!this._readableState.ended) this.push(null)
    if (!this._writableState.finished) this.end()

    this._connected = false
    this._pcReady = false
    this._channelReady = false
    this._remoteTracks = null
    this._remoteStreams = null
    this._senderMap = null

    clearInterval(this._closingInterval)
    this._closingInterval = null

    clearInterval(this._interval)
    this._interval = null
    this._chunk = null
    this._cb = null

    if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)
    this._onFinishBound = null

    if (this._channel) {
      try {
        this._channel.close()
      } catch (err) {}

      this._channel.onmessage = null
      this._channel.onopen = null
      this._channel.onclose = null
      this._channel.onerror = null
    }
    if (this._pc) {
      try {
        this._pc.close()
      } catch (err) {}

      this._pc.oniceconnectionstatechange = null
      this._pc.onicegatheringstatechange = null
      this._pc.onsignalingstatechange = null
      this._pc.onicecandidate = null
      this._pc.ontrack = null
      this._pc.ondatachannel = null
    }
    this._pc = null
    this._channel = null

    cb(err)
  }

  _setupData (event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
    }

    this._channel = event.channel
    this._channel.binaryType = 'arraybuffer'

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    this.channelName = this._channel.label

    this._channel.onmessage = event => {
      this._onChannelMessage(event)
    }
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow()
    }
    this._channel.onopen = () => {
      this._onChannelOpen()
    }
    this._channel.onclose = () => {
      this._onChannelClose()
    }
    this._channel.onerror = err => {
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
    }

    // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    var isClosing = false
    this._closingInterval = setInterval(() => { // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
        isClosing = true
      } else {
        isClosing = false
      }
    }, CHANNEL_CLOSING_TIMEOUT)
  }

  _read () {}

  _write (chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))

    if (this._connected) {
      try {
        this.send(chunk)
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)
        this._cb = cb
      } else {
        cb(null)
      }
    } else {
      this._debug('write before connect')
      this._chunk = chunk
      this._cb = cb
    }
  }

  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish () {
    if (this.destroyed) return

    // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000)
    }

    if (this._connected) {
      destroySoon()
    } else {
      this.once('connect', destroySoon)
    }
  }

  _startIceCompleteTimeout () {
    if (this.destroyed) return
    if (this._iceCompleteTimer) return
    this._debug('started iceComplete timeout')
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true
        this._debug('iceComplete timeout completed')
        this.emit('iceTimeout')
        this.emit('_iceComplete')
      }
    }, this.iceCompleteTimeout)
  }

  _createOffer () {
    if (this.destroyed) return

    this._pc.createOffer(this.offerOptions)
      .then(offer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
        offer.sdp = this.sdpTransform(offer.sdp)

        const sendOffer = () => {
          if (this.destroyed) return
          var signal = this._pc.localDescription || offer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
        }

        const onSuccess = () => {
          this._debug('createOffer success')
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendOffer()
          else this.once('_iceComplete', sendOffer) // wait for candidates
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(offer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))
      })
  }

  _requestMissingTransceivers () {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
          this.addTransceiver(transceiver.sender.track.kind)
        }
      })
    }
  }

  _createAnswer () {
    if (this.destroyed) return

    this._pc.createAnswer(this.answerOptions)
      .then(answer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
        answer.sdp = this.sdpTransform(answer.sdp)

        const sendAnswer = () => {
          if (this.destroyed) return
          var signal = this._pc.localDescription || answer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
          if (!this.initiator) this._requestMissingTransceivers()
        }

        const onSuccess = () => {
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendAnswer()
          else this.once('_iceComplete', sendAnswer)
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(answer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))
      })
  }

  _onConnectionStateChange () {
    if (this.destroyed) return
    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))
    }
  }

  _onIceStateChange () {
    if (this.destroyed) return
    var iceConnectionState = this._pc.iceConnectionState
    var iceGatheringState = this._pc.iceGatheringState

    this._debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState
    )
    this.emit('iceStateChange', iceConnectionState, iceGatheringState)

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true
      this._maybeReady()
    }
    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))
    }
    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
    }
  }

  getStats (cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value)
        })
      }
      return report
    }

    // Promise-based getStats() (standard)
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats()
        .then(res => {
          var reports = []
          res.forEach(report => {
            reports.push(flattenValues(report))
          })
          cb(null, reports)
        }, err => cb(err))

    // Single-parameter callback-based getStats() (non-standard)
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return

        var reports = []
        res.result().forEach(result => {
          var report = {}
          result.names().forEach(name => {
            report[name] = result.stat(name)
          })
          report.id = result.id
          report.type = result.type
          report.timestamp = result.timestamp
          reports.push(flattenValues(report))
        })
        cb(null, reports)
      }, err => cb(err))

    // Unknown browser, skip getStats() since it's anyone's guess which style of
    // getStats() they implement.
    } else {
      cb(null, [])
    }
  }

  _maybeReady () {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return

    this._connecting = true

    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
    const findCandidatePair = () => {
      if (this.destroyed) return

      this.getStats((err, items) => {
        if (this.destroyed) return

        // Treat getStats error as non-fatal. It's not essential.
        if (err) items = []

        var remoteCandidates = {}
        var localCandidates = {}
        var candidatePairs = {}
        var foundSelectedCandidatePair = false

        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item
          }
          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item
          }
          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item
          }
        })

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true

          var local = localCandidates[selectedCandidatePair.localCandidateId]

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address
            this.localPort = Number(local.port)
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress
            this.localPort = Number(local.portNumber)
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':')
            this.localAddress = local[0]
            this.localPort = Number(local[1])
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address
            this.remotePort = Number(remote.port)
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress
            this.remotePort = Number(remote.portNumber)
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':')
            this.remoteAddress = remote[0]
            this.remotePort = Number(remote[1])
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          this._debug(
            'connect local: %s:%s remote: %s:%s',
            this.localAddress, this.localPort, this.remoteAddress, this.remotePort
          )
        }

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
          }

          // Old implementations
          if (
            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
          ) {
            setSelectedCandidatePair(item)
          }
        })

        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100)
          return
        } else {
          this._connecting = false
          this._connected = true
        }

        if (this._chunk) {
          try {
            this.send(this._chunk)
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
          }
          this._chunk = null
          this._debug('sent chunk from "write before connect"')

          var cb = this._cb
          this._cb = null
          cb(null)
        }

        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.
        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150)
          if (this._interval.unref) this._interval.unref()
        }

        this._debug('connect')
        this.emit('connect')
      })
    }
    findCandidatePair()
  }

  _onInterval () {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return
    }
    this._onChannelBufferedAmountLow()
  }

  _onSignalingStateChange () {
    if (this.destroyed) return

    if (this._pc.signalingState === 'stable' && !this._firstStable) {
      this._isNegotiating = false

      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
      this._debug('flushing sender queue', this._sendersAwaitingStable)
      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender)
        this._queuedNegotiation = true
      })
      this._sendersAwaitingStable = []

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue')
        this._queuedNegotiation = false
        this._needsNegotiation() // negotiate again
      }

      this._debug('negotiate')
      this.emit('negotiate')
    }
    this._firstStable = false

    this._debug('signalingStateChange %s', this._pc.signalingState)
    this.emit('signalingStateChange', this._pc.signalingState)
  }

  _onIceCandidate (event) {
    if (this.destroyed) return
    if (event.candidate && this.trickle) {
      this.emit('signal', {
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      })
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true
      this.emit('_iceComplete')
    }
    // as soon as we've received one valid candidate start timeout
    if (event.candidate) {
      this._startIceCompleteTimeout()
    }
  }

  _onChannelMessage (event) {
    if (this.destroyed) return
    var data = event.data
    if (data instanceof ArrayBuffer) data = new Uint8Array(data)
    this.push(data)
  }

  _onChannelBufferedAmountLow () {
    if (this.destroyed || !this._cb) return
    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
    var cb = this._cb
    this._cb = null
    cb(null)
  }

  _onChannelOpen () {
    if (this._connected || this.destroyed) return
    this._debug('on channel open')
    this._channelReady = true
    this._maybeReady()
  }

  _onChannelClose () {
    if (this.destroyed) return
    this._debug('on channel close')
    this.destroy()
  }

  _onTrack (event) {
    if (this.destroyed) return

    event.streams.forEach(eventStream => {
      this._debug('on track')
      this.emit('track', event.track, eventStream)

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      })

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id
      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream)
      queueMicrotask(() => {
        this.emit('stream', eventStream) // ensure all tracks have been added
      })
    })
  }

  _debug () {
    var args = [].slice.call(arguments)
    args[0] = '[' + this._id + '] ' + args[0]
    debug.apply(null, args)
  }
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478'
      ]
    }
  ],
  sdpSemantics: 'unified-plan'
}

Peer.channelConfig = {}

module.exports = Peer

},{"debug":"node_modules/debug/src/browser.js","get-browser-rtc":"node_modules/get-browser-rtc/index.js","randombytes":"node_modules/randombytes/browser.js","readable-stream":"node_modules/readable-stream/readable-browser.js","queue-microtask":"node_modules/queue-microtask/index.js","err-code":"node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js"}],"node_modules/ipfs-utils/src/supports.js":[function(require,module,exports) {
'use strict'

module.exports = {
  // in React Native: global === window === self
  supportsFileReader: typeof self !== 'undefined' && 'FileReader' in self,
  supportsWebRTC: 'RTCPeerConnection' in globalThis &&
  (typeof navigator !== 'undefined' && typeof navigator.mediaDevices !== 'undefined' && 'getUserMedia' in navigator.mediaDevices),
  supportsWebRTCDataChannels: 'RTCPeerConnection' in globalThis
}

},{}],"node_modules/libp2p-webrtc-star/src/constants.js":[function(require,module,exports) {
'use strict'; // p2p multi-address code

exports.CODE_P2P = 421;
exports.CODE_CIRCUIT = 290; // Time to wait for a connection to close gracefully before destroying it manually

exports.CLOSE_TIMEOUT = 2000;
},{}],"node_modules/parseuri/index.js":[function(require,module,exports) {
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}

},{}],"node_modules/socket.io-client/build/url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url = void 0;

var parseuri = require("parseuri");

var debug = require("debug")("socket.io-client:url");
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */


function url(uri) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var loc = arguments.length > 2 ? arguments[2] : undefined;
  var obj = uri; // default to window.location

  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host; // relative path support

  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug("protocol-less url %s", uri);

      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    } // parse


    debug("parse %s", uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }

  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host; // define unique id

  obj.id = obj.protocol + "://" + host + ":" + obj.port + path; // define href

  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

exports.url = url;
},{"parseuri":"node_modules/parseuri/index.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/has-cors/index.js":[function(require,module,exports) {

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],"node_modules/engine.io-client/lib/globalThis.browser.js":[function(require,module,exports) {
module.exports = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();

},{}],"node_modules/engine.io-client/lib/xmlhttprequest.js":[function(require,module,exports) {
// browser shim for xmlhttprequest module

const hasCORS = require("has-cors");
const globalThis = require("./globalThis");

module.exports = function(opts) {
  const xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  const xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  const enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {}

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new globalThis[["Active"].concat("Object").join("X")](
        "Microsoft.XMLHTTP"
      );
    } catch (e) {}
  }
};

},{"has-cors":"node_modules/has-cors/index.js","./globalThis":"node_modules/engine.io-client/lib/globalThis.browser.js"}],"node_modules/engine.io-parser/lib/commons.js":[function(require,module,exports) {
var PACKET_TYPES = Object.create(null); // no Map = no polyfill

PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
module.exports = {
  PACKET_TYPES: PACKET_TYPES,
  PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE,
  ERROR_PACKET: ERROR_PACKET
};
},{}],"node_modules/engine.io-parser/lib/encodePacket.browser.js":[function(require,module,exports) {
var _require = require("./commons"),
    PACKET_TYPES = _require.PACKET_TYPES;

var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};

var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
      data = _ref.data;

  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data instanceof ArrayBuffer ? data : data.buffer);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  } // plain string


  return callback(PACKET_TYPES[type] + (data || ""));
};

var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();

  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + content);
  };

  return fileReader.readAsDataURL(data);
};

module.exports = encodePacket;
},{"./commons":"node_modules/engine.io-parser/lib/commons.js"}],"node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports) {
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function (chars) {
  "use strict";

  exports.encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
        i,
        len = bytes.length,
        base64 = "";

    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }

    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode = function (base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i,
        p = 0,
        encoded1,
        encoded2,
        encoded3,
        encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;

      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i + 1]);
      encoded3 = chars.indexOf(base64[i + 2]);
      encoded4 = chars.indexOf(base64[i + 3]);
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
},{}],"node_modules/engine.io-parser/lib/decodePacket.browser.js":[function(require,module,exports) {
var _require = require("./commons"),
    PACKET_TYPES_REVERSE = _require.PACKET_TYPES_REVERSE,
    ERROR_PACKET = _require.ERROR_PACKET;

var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var base64decoder;

if (withNativeArrayBuffer) {
  base64decoder = require("base64-arraybuffer");
}

var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }

  var type = encodedPacket.charAt(0);

  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }

  var packetType = PACKET_TYPES_REVERSE[type];

  if (!packetType) {
    return ERROR_PACKET;
  }

  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};

var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (base64decoder) {
    var decoded = base64decoder.decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};

var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;

    case "arraybuffer":
    default:
      return data;
    // assuming the data is already an ArrayBuffer
  }
};

module.exports = decodePacket;
},{"./commons":"node_modules/engine.io-parser/lib/commons.js","base64-arraybuffer":"node_modules/base64-arraybuffer/lib/base64-arraybuffer.js"}],"node_modules/engine.io-parser/lib/index.js":[function(require,module,exports) {
var encodePacket = require("./encodePacket");

var decodePacket = require("./decodePacket");

var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    encodePacket(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

module.exports = {
  protocol: 4,
  encodePacket: encodePacket,
  encodePayload: encodePayload,
  decodePacket: decodePacket,
  decodePayload: decodePayload
};
},{"./encodePacket":"node_modules/engine.io-parser/lib/encodePacket.browser.js","./decodePacket":"node_modules/engine.io-parser/lib/decodePacket.browser.js"}],"node_modules/component-emitter/index.js":[function(require,module,exports) {

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"node_modules/engine.io-client/lib/transport.js":[function(require,module,exports) {
const parser = require("engine.io-parser");
const Emitter = require("component-emitter");
const debug = require("debug")("engine.io-client:transport");

class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  constructor(opts) {
    super();

    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }

  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */
  onError(msg, desc) {
    const err = new Error(msg);
    err.type = "TransportError";
    err.description = desc;
    this.emit("error", err);
    return this;
  }

  /**
   * Opens the transport.
   *
   * @api public
   */
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }

    return this;
  }

  /**
   * Closes the transport.
   *
   * @api private
   */
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }

    return this;
  }

  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api private
   */
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    } else {
      // this might happen if the transport was silently closed in the beforeunload event handler
      debug("transport is not open, discarding packets");
    }
  }

  /**
   * Called upon open
   *
   * @api private
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    this.emit("open");
  }

  /**
   * Called with data.
   *
   * @param {String} data
   * @api private
   */
  onData(data) {
    const packet = parser.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }

  /**
   * Called with a decoded packet.
   */
  onPacket(packet) {
    this.emit("packet", packet);
  }

  /**
   * Called upon close.
   *
   * @api private
   */
  onClose() {
    this.readyState = "closed";
    this.emit("close");
  }
}

module.exports = Transport;

},{"engine.io-parser":"node_modules/engine.io-parser/lib/index.js","component-emitter":"node_modules/component-emitter/index.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/parseqs/index.js":[function(require,module,exports) {
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],"node_modules/yeast/index.js":[function(require,module,exports) {
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],"node_modules/engine.io-client/lib/transports/polling.js":[function(require,module,exports) {
const Transport = require("../transport");
const parseqs = require("parseqs");
const parser = require("engine.io-parser");
const yeast = require("yeast");

const debug = require("debug")("engine.io-client:polling");

class Polling extends Transport {
  /**
   * Transport name.
   */
  get name() {
    return "polling";
  }

  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */
  doOpen() {
    this.poll();
  }

  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */
  pause(onPause) {
    this.readyState = "pausing";

    const pause = () => {
      debug("paused");
      this.readyState = "paused";
      onPause();
    };

    if (this.polling || !this.writable) {
      let total = 0;

      if (this.polling) {
        debug("we are currently polling - waiting to pause");
        total++;
        this.once("pollComplete", function() {
          debug("pre-pause polling complete");
          --total || pause();
        });
      }

      if (!this.writable) {
        debug("we are currently writing - waiting to pause");
        total++;
        this.once("drain", function() {
          debug("pre-pause writing complete");
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }

  /**
   * Starts polling cycle.
   *
   * @api public
   */
  poll() {
    debug("polling");
    this.polling = true;
    this.doPoll();
    this.emit("poll");
  }

  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */
  onData(data) {
    debug("polling got data %s", data);
    const callback = packet => {
      // if its the first message we consider the transport open
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }

      // if its a close packet, we close the ongoing requests
      if ("close" === packet.type) {
        this.onClose();
        return false;
      }

      // otherwise bypass onData and handle the message
      this.onPacket(packet);
    };

    // decode payload
    parser.decodePayload(data, this.socket.binaryType).forEach(callback);

    // if an event did not trigger closing
    if ("closed" !== this.readyState) {
      // if we got data we're not polling
      this.polling = false;
      this.emit("pollComplete");

      if ("open" === this.readyState) {
        this.poll();
      } else {
        debug('ignoring poll - transport state "%s"', this.readyState);
      }
    }
  }

  /**
   * For polling, send a close packet.
   *
   * @api private
   */
  doClose() {
    const close = () => {
      debug("writing close packet");
      this.write([{ type: "close" }]);
    };

    if ("open" === this.readyState) {
      debug("transport open - closing");
      close();
    } else {
      // in case we're trying to close while
      // handshaking is in progress (GH-164)
      debug("transport not open - deferring close");
      this.once("open", close);
    }
  }

  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */
  write(packets) {
    this.writable = false;

    parser.encodePayload(packets, data => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emit("drain");
      });
    });
  }

  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";

    // cache busting is forced
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }

    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }

    query = parseqs.encode(query);

    // avoid port if default for schema
    if (
      this.opts.port &&
      (("https" === schema && Number(this.opts.port) !== 443) ||
        ("http" === schema && Number(this.opts.port) !== 80))
    ) {
      port = ":" + this.opts.port;
    }

    // prepend ? to query
    if (query.length) {
      query = "?" + query;
    }

    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return (
      schema +
      "://" +
      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
      port +
      this.opts.path +
      query
    );
  }
}

module.exports = Polling;

},{"../transport":"node_modules/engine.io-client/lib/transport.js","parseqs":"node_modules/parseqs/index.js","engine.io-parser":"node_modules/engine.io-parser/lib/index.js","yeast":"node_modules/yeast/index.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/engine.io-client/lib/util.js":[function(require,module,exports) {
module.exports.pick = (obj, ...attr) => {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
};

},{}],"node_modules/engine.io-client/lib/transports/polling-xhr.js":[function(require,module,exports) {
/* global attachEvent */

const XMLHttpRequest = require("../../contrib/xmlhttprequest-ssl/XMLHttpRequest");
const Polling = require("./polling");
const Emitter = require("component-emitter");
const { pick } = require("../util");
const globalThis = require("../globalThis");

const debug = require("debug")("engine.io-client:polling-xhr");

/**
 * Empty function
 */

function empty() {}

const hasXHR2 = (function() {
  const xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

class XHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  constructor(opts) {
    super(opts);

    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;

      // some user agents have empty `location.port`
      if (!port) {
        port = isSSL ? 443 : 80;
      }

      this.xd =
        (typeof location !== "undefined" &&
          opts.hostname !== location.hostname) ||
        port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    /**
     * XHR supports binary
     */
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }

  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }

  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data: data
    });
    req.on("success", fn);
    req.on("error", err => {
      this.onError("xhr post error", err);
    });
  }

  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    debug("xhr poll");
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", err => {
      this.onError("xhr poll error", err);
    });
    this.pollXhr = req;
  }
}

class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts) {
    super();
    this.opts = opts;

    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = undefined !== opts.data ? opts.data : null;

    this.create();
  }

  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */
  create() {
    const opts = pick(
      this.opts,
      "agent",
      "enablesXDR",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "autoUnref"
    );
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;

    const xhr = (this.xhr = new XMLHttpRequest(opts));

    try {
      debug("xhr open %s: %s", this.method, this.uri);
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {}

      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {}
      }

      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {}

      // ie6 check
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }

      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }

      if (this.hasXDR()) {
        xhr.onload = () => {
          this.onLoad();
        };
        xhr.onerror = () => {
          this.onError(xhr.responseText);
        };
      } else {
        xhr.onreadystatechange = () => {
          if (4 !== xhr.readyState) return;
          if (200 === xhr.status || 1223 === xhr.status) {
            this.onLoad();
          } else {
            // make sure the `error` event handler that's user-set
            // does not throw in the same tick and gets caught here
            setTimeout(() => {
              this.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
      }

      debug("xhr data %s", this.data);
      xhr.send(this.data);
    } catch (e) {
      // Need to defer since .create() is called directly from the constructor
      // and thus the 'error' event can only be only bound *after* this exception
      // occurs.  Therefore, also, we cannot throw here at all.
      setTimeout(() => {
        this.onError(e);
      }, 0);
      return;
    }

    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }

  /**
   * Called upon successful response.
   *
   * @api private
   */
  onSuccess() {
    this.emit("success");
    this.cleanup();
  }

  /**
   * Called if we have data.
   *
   * @api private
   */
  onData(data) {
    this.emit("data", data);
    this.onSuccess();
  }

  /**
   * Called upon error.
   *
   * @api private
   */
  onError(err) {
    this.emit("error", err);
    this.cleanup(true);
  }

  /**
   * Cleans up house.
   *
   * @api private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    // xmlhttprequest
    if (this.hasXDR()) {
      this.xhr.onload = this.xhr.onerror = empty;
    } else {
      this.xhr.onreadystatechange = empty;
    }

    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {}
    }

    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }

    this.xhr = null;
  }

  /**
   * Called upon load.
   *
   * @api private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.onData(data);
    }
  }

  /**
   * Check if it has XDomainRequest.
   *
   * @api private
   */
  hasXDR() {
    return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
  }

  /**
   * Aborts the request.
   *
   * @api public
   */
  abort() {
    this.cleanup();
  }
}

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

module.exports = XHR;
module.exports.Request = Request;

},{"../../contrib/xmlhttprequest-ssl/XMLHttpRequest":"node_modules/engine.io-client/lib/xmlhttprequest.js","./polling":"node_modules/engine.io-client/lib/transports/polling.js","component-emitter":"node_modules/component-emitter/index.js","../util":"node_modules/engine.io-client/lib/util.js","../globalThis":"node_modules/engine.io-client/lib/globalThis.browser.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/engine.io-client/lib/transports/polling-jsonp.js":[function(require,module,exports) {
const Polling = require("./polling");
const globalThis = require("../globalThis");

const rNewline = /\n/g;
const rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

let callbacks;

class JSONPPolling extends Polling {
  /**
   * JSONP Polling constructor.
   *
   * @param {Object} opts.
   * @api public
   */
  constructor(opts) {
    super(opts);

    this.query = this.query || {};

    // define global callbacks array if not present
    // we do this here (lazily) to avoid unneeded global pollution
    if (!callbacks) {
      // we need to consider multiple engines in the same page
      callbacks = globalThis.___eio = globalThis.___eio || [];
    }

    // callback identifier
    this.index = callbacks.length;

    // add callback to jsonp global
    callbacks.push(this.onData.bind(this));

    // append to query string
    this.query.j = this.index;
  }

  /**
   * JSONP only supports binary as base64 encoded strings
   */
  get supportsBinary() {
    return false;
  }

  /**
   * Closes the socket.
   *
   * @api private
   */
  doClose() {
    if (this.script) {
      // prevent spurious errors from being emitted when the window is unloaded
      this.script.onerror = () => {};
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    if (this.form) {
      this.form.parentNode.removeChild(this.form);
      this.form = null;
      this.iframe = null;
    }

    super.doClose();
  }

  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    const script = document.createElement("script");

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.uri();
    script.onerror = e => {
      this.onError("jsonp poll error", e);
    };

    const insertAt = document.getElementsByTagName("script")[0];
    if (insertAt) {
      insertAt.parentNode.insertBefore(script, insertAt);
    } else {
      (document.head || document.body).appendChild(script);
    }
    this.script = script;

    const isUAgecko =
      "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);

    if (isUAgecko) {
      setTimeout(function() {
        const iframe = document.createElement("iframe");
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  }

  /**
   * Writes with a hidden iframe.
   *
   * @param {String} data to send
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn) {
    let iframe;

    if (!this.form) {
      const form = document.createElement("form");
      const area = document.createElement("textarea");
      const id = (this.iframeId = "eio_iframe_" + this.index);

      form.className = "socketio";
      form.style.position = "absolute";
      form.style.top = "-1000px";
      form.style.left = "-1000px";
      form.target = id;
      form.method = "POST";
      form.setAttribute("accept-charset", "utf-8");
      area.name = "d";
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.uri();

    function complete() {
      initIframe();
      fn();
    }

    const initIframe = () => {
      if (this.iframe) {
        try {
          this.form.removeChild(this.iframe);
        } catch (e) {
          this.onError("jsonp polling iframe removal error", e);
        }
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        const html = '<iframe src="javascript:0" name="' + this.iframeId + '">';
        iframe = document.createElement(html);
      } catch (e) {
        iframe = document.createElement("iframe");
        iframe.name = this.iframeId;
        iframe.src = "javascript:0";
      }

      iframe.id = this.iframeId;

      this.form.appendChild(iframe);
      this.iframe = iframe;
    };

    initIframe();

    // escape \n to prevent it from being converted into \r\n by some UAs
    // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
    data = data.replace(rEscapedNewline, "\\\n");
    this.area.value = data.replace(rNewline, "\\n");

    try {
      this.form.submit();
    } catch (e) {}

    if (this.iframe.attachEvent) {
      this.iframe.onreadystatechange = () => {
        if (this.iframe.readyState === "complete") {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }
  }
}

module.exports = JSONPPolling;

},{"./polling":"node_modules/engine.io-client/lib/transports/polling.js","../globalThis":"node_modules/engine.io-client/lib/globalThis.browser.js"}],"node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js":[function(require,module,exports) {
const globalThis = require("../globalThis");
const nextTick = (() => {
  const isPromiseAvailable =
    typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return cb => Promise.resolve().then(cb);
  } else {
    return cb => setTimeout(cb, 0);
  }
})();

module.exports = {
  WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,
  usingBrowserWebSocket: true,
  defaultBinaryType: "arraybuffer",
  nextTick
};

},{"../globalThis":"node_modules/engine.io-client/lib/globalThis.browser.js"}],"node_modules/engine.io-client/lib/transports/websocket.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
const Transport = require("../transport");
const parser = require("engine.io-parser");
const parseqs = require("parseqs");
const yeast = require("yeast");
const { pick } = require("../util");
const {
  WebSocket,
  usingBrowserWebSocket,
  defaultBinaryType,
  nextTick
} = require("./websocket-constructor");

const debug = require("debug")("engine.io-client:websocket");

// detect ReactNative environment
const isReactNative =
  typeof navigator !== "undefined" &&
  typeof navigator.product === "string" &&
  navigator.product.toLowerCase() === "reactnative";

class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  constructor(opts) {
    super(opts);

    this.supportsBinary = !opts.forceBase64;
  }

  /**
   * Transport name.
   *
   * @api public
   */
  get name() {
    return "websocket";
  }

  /**
   * Opens socket.
   *
   * @api private
   */
  doOpen() {
    if (!this.check()) {
      // let probe timeout
      return;
    }

    const uri = this.uri();
    const protocols = this.opts.protocols;

    // React Native only supports the 'headers' option, and will print a warning if anything else is passed
    const opts = isReactNative
      ? {}
      : pick(
          this.opts,
          "agent",
          "perMessageDeflate",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "rejectUnauthorized",
          "localAddress",
          "protocolVersion",
          "origin",
          "maxPayload",
          "family",
          "checkServerIdentity"
        );

    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }

    try {
      this.ws =
        usingBrowserWebSocket && !isReactNative
          ? protocols
            ? new WebSocket(uri, protocols)
            : new WebSocket(uri)
          : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emit("error", err);
    }

    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;

    this.addEventListeners();
  }

  /**
   * Adds event listeners to the socket
   *
   * @api private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = this.onClose.bind(this);
    this.ws.onmessage = ev => this.onData(ev.data);
    this.ws.onerror = e => this.onError("websocket error", e);
  }

  /**
   * Writes data to socket.
   *
   * @param {Array} array of packets.
   * @api private
   */
  write(packets) {
    this.writable = false;

    // encodePacket efficient as it uses WS framing
    // no need for encodePayload
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;

      parser.encodePacket(packet, this.supportsBinary, data => {
        // always create a new object (GH-437)
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (this.opts.perMessageDeflate) {
            const len =
              "string" === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            this.ws.send(data);
          } else {
            this.ws.send(data, opts);
          }
        } catch (e) {
          debug("websocket closed before onclose event");
        }

        if (lastPacket) {
          // fake drain
          // defer to next tick to allow Socket to clear writeBuffer
          nextTick(() => {
            this.writable = true;
            this.emit("drain");
          });
        }
      });
    }
  }

  /**
   * Called upon close
   *
   * @api private
   */
  onClose() {
    Transport.prototype.onClose.call(this);
  }

  /**
   * Closes socket.
   *
   * @api private
   */
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }

  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";

    // avoid port if default for schema
    if (
      this.opts.port &&
      (("wss" === schema && Number(this.opts.port) !== 443) ||
        ("ws" === schema && Number(this.opts.port) !== 80))
    ) {
      port = ":" + this.opts.port;
    }

    // append timestamp to URI
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }

    // communicate binary support capabilities
    if (!this.supportsBinary) {
      query.b64 = 1;
    }

    query = parseqs.encode(query);

    // prepend ? to query
    if (query.length) {
      query = "?" + query;
    }

    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return (
      schema +
      "://" +
      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
      port +
      this.opts.path +
      query
    );
  }

  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @api public
   */
  check() {
    return (
      !!WebSocket &&
      !("__initialize" in WebSocket && this.name === WS.prototype.name)
    );
  }
}

module.exports = WS;

},{"../transport":"node_modules/engine.io-client/lib/transport.js","engine.io-parser":"node_modules/engine.io-parser/lib/index.js","parseqs":"node_modules/parseqs/index.js","yeast":"node_modules/yeast/index.js","../util":"node_modules/engine.io-client/lib/util.js","./websocket-constructor":"node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js","debug":"node_modules/debug/src/browser.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/engine.io-client/lib/transports/index.js":[function(require,module,exports) {
const XMLHttpRequest = require("../../contrib/xmlhttprequest-ssl/XMLHttpRequest");
const XHR = require("./polling-xhr");
const JSONP = require("./polling-jsonp");
const websocket = require("./websocket");

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts) {
  let xhr;
  let xd = false;
  let xs = false;
  const jsonp = false !== opts.jsonp;

  if (typeof location !== "undefined") {
    const isSSL = "https:" === location.protocol;
    let port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}

},{"../../contrib/xmlhttprequest-ssl/XMLHttpRequest":"node_modules/engine.io-client/lib/xmlhttprequest.js","./polling-xhr":"node_modules/engine.io-client/lib/transports/polling-xhr.js","./polling-jsonp":"node_modules/engine.io-client/lib/transports/polling-jsonp.js","./websocket":"node_modules/engine.io-client/lib/transports/websocket.js"}],"node_modules/engine.io-client/lib/socket.js":[function(require,module,exports) {
const transports = require("./transports/index");
const Emitter = require("component-emitter");
const debug = require("debug")("engine.io-client:socket");
const parser = require("engine.io-parser");
const parseuri = require("parseuri");
const parseqs = require("parseqs");

class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts = {}) {
    super();

    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }

    if (uri) {
      uri = parseuri(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query) opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri(opts.host).host;
    }

    this.secure =
      null != opts.secure
        ? opts.secure
        : typeof location !== "undefined" && "https:" === location.protocol;

    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? "443" : "80";
    }

    this.hostname =
      opts.hostname ||
      (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port =
      opts.port ||
      (typeof location !== "undefined" && location.port
        ? location.port
        : this.secure
        ? 443
        : 80);

    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;

    this.opts = Object.assign(
      {
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        jsonp: true,
        timestampParam: "t",
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: true
      },
      opts
    );

    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";

    if (typeof this.opts.query === "string") {
      this.opts.query = parseqs.decode(this.opts.query);
    }

    // set on handshake
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;

    // set on heartbeat
    this.pingTimeoutTimer = null;

    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        addEventListener(
          "beforeunload",
          () => {
            if (this.transport) {
              // silently close the transport
              this.transport.removeAllListeners();
              this.transport.close();
            }
          },
          false
        );
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close");
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }

    this.open();
  }

  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */
  createTransport(name) {
    debug('creating transport "%s"', name);
    const query = clone(this.opts.query);

    // append engine.io protocol identifier
    query.EIO = parser.protocol;

    // transport name
    query.transport = name;

    // session id if we already have one
    if (this.id) query.sid = this.id;

    const opts = Object.assign(
      {},
      this.opts.transportOptions[name],
      this.opts,
      {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }
    );

    debug("options: %j", opts);

    return new transports[name](opts);
  }

  /**
   * Initializes transport to use and starts probe.
   *
   * @api private
   */
  open() {
    let transport;
    if (
      this.opts.rememberUpgrade &&
      Socket.priorWebsocketSuccess &&
      this.transports.indexOf("websocket") !== -1
    ) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      // Emit error on next tick so it can be listened to
      setTimeout(() => {
        this.emit("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";

    // Retry with the next transport if the transport is disabled (jsonp: false)
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      debug("error while creating transport: %s", e);
      this.transports.shift();
      this.open();
      return;
    }

    transport.open();
    this.setTransport(transport);
  }

  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @api private
   */
  setTransport(transport) {
    debug("setting transport %s", transport.name);

    if (this.transport) {
      debug("clearing existing transport %s", this.transport.name);
      this.transport.removeAllListeners();
    }

    // set up transport
    this.transport = transport;

    // set up transport listeners
    transport
      .on("drain", this.onDrain.bind(this))
      .on("packet", this.onPacket.bind(this))
      .on("error", this.onError.bind(this))
      .on("close", () => {
        this.onClose("transport close");
      });
  }

  /**
   * Probes a transport.
   *
   * @param {String} transport name
   * @api private
   */
  probe(name) {
    debug('probing transport "%s"', name);
    let transport = this.createTransport(name, { probe: 1 });
    let failed = false;

    Socket.priorWebsocketSuccess = false;

    const onTransportOpen = () => {
      if (failed) return;

      debug('probe transport "%s" opened', name);
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", msg => {
        if (failed) return;
        if ("pong" === msg.type && "probe" === msg.data) {
          debug('probe transport "%s" pong', name);
          this.upgrading = true;
          this.emit("upgrading", transport);
          if (!transport) return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;

          debug('pausing current transport "%s"', this.transport.name);
          this.transport.pause(() => {
            if (failed) return;
            if ("closed" === this.readyState) return;
            debug("changing transport and sending upgrade packet");

            cleanup();

            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emit("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          debug('probe transport "%s" failed', name);
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emit("upgradeError", err);
        }
      });
    };

    function freezeTransport() {
      if (failed) return;

      // Any callback called by transport should be ignored since now
      failed = true;

      cleanup();

      transport.close();
      transport = null;
    }

    // Handle any error that happens while probing
    const onerror = err => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;

      freezeTransport();

      debug('probe transport "%s" failed because of error: %s', name, err);

      this.emit("upgradeError", error);
    };

    function onTransportClose() {
      onerror("transport closed");
    }

    // When the socket is closed while we're probing
    function onclose() {
      onerror("socket closed");
    }

    // When the socket is upgraded while we're probing
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        debug('"%s" works - aborting "%s"', to.name, transport.name);
        freezeTransport();
      }
    }

    // Remove all listeners on the transport and on self
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.removeListener("close", onclose);
      this.removeListener("upgrading", onupgrade);
    };

    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);

    this.once("close", onclose);
    this.once("upgrading", onupgrade);

    transport.open();
  }

  /**
   * Called when connection is deemed open.
   *
   * @api public
   */
  onOpen() {
    debug("socket open");
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emit("open");
    this.flush();

    // we check for `readyState` in case an `open`
    // listener already closed the socket
    if (
      "open" === this.readyState &&
      this.opts.upgrade &&
      this.transport.pause
    ) {
      debug("starting upgrade probes");
      let i = 0;
      const l = this.upgrades.length;
      for (; i < l; i++) {
        this.probe(this.upgrades[i]);
      }
    }
  }

  /**
   * Handles a packet.
   *
   * @api private
   */
  onPacket(packet) {
    if (
      "opening" === this.readyState ||
      "open" === this.readyState ||
      "closing" === this.readyState
    ) {
      debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

      this.emit("packet", packet);

      // Socket is live - any packet counts
      this.emit("heartbeat");

      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;

        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emit("ping");
          this.emit("pong");
          break;

        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    } else {
      debug('packet received with socket readyState "%s"', this.readyState);
    }
  }

  /**
   * Called upon handshake completion.
   *
   * @param {Object} handshake obj
   * @api private
   */
  onHandshake(data) {
    this.emit("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.onOpen();
    // In case open handler closes socket
    if ("closed" === this.readyState) return;
    this.resetPingTimeout();
  }

  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @api private
   */
  resetPingTimeout() {
    clearTimeout(this.pingTimeoutTimer);
    this.pingTimeoutTimer = setTimeout(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }

  /**
   * Called on `drain` event
   *
   * @api private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);

    // setting prevBufferLen = 0 is very important
    // for example, when upgrading, upgrade packet is sent over,
    // and a nonzero prevBufferLen could cause problems on `drain`
    this.prevBufferLen = 0;

    if (0 === this.writeBuffer.length) {
      this.emit("drain");
    } else {
      this.flush();
    }
  }

  /**
   * Flush write buffers.
   *
   * @api private
   */
  flush() {
    if (
      "closed" !== this.readyState &&
      this.transport.writable &&
      !this.upgrading &&
      this.writeBuffer.length
    ) {
      debug("flushing %d packets in socket", this.writeBuffer.length);
      this.transport.send(this.writeBuffer);
      // keep track of current length of writeBuffer
      // splice writeBuffer and callbackBuffer on `drain`
      this.prevBufferLen = this.writeBuffer.length;
      this.emit("flush");
    }
  }

  /**
   * Sends a message.
   *
   * @param {String} message.
   * @param {Function} callback function.
   * @param {Object} options.
   * @return {Socket} for chaining.
   * @api public
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }

  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }

  /**
   * Sends a packet.
   *
   * @param {String} packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} callback function.
   * @api private
   */
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = undefined;
    }

    if ("function" === typeof options) {
      fn = options;
      options = null;
    }

    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }

    options = options || {};
    options.compress = false !== options.compress;

    const packet = {
      type: type,
      data: data,
      options: options
    };
    this.emit("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn) this.once("flush", fn);
    this.flush();
  }

  /**
   * Closes the connection.
   *
   * @api private
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      debug("socket closing - telling transport to close");
      this.transport.close();
    };

    const cleanupAndClose = () => {
      this.removeListener("upgrade", cleanupAndClose);
      this.removeListener("upgradeError", cleanupAndClose);
      close();
    };

    const waitForUpgrade = () => {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };

    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }

    return this;
  }

  /**
   * Called upon transport error
   *
   * @api private
   */
  onError(err) {
    debug("socket error %j", err);
    Socket.priorWebsocketSuccess = false;
    this.emit("error", err);
    this.onClose("transport error", err);
  }

  /**
   * Called upon transport close.
   *
   * @api private
   */
  onClose(reason, desc) {
    if (
      "opening" === this.readyState ||
      "open" === this.readyState ||
      "closing" === this.readyState
    ) {
      debug('socket close with reason: "%s"', reason);

      // clear timers
      clearTimeout(this.pingIntervalTimer);
      clearTimeout(this.pingTimeoutTimer);

      // stop event from firing again for transport
      this.transport.removeAllListeners("close");

      // ensure transport won't stay open
      this.transport.close();

      // ignore further transport communication
      this.transport.removeAllListeners();

      if (typeof removeEventListener === "function") {
        removeEventListener("offline", this.offlineEventListener, false);
      }

      // set ready state
      this.readyState = "closed";

      // clear session id
      this.id = null;

      // emit close event
      this.emit("close", reason, desc);

      // clean buffers after, so users can still
      // grab the buffers on `close` event
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }

  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} server upgrades
   * @api private
   *
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i = 0;
    const j = upgrades.length;
    for (; i < j; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}

Socket.priorWebsocketSuccess = false;

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

function clone(obj) {
  const o = {};
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

module.exports = Socket;

},{"./transports/index":"node_modules/engine.io-client/lib/transports/index.js","component-emitter":"node_modules/component-emitter/index.js","debug":"node_modules/debug/src/browser.js","engine.io-parser":"node_modules/engine.io-parser/lib/index.js","parseuri":"node_modules/parseuri/index.js","parseqs":"node_modules/parseqs/index.js"}],"node_modules/engine.io-client/lib/index.js":[function(require,module,exports) {
const Socket = require("./socket");

module.exports = (uri, opts) => new Socket(uri, opts);

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

module.exports.Socket = Socket;
module.exports.protocol = Socket.protocol; // this is an int
module.exports.Transport = require("./transport");
module.exports.transports = require("./transports/index");
module.exports.parser = require("engine.io-parser");

},{"./socket":"node_modules/engine.io-client/lib/socket.js","./transport":"node_modules/engine.io-client/lib/transport.js","./transports/index":"node_modules/engine.io-client/lib/transports/index.js","engine.io-parser":"node_modules/engine.io-parser/lib/index.js"}],"node_modules/socket.io-parser/dist/is-binary.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */

function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}

exports.isBinary = isBinary;

function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }

  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (isBinary(obj)) {
    return true;
  }

  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

exports.hasBinary = hasBinary;
},{}],"node_modules/socket.io-parser/dist/binary.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconstructPacket = exports.deconstructPacket = void 0;

var is_binary_1 = require("./is-binary");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */


function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
}

exports.deconstructPacket = deconstructPacket;

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (is_binary_1.isBinary(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }

    return _newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */


function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
}

exports.reconstructPacket = reconstructPacket;

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }

  return data;
}
},{"./is-binary":"node_modules/socket.io-parser/dist/is-binary.js"}],"node_modules/socket.io-parser/dist/index.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;

var Emitter = require("component-emitter");

var binary_1 = require("./binary");

var is_binary_1 = require("./is-binary");

var debug = require("debug")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */


exports.protocol = 5;
var PacketType;

(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */


var Encoder = /*#__PURE__*/function () {
  function Encoder() {
    _classCallCheck(this, Encoder);
  }

  _createClass(Encoder, [{
    key: "encode",
    value:
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    function encode(obj) {
      debug("encoding packet %j", obj);

      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }

      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */

  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type; // attachments if we have them

      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      } // if we have a namespace other than `/`
      // we append it followed by a comma `,`


      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      } // immediately followed by the id


      if (null != obj.id) {
        str += obj.id;
      } // json data


      if (null != obj.data) {
        str += JSON.stringify(obj.data);
      }

      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */

  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = binary_1.deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      return buffers; // write all the buffers
    }
  }]);

  return Encoder;
}();

exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */

var Decoder = /*#__PURE__*/function (_Emitter) {
  _inherits(Decoder, _Emitter);

  var _super = _createSuper(Decoder);

  function Decoder() {
    _classCallCheck(this, Decoder);

    return _super.call(this);
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */


  _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;

      if (typeof obj === "string") {
        packet = this.decodeString(obj);

        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);

          if (packet) {
            // received final buffer
            this.reconstructor = null;

            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */

  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0; // look up type

      var p = {
        type: Number(str.charAt(0))
      };

      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      } // look up attachments if type binary


      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;

        while (str.charAt(++i) !== "-" && i != str.length) {}

        var buf = str.substring(start, i);

        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }

        p.attachments = Number(buf);
      } // look up namespace (if any)


      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;

        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }

        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      } // look up id


      var next = str.charAt(i + 1);

      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;

        while (++i) {
          var _c = str.charAt(i);

          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }

          if (i === str.length) break;
        }

        p.id = Number(str.substring(_start2, i + 1));
      } // look up json data


      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));

        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }

      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return _typeof(payload) === "object";

        case PacketType.DISCONNECT:
          return payload === undefined;

        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || _typeof(payload) === "object";

        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;

        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);

  return Decoder;
}(Emitter);

exports.Decoder = Decoder;

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */


var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);

    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */


  _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);

      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }

      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */

  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);

  return BinaryReconstructor;
}();
},{"component-emitter":"node_modules/component-emitter/index.js","./binary":"node_modules/socket.io-parser/dist/binary.js","./is-binary":"node_modules/socket.io-parser/dist/is-binary.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/socket.io-client/build/on.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.on = void 0;

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

exports.on = on;
},{}],"node_modules/socket.io-client/build/typed-events.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StrictEventEmitter = void 0;

var Emitter = require("component-emitter");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */


var StrictEventEmitter = /*#__PURE__*/function (_Emitter) {
  _inherits(StrictEventEmitter, _Emitter);

  var _super = _createSuper(StrictEventEmitter);

  function StrictEventEmitter() {
    _classCallCheck(this, StrictEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(StrictEventEmitter, [{
    key: "on",
    value:
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    function on(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "on", this).call(this, ev, listener);

      return this;
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */

  }, {
    key: "once",
    value: function once(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "once", this).call(this, ev, listener);

      return this;
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_get2 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));

      return this;
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitReserved",
    value: function emitReserved(ev) {
      var _get3;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_get3 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, ev].concat(args));

      return this;
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */

  }, {
    key: "listeners",
    value: function listeners(event) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "listeners", this).call(this, event);
    }
  }]);

  return StrictEventEmitter;
}(Emitter);

exports.StrictEventEmitter = StrictEventEmitter;
},{"component-emitter":"node_modules/component-emitter/index.js"}],"node_modules/socket.io-client/build/socket.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var socket_io_parser_1 = require("socket.io-parser");

var on_1 = require("./on");

var typed_events_1 = require("./typed-events");

var debug = require("debug")("socket.io-client:socket");
/**
 * Internal events.
 * These events can't be emitted by the user.
 */


var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});

var Socket = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Socket, _typed_events_1$Stric);

  var _super = _createSuper(Socket);

  /**
   * `Socket` constructor.
   *
   * @public
   */
  function Socket(io, nsp, opts) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.ids = 0;
    _this.acks = {};
    _this.flags = {};
    _this.io = io;
    _this.nsp = nsp;
    _this.ids = 0;
    _this.acks = {};
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.connected = false;
    _this.disconnected = true;
    _this.flags = {};

    if (opts && opts.auth) {
      _this.auth = opts.auth;
    }

    if (_this.io._autoConnect) _this.open();
    return _this;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */


  _createClass(Socket, [{
    key: "subEvents",
    value: function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [on_1.on(io, "open", this.onopen.bind(this)), on_1.on(io, "packet", this.onpacket.bind(this)), on_1.on(io, "error", this.onerror.bind(this)), on_1.on(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects
     */

  }, {
    key: "active",
    get: function get() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @public
     */

  }, {
    key: "connect",
    value: function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open

      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for connect()
     */

  }, {
    key: "open",
    value: function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @return self
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev + '" is a reserved event name');
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      args.unshift(ev);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false; // event ack callback

      if ("function" === typeof args[args.length - 1]) {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }

      var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      var discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);

      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }

      this.flags = {};
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "packet",
    value: function packet(_packet) {
      _packet.nsp = this.nsp;

      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      var _this2 = this;

      debug("transport is open - connecting");

      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this2.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: data
          });
        });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: this.auth
        });
      }
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emitReserved("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onpacket",
    value: function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;

      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            var id = packet.data.sid;
            this.onconnect(id);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }

          break;

        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          var err = new Error(packet.data.message); // @ts-ignore

          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);

      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }

      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */

  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        debug("sending ack %j", args);
        self.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks[packet.id];

      if ("function" === typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */

  }, {
    key: "onconnect",
    value: function onconnect(id) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.connected = true;
      this.disconnected = false;
      this.emitBuffered();
      this.emitReserved("connect");
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */

  }, {
    key: "emitBuffered",
    value: function emitBuffered() {
      var _this3 = this;

      this.receiveBuffer.forEach(function (args) {
        return _this3.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        return _this3.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */

  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }

      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return self
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });
      } // remove socket from pool


      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }

      return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return self
     * @public
     */

  }, {
    key: "close",
    value: function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      this.flags.volatile = true;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */

  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.push(listener);

      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */

  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.unshift(listener);

      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */

  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }

      if (listener) {
        var listeners = this._anyListeners;

        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }

      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */

  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
  }]);

  return Socket;
}(typed_events_1.StrictEventEmitter);

exports.Socket = Socket;
},{"socket.io-parser":"node_modules/socket.io-parser/dist/index.js","./on":"node_modules/socket.io-client/build/on.js","./typed-events":"node_modules/socket.io-client/build/typed-events.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/backo2/index.js":[function(require,module,exports) {

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],"node_modules/socket.io-client/build/manager.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = void 0;

var eio = require("engine.io-client");

var socket_1 = require("./socket");

var parser = require("socket.io-parser");

var on_1 = require("./on");

var Backoff = require("backo2");

var typed_events_1 = require("./typed-events");

var debug = require("debug")("socket.io-client:manager");

var Manager = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Manager, _typed_events_1$Stric);

  var _super = _createSuper(Manager);

  function Manager(uri, opts) {
    var _this;

    _classCallCheck(this, Manager);

    _this = _super.call(this);
    _this.nsps = {};
    _this.subs = [];

    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    _this.opts = opts;

    _this.reconnection(opts.reconnection !== false);

    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);

    _this.reconnectionDelay(opts.reconnectionDelay || 1000);

    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);

    _this.randomizationFactor(opts.randomizationFactor || 0.5);

    _this.backoff = new Backoff({
      min: _this.reconnectionDelay(),
      max: _this.reconnectionDelayMax(),
      jitter: _this.randomizationFactor()
    });

    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);

    _this._readyState = "closed";
    _this.uri = uri;

    var _parser = opts.parser || parser;

    _this.encoder = new _parser.Encoder();
    _this.decoder = new _parser.Decoder();
    _this._autoConnect = opts.autoConnect !== false;
    if (_this._autoConnect) _this.open();
    return _this;
  }

  _createClass(Manager, [{
    key: "reconnection",
    value: function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
  }, {
    key: "reconnectionAttempts",
    value: function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
  }, {
    key: "reconnectionDelay",
    value: function reconnectionDelay(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
  }, {
    key: "randomizationFactor",
    value: function randomizationFactor(v) {
      var _a;

      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
  }, {
    key: "reconnectionDelayMax",
    value: function reconnectionDelayMax(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
  }, {
    key: "timeout",
    value: function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */

  }, {
    key: "maybeReconnectOnOpen",
    value: function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */

  }, {
    key: "open",
    value: function open(fn) {
      var _this2 = this;

      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false; // emit `open`

      var openSubDestroy = on_1.on(socket, "open", function () {
        self.onopen();
        fn && fn();
      }); // emit `error`

      var errorSub = on_1.on(socket, "error", function (err) {
        debug("error");
        self.cleanup();
        self._readyState = "closed";

        _this2.emitReserved("error", err);

        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);

        if (timeout === 0) {
          openSubDestroy(); // prevents a race condition with the 'open' event
        } // set timer


        var timer = setTimeout(function () {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          socket.close();
          socket.emit("error", new Error("timeout"));
        }, timeout);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }

      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */

  }, {
    key: "connect",
    value: function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      debug("open"); // clear old subs

      this.cleanup(); // mark as open

      this._readyState = "open";
      this.emitReserved("open"); // add new subs

      var socket = this.engine;
      this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */

  }, {
    key: "onping",
    value: function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      this.emitReserved("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */

  }, {
    key: "socket",
    value: function socket(nsp, opts) {
      var socket = this.nsps[nsp];

      if (!socket) {
        socket = new socket_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      }

      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */

  }, {
    key: "_destroy",
    value: function _destroy(socket) {
      var nsps = Object.keys(this.nsps);

      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];

        if (_socket.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }

      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      debug("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);

      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      debug("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */

  }, {
    key: "_close",
    value: function _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;

      if ("opening" === this._readyState) {
        // `onclose` will not fire because
        // an open event never happened
        this.cleanup();
      }

      this.backoff.reset();
      this._readyState = "closed";
      if (this.engine) this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason);

      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */

  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this3 = this;

      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;

      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = setTimeout(function () {
          if (self.skipReconnect) return;
          debug("attempting reconnect");

          _this3.emitReserved("reconnect_attempt", self.backoff.attempts); // check again for the case socket closed in above events


          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();

              _this3.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */

  }, {
    key: "onreconnect",
    value: function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }]);

  return Manager;
}(typed_events_1.StrictEventEmitter);

exports.Manager = Manager;
},{"engine.io-client":"node_modules/engine.io-client/lib/index.js","./socket":"node_modules/socket.io-client/build/socket.js","socket.io-parser":"node_modules/socket.io-parser/dist/index.js","./on":"node_modules/socket.io-client/build/on.js","backo2":"node_modules/backo2/index.js","./typed-events":"node_modules/socket.io-client/build/typed-events.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/socket.io-client/build/index.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;

var url_1 = require("./url");

var manager_1 = require("./manager");

var debug = require("debug")("socket.io-client");
/**
 * Module exports.
 */


module.exports = exports = lookup;
/**
 * Managers cache.
 */

var cache = exports.managers = {};

function lookup(uri, opts) {
  if (_typeof(uri) === "object") {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  var parsed = url_1.url(uri, opts.path || "/socket.io");
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id]["nsps"];
  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  var io;

  if (newConnection) {
    debug("ignoring socket cache for %s", source);
    io = new manager_1.Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug("new io instance for %s", source);
      cache[id] = new manager_1.Manager(source, opts);
    }

    io = cache[id];
  }

  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }

  return io.socket(parsed.path, opts);
}

exports.io = lookup;
/**
 * Protocol version.
 *
 * @public
 */

var socket_io_parser_1 = require("socket.io-parser");

Object.defineProperty(exports, "protocol", {
  enumerable: true,
  get: function get() {
    return socket_io_parser_1.protocol;
  }
});
/**
 * `connect`.
 *
 * @param {String} uri
 * @public
 */

exports.connect = lookup;
/**
 * Expose constructors for standalone build.
 *
 * @public
 */

var manager_2 = require("./manager");

Object.defineProperty(exports, "Manager", {
  enumerable: true,
  get: function get() {
    return manager_2.Manager;
  }
});

var socket_1 = require("./socket");

Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
});
exports.default = lookup;
},{"./url":"node_modules/socket.io-client/build/url.js","./manager":"node_modules/socket.io-client/build/manager.js","debug":"node_modules/debug/src/browser.js","socket.io-parser":"node_modules/socket.io-parser/dist/index.js","./socket":"node_modules/socket.io-client/build/socket.js"}],"node_modules/stream-to-it/source.js":[function(require,module,exports) {
module.exports = readable => {
  // Node.js stream
  if (readable[Symbol.asyncIterator]) return readable

  // Browser ReadableStream
  if (readable.getReader) {
    return (async function * () {
      const reader = readable.getReader()

      try {
        while (true) {
          const { done, value } = await reader.read()
          if (done) return
          yield value
        }
      } finally {
        reader.releaseLock()
      }
    })()
  }

  throw new Error('unknown stream')
}

},{}],"node_modules/stream-to-it/sink.js":[function(require,module,exports) {
const getIterator = require('get-iterator')

module.exports = writable => async source => {
  source = getIterator(source)

  const maybeEndSource = (source) => {
    if (typeof source.return === 'function') source.return()
  }

  let error = null
  let errCb = null
  const errorHandler = (err) => {
    error = err
    if (errCb) errCb(err)
    // When the writable errors, try to end the source to exit iteration early
    maybeEndSource(source)
  }

  let closeCb = null
  let closed = false
  const closeHandler = () => {
    closed = true
    if (closeCb) closeCb()
  }

  let finishCb = null
  let finished = false
  const finishHandler = () => {
    finished = true
    if (finishCb) finishCb()
  }

  let drainCb = null
  const drainHandler = () => {
    if (drainCb) drainCb()
  }

  const waitForDrainOrClose = () => {
    return new Promise((resolve, reject) => {
      closeCb = drainCb = resolve
      errCb = reject
      writable.once('drain', drainHandler)
    })
  }

  const waitForDone = () => {
    // Immediately try to end the source
    maybeEndSource(source)
    return new Promise((resolve, reject) => {
      if (closed || finished || error) return resolve()
      finishCb = closeCb = resolve
      errCb = reject
    })
  }

  const cleanup = () => {
    writable.removeListener('error', errorHandler)
    writable.removeListener('close', closeHandler)
    writable.removeListener('finish', finishHandler)
    writable.removeListener('drain', drainHandler)
  }

  writable.once('error', errorHandler)
  writable.once('close', closeHandler)
  writable.once('finish', finishHandler)

  try {
    for await (const value of source) {
      if (!writable.writable || writable.destroyed || error) break

      if (writable.write(value) === false) {
        await waitForDrainOrClose()
      }
    }
  } catch (err) {
    // error is set by stream error handler so only destroy stream if source threw
    if (!error) {
      writable.destroy()
    }

    // could we be obscuring an error here?
    error = err
  }

  try {
    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)
    if (writable.writable) {
      writable.end()
    }

    // Wait until we close or finish. This supports halfClosed streams
    await waitForDone()

    // Notify the user an error occurred
    if (error) throw error
  } finally {
    // Clean up listeners
    cleanup()
  }
}

},{"get-iterator":"node_modules/get-iterator/index.js"}],"node_modules/stream-to-it/duplex.js":[function(require,module,exports) {
const toSink = require('./sink')
const toSource = require('./source')

module.exports = duplex => ({ sink: toSink(duplex), source: toSource(duplex) })

},{"./sink":"node_modules/stream-to-it/sink.js","./source":"node_modules/stream-to-it/source.js"}],"node_modules/stream-to-it/transform.js":[function(require,module,exports) {
const toDuplex = require('./duplex')

module.exports = transform => async function * (source) {
  const duplex = toDuplex(transform)
  // In a transform the sink and source are connected, an error in the sink
  // will be thrown in the source also. Catch the sink error to avoid unhandled
  // rejections and yield from the source.
  let sinkError
  duplex.sink(source).catch(err => { sinkError = err })

  yield * duplex.source
  if (sinkError) throw sinkError
}

},{"./duplex":"node_modules/stream-to-it/duplex.js"}],"node_modules/stream-to-it/index.js":[function(require,module,exports) {
module.exports = require('./source')
module.exports.source = require('./source')
module.exports.sink = require('./sink')
module.exports.transform = require('./transform')
module.exports.duplex = require('./duplex')

},{"./source":"node_modules/stream-to-it/source.js","./sink":"node_modules/stream-to-it/sink.js","./transform":"node_modules/stream-to-it/transform.js","./duplex":"node_modules/stream-to-it/duplex.js"}],"node_modules/libp2p-webrtc-star/src/socket-to-conn.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var abortable = require('abortable-iterator');

var toIterable = require('stream-to-it');

var _require = require('./constants'),
    CLOSE_TIMEOUT = _require.CLOSE_TIMEOUT;

var toMultiaddr = require('libp2p-utils/src/ip-port-to-multiaddr');

var debug = require('debug');

var log = debug('libp2p:webrtc-star:socket');
log.error = debug('libp2p:webrtc-star:socket:error');

var toWebrtcMultiaddr = function toWebrtcMultiaddr(address, port) {
  if (!address || !port) return undefined;

  try {
    return toMultiaddr(address, port);
  } catch (err) {
    log.error(err); // Account for mdns hostnames, just make it a local ip for now

    return toMultiaddr('0.0.0.0', port);
  }
}; // Convert a socket into a MultiaddrConnection
// https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection


module.exports = function (socket) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _toIterable$duplex = toIterable.duplex(socket),
      _sink = _toIterable$duplex.sink,
      source = _toIterable$duplex.source; // If the remote address was passed, use it - it may have the peer ID encapsulated


  var remoteAddr = options.remoteAddr || toWebrtcMultiaddr(socket.remoteAddress, socket.remotePort);
  var localAddr = toWebrtcMultiaddr(socket.localAddress, socket.localPort);
  var maConn = {
    sink: function sink(source) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (options.signal) {
                  source = abortable(source, options.signal);
                }

                _context2.prev = 1;
                _context2.next = 4;
                return _sink(_wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;

                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _iteratorAbruptCompletion = false;
                          _didIteratorError = false;
                          _context.prev = 2;
                          _iterator = _asyncIterator(source);

                        case 4:
                          _context.next = 6;
                          return _awaitAsyncGenerator(_iterator.next());

                        case 6:
                          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                            _context.next = 13;
                            break;
                          }

                          chunk = _step.value;
                          _context.next = 10;
                          return chunk instanceof Uint8Array ? chunk : chunk.slice();

                        case 10:
                          _iteratorAbruptCompletion = false;
                          _context.next = 4;
                          break;

                        case 13:
                          _context.next = 19;
                          break;

                        case 15:
                          _context.prev = 15;
                          _context.t0 = _context["catch"](2);
                          _didIteratorError = true;
                          _iteratorError = _context.t0;

                        case 19:
                          _context.prev = 19;
                          _context.prev = 20;

                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                            _context.next = 24;
                            break;
                          }

                          _context.next = 24;
                          return _awaitAsyncGenerator(_iterator.return());

                        case 24:
                          _context.prev = 24;

                          if (!_didIteratorError) {
                            _context.next = 27;
                            break;
                          }

                          throw _iteratorError;

                        case 27:
                          return _context.finish(24);

                        case 28:
                          return _context.finish(19);

                        case 29:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);
                }))());

              case 4:
                _context2.next = 9;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](1);

                // If aborted we can safely ignore
                if (_context2.t0.type !== 'aborted') {
                  // If the source errored the socket will already have been destroyed by
                  // toIterable.duplex(). If the socket errored it will already be
                  // destroyed. There's nothing to do here except log the error & return.
                  log.error(_context2.t0);
                }

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 6]]);
      }))();
    },
    source: options.signal ? abortable(source, options.signal) : source,
    conn: socket,
    localAddr: localAddr,
    remoteAddr: remoteAddr,
    timeline: {
      open: Date.now()
    },
    close: function close() {
      if (socket.destroyed) return;
      return new Promise(function (resolve, reject) {
        var start = Date.now(); // Attempt to end the socket. If it takes longer to close than the
        // timeout, destroy it manually.

        var timeout = setTimeout(function () {
          if (maConn.remoteAddr) {
            var _maConn$remoteAddr$to = maConn.remoteAddr.toOptions(),
                host = _maConn$remoteAddr$to.host,
                port = _maConn$remoteAddr$to.port;

            log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);
          }

          if (!socket.destroyed) {
            socket.destroy();
          }
        }, CLOSE_TIMEOUT);
        socket.once('close', function () {
          resolve();
        });
        socket.end(function (err) {
          clearTimeout(timeout);
          maConn.timeline.close = Date.now();
          if (err) return reject(err);
        });
      });
    }
  };
  socket.once('close', function () {
    // In instances where `close` was not explicitly called,
    // such as an iterable stream ending, ensure we have set the close
    // timeline
    if (!maConn.timeline.close) {
      maConn.timeline.close = Date.now();
    }
  });
  return maConn;
};
},{"abortable-iterator":"node_modules/abortable-iterator/index.js","stream-to-it":"node_modules/stream-to-it/index.js","./constants":"node_modules/libp2p-webrtc-star/src/constants.js","libp2p-utils/src/ip-port-to-multiaddr":"node_modules/libp2p-utils/src/ip-port-to-multiaddr.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/libp2p-webrtc-star/src/utils.js":[function(require,module,exports) {
'use strict';

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

function cleanUrlSIO(ma) {
  var maStrSplit = ma.toString().split('/');
  var tcpProto = ma.protos()[1].name;
  var wsProto = ma.protos()[2].name;
  var tcpPort = ma.stringTuples()[1][1];

  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {
    throw new Error('invalid multiaddr: ' + ma.toString());
  }

  if (!Multiaddr.isName(ma)) {
    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4];
  }

  if (wsProto === 'ws') {
    return 'http://' + maStrSplit[2] + (tcpPort === '80' ? '' : ':' + tcpPort);
  }

  if (wsProto === 'wss') {
    return 'https://' + maStrSplit[2] + (tcpPort === '443' ? '' : ':' + tcpPort);
  }
}

function cleanMultiaddr(maStr) {
  var legacy = '/libp2p-webrtc-star';

  if (maStr.indexOf(legacy) !== -1) {
    maStr = maStr.substring(legacy.length, maStr.length);
    var ma = new Multiaddr(maStr);
    var tuppleIPFS = ma.stringTuples().filter(function (tupple) {
      return tupple[0] === 421; // ipfs code
    })[0];
    ma = ma.decapsulate('p2p');
    ma = ma.encapsulate('/p2p-webrtc-star');
    ma = ma.encapsulate("/p2p/".concat(tuppleIPFS[1]));
    maStr = ma.toString();
  }

  return maStr;
}

module.exports = {
  cleanUrlSIO: cleanUrlSIO,
  cleanMultiaddr: cleanMultiaddr
};
},{"multiaddr":"node_modules/multiaddr/src/index.js"}],"node_modules/libp2p-webrtc-star/src/listener.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EventEmitter = require('events');

var debug = require('debug');

var log = debug('libp2p:webrtc-star:listener');
log.error = debug('libp2p:webrtc-star:listener:error');

var errCode = require('err-code');

var io = require('socket.io-client');

var SimplePeer = require('libp2p-webrtc-peer');

var pDefer = require('p-defer');

var toConnection = require('./socket-to-conn');

var _require = require('./utils'),
    cleanUrlSIO = _require.cleanUrlSIO;

var _require2 = require('./constants'),
    CODE_P2P = _require2.CODE_P2P;

var sioOptions = {
  transports: ['websocket'],
  'force new connection': true,
  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed

};

module.exports = function (_ref, WebRTCStar) {
  var handler = _ref.handler,
      upgrader = _ref.upgrader;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var listener = new EventEmitter();
  var listeningAddr;
  var signallingUrl;
  listener.__connections = [];
  listener.__spChannels = new Map();
  listener.__pendingIntents = new Map();

  listener.listen = function (ma) {
    // Should only be used if not already listening
    if (listeningAddr) {
      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');
    }

    var defer = pDefer(); // Should be kept unmodified

    listeningAddr = ma;
    var signallingAddr;

    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {
      signallingAddr = ma.encapsulate("/p2p/".concat(upgrader.localPeer.toB58String()));
    } else {
      signallingAddr = ma;
    }

    listener.on('error', function () {
      return defer.reject();
    });
    signallingUrl = cleanUrlSIO(ma);
    log('Dialing to Signalling Server on: ' + signallingUrl);
    listener.io = io.connect(signallingUrl, sioOptions);

    var incomingDial = function incomingDial(offer) {
      if (offer.answer || offer.err || !offer.intentId) {
        return;
      }

      var intentId = offer.intentId;

      var pendings = listener.__pendingIntents.get(intentId);

      if (!pendings) {
        pendings = [];

        listener.__pendingIntents.set(intentId, pendings);
      }

      var channel = listener.__spChannels.get(intentId);

      if (channel) {
        channel.signal(offer.signal);
        return;
      } else if (offer.signal.type !== 'offer') {
        pendings.push(offer);
        return;
      }

      var spOptions = _objectSpread({
        trickle: false
      }, options); // Use custom WebRTC implementation


      if (WebRTCStar.wrtc) {
        spOptions.wrtc = WebRTCStar.wrtc;
      }

      channel = new SimplePeer(spOptions);

      var onError = function onError(err) {
        log.error('incoming connection errored', err);
      };

      channel.on('error', onError);
      channel.once('close', function () {
        channel.removeListener('error', onError);
      });
      channel.on('signal', function (signal) {
        offer.signal = signal;
        offer.answer = true;
        listener.io.emit('ss-handshake', offer);
      });
      channel.signal(offer.signal);

      var _iterator = _createForOfIteratorHelper(pendings),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pendingOffer = _step.value;
          channel.signal(pendingOffer.signal);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      listener.__pendingIntents.set(intentId, []);

      channel.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var maConn, conn;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                maConn = toConnection(channel);
                log('new inbound connection %s', maConn.remoteAddr);
                _context.prev = 2;
                _context.next = 5;
                return upgrader.upgradeInbound(maConn);

              case 5:
                conn = _context.sent;
                _context.next = 12;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](2);
                log.error('inbound connection failed to upgrade', _context.t0);
                return _context.abrupt("return", maConn.close());

              case 12:
                if (!conn.remoteAddr) {
                  try {
                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate("/p2p/".concat(conn.remotePeer.toB58String()));
                  } catch (err) {
                    log.error('could not determine remote address', err);
                  }
                }

                log('inbound connection %s upgraded', maConn.remoteAddr);
                trackConn(listener, maConn, intentId);
                listener.emit('connection', conn);
                handler(conn);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 8]]);
      })));

      listener.__spChannels.set(intentId, channel);
    };

    listener.io.once('connect_error', function (err) {
      return defer.reject(err);
    });
    listener.io.once('error', function (err) {
      listener.emit('error', err);
      listener.emit('close');
    });
    listener.io.on('ws-handshake', incomingDial);
    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);
    listener.io.on('connect', function () {
      listener.io.emit('ss-join', signallingAddr.toString());
    });
    listener.io.once('connect', function () {
      listener.emit('listening');
      defer.resolve();
    }); // Store listen and signal reference addresses

    WebRTCStar.sigReferences.set(signallingUrl, {
      listener: listener,
      signallingAddr: signallingAddr
    });
    return defer.promise;
  };

  listener.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var ref;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // Close listener
            ref = WebRTCStar.sigReferences.get(signallingUrl);

            if (ref && ref.listener.io) {
              ref.listener.io.emit('ss-leave');
              ref.listener.io.close();
            }

            _context2.next = 4;
            return Promise.all(listener.__connections.map(function (maConn) {
              return maConn.close();
            }));

          case 4:
            listener.emit('close');
            listener.removeAllListeners(); // Reset state

            listeningAddr = undefined;
            WebRTCStar.sigReferences.delete(signallingUrl);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  listener.getAddrs = function () {
    return [listeningAddr];
  };

  return listener;
};

function trackConn(listener, maConn, intentId) {
  listener.__connections.push(maConn);

  var untrackConn = function untrackConn() {
    listener.__connections = listener.__connections.filter(function (c) {
      return c !== maConn;
    });

    listener.__spChannels.delete(intentId);

    listener.__pendingIntents.delete(intentId);
  };

  maConn.conn.once('close', untrackConn);
}
},{"events":"node_modules/events/events.js","debug":"node_modules/debug/src/browser.js","err-code":"node_modules/err-code/index.js","socket.io-client":"node_modules/socket.io-client/build/index.js","libp2p-webrtc-peer":"node_modules/libp2p-webrtc-peer/index.js","p-defer":"node_modules/p-defer/index.js","./socket-to-conn":"node_modules/libp2p-webrtc-star/src/socket-to-conn.js","./utils":"node_modules/libp2p-webrtc-star/src/utils.js","./constants":"node_modules/libp2p-webrtc-star/src/constants.js"}],"node_modules/libp2p-webrtc-star/src/index.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var debug = require('debug');

var log = debug('libp2p:webrtc-star');
log.error = debug('libp2p:webrtc-star:error');

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var errcode = require('err-code');

var withIs = require('class-is');

var _require2 = require('abortable-iterator'),
    AbortError = _require2.AbortError;

var SimplePeer = require('libp2p-webrtc-peer');

var _require3 = require('ipfs-utils/src/supports'),
    webrtcSupport = _require3.supportsWebRTCDataChannels;

var _require4 = require('multiaddr'),
    Multiaddr = _require4.Multiaddr;

var mafmt = require('mafmt');

var PeerId = require('peer-id');

var _require5 = require('./constants'),
    CODE_CIRCUIT = _require5.CODE_CIRCUIT;

var _createListener = require('./listener');

var toConnection = require('./socket-to-conn');

var _require6 = require('./utils'),
    cleanMultiaddr = _require6.cleanMultiaddr,
    cleanUrlSIO = _require6.cleanUrlSIO;

function noop() {}
/**
 * @class WebRTCStar
 */


var WebRTCStar = /*#__PURE__*/function () {
  /**
   * @class
   * @param {object} options
   * @param {Upgrader} options.upgrader
   */
  function WebRTCStar() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WebRTCStar);

    if (!options.upgrader) {
      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');
    }

    this._upgrader = options.upgrader;
    this.sioOptions = {
      transports: ['websocket'],
      'force new connection': true
    };

    if (options.wrtc) {
      this.wrtc = options.wrtc;
    } // Keep Signalling references


    this.sigReferences = new Map(); // Discovery

    this.discovery = new EventEmitter();
    this.discovery.tag = 'webRTCStar';
    this.discovery._isStarted = false;

    this.discovery.start = function () {
      _this.discovery._isStarted = true;
    };

    this.discovery.stop = function () {
      _this.discovery._isStarted = false;
    };

    this._peerDiscovered = this._peerDiscovered.bind(this);
  }
  /**
   * @async
   * @param {Multiaddr} ma
   * @param {object} options
   * @param {AbortSignal} options.signal - Used to abort dial requests
   * @returns {Connection} An upgraded Connection
   */


  _createClass(WebRTCStar, [{
    key: "dial",
    value: function () {
      var _dial = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ma) {
        var options,
            rawConn,
            maConn,
            conn,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this._connect(ma, options);

              case 3:
                rawConn = _context.sent;
                maConn = toConnection(rawConn, {
                  remoteAddr: ma,
                  signal: options.signal
                });
                log('new outbound connection %s', maConn.remoteAddr);
                _context.next = 8;
                return this._upgrader.upgradeOutbound(maConn);

              case 8:
                conn = _context.sent;
                log('outbound connection %s upgraded', maConn.remoteAddr);
                return _context.abrupt("return", conn);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function dial(_x) {
        return _dial.apply(this, arguments);
      }

      return dial;
    }()
    /**
     * @private
     * @param {Multiaddr} ma
     * @param {object} options
     * @param {AbortSignal} options.signal - Used to abort dial requests
     * @returns {Promise<SimplePeer>} Resolves a SimplePeer Webrtc channel
     */

  }, {
    key: "_connect",
    value: function _connect(ma) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.signal && options.signal.aborted) {
        throw new AbortError();
      }

      var spOptions = _objectSpread({
        initiator: true,
        trickle: false
      }, options.spOptions || {}); // Use custom WebRTC implementation


      if (this.wrtc) {
        spOptions.wrtc = this.wrtc;
      }

      var cOpts = ma.toOptions();
      var intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();
      return new Promise(function (resolve, reject) {
        var sio = _this2.sigReferences.get(cleanUrlSIO(ma));

        if (!sio || !sio.listener) {
          return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));
        }

        var sioClient = sio.listener.io;
        var start = Date.now();
        var connected;
        log('dialing %s:%s', cOpts.host, cOpts.port);
        var channel = new SimplePeer(spOptions);

        var onError = function onError(err) {
          if (!connected) {
            var msg = "connection error ".concat(cOpts.host, ":").concat(cOpts.port, ": ").concat(err.message);
            log.error(msg);
            done(err);
          }
        };

        var onTimeout = function onTimeout() {
          log('connnection timeout %s:%s', cOpts.host, cOpts.port);
          var err = errcode(new Error("connection timeout after ".concat(Date.now() - start, "ms")), 'ERR_CONNECT_TIMEOUT'); // Note: this will result in onError() being called

          channel.emit('error', err);
        };

        var onConnect = function onConnect() {
          connected = true;
          log('connection opened %s:%s', cOpts.host, cOpts.port);
          done(null);
        };

        var onAbort = function onAbort() {
          log.error('connection aborted %s:%s', cOpts.host, cOpts.port);
          channel.destroy();
          done(new AbortError());
        };

        var done = function done(err) {
          channel.removeListener('timeout', onTimeout);
          channel.removeListener('connect', onConnect);
          options.signal && options.signal.removeEventListener('abort', onAbort);
          err ? reject(err) : resolve(channel);
        };

        channel.on('error', onError);
        channel.once('timeout', onTimeout);
        channel.once('connect', onConnect);
        channel.on('close', function () {
          channel.removeListener('error', onError);
        });
        options.signal && options.signal.addEventListener('abort', onAbort);
        channel.on('signal', function (signal) {
          sioClient.emit('ss-handshake', {
            intentId: intentId,
            srcMultiaddr: sio.signallingAddr.toString(),
            dstMultiaddr: ma.toString(),
            signal: signal
          });
        }); // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we
        // are clueless as to why.

        sioClient.on('ws-handshake', function (offer) {
          if (offer.intentId === intentId && offer.err) {
            channel.destroy();
            reject(errcode(offer.err instanceof Error ? offer.err : new Error(offer.err), 'ERR_SIGNALLING_FAILED'));
          }

          if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {
            return;
          }

          channel.signal(offer.signal);
        });
      });
    }
    /**
     * Creates a WebrtcStar listener. The provided `handler` function will be called
     * anytime a new incoming Connection has been successfully upgraded via
     * `upgrader.upgradeInbound`.
     *
     * @param {object} [options] - simple-peer options for listener
     * @param {function (Connection)} handler
     * @returns {Listener} A WebrtcStar listener
     */

  }, {
    key: "createListener",
    value: function createListener() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var handler = arguments.length > 1 ? arguments[1] : undefined;

      if (!webrtcSupport && !this.wrtc) {
        throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');
      }

      if (typeof options === 'function') {
        handler = options;
        options = {};
      }

      handler = handler || noop;
      return _createListener({
        handler: handler,
        upgrader: this._upgrader
      }, this, options);
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid TCP addresses
     *
     * @param {Multiaddr[]} multiaddrs
     * @returns {Multiaddr[]} Valid TCP multiaddrs
     */

  }, {
    key: "filter",
    value: function filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter(function (ma) {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }

        return mafmt.WebRTCStar.matches(ma);
      });
    }
  }, {
    key: "_peerDiscovered",
    value: function _peerDiscovered(maStr) {
      if (!this.discovery._isStarted) return;
      log('Peer Discovered:', maStr);
      maStr = cleanMultiaddr(maStr);
      var ma = new Multiaddr(maStr);
      var peerId = PeerId.createFromB58String(ma.getPeerId());
      this.discovery.emit('peer', {
        id: peerId,
        multiaddrs: [ma]
      });
    }
  }]);

  return WebRTCStar;
}();

module.exports = withIs(WebRTCStar, {
  className: 'WebRTCStar',
  symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar'
});
},{"debug":"node_modules/debug/src/browser.js","events":"node_modules/events/events.js","err-code":"node_modules/err-code/index.js","class-is":"node_modules/class-is/index.js","abortable-iterator":"node_modules/abortable-iterator/index.js","libp2p-webrtc-peer":"node_modules/libp2p-webrtc-peer/index.js","ipfs-utils/src/supports":"node_modules/ipfs-utils/src/supports.js","multiaddr":"node_modules/multiaddr/src/index.js","mafmt":"node_modules/mafmt/src/index.js","peer-id":"node_modules/peer-id/src/index.js","./constants":"node_modules/libp2p-webrtc-star/src/constants.js","./listener":"node_modules/libp2p-webrtc-star/src/listener.js","./socket-to-conn":"node_modules/libp2p-webrtc-star/src/socket-to-conn.js","./utils":"node_modules/libp2p-webrtc-star/src/utils.js"}],"node_modules/@stablelib/random/lib/source/browser.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var QUOTA = 65536;
var BrowserRandomSource = /** @class */ (function () {
    function BrowserRandomSource() {
        this.isAvailable = false;
        this.isInstantiated = false;
        var browserCrypto = typeof self !== 'undefined'
            ? (self.crypto || self.msCrypto) // IE11 has msCrypto
            : null;
        if (browserCrypto && browserCrypto.getRandomValues) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    BrowserRandomSource.prototype.randomBytes = function (length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        var out = new Uint8Array(length);
        for (var i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    };
    return BrowserRandomSource;
}());
exports.BrowserRandomSource = BrowserRandomSource;

},{}],"node_modules/@stablelib/wipe/lib/wipe.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}
exports.wipe = wipe;

},{}],"node_modules/@stablelib/random/lib/source/node.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var wipe_1 = require("@stablelib/wipe");
var NodeRandomSource = /** @class */ (function () {
    function NodeRandomSource() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof require !== "undefined") {
            var nodeCrypto = require("crypto");
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    NodeRandomSource.prototype.randomBytes = function (length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        var buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        var out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for (var i = 0; i < out.length; i++) {
            out[i] = buffer[i];
        }
        // Cleanup.
        wipe_1.wipe(buffer);
        return out;
    };
    return NodeRandomSource;
}());
exports.NodeRandomSource = NodeRandomSource;

},{"@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js","crypto":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@stablelib/random/lib/source/system.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var browser_1 = require("./browser");
var node_1 = require("./node");
var SystemRandomSource = /** @class */ (function () {
    function SystemRandomSource() {
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
        // No sources, we're out of options.
    }
    SystemRandomSource.prototype.randomBytes = function (length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    };
    return SystemRandomSource;
}());
exports.SystemRandomSource = SystemRandomSource;

},{"./browser":"node_modules/@stablelib/random/lib/source/browser.js","./node":"node_modules/@stablelib/random/lib/source/node.js"}],"node_modules/@stablelib/int/lib/int.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package int provides helper functions for integerss.
 */
// Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
}
/** 32-bit integer multiplication.  */
// Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */
function add(a, b) {
    return (a + b) | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */
function sub(a, b) {
    return (a - b) | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */
function rotl(x, n) {
    return x << n | x >>> (32 - n);
}
exports.rotl = rotl;
/** 32-bit integer left rotation */
function rotr(x, n) {
    return x << (32 - n) | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */
exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */
exports.isSafeInteger = function (n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
};

},{}],"node_modules/@stablelib/binary/lib/binary.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
var int_1 = require("@stablelib/int");
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */
function readInt16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
}
exports.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
}
exports.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */
function readInt16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
}
exports.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 1] << 8) | array[offset]) >>> 0;
}
exports.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
exports.writeUint16BE = writeUint16BE;
exports.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
exports.writeUint16LE = writeUint16LE;
exports.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */
function readInt32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3];
}
exports.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
exports.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */
function readInt32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset];
}
exports.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset]) >>> 0;
}
exports.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
exports.writeUint32BE = writeUint32BE;
exports.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
exports.writeUint32LE = writeUint32LE;
exports.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64BE = writeUint64BE;
exports.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64LE = writeUint64LE;
exports.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintBE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintLE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
exports.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
exports.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
exports.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
exports.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
exports.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
exports.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
exports.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
exports.writeFloat64LE = writeFloat64LE;

},{"@stablelib/int":"node_modules/@stablelib/int/lib/int.js"}],"node_modules/@stablelib/random/lib/random.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var system_1 = require("./source/system");
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng) {
    if (prng === void 0) { prng = exports.defaultRandomSource; }
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */
function randomUint32(prng) {
    if (prng === void 0) { prng = exports.defaultRandomSource; }
    // Generate 4-byte random buffer.
    var buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    var result = binary_1.readUint32LE(buf);
    // Clean the buffer.
    wipe_1.wipe(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */
var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomString(length, charset, prng) {
    if (charset === void 0) { charset = ALPHANUMERIC; }
    if (prng === void 0) { prng = exports.defaultRandomSource; }
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    var out = '';
    var charsLen = charset.length;
    var maxByte = 256 - (256 % charsLen);
    while (length > 0) {
        var buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (var i = 0; i < buf.length && length > 0; i++) {
            var randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        wipe_1.wipe(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomStringForEntropy(bits, charset, prng) {
    if (charset === void 0) { charset = ALPHANUMERIC; }
    if (prng === void 0) { prng = exports.defaultRandomSource; }
    var length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy;

},{"./source/system":"node_modules/@stablelib/random/lib/source/system.js","@stablelib/binary":"node_modules/@stablelib/binary/lib/binary.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/@stablelib/x25519/lib/x25519.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package x25519 implements X25519 key agreement.
 */
var random_1 = require("@stablelib/random");
var wipe_1 = require("@stablelib/wipe");
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 32;
exports.SHARED_KEY_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    var r = new Float64Array(16);
    if (init) {
        for (var i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
var _9 = new Uint8Array(32);
_9[0] = 9;
var _121665 = gf([0xdb41, 1]);
function car25519(o) {
    var c = 1;
    for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    var c = ~(b - 1);
    for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    var m = gf();
    var t = gf();
    for (var i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (var i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        var b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    var c = gf();
    for (var i = 0; i < 16; i++) {
        c[i] = inp[i];
    }
    for (var i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for (var i = 0; i < 16; i++) {
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    var z = new Uint8Array(32);
    var x = new Float64Array(80);
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (var i = 0; i < 31; i++) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (var i = 0; i < 16; i++) {
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (var i = 254; i >= 0; --i) {
        var r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (var i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    var x32 = x.subarray(32);
    var x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    var q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
exports.scalarMult = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
exports.scalarMultBase = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error("x25519: seed must be " + exports.SECRET_KEY_LENGTH + " bytes");
    }
    var secretKey = new Uint8Array(seed);
    var publicKey = scalarMultBase(secretKey);
    return {
        publicKey: publicKey,
        secretKey: secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    var seed = random_1.randomBytes(32, prng);
    var result = generateKeyPairFromSeed(seed);
    wipe_1.wipe(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */
function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
    if (rejectZero === void 0) { rejectZero = false; }
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
    }
    var result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        var zeros = 0;
        for (var i = 0; i < result.length; i++) {
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.sharedKey = sharedKey;

},{"@stablelib/random":"node_modules/@stablelib/random/lib/random.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/is-buffer/index.js":[function(require,module,exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
module.exports = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
};
},{}],"node_modules/it-pb-rpc/src/index.js":[function(require,module,exports) {
'use strict'

const isBuffer = require('is-buffer')
const Shake = require('it-handshake')
const lp = require('it-length-prefixed')

module.exports = (duplex, opts = {}) => {
  const shake = Shake(duplex)
  const lpReader = lp.decode.fromReader(
      shake.reader,
      opts
  )

  let isDone = false

  const W = {
    read: async (bytes) => {
      // just read

      const { value, done } = await shake.reader.next(bytes)

      if (done && value.length < bytes) {
        throw new Error('Couldn\'t read enough bytes')
      }

      isDone = done

      if (!value) { throw new Error('Value is null') }
      return value
    },
    readLP: async () => {
      // read, decode
      const { value, done } = await lpReader.next()

      isDone = done

      if (!value) { throw new Error('Value is null') }
      return value
    },
    readPB: async (proto) => {
      // readLP, decode
      const value = await W.readLP()

      if (!value) { throw new Error('Value is null') }

      // Is this a buffer?
      const buf = isBuffer(value) ? value : value.slice()

      return proto.decode(buf)
    },
    write: (data) => {
      // just write
      shake.writer.push(data)
    },
    writeLP: (data) => {
      // encode, write
      W.write(lp.encode.single(data, opts))
    },
    writePB: (data, proto) => {
      // encode, writeLP
      W.writeLP(proto.encode(data))
    },

    pb: (proto) => {
      return {
        read: () => W.readPB(proto),
        write: (d) => W.writePB(d, proto)
      }
    },

    unwrap: () => {
      // returns vanilla duplex again, terminates all reads/writes from this object
      shake.rest()
      return shake.stream
    }
  }

  return W
}

},{"is-buffer":"node_modules/is-buffer/index.js","it-handshake":"node_modules/it-handshake/src/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js"}],"node_modules/it-pair/index.js":[function(require,module,exports) {
'use strict'

const getIterator = require('get-iterator')

// a pair of streams where one drains from the other
module.exports = function pair () {
  let _source, onSource

  const sink = async source => {
    if (_source) throw new Error('already piped')
    _source = getIterator(source)
    if (onSource) onSource(_source)
  }

  const source = {
    [Symbol.asyncIterator] () {
      return this
    },
    next () {
      if (_source) return _source.next()
      return new Promise(resolve => {
        onSource = source => {
          onSource = null
          resolve(source.next())
        }
      })
    }
  }

  return { sink, source }
}

},{"get-iterator":"node_modules/get-iterator/index.js"}],"node_modules/it-pair/duplex.js":[function(require,module,exports) {

var Pair = require('./')
module.exports = function () {
  var a = Pair()
  var b = Pair()
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ]
}

},{"./":"node_modules/it-pair/index.js"}],"node_modules/@stablelib/hash/lib/hash.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
function isSerializableHash(h) {
    return (typeof h.saveState !== "undefined" &&
        typeof h.restoreState !== "undefined" &&
        typeof h.cleanSavedState !== "undefined");
}
exports.isSerializableHash = isSerializableHash;
// TODO(dchest): figure out the standardized interface for XOF such as
// SHAKE and BLAKE2X.

},{}],"node_modules/@stablelib/constant-time/lib/constant-time.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */
/**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */
/**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */
function select(subject, resultIfOne, resultIfZero) {
    return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);
}
exports.select = select;
/**
 * Returns 1 if a <= b, or 0 if not.
 * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
 */
function lessOrEqual(a, b) {
    return (((a | 0) - (b | 0) - 1) >>> 31) & 1;
}
exports.lessOrEqual = lessOrEqual;
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */
function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return (1 & ((result - 1) >>> 8));
}
exports.compare = compare;
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */
function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}
exports.equal = equal;

},{}],"node_modules/@stablelib/hmac/lib/hmac.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package hmac implements HMAC algorithm.
 */
var hash_1 = require("@stablelib/hash");
var constant_time_1 = require("@stablelib/constant-time");
var wipe_1 = require("@stablelib/wipe");
/**
 *  HMAC implements hash-based message authentication algorithm.
 */
var HMAC = /** @class */ (function () {
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */
    function HMAC(hash, key) {
        this._finished = false; // true if HMAC was finalized
        // Initialize inner and outer hashes.
        this._inner = new hash();
        this._outer = new hash();
        // Set block and digest sizes for this HMAC
        // instance to values from the hash.
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        // Pad temporary stores a key (or its hash) padded with zeroes.
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            // If key is bigger than hash block size, it must be
            // hashed and this hash is used as a key instead.
            this._inner.update(key).finish(pad).clean();
        }
        else {
            // Otherwise, copy the key into pad.
            pad.set(key);
        }
        // Now two different keys are derived from padded key
        // by xoring a different byte value to each.
        // To make inner hash key, xor byte 0x36 into pad.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36;
        }
        // Update inner hash with the result.
        this._inner.update(pad);
        // To make outer hash key, xor byte 0x5c into pad.
        // But since we already xored 0x36 there, we must
        // first undo this by xoring it again.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36 ^ 0x5c;
        }
        // Update outer hash with the result.
        this._outer.update(pad);
        // Save states of both hashes, so that we can quickly restore
        // them later in reset() without the need to remember the actual
        // key and perform this initialization again.
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
        }
        // Clean pad.
        wipe_1.wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */
    HMAC.prototype.reset = function () {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        // Restore keyed states of inner and outer hashes.
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    /**
     * Cleans HMAC state.
     */
    HMAC.prototype.clean = function () {
        if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
    };
    /**
     * Updates state with provided data.
     */
    HMAC.prototype.update = function (data) {
        this._inner.update(data);
        return this;
    };
    /**
     * Finalizes HMAC and puts the result in out.
     */
    HMAC.prototype.finish = function (out) {
        if (this._finished) {
            // If HMAC was finalized, outer hash is also finalized,
            // so it produces the same digest it produced when it
            // was finalized.
            this._outer.finish(out);
            return this;
        }
        // Finalize inner hash and store the result temporarily.
        this._inner.finish(out);
        // Update outer hash with digest of inner hash and and finalize it.
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
    };
    /**
     * Returns the computed message authentication code.
     */
    HMAC.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */
    HMAC.prototype.saveState = function () {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
    };
    HMAC.prototype.restoreState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    HMAC.prototype.cleanSavedState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
    };
    return HMAC;
}());
exports.HMAC = HMAC;
/**
 * Returns HMAC using the given hash constructor for the key over data.
 */
function hmac(hash, key, data) {
    var h = new HMAC(hash, key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hmac = hmac;
/**
 * Returns true if two HMAC digests are equal.
 * Uses constant-time comparison to avoid leaking timing information.
 *
 * Example:
 *
 *    const receivedDigest = ...
 *    const realDigest = hmac(SHA256, key, data);
 *    if (!equal(receivedDigest, realDigest)) {
 *        throw new Error("Authentication error");
 *    }
 */
exports.equal = constant_time_1.equal;

},{"@stablelib/hash":"node_modules/@stablelib/hash/lib/hash.js","@stablelib/constant-time":"node_modules/@stablelib/constant-time/lib/constant-time.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/@stablelib/hkdf/lib/hkdf.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var hmac_1 = require("@stablelib/hmac");
var wipe_1 = require("@stablelib/wipe");
/**
 * HMAC-based Extract-and-Expand Key Derivation Function.
 *
 * Implements HKDF from RFC5869.
 *
 * Expands the given master key with salt and info into
 * a limited stream of key material.
 */
var HKDF = /** @class */ (function () {
    /**
     * Create a new HKDF instance for the given hash function
     * with the master key, optional salt, and info.
     *
     * - Master key is a high-entropy secret key (not a password).
     * - Salt is a non-secret random value.
     * - Info is application- and/or context-specific information.
     */
    function HKDF(hash, key, salt, info) {
        if (salt === void 0) { salt = new Uint8Array(0); }
        this._counter = new Uint8Array(1); // starts with zero
        this._hash = hash;
        this._info = info;
        // HKDF-Extract uses salt as HMAC key, and key as data.
        var okm = hmac_1.hmac(this._hash, salt, key);
        // Initialize HMAC for expanding with extracted key.
        this._hmac = new hmac_1.HMAC(hash, okm);
        // Allocate buffer.
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
    }
    // Fill buffer with new block of HKDF-Extract output.
    HKDF.prototype._fillBuffer = function () {
        // Increment counter.
        this._counter[0]++;
        var ctr = this._counter[0];
        // Check if counter overflowed.
        if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
        }
        // Prepare HMAC instance for new data with old key.
        this._hmac.reset();
        // Hash in previous output if it was generated
        // (i.e. counter is greater than 1).
        if (ctr > 1) {
            this._hmac.update(this._buffer);
        }
        // Hash in info if it exists.
        if (this._info) {
            this._hmac.update(this._info);
        }
        // Hash in the counter.
        this._hmac.update(this._counter);
        // Output result to buffer and clean HMAC instance.
        this._hmac.finish(this._buffer);
        // Reset buffer position.
        this._bufpos = 0;
    };
    /**
     * Expand returns next key material of the given length.
     *
     * It throws if expansion limit is reached (which is
     * 254 digests of the underlying HMAC function).
     */
    HKDF.prototype.expand = function (length) {
        var out = new Uint8Array(length);
        for (var i = 0; i < out.length; i++) {
            if (this._bufpos === this._buffer.length) {
                this._fillBuffer();
            }
            out[i] = this._buffer[this._bufpos++];
        }
        return out;
    };
    HKDF.prototype.clean = function () {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
    };
    return HKDF;
}());
exports.HKDF = HKDF;
// TODO(dchest): maybe implement deriveKey?

},{"@stablelib/hmac":"node_modules/@stablelib/hmac/lib/hmac.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/@stablelib/sha256/lib/sha256.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
exports.DIGEST_LENGTH = 32;
exports.BLOCK_SIZE = 64;
/**
 * SHA2-256 cryptographic hash algorithm.
 */
var SHA256 = /** @class */ (function () {
    function SHA256() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */
        this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._state = new Int32Array(8); // hash state
        this._temp = new Int32Array(64); // temporary state
        this._buffer = new Uint8Array(128); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA256.prototype._initState = function () {
        this._state[0] = 0x6a09e667;
        this._state[1] = 0xbb67ae85;
        this._state[2] = 0x3c6ef372;
        this._state[3] = 0xa54ff53a;
        this._state[4] = 0x510e527f;
        this._state[5] = 0x9b05688c;
        this._state[6] = 0x1f83d9ab;
        this._state[7] = 0x5be0cd19;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    SHA256.prototype.reset = function () {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */
    SHA256.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    SHA256.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    SHA256.prototype.finish = function (out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = (bytesHashed / 0x20000000) | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;
            this._buffer[left] = 0x80;
            for (var i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
            binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */
    SHA256.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Returns hash state to be used with restoreState().
     * Only chain value is saved, not buffers or other
     * state variables.
     */
    SHA256.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Restores state saved by saveState() and sets bytesHashed
     * to the given value.
     */
    SHA256.prototype.restoreState = function (savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */
    SHA256.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA256;
}());
exports.SHA256 = SHA256;
// Constants
var K = new Int32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
function hashBlocks(w, v, p, pos, len) {
    while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
            var j = pos + i * 4;
            w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
            var u = w[i - 2];
            var t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
            u = w[i - 15];
            var t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
            var t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
            var t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
            h = g;
            g = f;
            f = e;
            e = (d + t1) | 0;
            d = c;
            c = b;
            b = a;
            a = (t1 + t2) | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
function hash(data) {
    var h = new SHA256();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash;

},{"@stablelib/binary":"node_modules/@stablelib/binary/lib/binary.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/libp2p-noise/dist/src/proto/payload.js":[function(require,module,exports) {
var define;
"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function (global, factory) {
    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));
})(this, function ($protobuf) {
    "use strict";
    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    // Exported root namespace
    var $root = $protobuf.roots["libp2p-noise"] || ($protobuf.roots["libp2p-noise"] = {});
    $root.pb = (function () {
        /**
         * Namespace pb.
         * @exports pb
         * @namespace
         */
        var pb = {};
        pb.NoiseHandshakePayload = (function () {
            /**
             * Properties of a NoiseHandshakePayload.
             * @memberof pb
             * @interface INoiseHandshakePayload
             * @property {Uint8Array|null} [identityKey] NoiseHandshakePayload identityKey
             * @property {Uint8Array|null} [identitySig] NoiseHandshakePayload identitySig
             * @property {Uint8Array|null} [data] NoiseHandshakePayload data
             */
            /**
             * Constructs a new NoiseHandshakePayload.
             * @memberof pb
             * @classdesc Represents a NoiseHandshakePayload.
             * @implements INoiseHandshakePayload
             * @constructor
             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set
             */
            function NoiseHandshakePayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * NoiseHandshakePayload identityKey.
             * @member {Uint8Array} identityKey
             * @memberof pb.NoiseHandshakePayload
             * @instance
             */
            NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);
            /**
             * NoiseHandshakePayload identitySig.
             * @member {Uint8Array} identitySig
             * @memberof pb.NoiseHandshakePayload
             * @instance
             */
            NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);
            /**
             * NoiseHandshakePayload data.
             * @member {Uint8Array} data
             * @memberof pb.NoiseHandshakePayload
             * @instance
             */
            NoiseHandshakePayload.prototype.data = $util.newBuffer([]);
            /**
             * Creates a new NoiseHandshakePayload instance using the specified properties.
             * @function create
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set
             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload instance
             */
            NoiseHandshakePayload.create = function create(properties) {
                return new NoiseHandshakePayload(properties);
            };
            /**
             * Encodes the specified NoiseHandshakePayload message. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.
             * @function encode
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoiseHandshakePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.identityKey);
                if (message.identitySig != null && Object.hasOwnProperty.call(message, "identitySig"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.identitySig);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.data);
                return writer;
            };
            /**
             * Encodes the specified NoiseHandshakePayload message, length delimited. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a NoiseHandshakePayload message from the specified reader or buffer.
             * @function decode
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoiseHandshakePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.NoiseHandshakePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.identityKey = reader.bytes();
                            break;
                        case 2:
                            message.identitySig = reader.bytes();
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a NoiseHandshakePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a NoiseHandshakePayload message.
             * @function verify
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoiseHandshakePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                    if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                        return "identityKey: buffer expected";
                if (message.identitySig != null && message.hasOwnProperty("identitySig"))
                    if (!(message.identitySig && typeof message.identitySig.length === "number" || $util.isString(message.identitySig)))
                        return "identitySig: buffer expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
            /**
             * Creates a NoiseHandshakePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload
             */
            NoiseHandshakePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.pb.NoiseHandshakePayload)
                    return object;
                var message = new $root.pb.NoiseHandshakePayload();
                if (object.identityKey != null)
                    if (typeof object.identityKey === "string")
                        $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                    else if (object.identityKey.length)
                        message.identityKey = object.identityKey;
                if (object.identitySig != null)
                    if (typeof object.identitySig === "string")
                        $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);
                    else if (object.identitySig.length)
                        message.identitySig = object.identitySig;
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
            /**
             * Creates a plain object from a NoiseHandshakePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof pb.NoiseHandshakePayload
             * @static
             * @param {pb.NoiseHandshakePayload} message NoiseHandshakePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoiseHandshakePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.identityKey = "";
                    else {
                        object.identityKey = [];
                        if (options.bytes !== Array)
                            object.identityKey = $util.newBuffer(object.identityKey);
                    }
                    if (options.bytes === String)
                        object.identitySig = "";
                    else {
                        object.identitySig = [];
                        if (options.bytes !== Array)
                            object.identitySig = $util.newBuffer(object.identitySig);
                    }
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                    object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
                if (message.identitySig != null && message.hasOwnProperty("identitySig"))
                    object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
            /**
             * Converts this NoiseHandshakePayload to JSON.
             * @function toJSON
             * @memberof pb.NoiseHandshakePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoiseHandshakePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return NoiseHandshakePayload;
        })();
        return pb;
    })();
    return $root;
});

},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p-noise/dist/src/utils.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;
const hkdf_1 = require("@stablelib/hkdf");
const sha256_1 = require("@stablelib/sha256");
const x25519 = __importStar(require("@stablelib/x25519"));
const buffer_1 = require("buffer");
const peer_id_1 = __importDefault(require("peer-id"));
const libp2p_crypto_1 = require("libp2p-crypto");
const payload_1 = require("./proto/payload");
const equals_1 = __importDefault(require("uint8arrays/equals"));
const NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;
function generateKeypair() {
    const keypair = x25519.generateKeyPair();
    return {
        publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),
        privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)
    };
}
exports.generateKeypair = generateKeypair;
async function getPayload(localPeer, staticPublicKey, earlyData) {
    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
}
exports.getPayload = getPayload;
function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
    const payloadInit = NoiseHandshakePayloadProto.create({
        identityKey: buffer_1.Buffer.from(libp2pPublicKey),
        identitySig: signedPayload,
        data: earlyData !== null && earlyData !== void 0 ? earlyData : null
    });
    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());
}
exports.createHandshakePayload = createHandshakePayload;
async function signPayload(peerId, payload) {
    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));
}
exports.signPayload = signPayload;
async function getPeerIdFromPayload(payload) {
    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));
}
exports.getPeerIdFromPayload = getPeerIdFromPayload;
function decodePayload(payload) {
    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));
}
exports.decodePayload = decodePayload;
function getHandshakePayload(publicKey) {
    return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);
}
exports.getHandshakePayload = getHandshakePayload;
async function isValidPeerId(peerId, publicKeyProtobuf) {
    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);
    return equals_1.default(generatedPeerId.id, peerId);
}
/**
 * Verifies signed payload, throws on any irregularities.
 *
 * @param {bytes} noiseStaticKey - owner's noise static key
 * @param {bytes} payload - decoded payload
 * @param {PeerId} remotePeer - owner's libp2p peer ID
 * @returns {Promise<PeerId>} - peer ID of payload owner
 */
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
    const identityKey = buffer_1.Buffer.from(payload.identityKey);
    if (!(await isValidPeerId(remotePeer.id, identityKey))) {
        throw new Error("Peer ID doesn't match libp2p public key.");
    }
    const generatedPayload = getHandshakePayload(noiseStaticKey);
    // Unmarshaling from PublicKey protobuf
    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);
    // TODO remove this after libp2p-crypto ships proper types
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {
        throw new Error("Static key doesn't match to peer that signed payload!");
    }
    return await peer_id_1.default.createFromPubKey(identityKey);
}
exports.verifySignedPayload = verifySignedPayload;
function getHkdf(ck, ikm) {
    const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);
    const okmU8Array = hkdf.expand(96);
    const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);
    const k1 = okm.slice(0, 32);
    const k2 = okm.slice(32, 64);
    const k3 = okm.slice(64, 96);
    return [k1, k2, k3];
}
exports.getHkdf = getHkdf;
function isValidPublicKey(pk) {
    if (!buffer_1.Buffer.isBuffer(pk)) {
        return false;
    }
    if (pk.length !== 32) {
        return false;
    }
    return true;
}
exports.isValidPublicKey = isValidPublicKey;

},{"@stablelib/hkdf":"node_modules/@stablelib/hkdf/lib/hkdf.js","@stablelib/sha256":"node_modules/@stablelib/sha256/lib/sha256.js","@stablelib/x25519":"node_modules/@stablelib/x25519/lib/x25519.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","peer-id":"node_modules/peer-id/src/index.js","libp2p-crypto":"node_modules/libp2p-crypto/src/index.js","./proto/payload":"node_modules/libp2p-noise/dist/src/proto/payload.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js"}],"node_modules/@stablelib/chacha/lib/chacha.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package chacha implements ChaCha stream cipher.
 */
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
// Number of ChaCha rounds (ChaCha20).
var ROUNDS = 20;
// Applies the ChaCha core function to 16-byte input,
// 32-byte key key, and puts the result into 64-byte array out.
function core(out, input, key) {
    var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
    var j1 = 0x3320646E; // "nd 3"     for 32-byte keys
    var j2 = 0x79622D32; // "2-by"
    var j3 = 0x6B206574; // "te k"
    var j4 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    var j5 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    var j6 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    var j7 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    var j8 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    var j9 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    var j10 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    var j11 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    var j12 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
    var j13 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
    var j14 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
    var j15 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 7) | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 7) | x5 << 7;
    }
    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
 * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
 * write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
 * same key and nonce, otherwise the stream will repeat. The function will
 * throw error if counter overflows to prevent this.
 *
 * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
 * is more than a million petabytes). However, it is not recommended to
 * generate 8-byte nonces randomly, as the chance of collision is high.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each ChaCha block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
    }
    var nc;
    var counterLength;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        // First counterLength bytes of nc are counter, starting with zero.
        counterLength = nc.length - nonce.length;
        // Last bytes of nc after counterLength are nonce, set them.
        nc.set(nonce, counterLength);
    }
    else {
        if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
    }
    // Allocate temporary space for ChaCha block.
    var block = new Uint8Array(64);
    for (var i = 0; i < src.length; i += 64) {
        // Generate a block.
        core(block, nc, key);
        // XOR block bytes with src into dst.
        for (var j = i; j < i + 64 && j < src.length; j++) {
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, 0, counterLength);
    }
    // Cleanup temporary space.
    wipe_1.wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe_1.wipe(nc);
    }
    return dst;
}
exports.streamXOR = streamXOR;
/**
 * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
 * nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
 * the nonce as described in the streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    wipe_1.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
exports.stream = stream;
function incrementCounter(counter, pos, len) {
    var carry = 1;
    while (len--) {
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
    }
}

},{"@stablelib/binary":"node_modules/@stablelib/binary/lib/binary.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/@stablelib/poly1305/lib/poly1305.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */
var constant_time_1 = require("@stablelib/constant-time");
var wipe_1 = require("@stablelib/wipe");
exports.DIGEST_LENGTH = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */
var Poly1305 = /** @class */ (function () {
    function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = (t0) & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this._r[9] = ((t7 >>> 5)) & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    Poly1305.prototype._blocks = function (m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += (t0) & 0x1fff;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
            h5 += ((t4 >>> 1)) & 0x1fff;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
            h9 += ((t7 >>> 5)) | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = (d0 >>> 13);
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += (d0 >>> 13);
            d0 &= 0x1fff;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = (d1 >>> 13);
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += (d1 >>> 13);
            d1 &= 0x1fff;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = (d2 >>> 13);
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += (d2 >>> 13);
            d2 &= 0x1fff;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = (d3 >>> 13);
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += (d3 >>> 13);
            d3 &= 0x1fff;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = (d4 >>> 13);
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += (d4 >>> 13);
            d4 &= 0x1fff;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = (d5 >>> 13);
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += (d5 >>> 13);
            d5 &= 0x1fff;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = (d6 >>> 13);
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += (d6 >>> 13);
            d6 &= 0x1fff;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = (d7 >>> 13);
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += (d7 >>> 13);
            d7 &= 0x1fff;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = (d8 >>> 13);
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += (d8 >>> 13);
            d8 &= 0x1fff;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = (d9 >>> 13);
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += (d9 >>> 13);
            d9 &= 0x1fff;
            c = (((c << 2) + c)) | 0;
            c = (c + d0) | 0;
            d0 = c & 0x1fff;
            c = (c >>> 13);
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    };
    Poly1305.prototype.finish = function (mac, macpos) {
        if (macpos === void 0) { macpos = 0; }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += (c * 5);
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= (1 << 13);
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
            g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
            this._h[i] = (this._h[i] & mask) | g[i];
        }
        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for (i = 1; i < 8; i++) {
            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    };
    Poly1305.prototype.update = function (m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
            want = (16 - this._leftover);
            if (want > bytes) {
                want = bytes;
            }
            for (var i = 0; i < want; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - (bytes % 16);
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for (var i = 0; i < bytes; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    };
    Poly1305.prototype.digest = function () {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    };
    Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    };
    return Poly1305;
}());
exports.Poly1305 = Poly1305;
/**
 * Returns 16-byte authenticator of data using a one-time 32-byte key.
 *
 * Important: key should be used for only one message, it should never repeat.
 */
function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.oneTimeAuth = oneTimeAuth;
/**
 * Returns true if two authenticators are 16-byte long and equal.
 * Uses contant-time comparison to avoid leaking timing information.
 */
function equal(a, b) {
    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
    }
    return constant_time_1.equal(a, b);
}
exports.equal = equal;

},{"@stablelib/constant-time":"node_modules/@stablelib/constant-time/lib/constant-time.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js"}],"node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js":[function(require,module,exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var chacha_1 = require("@stablelib/chacha");
var poly1305_1 = require("@stablelib/poly1305");
var wipe_1 = require("@stablelib/wipe");
var binary_1 = require("@stablelib/binary");
var constant_time_1 = require("@stablelib/constant-time");
exports.KEY_LENGTH = 32;
exports.NONCE_LENGTH = 12;
exports.TAG_LENGTH = 16;
var ZEROS = new Uint8Array(16);
/**
 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
 *
 * Defined in RFC7539.
 */
var ChaCha20Poly1305 = /** @class */ (function () {
    /**
     * Creates a new instance with the given 32-byte key.
     */
    function ChaCha20Poly1305(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        // Copy key.
        this._key = new Uint8Array(key);
    }
    /**
     * Encrypts and authenticates plaintext, authenticates associated data,
     * and returns sealed ciphertext, which includes authentication tag.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If dst is given (it must be the size of plaintext + the size of tag
     * length) the result will be put into it. Dst and plaintext must not
     * overlap.
     */
    ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Allocate space for sealed ciphertext.
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Encrypt plaintext.
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    /**
     * Authenticates sealed ciphertext (which includes authentication tag) and
     * associated data, decrypts ciphertext and returns decrypted plaintext.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If authentication fails, it returns null.
     *
     * If dst is given (it must be of ciphertext length minus tag length),
     * the result will be put into it. Dst and plaintext must not overlap.
     */
    ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Sealed ciphertext should at least contain tag.
        if (sealed.length < this.tagLength) {
            // TODO(dchest): should we throw here instead?
            return null;
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        // Constant-time compare tags and return null if they differ.
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
        }
        // Allocate space for decrypted plaintext.
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Decrypt.
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    ChaCha20Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._key);
        return this;
    };
    ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        var h = new poly1305_1.Poly1305(authKey);
        // Authenticate padded associated data.
        if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
                h.update(ZEROS.subarray(associatedData.length % 16));
            }
        }
        // Authenticate padded ciphertext.
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        // Authenticate length of associated data.
        // XXX: can avoid allocation here?
        var length = new Uint8Array(8);
        if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length);
        }
        h.update(length);
        // Authenticate length of ciphertext.
        binary_1.writeUint64LE(ciphertext.length, length);
        h.update(length);
        // Get tag and copy it into tagOut.
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
            tagOut[i] = tag[i];
        }
        // Cleanup.
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length);
    };
    return ChaCha20Poly1305;
}());
exports.ChaCha20Poly1305 = ChaCha20Poly1305;

},{"@stablelib/chacha":"node_modules/@stablelib/chacha/lib/chacha.js","@stablelib/poly1305":"node_modules/@stablelib/poly1305/lib/poly1305.js","@stablelib/wipe":"node_modules/@stablelib/wipe/lib/wipe.js","@stablelib/binary":"node_modules/@stablelib/binary/lib/binary.js","@stablelib/constant-time":"node_modules/@stablelib/constant-time/lib/constant-time.js"}],"node_modules/libp2p-noise/dist/src/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DUMP_SESSION_KEYS = exports.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
exports.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
exports.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports.NOISE_MSG_MAX_LENGTH_BYTES - 16;
exports.DUMP_SESSION_KEYS = undefined;
},{}],"node_modules/libp2p-noise/dist/src/logger.js":[function(require,module,exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logCipherState = exports.logRemoteEphemeralKey = exports.logRemoteStaticKey = exports.logLocalEphemeralKeys = exports.logLocalStaticKeys = exports.logger = void 0;
const debug_1 = __importDefault(require("debug"));
const constants_1 = require("./constants");
exports.logger = debug_1.default('libp2p:noise');
let keyLogger;
if (constants_1.DUMP_SESSION_KEYS) {
    keyLogger = exports.logger;
}
else {
    keyLogger = () => { };
}
function logLocalStaticKeys(s) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`);
}
exports.logLocalStaticKeys = logLocalStaticKeys;
function logLocalEphemeralKeys(e) {
    if (e) {
        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`);
        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`);
    }
    else {
        keyLogger('Missing local ephemeral keys.');
    }
}
exports.logLocalEphemeralKeys = logLocalEphemeralKeys;
function logRemoteStaticKey(rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`);
}
exports.logRemoteStaticKey = logRemoteStaticKey;
function logRemoteEphemeralKey(re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`);
}
exports.logRemoteEphemeralKey = logRemoteEphemeralKey;
function logCipherState(session) {
    if (session.cs1 && session.cs2) {
        keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`);
        keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`);
    }
    else {
        keyLogger('Missing cipher state.');
    }
}
exports.logCipherState = logCipherState;

},{"debug":"node_modules/debug/src/browser.js","./constants":"node_modules/libp2p-noise/dist/src/constants.js"}],"node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractHandshake = exports.MIN_NONCE = void 0;
const buffer_1 = require("buffer");
const x25519 = __importStar(require("@stablelib/x25519"));
const SHA256 = __importStar(require("@stablelib/sha256"));
const chacha20poly1305_1 = require("@stablelib/chacha20poly1305");
const utils_1 = require("../utils");
const logger_1 = require("../logger");
exports.MIN_NONCE = 0;
class AbstractHandshake {
    encryptWithAd(cs, ad, plaintext) {
        const e = this.encrypt(cs.k, cs.n, ad, plaintext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return e;
    }
    decryptWithAd(cs, ad, ciphertext) {
        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return { plaintext, valid };
    }
    // Cipher state related
    hasKey(cs) {
        return !this.isEmptyKey(cs.k);
    }
    setNonce(cs, nonce) {
        cs.n = nonce;
    }
    createEmptyKey() {
        return buffer_1.Buffer.alloc(32);
    }
    isEmptyKey(k) {
        const emptyKey = this.createEmptyKey();
        return emptyKey.equals(k);
    }
    incrementNonce(n) {
        return n + 1;
    }
    nonceToBytes(n) {
        const nonce = buffer_1.Buffer.alloc(12);
        nonce.writeUInt32LE(n, 4);
        return nonce;
    }
    encrypt(k, n, ad, plaintext) {
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        const encryptedMessage = ctx.seal(nonce, plaintext, ad);
        return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);
    }
    encryptAndHash(ss, plaintext) {
        let ciphertext;
        if (this.hasKey(ss.cs)) {
            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
        }
        else {
            ciphertext = plaintext;
        }
        this.mixHash(ss, ciphertext);
        return ciphertext;
    }
    decrypt(k, n, ad, ciphertext) {
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        const encryptedMessage = ctx.open(nonce, ciphertext, ad);
        if (encryptedMessage) {
            return {
                plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),
                valid: true
            };
        }
        else {
            return {
                plaintext: buffer_1.Buffer.from(''),
                valid: false
            };
        }
    }
    decryptAndHash(ss, ciphertext) {
        let plaintext;
        let valid = true;
        if (this.hasKey(ss.cs)) {
            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
        }
        else {
            plaintext = ciphertext;
        }
        this.mixHash(ss, ciphertext);
        return { plaintext, valid };
    }
    dh(privateKey, publicKey) {
        try {
            const derivedU8 = x25519.sharedKey(privateKey, publicKey);
            const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);
            const result = buffer_1.Buffer.alloc(32);
            derived.copy(result);
            return result;
        }
        catch (e) {
            logger_1.logger(e.message);
            return buffer_1.Buffer.alloc(32);
        }
    }
    mixHash(ss, data) {
        ss.h = this.getHash(ss.h, data);
    }
    getHash(a, b) {
        const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));
        return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);
    }
    mixKey(ss, ikm) {
        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);
        ss.cs = this.initializeKey(tempK);
        ss.ck = ck;
    }
    initializeKey(k) {
        const n = exports.MIN_NONCE;
        return { k, n };
    }
    // Symmetric state related
    initializeSymmetric(protocolName) {
        const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');
        const h = this.hashProtocolName(protocolNameBytes);
        const ck = h;
        const key = this.createEmptyKey();
        const cs = this.initializeKey(key);
        return { cs, ck, h };
    }
    hashProtocolName(protocolName) {
        if (protocolName.length <= 32) {
            const h = buffer_1.Buffer.alloc(32);
            protocolName.copy(h);
            return h;
        }
        else {
            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));
        }
    }
    split(ss) {
        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));
        const cs1 = this.initializeKey(tempk1);
        const cs2 = this.initializeKey(tempk2);
        return { cs1, cs2 };
    }
    writeMessageRegular(cs, payload) {
        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);
        const ne = this.createEmptyKey();
        const ns = buffer_1.Buffer.alloc(0);
        return { ne, ns, ciphertext };
    }
    readMessageRegular(cs, message) {
        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);
    }
}
exports.AbstractHandshake = AbstractHandshake;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","@stablelib/x25519":"node_modules/@stablelib/x25519/lib/x25519.js","@stablelib/sha256":"node_modules/@stablelib/sha256/lib/sha256.js","@stablelib/chacha20poly1305":"node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js","../utils":"node_modules/libp2p-noise/dist/src/utils.js","../logger":"node_modules/libp2p-noise/dist/src/logger.js"}],"node_modules/libp2p-noise/dist/src/handshakes/xx.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XX = void 0;
const buffer_1 = require("buffer");
const utils_1 = require("../utils");
const abstract_handshake_1 = require("./abstract-handshake");
class XX extends abstract_handshake_1.AbstractHandshake {
    initializeInitiator(prologue, s, rs, psk) {
        const name = 'Noise_XX_25519_ChaChaPoly_SHA256';
        const ss = this.initializeSymmetric(name);
        this.mixHash(ss, prologue);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, psk, re };
    }
    initializeResponder(prologue, s, rs, psk) {
        const name = 'Noise_XX_25519_ChaChaPoly_SHA256';
        const ss = this.initializeSymmetric(name);
        this.mixHash(ss, prologue);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, psk, re };
    }
    writeMessageA(hs, payload, e) {
        const ns = buffer_1.Buffer.alloc(0);
        if (e !== undefined) {
            hs.e = e;
        }
        else {
            hs.e = utils_1.generateKeypair();
        }
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
    }
    writeMessageB(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
    }
    writeMessageC(hs, payload) {
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ne = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, messageBuffer, cs1, cs2 };
    }
    readMessageA(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        return this.decryptAndHash(hs.ss, message.ciphertext);
    }
    readMessageB(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
            throw new Error('Handshake state `e` param is missing.');
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: (valid1 && valid2) };
    }
    readMessageC(hs, message) {
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
        }
        if (!hs.e) {
            throw new Error('Handshake state `e` param is missing.');
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, plaintext, valid: (valid1 && valid2), cs1, cs2 };
    }
    initSession(initiator, prologue, s) {
        const psk = this.createEmptyKey();
        const rs = buffer_1.Buffer.alloc(32); // no static key yet
        let hs;
        if (initiator) {
            hs = this.initializeInitiator(prologue, s, rs, psk);
        }
        else {
            hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
            hs,
            i: initiator,
            mc: 0
        };
    }
    sendMessage(session, message, ephemeral) {
        let messageBuffer;
        if (session.mc === 0) {
            messageBuffer = this.writeMessageA(session.hs, message, ephemeral);
        }
        else if (session.mc === 1) {
            messageBuffer = this.writeMessageB(session.hs, message);
        }
        else if (session.mc === 2) {
            const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);
            messageBuffer = resultingBuffer;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
        }
        else if (session.mc > 2) {
            if (session.i) {
                if (!session.cs1) {
                    throw new Error('CS1 (cipher state) is not defined');
                }
                messageBuffer = this.writeMessageRegular(session.cs1, message);
            }
            else {
                if (!session.cs2) {
                    throw new Error('CS2 (cipher state) is not defined');
                }
                messageBuffer = this.writeMessageRegular(session.cs2, message);
            }
        }
        else {
            throw new Error('Session invalid.');
        }
        session.mc++;
        return messageBuffer;
    }
    recvMessage(session, message) {
        let plaintext = buffer_1.Buffer.alloc(0);
        let valid = false;
        if (session.mc === 0) {
            ({ plaintext, valid } = this.readMessageA(session.hs, message));
        }
        else if (session.mc === 1) {
            ({ plaintext, valid } = this.readMessageB(session.hs, message));
        }
        else if (session.mc === 2) {
            const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);
            plaintext = resultingPlaintext;
            valid = resultingValid;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
    }
}
exports.XX = XX;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","../utils":"node_modules/libp2p-noise/dist/src/utils.js","./abstract-handshake":"node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js"}],"node_modules/libp2p-noise/dist/src/encoder.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;
const buffer_1 = require("buffer");
const uint16BEEncode = (value, target, offset) => {
    target = target || buffer_1.Buffer.allocUnsafe(2);
    target.writeUInt16BE(value, offset);
    return target;
};
exports.uint16BEEncode = uint16BEEncode;
exports.uint16BEEncode.bytes = 2;
const uint16BEDecode = (data) => {
    if (data.length < 2)
        throw RangeError('Could not decode int16BE');
    return data.readUInt16BE(0);
};
exports.uint16BEDecode = uint16BEDecode;
exports.uint16BEDecode.bytes = 2;
// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)
function encode0(message) {
    return buffer_1.Buffer.concat([message.ne, message.ciphertext]);
}
exports.encode0 = encode0;
function encode1(message) {
    return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);
}
exports.encode1 = encode1;
function encode2(message) {
    return buffer_1.Buffer.concat([message.ns, message.ciphertext]);
}
exports.encode2 = encode2;
function decode0(input) {
    if (input.length < 32) {
        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');
    }
    return {
        ne: input.slice(0, 32),
        ciphertext: input.slice(32, input.length),
        ns: buffer_1.Buffer.alloc(0)
    };
}
exports.decode0 = decode0;
function decode1(input) {
    if (input.length < 80) {
        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');
    }
    return {
        ne: input.slice(0, 32),
        ns: input.slice(32, 80),
        ciphertext: input.slice(80, input.length)
    };
}
exports.decode1 = decode1;
function decode2(input) {
    if (input.length < 48) {
        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');
    }
    return {
        ne: buffer_1.Buffer.alloc(0),
        ns: input.slice(0, 48),
        ciphertext: input.slice(48, input.length)
    };
}
exports.decode2 = decode2;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/libp2p-noise/dist/src/handshake-xx.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XXHandshake = void 0;
const buffer_1 = require("buffer");
const xx_1 = require("./handshakes/xx");
const utils_1 = require("./utils");
const logger_1 = require("./logger");
const encoder_1 = require("./encoder");
class XXHandshake {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = payload;
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
            this.remotePeer = remotePeer;
        }
        this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();
        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
        this.remoteEarlyData = buffer_1.Buffer.alloc(0);
    }
    // stage 0
    async propose() {
        logger_1.logLocalStaticKeys(this.session.hs.s);
        if (this.isInitiator) {
            logger_1.logger('Stage 0 - Initiator starting to send first message.');
            const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));
            this.connection.writeLP(encoder_1.encode0(messageBuffer));
            logger_1.logger('Stage 0 - Initiator finished sending first message.');
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
        else {
            logger_1.logger('Stage 0 - Responder waiting to receive first message...');
            const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());
            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
                throw new Error('xx handshake stage 0 validation fail');
            }
            logger_1.logger('Stage 0 - Responder received first message.');
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
        }
    }
    // stage 1
    async exchange() {
        if (this.isInitiator) {
            logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');
            const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
                throw new Error('xx handshake stage 1 validation fail');
            }
            logger_1.logger('Stage 1 - Initiator received the message.');
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
            logger_1.logRemoteStaticKey(this.session.hs.rs);
            logger_1.logger("Initiator going to check remote's signature...");
            try {
                const decodedPayload = await utils_1.decodePayload(plaintext);
                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
                this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);
                this.setRemoteEarlyData(decodedPayload.data);
            }
            catch (e) {
                const err = e;
                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
            }
            logger_1.logger('All good with the signature!');
        }
        else {
            logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');
            const messageBuffer = this.xx.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode1(messageBuffer));
            logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
    }
    // stage 2
    async finish() {
        if (this.isInitiator) {
            logger_1.logger('Stage 2 - Initiator sending third handshake message.');
            const messageBuffer = this.xx.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode2(messageBuffer));
            logger_1.logger('Stage 2 - Initiator sent message with signed payload.');
        }
        else {
            logger_1.logger('Stage 2 - Responder waiting for third handshake message...');
            const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
                throw new Error('xx handshake stage 2 validation fail');
            }
            logger_1.logger('Stage 2 - Responder received the message, finished handshake.');
            try {
                const decodedPayload = await utils_1.decodePayload(plaintext);
                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
                this.setRemoteEarlyData(decodedPayload.data);
            }
            catch (e) {
                const err = e;
                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
            }
        }
        logger_1.logCipherState(this.session);
    }
    encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
    }
    decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
    }
    getRemoteStaticKey() {
        return this.session.hs.rs;
    }
    getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
            throw new Error('Handshake not completed properly, cipher state does not exist.');
        }
        if (this.isInitiator) {
            return encryption ? session.cs1 : session.cs2;
        }
        else {
            return encryption ? session.cs2 : session.cs1;
        }
    }
    setRemoteEarlyData(data) {
        if (data) {
            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
        }
    }
}
exports.XXHandshake = XXHandshake;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","./handshakes/xx":"node_modules/libp2p-noise/dist/src/handshakes/xx.js","./utils":"node_modules/libp2p-noise/dist/src/utils.js","./logger":"node_modules/libp2p-noise/dist/src/logger.js","./encoder":"node_modules/libp2p-noise/dist/src/encoder.js"}],"node_modules/libp2p-noise/dist/src/handshakes/ik.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IK = void 0;
const buffer_1 = require("buffer");
const utils_1 = require("../utils");
const abstract_handshake_1 = require("./abstract-handshake");
class IK extends abstract_handshake_1.AbstractHandshake {
    initSession(initiator, prologue, s, rs) {
        const psk = this.createEmptyKey();
        let hs;
        if (initiator) {
            hs = this.initializeInitiator(prologue, s, rs, psk);
        }
        else {
            hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
            hs,
            i: initiator,
            mc: 0
        };
    }
    sendMessage(session, message) {
        let messageBuffer;
        if (session.mc === 0) {
            messageBuffer = this.writeMessageA(session.hs, message);
        }
        else if (session.mc === 1) {
            const { messageBuffer: mb, h, cs1, cs2 } = this.writeMessageB(session.hs, message);
            messageBuffer = mb;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
        }
        else if (session.mc > 1) {
            if (session.i) {
                if (!session.cs1) {
                    throw new Error('CS1 (cipher state) is not defined');
                }
                messageBuffer = this.writeMessageRegular(session.cs1, message);
            }
            else {
                if (!session.cs2) {
                    throw new Error('CS2 (cipher state) is not defined');
                }
                messageBuffer = this.writeMessageRegular(session.cs2, message);
            }
        }
        else {
            throw new Error('Session invalid.');
        }
        session.mc++;
        return messageBuffer;
    }
    recvMessage(session, message) {
        let plaintext = buffer_1.Buffer.alloc(0);
        let valid = false;
        if (session.mc === 0) {
            ({ plaintext, valid } = this.readMessageA(session.hs, message));
        }
        if (session.mc === 1) {
            const { plaintext: pt, valid: v, h, cs1, cs2 } = this.readMessageB(session.hs, message);
            plaintext = pt;
            valid = v;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
    }
    writeMessageA(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
    }
    writeMessageB(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ns = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { messageBuffer, cs1, cs2, h: hs.ss.h };
    }
    readMessageA(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: (valid1 && valid2) };
    }
    readMessageB(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
            throw new Error('Handshake state should contain ephemeral key by now.');
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext, valid } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, valid, plaintext, cs1, cs2 };
    }
    initializeInitiator(prologue, s, rs, psk) {
        const name = 'Noise_IK_25519_ChaChaPoly_SHA256';
        const ss = this.initializeSymmetric(name);
        this.mixHash(ss, prologue);
        this.mixHash(ss, rs);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, re, psk };
    }
    initializeResponder(prologue, s, rs, psk) {
        const name = 'Noise_IK_25519_ChaChaPoly_SHA256';
        const ss = this.initializeSymmetric(name);
        this.mixHash(ss, prologue);
        this.mixHash(ss, s.publicKey);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, re, psk };
    }
}
exports.IK = IK;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","../utils":"node_modules/libp2p-noise/dist/src/utils.js","./abstract-handshake":"node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js"}],"node_modules/libp2p-noise/dist/src/errors.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailedIKError = void 0;
class FailedIKError extends Error {
    constructor(initialMsg, message) {
        super(message);
        this.initialMsg = initialMsg;
        this.name = 'FailedIKhandshake';
    }
}
exports.FailedIKError = FailedIKError;

},{}],"node_modules/libp2p-noise/dist/src/handshake-ik.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IKHandshake = void 0;
const ik_1 = require("./handshakes/ik");
const buffer_1 = require("buffer");
const encoder_1 = require("./encoder");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
class IKHandshake {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = buffer_1.Buffer.from(payload);
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
            this.remotePeer = remotePeer;
        }
        this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();
        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
        this.remoteEarlyData = buffer_1.Buffer.alloc(0);
    }
    async stage0() {
        logger_1.logLocalStaticKeys(this.session.hs.s);
        logger_1.logRemoteStaticKey(this.session.hs.rs);
        if (this.isInitiator) {
            logger_1.logger('IK Stage 0 - Initiator sending message...');
            const messageBuffer = this.ik.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode1(messageBuffer));
            logger_1.logger('IK Stage 0 - Initiator sent message.');
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
        else {
            logger_1.logger('IK Stage 0 - Responder receiving message...');
            const receivedMsg = await this.connection.readLP();
            try {
                const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());
                const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
                if (!valid) {
                    throw new Error('ik handshake stage 0 decryption validation fail');
                }
                logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');
                const decodedPayload = await utils_1.decodePayload(plaintext);
                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
                this.setRemoteEarlyData(decodedPayload.data);
                logger_1.logger('IK Stage 0 - Responder successfully verified payload!');
                logger_1.logRemoteEphemeralKey(this.session.hs.re);
            }
            catch (e) {
                const err = e;
                logger_1.logger('Responder breaking up with IK handshake in stage 0.');
                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);
            }
        }
    }
    async stage1() {
        if (this.isInitiator) {
            logger_1.logger('IK Stage 1 - Initiator receiving message...');
            const receivedMsg = (await this.connection.readLP()).slice();
            const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));
            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
            logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');
            try {
                if (!valid) {
                    throw new Error('ik stage 1 decryption validation fail');
                }
                const decodedPayload = await utils_1.decodePayload(plaintext);
                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
                await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
                this.setRemoteEarlyData(decodedPayload.data);
                logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');
                logger_1.logRemoteEphemeralKey(this.session.hs.re);
            }
            catch (e) {
                const err = e;
                logger_1.logger('Initiator breaking up with IK handshake in stage 1.');
                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);
            }
        }
        else {
            logger_1.logger('IK Stage 1 - Responder sending message...');
            const messageBuffer = this.ik.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode0(messageBuffer));
            logger_1.logger('IK Stage 1 - Responder sent message...');
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
        logger_1.logCipherState(this.session);
    }
    decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
    }
    encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
    }
    getLocalEphemeralKeys() {
        if (!this.session.hs.e) {
            throw new Error('Ephemeral keys do not exist.');
        }
        return this.session.hs.e;
    }
    getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
            throw new Error('Handshake not completed properly, cipher state does not exist.');
        }
        if (this.isInitiator) {
            return encryption ? session.cs1 : session.cs2;
        }
        else {
            return encryption ? session.cs2 : session.cs1;
        }
    }
    setRemoteEarlyData(data) {
        if (data) {
            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
        }
    }
}
exports.IKHandshake = IKHandshake;

},{"./handshakes/ik":"node_modules/libp2p-noise/dist/src/handshakes/ik.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","./encoder":"node_modules/libp2p-noise/dist/src/encoder.js","./utils":"node_modules/libp2p-noise/dist/src/utils.js","./errors":"node_modules/libp2p-noise/dist/src/errors.js","./logger":"node_modules/libp2p-noise/dist/src/logger.js"}],"node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XXFallbackHandshake = void 0;
const buffer_1 = require("buffer");
const handshake_xx_1 = require("./handshake-xx");
const utils_1 = require("./utils");
const logger_1 = require("./logger");
const encoder_1 = require("./encoder");
class XXFallbackHandshake extends handshake_xx_1.XXHandshake {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);
        if (ephemeralKeys) {
            this.ephemeralKeys = ephemeralKeys;
        }
        this.initialMsg = initialMsg;
    }
    // stage 0
    // eslint-disable-next-line require-await
    async propose() {
        if (this.isInitiator) {
            this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);
            logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
        else {
            logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');
            const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);
            const { valid } = this.xx.recvMessage(this.session, {
                ne: receivedMessageBuffer.ne,
                ns: buffer_1.Buffer.alloc(0),
                ciphertext: buffer_1.Buffer.alloc(0)
            });
            if (!valid) {
                throw new Error('xx fallback stage 0 decryption validation fail');
            }
            logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
        }
    }
    // stage 1
    async exchange() {
        if (this.isInitiator) {
            const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
                throw new Error('xx fallback stage 1 decryption validation fail');
            }
            logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
            logger_1.logRemoteStaticKey(this.session.hs.rs);
            logger_1.logger("Initiator going to check remote's signature...");
            try {
                const decodedPayload = await utils_1.decodePayload(plaintext);
                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
                this.setRemoteEarlyData(decodedPayload.data);
            }
            catch (e) {
                const err = e;
                throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);
            }
            logger_1.logger('All good with the signature!');
        }
        else {
            logger_1.logger('XX Fallback Stage 1 - Responder start');
            await super.exchange();
            logger_1.logger('XX Fallback Stage 1 - Responder end');
        }
    }
}
exports.XXFallbackHandshake = XXFallbackHandshake;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","./handshake-xx":"node_modules/libp2p-noise/dist/src/handshake-xx.js","./utils":"node_modules/libp2p-noise/dist/src/utils.js","./logger":"node_modules/libp2p-noise/dist/src/logger.js","./encoder":"node_modules/libp2p-noise/dist/src/encoder.js"}],"node_modules/libp2p-noise/dist/src/crypto.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptStream = exports.encryptStream = void 0;
const buffer_1 = require("buffer");
const constants_1 = require("./constants");
// Returns generator that encrypts payload from the user
function encryptStream(handshake) {
    return async function* (source) {
        for await (const chunk of source) {
            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
                if (end > chunkBuffer.length) {
                    end = chunkBuffer.length;
                }
                const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);
                yield data;
            }
        }
    };
}
exports.encryptStream = encryptStream;
// Decrypt received payload to the user
function decryptStream(handshake) {
    return async function* (source) {
        for await (const chunk of source) {
            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
                if (end > chunkBuffer.length) {
                    end = chunkBuffer.length;
                }
                const chunk = chunkBuffer.slice(i, end);
                const { plaintext: decrypted, valid } = await handshake.decrypt(chunk, handshake.session);
                if (!valid) {
                    throw new Error('Failed to validate decrypted chunk');
                }
                yield decrypted;
            }
        }
    };
}
exports.decryptStream = decryptStream;

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","./constants":"node_modules/libp2p-noise/dist/src/constants.js"}],"node_modules/libp2p-noise/dist/src/keycache.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyCache = void 0;
/**
 * Storage for static keys of previously connected peers.
 */
class Keycache {
    constructor() {
        this.storage = new Map();
    }
    store(peerId, key) {
        this.storage.set(peerId.id, key);
    }
    load(peerId) {
        var _a;
        if (!peerId) {
            return null;
        }
        return (_a = this.storage.get(peerId.id)) !== null && _a !== void 0 ? _a : null;
    }
    resetStorage() {
        this.storage.clear();
    }
}
const KeyCache = new Keycache();
exports.KeyCache = KeyCache;

},{}],"node_modules/libp2p-noise/dist/src/noise.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Noise = void 0;
const x25519 = __importStar(require("@stablelib/x25519"));
const buffer_1 = require("buffer");
const it_pb_rpc_1 = __importDefault(require("it-pb-rpc"));
const duplex_1 = __importDefault(require("it-pair/duplex"));
const it_buffer_1 = __importDefault(require("it-buffer"));
const it_pipe_1 = __importDefault(require("it-pipe"));
const it_length_prefixed_1 = require("it-length-prefixed");
const handshake_xx_1 = require("./handshake-xx");
const handshake_ik_1 = require("./handshake-ik");
const handshake_xx_fallback_1 = require("./handshake-xx-fallback");
const utils_1 = require("./utils");
const encoder_1 = require("./encoder");
const crypto_1 = require("./crypto");
const keycache_1 = require("./keycache");
const logger_1 = require("./logger");
const constants_1 = require("./constants");
class Noise {
    /**
     *
     * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes
     * @param {bytes} earlyData
     */
    constructor(staticNoiseKey, earlyData) {
        this.protocol = '/noise';
        this.prologue = buffer_1.Buffer.alloc(0);
        this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
        // disabled until properly specked
        this.useNoisePipes = false;
        if (staticNoiseKey) {
            // accepts x25519 private key of length 32
            const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);
            this.staticKeys = {
                privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),
                publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)
            };
        }
        else {
            this.staticKeys = utils_1.generateKeypair();
        }
    }
    /**
     * Encrypt outgoing data to the remote party (handshake as initiator)
     *
     * @param {PeerId} localPeer - PeerId of the receiving peer
     * @param {any} connection - streaming iterable duplex that will be encrypted
     * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
     * @returns {Promise<SecureOutbound>}
     */
    async secureOutbound(localPeer, connection, remotePeer) {
        const wrappedConnection = it_pb_rpc_1.default(connection, {
            lengthEncoder: encoder_1.uint16BEEncode,
            lengthDecoder: encoder_1.uint16BEDecode,
            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
            connection: wrappedConnection,
            isInitiator: true,
            localPeer,
            remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
            conn,
            remoteEarlyData: handshake.remoteEarlyData,
            remotePeer: handshake.remotePeer
        };
    }
    /**
     * Decrypt incoming data (handshake as responder).
     *
     * @param {PeerId} localPeer - PeerId of the receiving peer.
     * @param {any} connection - streaming iterable duplex that will be encryption.
     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
     * @returns {Promise<SecureOutbound>}
     */
    async secureInbound(localPeer, connection, remotePeer) {
        const wrappedConnection = it_pb_rpc_1.default(connection, {
            lengthEncoder: encoder_1.uint16BEEncode,
            lengthDecoder: encoder_1.uint16BEDecode,
            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
            connection: wrappedConnection,
            isInitiator: false,
            localPeer,
            remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
            conn,
            remoteEarlyData: handshake.remoteEarlyData,
            remotePeer: handshake.remotePeer
        };
    }
    /**
     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
     * If noise pipes disabled or remote peer static key is unknown, use XX.
     *
     * @param {HandshakeParams} params
     */
    async performHandshake(params) {
        var _a;
        const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
        let tryIK = this.useNoisePipes;
        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {
            // if we are initiator and remote static key is unknown, don't try IK
            tryIK = false;
        }
        // Try IK if acting as responder or initiator that has remote's static key.
        if (tryIK) {
            // Try IK first
            const { remotePeer, connection, isInitiator } = params;
            const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, 
            // safe to cast as we did checks
            (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);
            try {
                return await this.performIKHandshake(ikHandshake);
            }
            catch (e) {
                // IK failed, go to XX fallback
                let ephemeralKeys;
                if (params.isInitiator) {
                    ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
                }
                return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
            }
        }
        else {
            // run XX handshake
            return await this.performXXHandshake(params, payload);
        }
    }
    async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);
        try {
            await handshake.propose();
            await handshake.exchange();
            await handshake.finish();
        }
        catch (e) {
            logger_1.logger(e);
            const err = e;
            throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);
        }
        return handshake;
    }
    async performXXHandshake(params, payload) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);
        try {
            await handshake.propose();
            await handshake.exchange();
            await handshake.finish();
            if (this.useNoisePipes && handshake.remotePeer) {
                keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
            }
        }
        catch (e) {
            const err = e;
            throw new Error(`Error occurred during XX handshake: ${err.message}`);
        }
        return handshake;
    }
    async performIKHandshake(handshake) {
        await handshake.stage0();
        await handshake.stage1();
        return handshake;
    }
    async createSecureConnection(connection, handshake) {
        // Create encryption box/unbox wrapper
        const [secure, user] = duplex_1.default();
        const network = connection.unwrap();
        await it_pipe_1.default(secure, // write to wrapper
        it_buffer_1.default, // ensure any type of data is converted to buffer
        crypto_1.encryptStream(handshake), // data is encrypted
        it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), // prefix with message length
        network, // send to the remote peer
        it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), // read message length prefix
        it_buffer_1.default, // ensure any type of data is converted to buffer
        crypto_1.decryptStream(handshake), // decrypt the incoming data
        secure // pipe to the wrapper
        );
        return user;
    }
}
exports.Noise = Noise;

},{"@stablelib/x25519":"node_modules/@stablelib/x25519/lib/x25519.js","buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js","it-pb-rpc":"node_modules/it-pb-rpc/src/index.js","it-pair/duplex":"node_modules/it-pair/duplex.js","it-buffer":"node_modules/it-buffer/index.js","it-pipe":"node_modules/it-pipe/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","./handshake-xx":"node_modules/libp2p-noise/dist/src/handshake-xx.js","./handshake-ik":"node_modules/libp2p-noise/dist/src/handshake-ik.js","./handshake-xx-fallback":"node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","./utils":"node_modules/libp2p-noise/dist/src/utils.js","./encoder":"node_modules/libp2p-noise/dist/src/encoder.js","./crypto":"node_modules/libp2p-noise/dist/src/crypto.js","./keycache":"node_modules/libp2p-noise/dist/src/keycache.js","./logger":"node_modules/libp2p-noise/dist/src/logger.js","./constants":"node_modules/libp2p-noise/dist/src/constants.js"}],"node_modules/libp2p-noise/dist/src/index.js":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOISE = void 0;
const noise_1 = require("./noise");
__exportStar(require("./noise"), exports);
/**
 * Default configuration, it will generate new noise static key and enable noise pipes (IK handshake).
 */
exports.NOISE = new noise_1.Noise();

},{"./noise":"node_modules/libp2p-noise/dist/src/noise.js"}],"node_modules/libp2p-mplex/src/coder/encode.browser.js":[function(require,module,exports) {
'use strict'

const varint = require('varint')
const BufferList = require('bl/BufferList')

const POOL_SIZE = 10 * 1024

class Encoder {
  constructor () {
    this._pool = new Uint8Array(POOL_SIZE)
    this._poolOffset = 0
  }

  /**
   * Encodes the given message and returns it and its header
   *
   * @param {*} msg - The message object to encode
   * @returns {Uint8Array|Uint8Array[]}
   */
  write (msg) {
    const pool = this._pool
    let offset = this._poolOffset

    varint.encode(msg.id << 3 | msg.type, pool, offset)
    offset += varint.encode.bytes
    varint.encode(msg.data ? msg.data.length : 0, pool, offset)
    offset += varint.encode.bytes

    const header = pool.subarray(this._poolOffset, offset)

    if (POOL_SIZE - offset < 100) {
      this._pool = new Uint8Array(POOL_SIZE)
      this._poolOffset = 0
    } else {
      this._poolOffset = offset
    }

    if (!msg.data) return header

    return [header, msg.data]
  }
}

const encoder = new Encoder()

// Encode one or more messages and yield a BufferList of encoded messages
module.exports = source => (async function * encode () {
  for await (const msg of source) {
    if (Array.isArray(msg)) {
      yield new BufferList(msg.map(m => encoder.write(m)))
    } else {
      yield new BufferList(encoder.write(msg))
    }
  }
})()

},{"varint":"node_modules/varint/index.js","bl/BufferList":"node_modules/bl/BufferList.js"}],"node_modules/libp2p-mplex/src/coder/decode.js":[function(require,module,exports) {
'use strict'

const varint = require('varint')
const BufferList = require('bl/BufferList')

// Decode a chunk and yield an _array_ of decoded messages
module.exports = source => (async function * decode () {
  const decoder = new Decoder()
  for await (const chunk of source) {
    const msgs = decoder.write(chunk)
    if (msgs.length) yield msgs
  }
})()

class Decoder {
  constructor () {
    this._buffer = new BufferList()
    // optimization to allow varint to take a BufferList (well a proxy to)
    this._bufferProxy = new Proxy({}, {
      get: (_, prop) => prop[0] === 'l' ? this._buffer[prop] : this._buffer.get(parseInt(prop))
    })
    this._headerInfo = null
  }

  /**
   * @param {Uint8Array|BufferList} chunk
   * @returns {object[]} An array of message objects
   */
  write (chunk) {
    if (!chunk || !chunk.length) return []

    this._buffer.append(chunk)
    const msgs = []

    while (true) {
      if (!this._headerInfo) {
        try {
          this._headerInfo = this._decodeHeader(this._bufferProxy)
        } catch (_) {
          break // We haven't received enough data yet
        }
      }

      const { id, type, length, offset } = this._headerInfo
      const bufferedDataLength = this._buffer.length - offset

      if (bufferedDataLength < length) break // not enough data yet

      msgs.push({ id, type, data: this._buffer.shallowSlice(offset, offset + length) })

      this._buffer.consume(offset + length)
      this._headerInfo = null
    }

    return msgs
  }

  /**
   * Attempts to decode the message header from the buffer
   *
   * @private
   * @param {Uint8Array} data
   * @returns {*} message header (id, type, offset, length)
   */
  _decodeHeader (data) {
    const h = varint.decode(data)
    let offset = varint.decode.bytes
    const length = varint.decode(data, offset)
    offset += varint.decode.bytes
    return { id: h >> 3, type: h & 7, offset, length }
  }
}

},{"varint":"node_modules/varint/index.js","bl/BufferList":"node_modules/bl/BufferList.js"}],"node_modules/libp2p-mplex/src/coder/index.js":[function(require,module,exports) {
'use strict'

exports.encode = require('./encode')
exports.decode = require('./decode')

},{"./encode":"node_modules/libp2p-mplex/src/coder/encode.browser.js","./decode":"node_modules/libp2p-mplex/src/coder/decode.js"}],"node_modules/libp2p-mplex/src/restrict-size.js":[function(require,module,exports) {
'use strict'

const MAX_MSG_SIZE = 1 << 20 // 1MB

/**
 * Creates an iterable transform that restricts message sizes to
 * the given maximum size.
 *
 * @param {number} [max] - The maximum message size. Defaults to 1MB
 * @returns {*} An iterable transform.
 */
module.exports = max => {
  max = max || MAX_MSG_SIZE

  const checkSize = msg => {
    if (msg.data && msg.data.length > max) {
      throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })
    }
  }

  return source => {
    return (async function * restrictSize () {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          msg.forEach(checkSize)
        } else {
          checkSize(msg)
        }
        yield msg
      }
    })()
  }
}

module.exports.MAX_MSG_SIZE = MAX_MSG_SIZE

},{}],"node_modules/libp2p-mplex/src/message-types.js":[function(require,module,exports) {
'use strict'

const MessageTypes = Object.freeze({
  NEW_STREAM: 0,
  MESSAGE_RECEIVER: 1,
  MESSAGE_INITIATOR: 2,
  CLOSE_RECEIVER: 3,
  CLOSE_INITIATOR: 4,
  RESET_RECEIVER: 5,
  RESET_INITIATOR: 6
})

exports.MessageTypes = MessageTypes

exports.InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
})

exports.ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
})

exports.MessageTypeNames = Object.freeze(
  Object.entries(MessageTypes).reduce((obj, e) => {
    obj[e[1]] = e[0]
    return obj
  }, {})
)

},{}],"node_modules/libp2p-mplex/src/stream.js":[function(require,module,exports) {
'use strict'

const abortable = require('abortable-iterator')
const AbortController = require('abort-controller')
const log = require('debug')('libp2p:mplex:stream')
const pushable = require('it-pushable')
const BufferList = require('bl/BufferList')
const errCode = require('err-code')
const { MAX_MSG_SIZE } = require('./restrict-size')
const { InitiatorMessageTypes, ReceiverMessageTypes } = require('./message-types')

const ERR_MPLEX_STREAM_RESET = 'ERR_MPLEX_STREAM_RESET'
const ERR_MPLEX_STREAM_ABORT = 'ERR_MPLEX_STREAM_ABORT'

/**
 * @param {object} options
 * @param {number} options.id
 * @param {string} options.name
 * @param {function(*)} options.send - Called to send data through the stream
 * @param {function(Error)} [options.onEnd] - Called whenever the stream ends
 * @param {string} [options.type] - One of ['initiator','receiver']. Defaults to 'initiator'
 * @param {number} [options.maxMsgSize] - Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB
 * @returns {*} A muxed stream
 */
module.exports = ({ id, name, send, onEnd = () => {}, type = 'initiator', maxMsgSize = MAX_MSG_SIZE }) => {
  const abortController = new AbortController()
  const resetController = new AbortController()
  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes
  const externalId = type === 'initiator' ? (`i${id}`) : `r${id}`

  name = String(name == null ? id : name)

  let sourceEnded = false
  let sinkEnded = false
  let endErr

  const onSourceEnd = err => {
    if (sourceEnded) return
    sourceEnded = true
    log('%s stream %s source end', type, name, err)
    if (err && !endErr) endErr = err
    if (sinkEnded) {
      stream.timeline.close = Date.now()
      onEnd(endErr)
    }
  }

  const onSinkEnd = err => {
    if (sinkEnded) return
    sinkEnded = true
    log('%s stream %s sink end', type, name, err)
    if (err && !endErr) endErr = err
    if (sourceEnded) {
      stream.timeline.close = Date.now()
      onEnd(endErr)
    }
  }

  const stream = {
    // Close for reading
    close: () => stream.source.end(),
    // Close for reading and writing (local error)
    abort: err => {
      log('%s stream %s abort', type, name, err)
      // End the source with the passed error
      stream.source.end(err)
      abortController.abort()
      onSinkEnd(err)
    },
    // Close immediately for reading and writing (remote error)
    reset: () => {
      const err = errCode(new Error('stream reset'), ERR_MPLEX_STREAM_RESET)
      resetController.abort()
      stream.source.end(err)
      onSinkEnd(err)
    },
    sink: async source => {
      source = abortable(source, [
        { signal: abortController.signal, options: { abortMessage: 'stream aborted', abortCode: ERR_MPLEX_STREAM_ABORT } },
        { signal: resetController.signal, options: { abortMessage: 'stream reset', abortCode: ERR_MPLEX_STREAM_RESET } }
      ])

      if (type === 'initiator') { // If initiator, open a new stream
        send({ id, type: Types.NEW_STREAM, data: name })
      }

      try {
        for await (let data of source) {
          while (data.length) {
            if (data.length <= maxMsgSize) {
              send({ id, type: Types.MESSAGE, data })
              break
            }
            data = BufferList.isBufferList(data) ? data : new BufferList(data)
            send({ id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize) })
            data.consume(maxMsgSize)
          }
        }
      } catch (err) {
        // Send no more data if this stream was remotely reset
        if (err.code === ERR_MPLEX_STREAM_RESET) {
          log('%s stream %s reset', type, name)
        } else {
          log('%s stream %s error', type, name, err)
          send({ id, type: Types.RESET })
        }

        stream.source.end(err)
        return onSinkEnd(err)
      }

      send({ id, type: Types.CLOSE })
      onSinkEnd()
    },
    source: pushable(onSourceEnd),
    timeline: {
      open: Date.now(),
      close: null
    },
    id: externalId
  }

  return stream
}

},{"abortable-iterator":"node_modules/abortable-iterator/index.js","abort-controller":"node_modules/abort-controller/browser.js","debug":"node_modules/debug/src/browser.js","it-pushable":"node_modules/it-pushable/index.js","bl/BufferList":"node_modules/bl/BufferList.js","err-code":"node_modules/err-code/index.js","./restrict-size":"node_modules/libp2p-mplex/src/restrict-size.js","./message-types":"node_modules/libp2p-mplex/src/message-types.js"}],"node_modules/libp2p-mplex/src/mplex.js":[function(require,module,exports) {
'use strict'

const pipe = require('it-pipe')
const pushable = require('it-pushable')
const log = require('debug')('libp2p:mplex')
const abortable = require('abortable-iterator')
const Coder = require('./coder')
const restrictSize = require('./restrict-size')
const { MessageTypes, MessageTypeNames } = require('./message-types')
const createStream = require('./stream')

class Mplex {
  /**
   * @class
   * @param {object} options
   * @param {function(*)} options.onStream - Called whenever an inbound stream is created
   * @param {function(*)} options.onStreamEnd - Called whenever a stream ends
   * @param {AbortSignal} options.signal - An AbortController signal
   */
  constructor (options) {
    options = options || {}
    options = typeof options === 'function' ? { onStream: options } : options

    this._streamId = 0
    this._streams = {
      /**
       * @type {Map<number, *>} Stream to ids map
       */
      initiators: new Map(),
      /**
       * @type {Map<number, *>} Stream to ids map
       */
      receivers: new Map()
    }
    this._options = options

    /**
     * An iterable sink
     */
    this.sink = this._createSink()

    /**
     * An iterable source
     */
    this.source = this._createSource()

    /**
     * @property {Function} onStream
     */
    this.onStream = options.onStream

    /**
     * @property {Function} onStreamEnd
     */
    this.onStreamEnd = options.onStreamEnd
  }

  /**
   * Returns a Map of streams and their ids
   *
   * @returns {Map<number,*>}
   */
  get streams () {
    // Inbound and Outbound streams may have the same ids, so we need to make those unique
    const streams = []
    this._streams.initiators.forEach(stream => {
      streams.push(stream)
    })
    this._streams.receivers.forEach(stream => {
      streams.push(stream)
    })
    return streams
  }

  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of th stream will be used.
   *
   * @param {string} [name] - If name is not a string it will be cast to one
   * @returns {Stream}
   */
  newStream (name) {
    const id = this._streamId++
    name = name == null ? id.toString() : String(name)
    const registry = this._streams.initiators
    return this._newStream({ id, name, type: 'initiator', registry })
  }

  /**
   * Called whenever an inbound stream is created
   *
   * @private
   * @param {*} options
   * @param {number} options.id
   * @param {string} options.name
   * @returns {*} A muxed stream
   */
  _newReceiverStream ({ id, name }) {
    const registry = this._streams.receivers
    return this._newStream({ id, name, type: 'receiver', registry })
  }

  /**
   * Creates a new stream
   *
   * @private
   * @param {object} options
   * @param {number} options.id
   * @param {string} options.name
   * @param {string} options.type
   * @param {Map<number, *>} options.registry - A map of streams to their ids
   * @returns {*} A muxed stream
   */
  _newStream ({ id, name, type, registry }) {
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`)
    }
    log('new %s stream %s %s', type, id, name)
    const send = msg => {
      if (log.enabled) {
        log('%s stream %s %s send', type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() })
      }
      return this.source.push(msg)
    }
    const onEnd = () => {
      log('%s stream %s %s ended', type, id, name)
      registry.delete(id)
      this.onStreamEnd && this.onStreamEnd(stream)
    }
    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize })
    registry.set(id, stream)
    return stream
  }

  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   *
   * @private
   * @returns {*} Returns an iterable sink
   */
  _createSink () {
    return async source => {
      if (this._options.signal) {
        source = abortable(source, this._options.signal)
      }

      try {
        await pipe(
          source,
          Coder.decode,
          restrictSize(this._options.maxMsgSize),
          async source => {
            for await (const msgs of source) {
              for (const msg of msgs) {
                this._handleIncoming(msg)
              }
            }
          }
        )
      } catch (err) {
        log('error in sink', err)
        return this.source.end(err) // End the source with an error
      }

      this.source.end()
    }
  }

  /**
   * Creates a source that restricts outgoing message sizes
   * and varint encodes them.
   *
   * @private
   * @returns {*} An iterable source
   */
  _createSource () {
    const onEnd = err => {
      const { initiators, receivers } = this._streams
      // Abort all the things!
      for (const s of initiators.values()) s.abort(err)
      for (const s of receivers.values()) s.abort(err)
    }
    const source = pushable({ onEnd, writev: true })
    return Object.assign(Coder.encode(source), {
      push: source.push,
      end: source.end,
      return: source.return
    })
  }

  /**
   * @private
   * @param {object} options
   * @param {number} options.id
   * @param {string} options.type
   * @param {Uint8Array|BufferList} options.data
   * @returns {void}
   */
  _handleIncoming ({ id, type, data }) {
    if (log.enabled) {
      log('incoming message', { id, type: MessageTypeNames[type], data: data.slice() })
    }

    // Create a new stream?
    if (type === MessageTypes.NEW_STREAM && this.onStream) {
      const stream = this._newReceiverStream({ id, name: data.toString() })
      return this.onStream(stream)
    }

    const list = type & 1 ? this._streams.initiators : this._streams.receivers
    const stream = list.get(id)

    if (!stream) return log('missing stream %s', id)

    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        stream.source.push(data)
        break
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.close()
        break
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset()
        break
      default:
        log('unknown message type %s', type)
    }
  }
}

Mplex.multicodec = '/mplex/6.7.0'

module.exports = Mplex

},{"it-pipe":"node_modules/it-pipe/index.js","it-pushable":"node_modules/it-pushable/index.js","debug":"node_modules/debug/src/browser.js","abortable-iterator":"node_modules/abortable-iterator/index.js","./coder":"node_modules/libp2p-mplex/src/coder/index.js","./restrict-size":"node_modules/libp2p-mplex/src/restrict-size.js","./message-types":"node_modules/libp2p-mplex/src/message-types.js","./stream":"node_modules/libp2p-mplex/src/stream.js"}],"node_modules/libp2p-mplex/src/index.js":[function(require,module,exports) {
'use strict'

module.exports = require('./mplex')

},{"./mplex":"node_modules/libp2p-mplex/src/mplex.js"}],"node_modules/libp2p-bootstrap/src/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var PeerId = require('peer-id');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var mafmt = require('mafmt');

var _require2 = require('events'),
    EventEmitter = _require2.EventEmitter;

var debug = require('debug');

var log = Object.assign(debug('libp2p:bootstrap'), {
  error: debug('libp2p:bootstrap:error')
});
/**
 * Emits 'peer' events on a regular interval for each peer in the provided list.
 */

var Bootstrap = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Bootstrap, _EventEmitter);

  var _super = _createSuper(Bootstrap);

  /**
   * Constructs a new Bootstrap.
   *
   * @param {Object} options
   * @param {Array<string>} options.list - the list of peer addresses in multi-address format
   * @param {number} [options.interval = 10000] - the interval between emitting addresses in milliseconds
   *
   */
  function Bootstrap() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      list: []
    };

    _classCallCheck(this, Bootstrap);

    if (!options.list || !options.list.length) {
      throw new Error('Bootstrap requires a list of peer addresses');
    }

    _this = _super.call(this);
    _this._list = options.list;
    _this._interval = options.interval || 10000;
    _this._timer = null;
    return _this;
  }
  /**
   * Start emitting events.
   */


  _createClass(Bootstrap, [{
    key: "start",
    value: function start() {
      var _this2 = this;

      if (this._timer) {
        return;
      }

      this._timer = setInterval(function () {
        return _this2._discoverBootstrapPeers();
      }, this._interval);
      log('Starting bootstrap node discovery');

      this._discoverBootstrapPeers();
    }
    /**
     * Emit each address in the list as a PeerInfo.
     */

  }, {
    key: "_discoverBootstrapPeers",
    value: function _discoverBootstrapPeers() {
      var _this3 = this;

      if (!this._timer) {
        return;
      }

      this._list.forEach(function (candidate) {
        if (!mafmt.P2P.matches(candidate)) {
          return log.error('Invalid multiaddr');
        }

        var ma = new Multiaddr(candidate);
        var peerIdStr = ma.getPeerId();

        if (!peerIdStr) {
          log.error('Invalid bootstrap multiaddr without peer id');
          return;
        }

        var peerId = PeerId.createFromB58String(peerIdStr);

        try {
          _this3.emit('peer', {
            id: peerId,
            multiaddrs: [ma]
          });
        } catch (err) {
          log.error('Invalid bootstrap peer id', err);
        }
      });
    }
    /**
     * Stop emitting events.
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._timer) clearInterval(this._timer);
      this._timer = null;
    }
  }]);

  return Bootstrap;
}(EventEmitter);

exports = module.exports = Bootstrap;
exports.tag = 'bootstrap';
},{"peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","mafmt":"node_modules/mafmt/src/index.js","events":"node_modules/events/events.js","debug":"node_modules/debug/src/browser.js"}],"node_modules/libp2p-record/src/record/record.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-record"] || ($protobuf.roots["libp2p-record"] = {});

$root.Record = function () {
  /**
   * Properties of a Record.
   * @exports IRecord
   * @interface IRecord
   * @property {Uint8Array|null} [key] Record key
   * @property {Uint8Array|null} [value] Record value
   * @property {string|null} [timeReceived] Record timeReceived
   */

  /**
   * Constructs a new Record.
   * @exports Record
   * @classdesc Represents a Record.
   * @implements IRecord
   * @constructor
   * @param {IRecord=} [p] Properties to set
   */
  function Record(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Record key.
   * @member {Uint8Array} key
   * @memberof Record
   * @instance
   */


  Record.prototype.key = $util.newBuffer([]);
  /**
   * Record value.
   * @member {Uint8Array} value
   * @memberof Record
   * @instance
   */

  Record.prototype.value = $util.newBuffer([]);
  /**
   * Record timeReceived.
   * @member {string} timeReceived
   * @memberof Record
   * @instance
   */

  Record.prototype.timeReceived = "";
  /**
   * Encodes the specified Record message. Does not implicitly {@link Record.verify|verify} messages.
   * @function encode
   * @memberof Record
   * @static
   * @param {IRecord} m Record message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Record.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key")) w.uint32(10).bytes(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(18).bytes(m.value);
    if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived")) w.uint32(42).string(m.timeReceived);
    return w;
  };
  /**
   * Decodes a Record message from the specified reader or buffer.
   * @function decode
   * @memberof Record
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Record} Record
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Record.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Record();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.key = r.bytes();
          break;

        case 2:
          m.value = r.bytes();
          break;

        case 5:
          m.timeReceived = r.string();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a Record message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Record
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Record} Record
   */


  Record.fromObject = function fromObject(d) {
    if (d instanceof $root.Record) return d;
    var m = new $root.Record();

    if (d.key != null) {
      if (typeof d.key === "string") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;
    }

    if (d.value != null) {
      if (typeof d.value === "string") $util.base64.decode(d.value, m.value = $util.newBuffer($util.base64.length(d.value)), 0);else if (d.value.length) m.value = d.value;
    }

    if (d.timeReceived != null) {
      m.timeReceived = String(d.timeReceived);
    }

    return m;
  };
  /**
   * Creates a plain object from a Record message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Record
   * @static
   * @param {Record} m Record
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Record.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.defaults) {
      if (o.bytes === String) d.key = "";else {
        d.key = [];
        if (o.bytes !== Array) d.key = $util.newBuffer(d.key);
      }
      if (o.bytes === String) d.value = "";else {
        d.value = [];
        if (o.bytes !== Array) d.value = $util.newBuffer(d.value);
      }
      d.timeReceived = "";
    }

    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
    }

    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }

    if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
      d.timeReceived = m.timeReceived;
    }

    return d;
  };
  /**
   * Converts this Record to JSON.
   * @function toJSON
   * @memberof Record
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Record.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return Record;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p-record/src/utils.js":[function(require,module,exports) {
'use strict';
/**
 * Convert a JavaScript date into an `RFC3339Nano` formatted
 * string.
 *
 * @param {Date} time
 */

module.exports.toRFC3339 = function (time) {
  var year = time.getUTCFullYear();
  var month = String(time.getUTCMonth() + 1).padStart(2, '0');
  var day = String(time.getUTCDate()).padStart(2, '0');
  var hour = String(time.getUTCHours()).padStart(2, '0');
  var minute = String(time.getUTCMinutes()).padStart(2, '0');
  var seconds = String(time.getUTCSeconds()).padStart(2, '0');
  var milliseconds = time.getUTCMilliseconds();
  var nanoseconds = milliseconds * 1000 * 1000;
  return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(seconds, ".").concat(nanoseconds, "Z");
};
/**
 * Parses a date string formatted as `RFC3339Nano` into a
 * JavaScript Date object.
 *
 * @param {string} time
 */


module.exports.parseRFC3339 = function (time) {
  var rfc3339Matcher = new RegExp( // 2006-01-02T
  '(\\d{4})-(\\d{2})-(\\d{2})T' + // 15:04:05
  '(\\d{2}):(\\d{2}):(\\d{2})' + // .999999999Z
  '\\.(\\d+)Z');
  var m = String(time).trim().match(rfc3339Matcher);

  if (!m) {
    throw new Error('Invalid format');
  }

  var year = parseInt(m[1], 10);
  var month = parseInt(m[2], 10) - 1;
  var date = parseInt(m[3], 10);
  var hour = parseInt(m[4], 10);
  var minute = parseInt(m[5], 10);
  var second = parseInt(m[6], 10);
  var millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));
};
},{}],"node_modules/libp2p-record/src/record/index.js":[function(require,module,exports) {
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./record'),
    PBRecord = _require.Record;

var utils = require('../utils');
/**
 * @typedef {{ key: Uint8Array, value: Uint8Array, timeReceived: string }} ProtobufRecord
 */


var Record = /*#__PURE__*/function () {
  /**
   * @param {Uint8Array} [key]
   * @param {Uint8Array} [value]
   * @param {Date} [timeReceived]
   */
  function Record(key, value, timeReceived) {
    _classCallCheck(this, Record);

    if (!(key instanceof Uint8Array)) {
      throw new Error('key must be a Uint8Array');
    }

    if (!(value instanceof Uint8Array)) {
      throw new Error('value must be a Uint8Array');
    }

    this.key = key;
    this.value = value;
    this.timeReceived = timeReceived;
  }

  _createClass(Record, [{
    key: "serialize",
    value: function serialize() {
      return PBRecord.encode(this.prepareSerialize()).finish();
    }
    /**
     * Return the object format ready to be given to the protobuf library.
     */

  }, {
    key: "prepareSerialize",
    value: function prepareSerialize() {
      return {
        key: this.key,
        value: this.value,
        timeReceived: this.timeReceived && utils.toRFC3339(this.timeReceived)
      };
    }
    /**
     * Decode a protobuf encoded record.
     *
     * @param {Uint8Array} raw
     */

  }], [{
    key: "deserialize",
    value: function deserialize(raw) {
      var message = PBRecord.decode(raw);
      return Record.fromDeserialized(PBRecord.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      }));
    }
    /**
     * Create a record from the raw object returned from the protobuf library.
     *
     * @param {{ [k: string]: any }} obj
     */

  }, {
    key: "fromDeserialized",
    value: function fromDeserialized(obj) {
      var recvtime;

      if (obj.timeReceived) {
        recvtime = utils.parseRFC3339(obj.timeReceived);
      }

      var rec = new Record(obj.key, obj.value, recvtime);
      return rec;
    }
  }]);

  return Record;
}();

module.exports = Record;
},{"./record":"node_modules/libp2p-record/src/record/record.js","../utils":"node_modules/libp2p-record/src/utils.js"}],"node_modules/libp2p-record/src/validators/public-key.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var errcode = require('err-code');

var uint8ArrayToString = require('uint8arrays/to-string');

var uint8ArrayEquals = require('uint8arrays/equals');
/**
 * Validator for public key records.
 * Verifies that the passed in record value is the PublicKey
 * that matches the passed in key.
 * If validation fails the returned Promise will reject with the error.
 *
 * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`
 * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).
 */


var validatePublicKeyRecord = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, publicKey) {
    var prefix, keyhash, publicKeyHash;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (key instanceof Uint8Array) {
              _context.next = 2;
              break;
            }

            throw errcode(new Error('"key" must be a Uint8Array'), 'ERR_INVALID_RECORD_KEY_NOT_BUFFER');

          case 2:
            if (!(key.byteLength < 5)) {
              _context.next = 4;
              break;
            }

            throw errcode(new Error('invalid public key record'), 'ERR_INVALID_RECORD_KEY_TOO_SHORT');

          case 4:
            prefix = uint8ArrayToString(key.subarray(0, 4));

            if (!(prefix !== '/pk/')) {
              _context.next = 7;
              break;
            }

            throw errcode(new Error('key was not prefixed with /pk/'), 'ERR_INVALID_RECORD_KEY_BAD_PREFIX');

          case 7:
            keyhash = key.slice(4);
            _context.next = 10;
            return sha256.digest(publicKey);

          case 10:
            publicKeyHash = _context.sent;

            if (uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {
              _context.next = 13;
              break;
            }

            throw errcode(new Error('public key does not match passed in key'), 'ERR_INVALID_RECORD_HASH_MISMATCH');

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function validatePublicKeyRecord(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

module.exports = {
  func: validatePublicKeyRecord,
  sign: false
};
},{"multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","err-code":"node_modules/err-code/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js"}],"node_modules/libp2p-record/src/validators/index.js":[function(require,module,exports) {
'use strict';

module.exports = {
  pk: require('./public-key')
};
},{"./public-key":"node_modules/libp2p-record/src/validators/public-key.js"}],"node_modules/libp2p-record/src/validator.js":[function(require,module,exports) {
'use strict';

var errcode = require('err-code');

var uint8ArrayToString = require('uint8arrays/to-string');
/**
 * @typedef {import('./record')} Record
 */

/**
 * Checks a record and ensures it is still valid.
 * It runs the needed validators.
 * If verification fails the returned Promise will reject with the error.
 *
 * @param {import('libp2p-interfaces/src/types').DhtValidators} validators
 * @param {Record} record
 */


var verifyRecord = function verifyRecord(validators, record) {
  var key = record.key;
  var keyString = uint8ArrayToString(key);
  var parts = keyString.split('/');

  if (parts.length < 3) {
    // No validator available
    return;
  }

  var validator = validators[parts[1].toString()];

  if (!validator) {
    var errMsg = 'Invalid record keytype';
    throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_KEY_TYPE');
  }

  return validator.func(key, record.value);
};

module.exports = {
  verifyRecord: verifyRecord,
  validators: require('./validators')
};
},{"err-code":"node_modules/err-code/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","./validators":"node_modules/libp2p-record/src/validators/index.js"}],"node_modules/libp2p-record/src/selectors/public-key.js":[function(require,module,exports) {
'use strict';
/**
 * Best record selector, for public key records.
 * Simply returns the first record, as all valid public key
 * records are equal.
 *
 * @param {Uint8Array} k
 * @param {Array<Uint8Array>} records
 */

var publicKeySelector = function publicKeySelector(k, records) {
  return 0;
};

module.exports = publicKeySelector;
},{}],"node_modules/libp2p-record/src/selectors/index.js":[function(require,module,exports) {
'use strict';

module.exports = {
  pk: require('./public-key')
};
},{"./public-key":"node_modules/libp2p-record/src/selectors/public-key.js"}],"node_modules/libp2p-record/src/selection.js":[function(require,module,exports) {
'use strict';

var errcode = require('err-code');

var uint8ArrayToString = require('uint8arrays/to-string');
/**
 * Select the best record out of the given records.
 *
 * @param {import('libp2p-interfaces/src/types').DhtSelectors} selectors
 * @param {Uint8Array} k
 * @param {Array<Uint8Array>} records
 */


var bestRecord = function bestRecord(selectors, k, records) {
  if (records.length === 0) {
    var errMsg = 'No records given';
    throw errcode(new Error(errMsg), 'ERR_NO_RECORDS_RECEIVED');
  }

  var kStr = uint8ArrayToString(k);
  var parts = kStr.split('/');

  if (parts.length < 3) {
    var _errMsg = 'Record key does not have a selector function';
    throw errcode(new Error(_errMsg), 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY');
  }

  var selector = selectors[parts[1].toString()];

  if (!selector) {
    var _errMsg2 = "Unrecognized key prefix: ".concat(parts[1]);

    throw errcode(new Error(_errMsg2), 'ERR_UNRECOGNIZED_KEY_PREFIX');
  }

  return selector(k, records);
};

module.exports = {
  bestRecord: bestRecord,
  selectors: require('./selectors')
};
},{"err-code":"node_modules/err-code/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","./selectors":"node_modules/libp2p-record/src/selectors/index.js"}],"node_modules/libp2p-record/src/index.js":[function(require,module,exports) {
'use strict';

module.exports = {
  Record: require('./record'),
  validator: require('./validator'),
  selection: require('./selection')
};
},{"./record":"node_modules/libp2p-record/src/record/index.js","./validator":"node_modules/libp2p-record/src/validator.js","./selection":"node_modules/libp2p-record/src/selection.js"}],"node_modules/k-bucket/index.js":[function(require,module,exports) {
/*
index.js - Kademlia DHT K-bucket implementation as a binary tree.

The MIT License (MIT)

Copyright (c) 2013-2021 Tristan Slominski

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/
'use strict'

const randomBytes = require('randombytes')
const { EventEmitter } = require('events')

/**
 * @param  {Uint8Array} array1
 * @param  {Uint8Array} array2
 * @return {Boolean}
 */
function arrayEquals (array1, array2) {
  if (array1 === array2) {
    return true
  }
  if (array1.length !== array2.length) {
    return false
  }
  for (let i = 0, length = array1.length; i < length; ++i) {
    if (array1[i] !== array2[i]) {
      return false
    }
  }
  return true
}

function createNode () {
  return { contacts: [], dontSplit: false, left: null, right: null }
}

function ensureInt8 (name, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name + ' is not a Uint8Array')
  }
}

/**
 * Implementation of a Kademlia DHT k-bucket used for storing
 * contact (peer node) information.
 *
 * @extends EventEmitter
 */
class KBucket extends EventEmitter {
  /**
   * `options`:
   *   `distance`: _Function_
   *     `function (firstId, secondId) { return distance }` An optional
   *     `distance` function that gets two `id` Uint8Arrays
   *     and return distance (as number) between them.
   *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_
   *     `function (incumbent, candidate) { return contact; }` An optional
   *     `arbiter` function that givent two `contact` objects with the same `id`
   *     returns the desired object to be used for updating the k-bucket. For
   *     more details, see [arbiter function](#arbiter-function).
   *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.
   *     If not provided, a local node id will be created via `randomBytes(20)`.
   *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include
   *     with the k-bucket. `metadata` property is guaranteed not be altered by,
   *     it is provided as an explicit container for users of k-bucket to store
   *     implementation-specific data.
   *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes
   *     that a k-bucket can contain before being full or split.
   *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to
   *     ping when a bucket that should not be split becomes full. KBucket will
   *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
   *     not been contacted the longest.
   *
   * @param {Object=} options optional
   */
  constructor (options = {}) {
    super()

    this.localNodeId = options.localNodeId || randomBytes(20)
    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20
    this.numberOfNodesToPing = options.numberOfNodesToPing || 3
    this.distance = options.distance || KBucket.distance
    // use an arbiter from options or vectorClock arbiter by default
    this.arbiter = options.arbiter || KBucket.arbiter
    this.metadata = Object.assign({}, options.metadata)

    ensureInt8('option.localNodeId as parameter 1', this.localNodeId)

    this.root = createNode()
  }

  /**
   * Default arbiter function for contacts with the same id. Uses
   * contact.vectorClock to select which contact to update the k-bucket with.
   * Contact with larger vectorClock field will be selected. If vectorClock is
   * the same, candidat will be selected.
   *
   * @param  {Object} incumbent Contact currently stored in the k-bucket.
   * @param  {Object} candidate Contact being added to the k-bucket.
   * @return {Object}           Contact to updated the k-bucket with.
   */
  static arbiter (incumbent, candidate) {
    return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate
  }

  /**
   * Default distance function. Finds the XOR
   * distance between firstId and secondId.
   *
   * @param  {Uint8Array} firstId  Uint8Array containing first id.
   * @param  {Uint8Array} secondId Uint8Array containing second id.
   * @return {Number}              Integer The XOR distance between firstId
   *                               and secondId.
   */
  static distance (firstId, secondId) {
    let distance = 0
    let i = 0
    const min = Math.min(firstId.length, secondId.length)
    const max = Math.max(firstId.length, secondId.length)
    for (; i < min; ++i) {
      distance = distance * 256 + (firstId[i] ^ secondId[i])
    }
    for (; i < max; ++i) distance = distance * 256 + 255
    return distance
  }

  /**
   * Adds a contact to the k-bucket.
   *
   * @param {Object} contact the contact object to add
   */
  add (contact) {
    ensureInt8('contact.id', (contact || {}).id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      // this is not a leaf node but an inner node with 'low' and 'high'
      // branches; we will check the appropriate bit of the identifier and
      // delegate to the appropriate node for further processing
      node = this._determineNode(node, contact.id, bitIndex++)
    }

    // check if the contact already exists
    const index = this._indexOf(node, contact.id)
    if (index >= 0) {
      this._update(node, index, contact)
      return this
    }

    if (node.contacts.length < this.numberOfNodesPerKBucket) {
      node.contacts.push(contact)
      this.emit('added', contact)
      return this
    }

    // the bucket is full
    if (node.dontSplit) {
      // we are not allowed to split the bucket
      // we need to ping the first this.numberOfNodesToPing
      // in order to determine if they are alive
      // only if one of the pinged nodes does not respond, can the new contact
      // be added (this prevents DoS flodding with new invalid contacts)
      this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact)
      return this
    }

    this._split(node, bitIndex)
    return this.add(contact)
  }

  /**
   * Get the n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param  {Uint8Array} id  Contact node id
   * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
   *                          closest contacts to return
   * @return {Array}          Array Maximum of n closest contacts to the node id
   */
  closest (id, n = Infinity) {
    ensureInt8('id', id)

    if ((!Number.isInteger(n) && n !== Infinity) || n <= 0) {
      throw new TypeError('n is not positive number')
    }

    let contacts = []

    for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {
      const node = nodes.pop()
      if (node.contacts === null) {
        const detNode = this._determineNode(node, id, bitIndex++)
        nodes.push(node.left === detNode ? node.right : node.left)
        nodes.push(detNode)
      } else {
        contacts = contacts.concat(node.contacts)
      }
    }

    return contacts
      .map(a => [this.distance(a.id, id), a])
      .sort((a, b) => a[0] - b[0])
      .slice(0, n)
      .map(a => a[1])
  }

  /**
   * Counts the total number of contacts in the tree.
   *
   * @return {Number} The number of contacts held in the tree
   */
  count () {
    // return this.toArray().length
    let count = 0
    for (const nodes = [this.root]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else count += node.contacts.length
    }
    return count
  }

  /**
   * Determines whether the id at the bitIndex is 0 or 1.
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param  {Object} node     internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id   Id to compare localNodeId with.
   * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
   *                           to check in the id Uint8Array.
   * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineNode (node, id, bitIndex) {
    // **NOTE** remember that id is a Uint8Array and has granularity of
    // bytes (8 bits), whereas the bitIndex is the _bit_ index (not byte)

    // id's that are too short are put in low bucket (1 byte = 8 bits)
    // (bitIndex >> 3) finds how many bytes the bitIndex describes
    // bitIndex % 8 checks if we have extra bits beyond byte multiples
    // if number of bytes is <= no. of bytes described by bitIndex and there
    // are extra bits to consider, this means id has less bits than what
    // bitIndex describes, id therefore is too short, and will be put in low
    // bucket
    const bytesDescribedByBitIndex = bitIndex >> 3
    const bitIndexWithinByte = bitIndex % 8
    if ((id.length <= bytesDescribedByBitIndex) && (bitIndexWithinByte !== 0)) {
      return node.left
    }

    const byteUnderConsideration = id[bytesDescribedByBitIndex]

    // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits
    // where 255 is 11111111 and 0 is 00000000
    // in order to find out whether the bit at bitIndexWithinByte is set
    // we construct (1 << (7 - bitIndexWithinByte)) which will consist
    // of all bits being 0, with only one bit set to 1
    // for example, if bitIndexWithinByte is 3, we will construct 00010000 by
    // (1 << (7 - 3)) -> (1 << 4) -> 16
    if (byteUnderConsideration & (1 << (7 - bitIndexWithinByte))) {
      return node.right
    }

    return node.left
  }

  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param  {Uint8Array} id The ID of the contact to fetch.
   * @return {Object|Null}   The contact if available, otherwise null
   */
  get (id) {
    ensureInt8('id', id)

    let bitIndex = 0

    let node = this.root
    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    // index of uses contact id for matching
    const index = this._indexOf(node, id)
    return index >= 0 ? node.contacts[index] : null
  }

  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id  Contact node id.
   * @return {Number}         Integer Index of contact with provided id if it
   *                          exists, -1 otherwise.
   */
  _indexOf (node, id) {
    for (let i = 0; i < node.contacts.length; ++i) {
      if (arrayEquals(node.contacts[i].id, id)) return i
    }

    return -1
  }

  /**
   * Removes contact with the provided id.
   *
   * @param  {Uint8Array} id The ID of the contact to remove.
   * @return {Object}        The k-bucket itself.
   */
  remove (id) {
    ensureInt8('the id as parameter 1', id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    const index = this._indexOf(node, id)
    if (index >= 0) {
      const contact = node.contacts.splice(index, 1)[0]
      this.emit('removed', contact)
    }

    return this
  }

  /**
   * Splits the node, redistributes contacts to the new nodes, and marks the
   * node that was split as an inner node of the binary tree of nodes by
   * setting this.root.contacts = null
   *
   * @param  {Object} node     node for splitting
   * @param  {Number} bitIndex the bitIndex to which byte to check in the
   *                           Uint8Array for navigating the binary tree
   */
  _split (node, bitIndex) {
    node.left = createNode()
    node.right = createNode()

    // redistribute existing contacts amongst the two newly created nodes
    for (const contact of node.contacts) {
      this._determineNode(node, contact.id, bitIndex).contacts.push(contact)
    }

    node.contacts = null // mark as inner tree node

    // don't split the "far away" node
    // we check where the local node would end up and mark the other one as
    // "dontSplit" (i.e. "far away")
    const detNode = this._determineNode(node, this.localNodeId, bitIndex)
    const otherNode = node.left === detNode ? node.right : node.left
    otherNode.dontSplit = true
  }

  /**
   * Returns all the contacts contained in the tree as an array.
   * If this is a leaf, return a copy of the bucket. If this is not a leaf,
   * return the union of the low and high branches (themselves also as arrays).
   *
   * @return {Array} All of the contacts in the tree, as an array
   */
  toArray () {
    let result = []
    for (const nodes = [this.root]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else result = result.concat(node.contacts)
    }
    return result
  }

  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @return {Iterable} All of the contacts in the tree, as an iterable
   */
  * toIterable () {
    for (const nodes = [this.root]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) {
        nodes.push(node.right, node.left)
      } else {
        yield * node.contacts
      }
    }
  }

  /**
   * Updates the contact selected by the arbiter.
   * If the selection is our old contact and the candidate is some new contact
   * then the new contact is abandoned (not added).
   * If the selection is our old contact and the candidate is our old contact
   * then we are refreshing the contact and it is marked as most recently
   * contacted (by being moved to the right/end of the bucket array).
   * If the selection is our new contact, the old contact is removed and the new
   * contact is marked as most recently contacted.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Number} index   the index in the bucket where contact exists
   *                          (index has already been computed in a previous
   *                          calculation)
   * @param  {Object} contact The contact object to update.
   */
  _update (node, index, contact) {
    // sanity check
    if (!arrayEquals(node.contacts[index].id, contact.id)) {
      throw new Error('wrong index for _update')
    }

    const incumbent = node.contacts[index]
    const selection = this.arbiter(incumbent, contact)
    // if the selection is our old contact and the candidate is some new
    // contact, then there is nothing to do
    if (selection === incumbent && incumbent !== contact) return

    node.contacts.splice(index, 1) // remove old contact
    node.contacts.push(selection) // add more recent contact version
    this.emit('updated', incumbent, selection)
  }
}

module.exports = KBucket

},{"randombytes":"node_modules/randombytes/browser.js","events":"node_modules/events/events.js"}],"node_modules/xor-distance/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
module.exports = dist

function dist (a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length')
  var result = Buffer.allocUnsafe(a.length)
  for (var i = 0; i < a.length; i++) result[i] = a[i] ^ b[i]
  return result
}

dist.compare = function compare (a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length')
  for (var i = 0; i < a.length; i++) {
    if (a[i] === b[i]) continue
    return a[i] < b[i] ? -1 : 1
  }
  return 0
}

dist.gt = function gt (a, b) {
  return dist.compare(a, b) === 1
}

dist.lt = function lt (a, b) {
  return dist.compare(a, b) === -1
}

dist.eq = function eq (a, b) {
  return dist.compare(a, b) === 0
}

},{"buffer":"node_modules/node-libs-browser/node_modules/buffer/index.js"}],"node_modules/p-map/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var AggregateError = require('aggregate-error');

module.exports = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(iterable, mapper) {
    var _ref2,
        _ref2$concurrency,
        concurrency,
        _ref2$stopOnError,
        stopOnError,
        _args2 = arguments;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref2 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref2$concurrency = _ref2.concurrency, concurrency = _ref2$concurrency === void 0 ? Infinity : _ref2$concurrency, _ref2$stopOnError = _ref2.stopOnError, stopOnError = _ref2$stopOnError === void 0 ? true : _ref2$stopOnError;
            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              if (typeof mapper !== 'function') {
                throw new TypeError('Mapper function is required');
              }

              if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
                throw new TypeError("Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `".concat(concurrency, "` (").concat(_typeof(concurrency), ")"));
              }

              var result = [];
              var errors = [];
              var iterator = iterable[Symbol.iterator]();
              var isRejected = false;
              var isIterableDone = false;
              var resolvingCount = 0;
              var currentIndex = 0;

              var next = function next() {
                if (isRejected) {
                  return;
                }

                var nextItem = iterator.next();
                var index = currentIndex;
                currentIndex++;

                if (nextItem.done) {
                  isIterableDone = true;

                  if (resolvingCount === 0) {
                    if (!stopOnError && errors.length !== 0) {
                      reject(new AggregateError(errors));
                    } else {
                      resolve(result);
                    }
                  }

                  return;
                }

                resolvingCount++;

                _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  var element;
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return nextItem.value;

                        case 3:
                          element = _context.sent;
                          _context.next = 6;
                          return mapper(element, index);

                        case 6:
                          result[index] = _context.sent;
                          resolvingCount--;
                          next();
                          _context.next = 14;
                          break;

                        case 11:
                          _context.prev = 11;
                          _context.t0 = _context["catch"](0);

                          if (stopOnError) {
                            isRejected = true;
                            reject(_context.t0);
                          } else {
                            errors.push(_context.t0);
                            resolvingCount--;
                            next();
                          }

                        case 14:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 11]]);
                }))();
              };

              for (var i = 0; i < concurrency; i++) {
                next();

                if (isIterableDone) {
                  break;
                }
              }
            }));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
},{"aggregate-error":"node_modules/aggregate-error/index.js"}],"node_modules/libp2p-kad-dht/src/utils.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var debug = require('debug');

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var _require2 = require('multiformats/bases/base58'),
    base58btc = _require2.base58btc;

var _require3 = require('interface-datastore'),
    Key = _require3.Key; // @ts-ignore


var distance = require('xor-distance');

var pMap = require('p-map');

var _require4 = require('libp2p-record'),
    Record = _require4.Record;

var PeerId = require('peer-id');

var errcode = require('err-code');

var uint8ArrayConcat = require('uint8arrays/concat');

var uint8ArrayFromString = require('uint8arrays/from-string');

var uint8ArrayToString = require('uint8arrays/to-string');

var pTimeout = require('p-timeout');
/**
 * Creates a DHT ID by hashing a given Uint8Array.
 *
 * @param {Uint8Array} buf
 * @returns {Promise<Uint8Array>}
 */


exports.convertBuffer = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(buf) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return sha256.digest(buf);

          case 2:
            return _context.abrupt("return", _context.sent.digest);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Creates a DHT ID by hashing a Peer ID
 *
 * @param {PeerId} peer
 * @returns {Promise<Uint8Array>}
 */


exports.convertPeerId = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return sha256.digest(peer.id);

          case 2:
            return _context2.abrupt("return", _context2.sent.digest);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Convert a Uint8Array to their SHA2-256 hash.
 *
 * @param {Uint8Array} buf
 * @returns {Key}
 */


exports.bufferToKey = function (buf) {
  return new Key('/' + exports.encodeBase32(buf), false);
};
/**
 * Generate the key for a public key.
 *
 * @param {PeerId} peer
 * @returns {Uint8Array}
 */


exports.keyForPublicKey = function (peer) {
  return uint8ArrayConcat([uint8ArrayFromString('/pk/'), peer.id]);
};
/**
 * @param {Uint8Array} key
 */


exports.isPublicKeyKey = function (key) {
  return uint8ArrayToString(key.slice(0, 4)) === '/pk/';
};
/**
 * @param {Uint8Array} key
 */


exports.fromPublicKeyKey = function (key) {
  return new PeerId(key.slice(4));
};
/**
 * Get the current time as timestamp.
 *
 * @returns {number}
 */


exports.now = function () {
  return Date.now();
};
/**
 * Encode a given Uint8Array into a base32 string.
 *
 * @param {Uint8Array} buf
 * @returns {string}
 */


exports.encodeBase32 = function (buf) {
  return uint8ArrayToString(buf, 'base32');
};
/**
 * Decode a given base32 string into a Uint8Array.
 *
 * @param {string} raw
 * @returns {Uint8Array}
 */


exports.decodeBase32 = function (raw) {
  return uint8ArrayFromString(raw, 'base32');
};
/**
 * Sort peers by distance to the given `target`.
 *
 * @param {Array<PeerId>} peers
 * @param {Uint8Array} target
 */


exports.sortClosestPeers = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peers, target) {
    var distances;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return pMap(peers, /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(peer) {
                var id;
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return exports.convertPeerId(peer);

                      case 2:
                        id = _context3.sent;
                        return _context3.abrupt("return", {
                          peer: peer,
                          distance: distance(id, target)
                        });

                      case 4:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x5) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 2:
            distances = _context4.sent;
            return _context4.abrupt("return", distances.sort(exports.xorCompare).map(function (d) {
              return d.peer;
            }));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Compare function to sort an array of elements which have a distance property which is the xor distance to a given element.
 *
 * @param {{ distance: Uint8Array }} a
 * @param {{ distance: Uint8Array }} b
 */


exports.xorCompare = function (a, b) {
  return distance.compare(a.distance, b.distance);
};
/**
 * Computes how many results to collect on each disjoint path, rounding up.
 * This ensures that we look for at least one result per path.
 *
 * @param {number} resultsWanted
 * @param {number} numPaths - total number of paths
 */


exports.pathSize = function (resultsWanted, numPaths) {
  return Math.ceil(resultsWanted / numPaths);
};
/**
 * Create a new put record, encodes and signs it if enabled.
 *
 * @param {Uint8Array} key
 * @param {Uint8Array} value
 * @returns {Uint8Array}
 */


exports.createPutRecord = function (key, value) {
  var timeReceived = new Date();
  var rec = new Record(key, value, timeReceived);
  return rec.serialize();
};
/**
 * Creates a logger for the given subsystem
 *
 * @param {PeerId} [id]
 * @param {string} [subsystem]
 */


exports.logger = function (id, subsystem) {
  var name = ['libp2p', 'dht'];

  if (subsystem) {
    name.push(subsystem);
  }

  if (id) {
    name.push("".concat(id.toB58String().slice(0, 8)));
  } // Add a formatter for converting to a base58 string


  debug.formatters.b = function (v) {
    return base58btc.baseEncode(v);
  };

  var logger = Object.assign(debug(name.join(':')), {
    error: debug(name.concat(['error']).join(':'))
  });
  return logger;
};

exports.TimeoutError = /*#__PURE__*/function (_Error) {
  _inherits(TimeoutError, _Error);

  var _super = _createSuper(TimeoutError);

  function TimeoutError() {
    _classCallCheck(this, TimeoutError);

    return _super.apply(this, arguments);
  }

  _createClass(TimeoutError, [{
    key: "code",
    get: function get() {
      return 'ETIMEDOUT';
    }
  }]);

  return TimeoutError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Creates an async function that calls the given `asyncFn` and Errors
 * if it does not resolve within `time` ms
 *
 * @template T
 * @param {(...args: any[]) => Promise<T>} asyncFn
 * @param {number} [time]
 */


exports.withTimeout = function (asyncFn, time) {
  /**
   * @param  {...any} args
   * @returns {Promise<T>}
   */
  function timeoutFn() {
    return _timeoutFn.apply(this, arguments);
  }

  function _timeoutFn() {
    _timeoutFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var res,
          _args5 = arguments;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (time) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return", asyncFn.apply(void 0, _args5));

            case 2:
              _context5.prev = 2;
              _context5.next = 5;
              return pTimeout(asyncFn.apply(void 0, _args5), time);

            case 5:
              res = _context5.sent;
              _context5.next = 13;
              break;

            case 8:
              _context5.prev = 8;
              _context5.t0 = _context5["catch"](2);

              if (!(_context5.t0 instanceof pTimeout.TimeoutError)) {
                _context5.next = 12;
                break;
              }

              throw errcode(_context5.t0, 'ETIMEDOUT');

            case 12:
              throw _context5.t0;

            case 13:
              return _context5.abrupt("return", res);

            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[2, 8]]);
    }));
    return _timeoutFn.apply(this, arguments);
  }

  return timeoutFn;
};
/**
 * Iterates the given `asyncIterator` and runs each item through the given `asyncFn` in parallel.
 * Returns a promise that resolves when all items of the `asyncIterator` have been passed
 * through `asyncFn`.
 *
 * @template T
 * @template O
 *
 * @param {AsyncIterable<T>} asyncIterator
 * @param {(arg0: T) => Promise<O>} asyncFn
 */


exports.mapParallel = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(asyncIterator, asyncFn) {
    var tasks, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            tasks = [];
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context6.prev = 3;
            _iterator = _asyncIterator(asyncIterator);

          case 5:
            _context6.next = 7;
            return _iterator.next();

          case 7:
            if (!(_iteratorAbruptCompletion = !(_step = _context6.sent).done)) {
              _context6.next = 13;
              break;
            }

            item = _step.value;
            tasks.push(asyncFn(item));

          case 10:
            _iteratorAbruptCompletion = false;
            _context6.next = 5;
            break;

          case 13:
            _context6.next = 19;
            break;

          case 15:
            _context6.prev = 15;
            _context6.t0 = _context6["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 19:
            _context6.prev = 19;
            _context6.prev = 20;

            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context6.next = 24;
              break;
            }

            _context6.next = 24;
            return _iterator.return();

          case 24:
            _context6.prev = 24;

            if (!_didIteratorError) {
              _context6.next = 27;
              break;
            }

            throw _iteratorError;

          case 27:
            return _context6.finish(24);

          case 28:
            return _context6.finish(19);

          case 29:
            return _context6.abrupt("return", Promise.all(tasks));

          case 30:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[3, 15, 19, 29], [20,, 24, 28]]);
  }));

  return function (_x6, _x7) {
    return _ref5.apply(this, arguments);
  };
}();
},{"debug":"node_modules/debug/src/browser.js","multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","interface-datastore":"node_modules/interface-datastore/src/index.js","xor-distance":"node_modules/xor-distance/index.js","p-map":"node_modules/p-map/index.js","libp2p-record":"node_modules/libp2p-record/src/index.js","peer-id":"node_modules/peer-id/src/index.js","err-code":"node_modules/err-code/index.js","uint8arrays/concat":"node_modules/uint8arrays/concat.js","uint8arrays/from-string":"node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","p-timeout":"node_modules/p-timeout/index.js"}],"node_modules/libp2p-kad-dht/src/routing.js":[function(require,module,exports) {
'use strict'; // @ts-ignore

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var KBucket = require('k-bucket');

var utils = require('./utils');
/**
 * @typedef {import('peer-id')} PeerId
 *
 * @typedef {object} KBucketPeer
 * @property {Uint8Array} id
 * @property {PeerId} peer
 */

/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */


var RoutingTable = /*#__PURE__*/function () {
  /**
   * @param {PeerId} self
   * @param {number} kBucketSize
   */
  function RoutingTable(self, kBucketSize) {
    _classCallCheck(this, RoutingTable);

    this.self = self;
    this._onPing = this._onPing.bind(this);

    this._onInit(kBucketSize);
  }
  /**
   * @param {number} kBucketSize
   */


  _createClass(RoutingTable, [{
    key: "_onInit",
    value: function () {
      var _onInit2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(kBucketSize) {
        var selfKey;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return utils.convertPeerId(this.self);

              case 2:
                selfKey = _context.sent;
                this.kb = new KBucket({
                  localNodeId: selfKey,
                  numberOfNodesPerKBucket: kBucketSize,
                  numberOfNodesToPing: 1
                });
                this.kb.on('ping', this._onPing);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _onInit(_x) {
        return _onInit2.apply(this, arguments);
      }

      return _onInit;
    }()
    /**
     * Called on the `ping` event from `k-bucket`.
     * Currently this just removes the oldest contact from
     * the list, without actually pinging the individual peers.
     * This is the same as go does, but should probably
     * be upgraded to actually ping the individual peers.
     *
     * @param {KBucketPeer[]} oldContacts
     * @param {KBucketPeer} newContact
     */

  }, {
    key: "_onPing",
    value: function _onPing(oldContacts, newContact) {
      // just use the first one (k-bucket sorts from oldest to newest)
      var oldest = oldContacts[0];

      if (oldest) {
        // remove the oldest one
        this.kb.remove(oldest.id);
      } // add the new one


      this.kb.add(newContact);
    } // -- Public Interface

    /**
     * Amount of currently stored peers.
     */

  }, {
    key: "size",
    get: function get() {
      return this.kb.count();
    }
    /**
     * Find a specific peer by id.
     *
     * @param {PeerId} peer
     * @returns {Promise<PeerId | undefined>}
     */

  }, {
    key: "find",
    value: function () {
      var _find = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
        var key, closest;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return utils.convertPeerId(peer);

              case 2:
                key = _context2.sent;
                closest = this.closestPeer(key);

                if (!(closest && peer.equals(closest))) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", closest);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function find(_x2) {
        return _find.apply(this, arguments);
      }

      return find;
    }()
    /**
     * Retrieve the closest peers to the given key.
     *
     * @param {Uint8Array} key
     */

  }, {
    key: "closestPeer",
    value: function closestPeer(key) {
      var res = this.closestPeers(key, 1);

      if (res.length > 0) {
        return res[0];
      }
    }
    /**
     * Retrieve the `count`-closest peers to the given key.
     *
     * @param {Uint8Array} key
     * @param {number} count
     */

  }, {
    key: "closestPeers",
    value: function closestPeers(key, count) {
      /** @type {KBucketPeer[]} */
      var closest = this.kb.closest(key, count);
      return closest.map(function (p) {
        return p.peer;
      });
    }
    /**
     * Add or update the routing table with the given peer.
     *
     * @param {PeerId} peer
     */

  }, {
    key: "add",
    value: function () {
      var _add = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(peer) {
        var id;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return utils.convertPeerId(peer);

              case 2:
                id = _context3.sent;
                this.kb.add({
                  id: id,
                  peer: peer
                });

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function add(_x3) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
    /**
     * Remove a given peer from the table.
     *
     * @param {PeerId} peer
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peer) {
        var id;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return utils.convertPeerId(peer);

              case 2:
                id = _context4.sent;
                this.kb.remove(id);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function remove(_x4) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }]);

  return RoutingTable;
}();

module.exports = RoutingTable;
},{"k-bucket":"node_modules/k-bucket/index.js","./utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/constants.js":[function(require,module,exports) {
'use strict'; // MaxRecordAge specifies the maximum time that any node will hold onto a record
// from the time its received. This does not apply to any other forms of validity that
// the record may contain.
// For example, a record may contain an ipns entry with an EOL saying its valid
// until the year 2020 (a great time in the future). For that record to stick around
// it must be rebroadcasted more frequently than once every 'MaxRecordAge'

var second = exports.second = 1000;
var minute = exports.minute = 60 * second;
var hour = exports.hour = 60 * minute;
exports.MAX_RECORD_AGE = 36 * hour;
exports.PROTOCOL_DHT = '/kad/1.0.0';
exports.PROVIDERS_KEY_PREFIX = '/providers/';
exports.PROVIDERS_LRU_CACHE_SIZE = 256;
exports.PROVIDERS_VALIDITY = 24 * hour;
exports.PROVIDERS_CLEANUP_INTERVAL = hour;
exports.READ_MESSAGE_TIMEOUT = 10 * second; // The number of records that will be retrieved on a call to getMany()

exports.GET_MANY_RECORD_COUNT = 16; // K is the maximum number of requests to perform before returning failure

exports.K = 20; // Alpha is the concurrency for asynchronous requests

exports.ALPHA = 3;
exports.defaultRandomWalk = {
  enabled: true,
  queriesPerPeriod: 1,
  interval: 5 * minute,
  timeout: 10 * second,
  delay: 10 * second
};
},{}],"node_modules/libp2p-interfaces/src/topology/multicodec-topology.js":[function(require,module,exports) {
'use strict'

const Topology = require('./index')
const multicodecTopologySymbol = Symbol.for('@libp2p/js-interfaces/topology/multicodec-topology')

class MulticodecTopology extends Topology {
  /**
   * @param {TopologyOptions & MulticodecOptions} props
   */
  constructor ({
    min,
    max,
    multicodecs,
    handlers
  }) {
    super({ min, max, handlers })

    if (!multicodecs) {
      throw new Error('one or more multicodec should be provided')
    }

    if (!handlers) {
      throw new Error('the handlers should be provided')
    }

    if (typeof handlers.onConnect !== 'function') {
      throw new Error('the \'onConnect\' handler must be provided')
    }

    if (typeof handlers.onDisconnect !== 'function') {
      throw new Error('the \'onDisconnect\' handler must be provided')
    }

    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs]
    this._registrar = undefined

    this._onProtocolChange = this._onProtocolChange.bind(this)
    this._onPeerConnect = this._onPeerConnect.bind(this)
  }

  get [Symbol.toStringTag] () {
    return 'Topology'
  }

  get [multicodecTopologySymbol] () {
    return true
  }

  /**
   * Checks if the given value is a `MulticodecTopology` instance.
   *
   * @param {any} other
   * @returns {other is MulticodecTopology}
   */
  static isMulticodecTopology (other) {
    return Boolean(other && other[multicodecTopologySymbol])
  }

  /**
   * @param {any} registrar
   */
  set registrar (registrar) { // eslint-disable-line
    this._registrar = registrar
    this._registrar.peerStore.on('change:protocols', this._onProtocolChange)
    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect)

    // Update topology peers
    this._updatePeers(this._registrar.peerStore.peers.values())
  }

  /**
   * Update topology.
   *
   * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable
   * @returns {void}
   */
  _updatePeers (peerDataIterable) {
    for (const { id, protocols } of peerDataIterable) {
      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {
        // Add the peer regardless of whether or not there is currently a connection
        this.peers.add(id.toB58String())
        // If there is a connection, call _onConnect
        const connection = this._registrar.getConnection(id)
        connection && this._onConnect(id, connection)
      } else {
        // Remove any peers we might be tracking that are no longer of value to us
        this.peers.delete(id.toB58String())
      }
    }
  }

  /**
   * Check if a new peer support the multicodecs for this topology.
   *
   * @param {Object} props
   * @param {PeerId} props.peerId
   * @param {Array<string>} props.protocols
   */
  _onProtocolChange ({ peerId, protocols }) {
    const hadPeer = this.peers.has(peerId.toB58String())
    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol))

    // Not supporting the protocol anymore?
    if (hadPeer && hasProtocol.length === 0) {
      this._onDisconnect(peerId)
    }

    // New to protocol support
    for (const protocol of protocols) {
      if (this.multicodecs.includes(protocol)) {
        const peerData = this._registrar.peerStore.get(peerId)
        this._updatePeers([peerData])
        return
      }
    }
  }

  /**
   * Verify if a new connected peer has a topology multicodec and call _onConnect.
   *
   * @param {Connection} connection
   * @returns {void}
   */
  _onPeerConnect (connection) {
    // @ts-ignore - remotePeer does not existist on Connection
    const peerId = connection.remotePeer
    const protocols = this._registrar.peerStore.protoBook.get(peerId)

    if (!protocols) {
      return
    }

    if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {
      this.peers.add(peerId.toB58String())
      this._onConnect(peerId, connection)
    }
  }
}

/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr')} Multiaddr
 * @typedef {import('../connection/connection')} Connection
 * @typedef {import('.').Options} TopologyOptions
 * @typedef {Object} MulticodecOptions
 * @property {string[]} multicodecs - protocol multicodecs
 * @property {Required<Handlers>} handlers
 * @typedef {import('.').Handlers} Handlers
 */
module.exports = MulticodecTopology

},{"./index":"node_modules/libp2p-interfaces/src/topology/index.js"}],"node_modules/libp2p-kad-dht/src/message/dht.js":[function(require,module,exports) {
/*eslint-disable*/
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var $protobuf = require("protobufjs/minimal"); // Common aliases


var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util; // Exported root namespace

var $root = $protobuf.roots["libp2p-dht-message"] || ($protobuf.roots["libp2p-dht-message"] = {});

$root.Record = function () {
  /**
   * Properties of a Record.
   * @exports IRecord
   * @interface IRecord
   * @property {Uint8Array|null} [key] Record key
   * @property {Uint8Array|null} [value] Record value
   * @property {Uint8Array|null} [author] Record author
   * @property {Uint8Array|null} [signature] Record signature
   * @property {string|null} [timeReceived] Record timeReceived
   */

  /**
   * Constructs a new Record.
   * @exports Record
   * @classdesc Represents a Record.
   * @implements IRecord
   * @constructor
   * @param {IRecord=} [p] Properties to set
   */
  function Record(p) {
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Record key.
   * @member {Uint8Array|null|undefined} key
   * @memberof Record
   * @instance
   */


  Record.prototype.key = null;
  /**
   * Record value.
   * @member {Uint8Array|null|undefined} value
   * @memberof Record
   * @instance
   */

  Record.prototype.value = null;
  /**
   * Record author.
   * @member {Uint8Array|null|undefined} author
   * @memberof Record
   * @instance
   */

  Record.prototype.author = null;
  /**
   * Record signature.
   * @member {Uint8Array|null|undefined} signature
   * @memberof Record
   * @instance
   */

  Record.prototype.signature = null;
  /**
   * Record timeReceived.
   * @member {string|null|undefined} timeReceived
   * @memberof Record
   * @instance
   */

  Record.prototype.timeReceived = null; // OneOf field names bound to virtual getters and setters

  var $oneOfFields;
  /**
   * Record _key.
   * @member {"key"|undefined} _key
   * @memberof Record
   * @instance
   */

  Object.defineProperty(Record.prototype, "_key", {
    get: $util.oneOfGetter($oneOfFields = ["key"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Record _value.
   * @member {"value"|undefined} _value
   * @memberof Record
   * @instance
   */

  Object.defineProperty(Record.prototype, "_value", {
    get: $util.oneOfGetter($oneOfFields = ["value"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Record _author.
   * @member {"author"|undefined} _author
   * @memberof Record
   * @instance
   */

  Object.defineProperty(Record.prototype, "_author", {
    get: $util.oneOfGetter($oneOfFields = ["author"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Record _signature.
   * @member {"signature"|undefined} _signature
   * @memberof Record
   * @instance
   */

  Object.defineProperty(Record.prototype, "_signature", {
    get: $util.oneOfGetter($oneOfFields = ["signature"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Record _timeReceived.
   * @member {"timeReceived"|undefined} _timeReceived
   * @memberof Record
   * @instance
   */

  Object.defineProperty(Record.prototype, "_timeReceived", {
    get: $util.oneOfGetter($oneOfFields = ["timeReceived"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Encodes the specified Record message. Does not implicitly {@link Record.verify|verify} messages.
   * @function encode
   * @memberof Record
   * @static
   * @param {IRecord} m Record message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Record.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key")) w.uint32(10).bytes(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(18).bytes(m.value);
    if (m.author != null && Object.hasOwnProperty.call(m, "author")) w.uint32(26).bytes(m.author);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature")) w.uint32(34).bytes(m.signature);
    if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived")) w.uint32(42).string(m.timeReceived);
    return w;
  };
  /**
   * Decodes a Record message from the specified reader or buffer.
   * @function decode
   * @memberof Record
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Record} Record
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Record.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Record();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.key = r.bytes();
          break;

        case 2:
          m.value = r.bytes();
          break;

        case 3:
          m.author = r.bytes();
          break;

        case 4:
          m.signature = r.bytes();
          break;

        case 5:
          m.timeReceived = r.string();
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a Record message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Record
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Record} Record
   */


  Record.fromObject = function fromObject(d) {
    if (d instanceof $root.Record) return d;
    var m = new $root.Record();

    if (d.key != null) {
      if (typeof d.key === "string") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;
    }

    if (d.value != null) {
      if (typeof d.value === "string") $util.base64.decode(d.value, m.value = $util.newBuffer($util.base64.length(d.value)), 0);else if (d.value.length) m.value = d.value;
    }

    if (d.author != null) {
      if (typeof d.author === "string") $util.base64.decode(d.author, m.author = $util.newBuffer($util.base64.length(d.author)), 0);else if (d.author.length) m.author = d.author;
    }

    if (d.signature != null) {
      if (typeof d.signature === "string") $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);else if (d.signature.length) m.signature = d.signature;
    }

    if (d.timeReceived != null) {
      m.timeReceived = String(d.timeReceived);
    }

    return m;
  };
  /**
   * Creates a plain object from a Record message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Record
   * @static
   * @param {Record} m Record
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Record.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
      if (o.oneofs) d._key = "key";
    }

    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
      if (o.oneofs) d._value = "value";
    }

    if (m.author != null && m.hasOwnProperty("author")) {
      d.author = o.bytes === String ? $util.base64.encode(m.author, 0, m.author.length) : o.bytes === Array ? Array.prototype.slice.call(m.author) : m.author;
      if (o.oneofs) d._author = "author";
    }

    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
      if (o.oneofs) d._signature = "signature";
    }

    if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
      d.timeReceived = m.timeReceived;
      if (o.oneofs) d._timeReceived = "timeReceived";
    }

    return d;
  };
  /**
   * Converts this Record to JSON.
   * @function toJSON
   * @memberof Record
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Record.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };

  return Record;
}();

$root.Message = function () {
  /**
   * Properties of a Message.
   * @exports IMessage
   * @interface IMessage
   * @property {Message.MessageType|null} [type] Message type
   * @property {number|null} [clusterLevelRaw] Message clusterLevelRaw
   * @property {Uint8Array|null} [key] Message key
   * @property {Uint8Array|null} [record] Message record
   * @property {Array.<Message.IPeer>|null} [closerPeers] Message closerPeers
   * @property {Array.<Message.IPeer>|null} [providerPeers] Message providerPeers
   */

  /**
   * Constructs a new Message.
   * @exports Message
   * @classdesc Represents a Message.
   * @implements IMessage
   * @constructor
   * @param {IMessage=} [p] Properties to set
   */
  function Message(p) {
    this.closerPeers = [];
    this.providerPeers = [];
    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
      if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
    }
  }
  /**
   * Message type.
   * @member {Message.MessageType|null|undefined} type
   * @memberof Message
   * @instance
   */


  Message.prototype.type = null;
  /**
   * Message clusterLevelRaw.
   * @member {number|null|undefined} clusterLevelRaw
   * @memberof Message
   * @instance
   */

  Message.prototype.clusterLevelRaw = null;
  /**
   * Message key.
   * @member {Uint8Array|null|undefined} key
   * @memberof Message
   * @instance
   */

  Message.prototype.key = null;
  /**
   * Message record.
   * @member {Uint8Array|null|undefined} record
   * @memberof Message
   * @instance
   */

  Message.prototype.record = null;
  /**
   * Message closerPeers.
   * @member {Array.<Message.IPeer>} closerPeers
   * @memberof Message
   * @instance
   */

  Message.prototype.closerPeers = $util.emptyArray;
  /**
   * Message providerPeers.
   * @member {Array.<Message.IPeer>} providerPeers
   * @memberof Message
   * @instance
   */

  Message.prototype.providerPeers = $util.emptyArray; // OneOf field names bound to virtual getters and setters

  var $oneOfFields;
  /**
   * Message _type.
   * @member {"type"|undefined} _type
   * @memberof Message
   * @instance
   */

  Object.defineProperty(Message.prototype, "_type", {
    get: $util.oneOfGetter($oneOfFields = ["type"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Message _clusterLevelRaw.
   * @member {"clusterLevelRaw"|undefined} _clusterLevelRaw
   * @memberof Message
   * @instance
   */

  Object.defineProperty(Message.prototype, "_clusterLevelRaw", {
    get: $util.oneOfGetter($oneOfFields = ["clusterLevelRaw"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Message _key.
   * @member {"key"|undefined} _key
   * @memberof Message
   * @instance
   */

  Object.defineProperty(Message.prototype, "_key", {
    get: $util.oneOfGetter($oneOfFields = ["key"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Message _record.
   * @member {"record"|undefined} _record
   * @memberof Message
   * @instance
   */

  Object.defineProperty(Message.prototype, "_record", {
    get: $util.oneOfGetter($oneOfFields = ["record"]),
    set: $util.oneOfSetter($oneOfFields)
  });
  /**
   * Encodes the specified Message message. Does not implicitly {@link Message.verify|verify} messages.
   * @function encode
   * @memberof Message
   * @static
   * @param {IMessage} m Message message or plain object to encode
   * @param {$protobuf.Writer} [w] Writer to encode to
   * @returns {$protobuf.Writer} Writer
   */

  Message.encode = function encode(m, w) {
    if (!w) w = $Writer.create();
    if (m.type != null && Object.hasOwnProperty.call(m, "type")) w.uint32(8).int32(m.type);
    if (m.key != null && Object.hasOwnProperty.call(m, "key")) w.uint32(18).bytes(m.key);
    if (m.record != null && Object.hasOwnProperty.call(m, "record")) w.uint32(26).bytes(m.record);

    if (m.closerPeers != null && m.closerPeers.length) {
      for (var i = 0; i < m.closerPeers.length; ++i) {
        $root.Message.Peer.encode(m.closerPeers[i], w.uint32(66).fork()).ldelim();
      }
    }

    if (m.providerPeers != null && m.providerPeers.length) {
      for (var i = 0; i < m.providerPeers.length; ++i) {
        $root.Message.Peer.encode(m.providerPeers[i], w.uint32(74).fork()).ldelim();
      }
    }

    if (m.clusterLevelRaw != null && Object.hasOwnProperty.call(m, "clusterLevelRaw")) w.uint32(80).int32(m.clusterLevelRaw);
    return w;
  };
  /**
   * Decodes a Message message from the specified reader or buffer.
   * @function decode
   * @memberof Message
   * @static
   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
   * @param {number} [l] Message length if known beforehand
   * @returns {Message} Message
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */


  Message.decode = function decode(r, l) {
    if (!(r instanceof $Reader)) r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l,
        m = new $root.Message();

    while (r.pos < c) {
      var t = r.uint32();

      switch (t >>> 3) {
        case 1:
          m.type = r.int32();
          break;

        case 10:
          m.clusterLevelRaw = r.int32();
          break;

        case 2:
          m.key = r.bytes();
          break;

        case 3:
          m.record = r.bytes();
          break;

        case 8:
          if (!(m.closerPeers && m.closerPeers.length)) m.closerPeers = [];
          m.closerPeers.push($root.Message.Peer.decode(r, r.uint32()));
          break;

        case 9:
          if (!(m.providerPeers && m.providerPeers.length)) m.providerPeers = [];
          m.providerPeers.push($root.Message.Peer.decode(r, r.uint32()));
          break;

        default:
          r.skipType(t & 7);
          break;
      }
    }

    return m;
  };
  /**
   * Creates a Message message from a plain object. Also converts values to their respective internal types.
   * @function fromObject
   * @memberof Message
   * @static
   * @param {Object.<string,*>} d Plain object
   * @returns {Message} Message
   */


  Message.fromObject = function fromObject(d) {
    if (d instanceof $root.Message) return d;
    var m = new $root.Message();

    switch (d.type) {
      case "PUT_VALUE":
      case 0:
        m.type = 0;
        break;

      case "GET_VALUE":
      case 1:
        m.type = 1;
        break;

      case "ADD_PROVIDER":
      case 2:
        m.type = 2;
        break;

      case "GET_PROVIDERS":
      case 3:
        m.type = 3;
        break;

      case "FIND_NODE":
      case 4:
        m.type = 4;
        break;

      case "PING":
      case 5:
        m.type = 5;
        break;
    }

    if (d.clusterLevelRaw != null) {
      m.clusterLevelRaw = d.clusterLevelRaw | 0;
    }

    if (d.key != null) {
      if (typeof d.key === "string") $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);else if (d.key.length) m.key = d.key;
    }

    if (d.record != null) {
      if (typeof d.record === "string") $util.base64.decode(d.record, m.record = $util.newBuffer($util.base64.length(d.record)), 0);else if (d.record.length) m.record = d.record;
    }

    if (d.closerPeers) {
      if (!Array.isArray(d.closerPeers)) throw TypeError(".Message.closerPeers: array expected");
      m.closerPeers = [];

      for (var i = 0; i < d.closerPeers.length; ++i) {
        if (_typeof(d.closerPeers[i]) !== "object") throw TypeError(".Message.closerPeers: object expected");
        m.closerPeers[i] = $root.Message.Peer.fromObject(d.closerPeers[i]);
      }
    }

    if (d.providerPeers) {
      if (!Array.isArray(d.providerPeers)) throw TypeError(".Message.providerPeers: array expected");
      m.providerPeers = [];

      for (var i = 0; i < d.providerPeers.length; ++i) {
        if (_typeof(d.providerPeers[i]) !== "object") throw TypeError(".Message.providerPeers: object expected");
        m.providerPeers[i] = $root.Message.Peer.fromObject(d.providerPeers[i]);
      }
    }

    return m;
  };
  /**
   * Creates a plain object from a Message message. Also converts values to other types if specified.
   * @function toObject
   * @memberof Message
   * @static
   * @param {Message} m Message
   * @param {$protobuf.IConversionOptions} [o] Conversion options
   * @returns {Object.<string,*>} Plain object
   */


  Message.toObject = function toObject(m, o) {
    if (!o) o = {};
    var d = {};

    if (o.arrays || o.defaults) {
      d.closerPeers = [];
      d.providerPeers = [];
    }

    if (m.type != null && m.hasOwnProperty("type")) {
      d.type = o.enums === String ? $root.Message.MessageType[m.type] : m.type;
      if (o.oneofs) d._type = "type";
    }

    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
      if (o.oneofs) d._key = "key";
    }

    if (m.record != null && m.hasOwnProperty("record")) {
      d.record = o.bytes === String ? $util.base64.encode(m.record, 0, m.record.length) : o.bytes === Array ? Array.prototype.slice.call(m.record) : m.record;
      if (o.oneofs) d._record = "record";
    }

    if (m.closerPeers && m.closerPeers.length) {
      d.closerPeers = [];

      for (var j = 0; j < m.closerPeers.length; ++j) {
        d.closerPeers[j] = $root.Message.Peer.toObject(m.closerPeers[j], o);
      }
    }

    if (m.providerPeers && m.providerPeers.length) {
      d.providerPeers = [];

      for (var j = 0; j < m.providerPeers.length; ++j) {
        d.providerPeers[j] = $root.Message.Peer.toObject(m.providerPeers[j], o);
      }
    }

    if (m.clusterLevelRaw != null && m.hasOwnProperty("clusterLevelRaw")) {
      d.clusterLevelRaw = m.clusterLevelRaw;
      if (o.oneofs) d._clusterLevelRaw = "clusterLevelRaw";
    }

    return d;
  };
  /**
   * Converts this Message to JSON.
   * @function toJSON
   * @memberof Message
   * @instance
   * @returns {Object.<string,*>} JSON object
   */


  Message.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  /**
   * MessageType enum.
   * @name Message.MessageType
   * @enum {number}
   * @property {number} PUT_VALUE=0 PUT_VALUE value
   * @property {number} GET_VALUE=1 GET_VALUE value
   * @property {number} ADD_PROVIDER=2 ADD_PROVIDER value
   * @property {number} GET_PROVIDERS=3 GET_PROVIDERS value
   * @property {number} FIND_NODE=4 FIND_NODE value
   * @property {number} PING=5 PING value
   */


  Message.MessageType = function () {
    var valuesById = {},
        values = Object.create(valuesById);
    values[valuesById[0] = "PUT_VALUE"] = 0;
    values[valuesById[1] = "GET_VALUE"] = 1;
    values[valuesById[2] = "ADD_PROVIDER"] = 2;
    values[valuesById[3] = "GET_PROVIDERS"] = 3;
    values[valuesById[4] = "FIND_NODE"] = 4;
    values[valuesById[5] = "PING"] = 5;
    return values;
  }();
  /**
   * ConnectionType enum.
   * @name Message.ConnectionType
   * @enum {number}
   * @property {number} NOT_CONNECTED=0 NOT_CONNECTED value
   * @property {number} CONNECTED=1 CONNECTED value
   * @property {number} CAN_CONNECT=2 CAN_CONNECT value
   * @property {number} CANNOT_CONNECT=3 CANNOT_CONNECT value
   */


  Message.ConnectionType = function () {
    var valuesById = {},
        values = Object.create(valuesById);
    values[valuesById[0] = "NOT_CONNECTED"] = 0;
    values[valuesById[1] = "CONNECTED"] = 1;
    values[valuesById[2] = "CAN_CONNECT"] = 2;
    values[valuesById[3] = "CANNOT_CONNECT"] = 3;
    return values;
  }();

  Message.Peer = function () {
    /**
     * Properties of a Peer.
     * @memberof Message
     * @interface IPeer
     * @property {Uint8Array|null} [id] Peer id
     * @property {Array.<Uint8Array>|null} [addrs] Peer addrs
     * @property {Message.ConnectionType|null} [connection] Peer connection
     */

    /**
     * Constructs a new Peer.
     * @memberof Message
     * @classdesc Represents a Peer.
     * @implements IPeer
     * @constructor
     * @param {Message.IPeer=} [p] Properties to set
     */
    function Peer(p) {
      this.addrs = [];
      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) {
        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
      }
    }
    /**
     * Peer id.
     * @member {Uint8Array|null|undefined} id
     * @memberof Message.Peer
     * @instance
     */


    Peer.prototype.id = null;
    /**
     * Peer addrs.
     * @member {Array.<Uint8Array>} addrs
     * @memberof Message.Peer
     * @instance
     */

    Peer.prototype.addrs = $util.emptyArray;
    /**
     * Peer connection.
     * @member {Message.ConnectionType|null|undefined} connection
     * @memberof Message.Peer
     * @instance
     */

    Peer.prototype.connection = null; // OneOf field names bound to virtual getters and setters

    var $oneOfFields;
    /**
     * Peer _id.
     * @member {"id"|undefined} _id
     * @memberof Message.Peer
     * @instance
     */

    Object.defineProperty(Peer.prototype, "_id", {
      get: $util.oneOfGetter($oneOfFields = ["id"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    /**
     * Peer _connection.
     * @member {"connection"|undefined} _connection
     * @memberof Message.Peer
     * @instance
     */

    Object.defineProperty(Peer.prototype, "_connection", {
      get: $util.oneOfGetter($oneOfFields = ["connection"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    /**
     * Encodes the specified Peer message. Does not implicitly {@link Message.Peer.verify|verify} messages.
     * @function encode
     * @memberof Message.Peer
     * @static
     * @param {Message.IPeer} m Peer message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */

    Peer.encode = function encode(m, w) {
      if (!w) w = $Writer.create();
      if (m.id != null && Object.hasOwnProperty.call(m, "id")) w.uint32(10).bytes(m.id);

      if (m.addrs != null && m.addrs.length) {
        for (var i = 0; i < m.addrs.length; ++i) {
          w.uint32(18).bytes(m.addrs[i]);
        }
      }

      if (m.connection != null && Object.hasOwnProperty.call(m, "connection")) w.uint32(24).int32(m.connection);
      return w;
    };
    /**
     * Decodes a Peer message from the specified reader or buffer.
     * @function decode
     * @memberof Message.Peer
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Message.Peer} Peer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */


    Peer.decode = function decode(r, l) {
      if (!(r instanceof $Reader)) r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l,
          m = new $root.Message.Peer();

      while (r.pos < c) {
        var t = r.uint32();

        switch (t >>> 3) {
          case 1:
            m.id = r.bytes();
            break;

          case 2:
            if (!(m.addrs && m.addrs.length)) m.addrs = [];
            m.addrs.push(r.bytes());
            break;

          case 3:
            m.connection = r.int32();
            break;

          default:
            r.skipType(t & 7);
            break;
        }
      }

      return m;
    };
    /**
     * Creates a Peer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Message.Peer
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Message.Peer} Peer
     */


    Peer.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.Peer) return d;
      var m = new $root.Message.Peer();

      if (d.id != null) {
        if (typeof d.id === "string") $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);else if (d.id.length) m.id = d.id;
      }

      if (d.addrs) {
        if (!Array.isArray(d.addrs)) throw TypeError(".Message.Peer.addrs: array expected");
        m.addrs = [];

        for (var i = 0; i < d.addrs.length; ++i) {
          if (typeof d.addrs[i] === "string") $util.base64.decode(d.addrs[i], m.addrs[i] = $util.newBuffer($util.base64.length(d.addrs[i])), 0);else if (d.addrs[i].length) m.addrs[i] = d.addrs[i];
        }
      }

      switch (d.connection) {
        case "NOT_CONNECTED":
        case 0:
          m.connection = 0;
          break;

        case "CONNECTED":
        case 1:
          m.connection = 1;
          break;

        case "CAN_CONNECT":
        case 2:
          m.connection = 2;
          break;

        case "CANNOT_CONNECT":
        case 3:
          m.connection = 3;
          break;
      }

      return m;
    };
    /**
     * Creates a plain object from a Peer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Message.Peer
     * @static
     * @param {Message.Peer} m Peer
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */


    Peer.toObject = function toObject(m, o) {
      if (!o) o = {};
      var d = {};

      if (o.arrays || o.defaults) {
        d.addrs = [];
      }

      if (m.id != null && m.hasOwnProperty("id")) {
        d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
        if (o.oneofs) d._id = "id";
      }

      if (m.addrs && m.addrs.length) {
        d.addrs = [];

        for (var j = 0; j < m.addrs.length; ++j) {
          d.addrs[j] = o.bytes === String ? $util.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
        }
      }

      if (m.connection != null && m.hasOwnProperty("connection")) {
        d.connection = o.enums === String ? $root.Message.ConnectionType[m.connection] : m.connection;
        if (o.oneofs) d._connection = "connection";
      }

      return d;
    };
    /**
     * Converts this Peer to JSON.
     * @function toJSON
     * @memberof Message.Peer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */


    Peer.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Peer;
  }();

  return Message;
}();

module.exports = $root;
},{"protobufjs/minimal":"node_modules/protobufjs/minimal.js"}],"node_modules/libp2p-kad-dht/src/message/index.js":[function(require,module,exports) {
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PeerId = require('peer-id');

var _require = require('multiaddr'),
    Multiaddr = _require.Multiaddr;

var _require2 = require('libp2p-record'),
    Record = _require2.Record;

var Proto = require('./dht');

var MESSAGE_TYPE = Proto.Message.MessageType;
var CONNECTION_TYPE = Proto.Message.ConnectionType;
/**
 * @typedef {0|1|2|3|4} ConnectionType
 *
 * @typedef {object} PBPeer
 * @property {Uint8Array} id
 * @property {Uint8Array[]} addrs
 * @property {ConnectionType} connection
 *
 * @typedef {import('../index').PeerData} PeerData
 */

/**
 * Represents a single DHT control message.
 */

var Message = /*#__PURE__*/function () {
  /**
   * @param {import('./dht').Message.MessageType} type
   * @param {Uint8Array} key
   * @param {number} level
   */
  function Message(type, key, level) {
    _classCallCheck(this, Message);

    if (key && !(key instanceof Uint8Array)) {
      throw new Error('Key must be a Uint8Array');
    }

    this.type = type;
    this.key = key;
    this._clusterLevelRaw = level;
    /** @type {PeerData[]} */

    this.closerPeers = [];
    /** @type {PeerData[]} */

    this.providerPeers = [];
    /** @type {import('libp2p-record').Record | undefined} */

    this.record = undefined;
  }
  /**
   * @type {number}
   */


  _createClass(Message, [{
    key: "clusterLevel",
    get: function get() {
      var level = this._clusterLevelRaw - 1;

      if (level < 0) {
        return 0;
      }

      return level;
    },
    set: function set(level) {
      this._clusterLevelRaw = level;
    }
    /**
     * Encode into protobuf
     */

  }, {
    key: "serialize",
    value: function serialize() {
      var obj = {
        key: this.key,
        type: this.type,
        clusterLevelRaw: this._clusterLevelRaw,
        closerPeers: this.closerPeers.map(toPbPeer),
        providerPeers: this.providerPeers.map(toPbPeer),

        /** @type {Uint8Array | undefined} */
        record: undefined
      };

      if (this.record) {
        if (this.record instanceof Uint8Array) {
          obj.record = this.record;
        } else {
          obj.record = this.record.serialize();
        }
      }

      return Proto.Message.encode(obj).finish();
    }
    /**
     * Decode from protobuf
     *
     * @param {Uint8Array} raw
     */

  }], [{
    key: "deserialize",
    value: function deserialize(raw) {
      var dec = Proto.Message.decode(raw);
      var msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);
      msg.closerPeers = dec.closerPeers.map(fromPbPeer);
      msg.providerPeers = dec.providerPeers.map(fromPbPeer);

      if (dec.record && dec.record.length) {
        msg.record = Record.deserialize(dec.record);
      }

      return msg;
    }
  }]);

  return Message;
}();

Message.TYPES = MESSAGE_TYPE;
Message.CONNECTION_TYPES = CONNECTION_TYPE;
/**
 * @param {PeerData} peer
 */

function toPbPeer(peer) {
  /** @type {PBPeer} */
  var output = {
    id: peer.id.id,
    addrs: (peer.multiaddrs || []).map(function (m) {
      return m.bytes;
    }),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output;
}
/**
 * @param {import('./dht').Message.IPeer} peer
 */


function fromPbPeer(peer) {
  return {
    // @ts-ignore id is optional on protobuf, but it will exist?
    id: new PeerId(peer.id),
    multiaddrs: (peer.addrs || []).map(function (a) {
      return new Multiaddr(a);
    })
  };
}

module.exports = Message;
},{"peer-id":"node_modules/peer-id/src/index.js","multiaddr":"node_modules/multiaddr/src/index.js","libp2p-record":"node_modules/libp2p-record/src/index.js","./dht":"node_modules/libp2p-kad-dht/src/message/dht.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('libp2p-record'),
    Record = _require.Record;

var errcode = require('err-code');

var Message = require('../../message');

var utils = require('../../utils');
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:get-value');
  /**
   * Process `GetValue` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   * @returns {Promise<Message>}
   */

  function getValue(_x, _x2) {
    return _getValue.apply(this, arguments);
  }

  function _getValue() {
    _getValue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var key, response, idFromKey, id, peerData, _yield$Promise$all, _yield$Promise$all2, record, closer;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              key = msg.key;
              log('key: %b', key);

              if (!(!key || key.length === 0)) {
                _context.next = 4;
                break;
              }

              throw errcode(new Error('Invalid key'), 'ERR_INVALID_KEY');

            case 4:
              response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);

              if (!utils.isPublicKeyKey(key)) {
                _context.next = 13;
                break;
              }

              log('is public key');
              idFromKey = utils.fromPublicKeyKey(key);

              if (dht._isSelf(idFromKey)) {
                id = dht.peerId;
              } else {
                peerData = dht.peerStore.get(idFromKey);
                id = peerData && peerData.id;
              }

              if (!(id && id.pubKey)) {
                _context.next = 13;
                break;
              }

              log('returning found public key');
              response.record = new Record(key, id.pubKey.bytes);
              return _context.abrupt("return", response);

            case 13:
              _context.next = 15;
              return Promise.all([dht._checkLocalDatastore(key), dht._betterPeersToQuery(msg, peerId)]);

            case 15:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              record = _yield$Promise$all2[0];
              closer = _yield$Promise$all2[1];

              if (record) {
                log('got record');
                response.record = record;
              }

              if (closer.length > 0) {
                log('got closer %s', closer.length);
                response.closerPeers = closer;
              }

              return _context.abrupt("return", response);

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _getValue.apply(this, arguments);
  }

  return getValue;
};
},{"libp2p-record":"node_modules/libp2p-record/src/index.js","err-code":"node_modules/err-code/index.js","../../message":"node_modules/libp2p-kad-dht/src/message/index.js","../../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var utils = require('../../utils');

var errcode = require('err-code');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../../message')} Message
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:put-value');
  /**
   * Process `PutValue` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function putValue(_x, _x2) {
    return _putValue.apply(this, arguments);
  }

  function _putValue() {
    _putValue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var key, record, errMsg, recordKey;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              key = msg.key;
              log('key: %b', key);
              record = msg.record;

              if (record) {
                _context.next = 7;
                break;
              }

              errMsg = "Empty record from: ".concat(peerId.toB58String());
              log.error(errMsg);
              throw errcode(new Error(errMsg), 'ERR_EMPTY_RECORD');

            case 7:
              _context.next = 9;
              return dht._verifyRecordLocally(record);

            case 9:
              record.timeReceived = new Date();
              recordKey = utils.bufferToKey(record.key);
              _context.next = 13;
              return dht.datastore.put(recordKey, record.serialize());

            case 13:
              dht.onPut(record, peerId);
              return _context.abrupt("return", msg);

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _putValue.apply(this, arguments);
  }

  return putValue;
};
},{"../../utils":"node_modules/libp2p-kad-dht/src/utils.js","err-code":"node_modules/err-code/index.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var uint8ArrayEquals = require('uint8arrays/equals');

var Message = require('../../message');

var utils = require('../../utils');
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:find-node');
  /**
   * Process `FindNode` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function findNode(_x, _x2) {
    return _findNode.apply(this, arguments);
  }

  function _findNode() {
    _findNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var closer, response;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              log('start');

              if (!uint8ArrayEquals(msg.key, dht.peerId.id)) {
                _context.next = 5;
                break;
              }

              closer = [{
                id: dht.peerId,
                multiaddrs: dht.libp2p.multiaddrs
              }];
              _context.next = 8;
              break;

            case 5:
              _context.next = 7;
              return dht._betterPeersToQuery(msg, peerId);

            case 7:
              closer = _context.sent;

            case 8:
              response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel);

              if (closer.length > 0) {
                response.closerPeers = closer;
              } else {
                log('handle FindNode %s: could not find anything', peerId.toB58String());
              }

              return _context.abrupt("return", response);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _findNode.apply(this, arguments);
  }

  return findNode;
};
},{"uint8arrays/equals":"node_modules/uint8arrays/equals.js","../../message":"node_modules/libp2p-kad-dht/src/message/index.js","../../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/cid'),
    CID = _require.CID;

var errcode = require('err-code');

var utils = require('../../utils');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../../message')} Message
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:add-provider');
  /**
   * Process `AddProvider` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function addProvider(_x, _x2) {
    return _addProvider.apply(this, arguments);
  }

  function _addProvider() {
    _addProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var cid, errMsg;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // eslint-disable-line require-await
              log('start');

              if (!(!msg.key || msg.key.length === 0)) {
                _context.next = 3;
                break;
              }

              throw errcode(new Error('Missing key'), 'ERR_MISSING_KEY');

            case 3:
              _context.prev = 3;
              cid = CID.decode(msg.key);
              _context.next = 11;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](3);
              errMsg = "Invalid CID: ".concat(_context.t0.message);
              throw errcode(new Error(errMsg), 'ERR_INVALID_CID');

            case 11:
              msg.providerPeers.forEach(function (pi) {
                // Ignore providers not from the originator
                if (!pi.id.isEqual(peerId)) {
                  log('invalid provider peer %s from %s', pi.id.toB58String(), peerId.toB58String());
                  return;
                }

                if (pi.multiaddrs.length < 1) {
                  log('no valid addresses for provider %s. Ignore', peerId.toB58String());
                  return;
                }

                log('received provider %s for %s (addrs %s)', peerId.toB58String(), cid.toString(), pi.multiaddrs.map(function (m) {
                  return m.toString();
                }));

                if (!dht._isSelf(pi.id)) {
                  // Add known address to peer store
                  dht.peerStore.addressBook.add(pi.id, pi.multiaddrs);
                  return dht.providers.addProvider(cid, pi.id);
                }
              }); // Previous versions of the JS DHT sent erroneous providers in the
              // `providerPeers` field. In order to accommodate older clients that have
              // this bug, we fall back to assuming the originator is the provider if
              // we can't find any valid providers in the payload.
              // https://github.com/libp2p/js-libp2p-kad-dht/pull/127
              // https://github.com/libp2p/js-libp2p-kad-dht/issues/128

              return _context.abrupt("return", dht.providers.addProvider(cid, peerId));

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 7]]);
    }));
    return _addProvider.apply(this, arguments);
  }

  return addProvider;
};
},{"multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","err-code":"node_modules/err-code/index.js","../../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('multiformats/cid'),
    CID = _require.CID;

var errcode = require('err-code');

var Message = require('../../message');

var utils = require('../../utils');
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:get-providers');
  /**
   * Process `GetProviders` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function getProviders(_x, _x2) {
    return _getProviders.apply(this, arguments);
  }

  function _getProviders() {
    _getProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var cid, dsKey, _yield$Promise$all, _yield$Promise$all2, has, peers, closer, providerPeers, closerPeers, response;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              cid = CID.decode(msg.key);
              _context.next = 7;
              break;

            case 4:
              _context.prev = 4;
              _context.t0 = _context["catch"](0);
              throw errcode(new Error("Invalid CID: ".concat(_context.t0.message)), 'ERR_INVALID_CID');

            case 7:
              log('%s', cid.toString());
              dsKey = utils.bufferToKey(cid.bytes);
              _context.next = 11;
              return Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQuery(msg, peerId)]);

            case 11:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);
              has = _yield$Promise$all2[0];
              peers = _yield$Promise$all2[1];
              closer = _yield$Promise$all2[2];
              providerPeers = peers.map(function (peerId) {
                return {
                  id: peerId,
                  multiaddrs: []
                };
              });
              closerPeers = closer.map(function (c) {
                return {
                  id: c.id,
                  multiaddrs: []
                };
              });

              if (has) {
                providerPeers.push({
                  id: dht.peerId,
                  multiaddrs: []
                });
              }

              response = new Message(msg.type, msg.key, msg.clusterLevel);

              if (providerPeers.length > 0) {
                response.providerPeers = providerPeers;
              }

              if (closerPeers.length > 0) {
                response.closerPeers = closerPeers;
              }

              log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);
              return _context.abrupt("return", response);

            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 4]]);
    }));
    return _getProviders.apply(this, arguments);
  }

  return getProviders;
};
},{"multiformats/cid":"node_modules/multiformats/cjs/src/cid.js","err-code":"node_modules/err-code/index.js","../../message":"node_modules/libp2p-kad-dht/src/message/index.js","../../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js":[function(require,module,exports) {
'use strict';

var utils = require('../../utils');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../../message')} Message
 */

/**
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc:ping');
  /**
   * Process `Ping` DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function ping(peerId, msg) {
    log('from %s', peerId.toB58String());
    return msg;
  }

  return ping;
};
},{"../../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/rpc/handlers/index.js":[function(require,module,exports) {
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var T = require('../../message').TYPES;
/**
 *
 * @param {import('../../index')} dht
 */


module.exports = function (dht) {
  var _handlers;

  var handlers = (_handlers = {}, _defineProperty(_handlers, T.GET_VALUE, require('./get-value')(dht)), _defineProperty(_handlers, T.PUT_VALUE, require('./put-value')(dht)), _defineProperty(_handlers, T.FIND_NODE, require('./find-node')(dht)), _defineProperty(_handlers, T.ADD_PROVIDER, require('./add-provider')(dht)), _defineProperty(_handlers, T.GET_PROVIDERS, require('./get-providers')(dht)), _defineProperty(_handlers, T.PING, require('./ping')(dht)), _handlers);
  /**
   * Get the message handler matching the passed in type.
   *
   * @param {number} type
   */

  function getMessageHandler(type) {
    // @ts-ignore ts does not aknowledge number as an index type
    return handlers[type];
  }

  return getMessageHandler;
};
},{"../../message":"node_modules/libp2p-kad-dht/src/message/index.js","./get-value":"node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js","./put-value":"node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js","./find-node":"node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js","./add-provider":"node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js","./get-providers":"node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js","./ping":"node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js"}],"node_modules/libp2p-kad-dht/src/rpc/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var _require = require('it-pipe'),
    pipe = _require.pipe;

var lp = require('it-length-prefixed');

var Message = require('../message');

var handlers = require('./handlers');

var utils = require('../utils');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 */

/**
 * @param {import('../index')} dht
 */


module.exports = function (dht) {
  var log = utils.logger(dht.peerId, 'rpc');
  var getMessageHandler = handlers(dht);
  /**
   * Process incoming DHT messages.
   *
   * @param {PeerId} peerId
   * @param {Message} msg
   */

  function handleMessage(_x, _x2) {
    return _handleMessage.apply(this, arguments);
  }
  /**
   * Handle incoming streams on the dht protocol
   *
   * @param {object} props
   * @param {MuxedStream} props.stream
   * @param {import('libp2p-interfaces/src/connection').Connection} props.connection
   */


  function _handleMessage() {
    _handleMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId, msg) {
      var handler;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // get handler & execute it
              handler = getMessageHandler(msg.type);
              _context.prev = 1;
              _context.next = 4;
              return dht._add(peerId);

            case 4:
              _context.next = 9;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](1);
              log.error('Failed to update the kbucket store', _context.t0);

            case 9:
              if (handler) {
                _context.next = 12;
                break;
              }

              log.error("no handler found for message type: ".concat(msg.type));
              return _context.abrupt("return");

            case 12:
              return _context.abrupt("return", handler(peerId, msg));

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 6]]);
    }));
    return _handleMessage.apply(this, arguments);
  }

  function onIncomingStream(_x3) {
    return _onIncomingStream.apply(this, arguments);
  }

  function _onIncomingStream() {
    _onIncomingStream = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
      var stream, connection, peerId, idB58Str;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              stream = _ref2.stream, connection = _ref2.connection;
              peerId = connection.remotePeer;
              _context3.prev = 2;
              _context3.next = 5;
              return dht._add(peerId);

            case 5:
              _context3.next = 10;
              break;

            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](2);
              log.error(_context3.t0);

            case 10:
              idB58Str = peerId.toB58String();
              log('from: %s', idB58Str);
              _context3.next = 14;
              return pipe(stream.source, lp.decode(),
              /**
               * @param {AsyncIterable<Uint8Array>} source
               */
              function (source) {
                return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msg, desMessage, res;

                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _iteratorAbruptCompletion = false;
                          _didIteratorError = false;
                          _context2.prev = 2;
                          _iterator = _asyncIterator(source);

                        case 4:
                          _context2.next = 6;
                          return _awaitAsyncGenerator(_iterator.next());

                        case 6:
                          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                            _context2.next = 18;
                            break;
                          }

                          msg = _step.value;
                          // handle the message
                          desMessage = Message.deserialize(msg.slice());
                          _context2.next = 11;
                          return _awaitAsyncGenerator(handleMessage(peerId, desMessage));

                        case 11:
                          res = _context2.sent;

                          if (!res) {
                            _context2.next = 15;
                            break;
                          }

                          _context2.next = 15;
                          return res.serialize();

                        case 15:
                          _iteratorAbruptCompletion = false;
                          _context2.next = 4;
                          break;

                        case 18:
                          _context2.next = 24;
                          break;

                        case 20:
                          _context2.prev = 20;
                          _context2.t0 = _context2["catch"](2);
                          _didIteratorError = true;
                          _iteratorError = _context2.t0;

                        case 24:
                          _context2.prev = 24;
                          _context2.prev = 25;

                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                            _context2.next = 29;
                            break;
                          }

                          _context2.next = 29;
                          return _awaitAsyncGenerator(_iterator.return());

                        case 29:
                          _context2.prev = 29;

                          if (!_didIteratorError) {
                            _context2.next = 32;
                            break;
                          }

                          throw _iteratorError;

                        case 32:
                          return _context2.finish(29);

                        case 33:
                          return _context2.finish(24);

                        case 34:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
                }))();
              }, lp.encode(), stream.sink);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 7]]);
    }));
    return _onIncomingStream.apply(this, arguments);
  }

  return onIncomingStream;
};
},{"it-pipe":"node_modules/it-pipe/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","../message":"node_modules/libp2p-kad-dht/src/message/index.js","./handlers":"node_modules/libp2p-kad-dht/src/rpc/handlers/index.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/network.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var errcode = require('err-code');

var _require = require('it-pipe'),
    pipe = _require.pipe;

var lp = require('it-length-prefixed');

var pTimeout = require('p-timeout');

var _require2 = require('streaming-iterables'),
    consume = _require2.consume;

var first = require('it-first');

var MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');

var rpc = require('./rpc');

var c = require('./constants');

var Message = require('./message');

var utils = require('./utils');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 */

/**
 * Handle network operations for the dht
 */


var Network = /*#__PURE__*/function () {
  /**
   * Create a new network
   *
   * @param {import('./index')} dht
   */
  function Network(dht) {
    _classCallCheck(this, Network);

    this.dht = dht;
    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;
    this._log = utils.logger(this.dht.peerId, 'net');
    this._rpc = rpc(this.dht);
    this._onPeerConnected = this._onPeerConnected.bind(this);
    this._running = false;
  }
  /**
   * Start the network
   */


  _createClass(Network, [{
    key: "start",
    value: function start() {
      if (this._running) {
        return;
      }

      if (!this.dht.isStarted) {
        throw errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK');
      }

      this._running = true; // Only respond to queries when not in client mode

      if (this.dht._clientMode === false) {
        // Incoming streams
        this.dht.registrar.handle(this.dht.protocol, this._rpc);
      } // register protocol with topology


      var topology = new MulticodecTopology({
        multicodecs: [this.dht.protocol],
        handlers: {
          onConnect: this._onPeerConnected,
          onDisconnect: function onDisconnect() {}
        }
      });
      this._registrarId = this.dht.registrar.register(topology);
    }
    /**
     * Stop all network activity
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this.dht.isStarted && !this.isStarted) {
        return;
      }

      this._running = false; // unregister protocol and handlers

      if (this._registrarId) {
        this.dht.registrar.unregister(this._registrarId);
      }
    }
    /**
     * Is the network online?
     *
     * @type {boolean}
     */

  }, {
    key: "isStarted",
    get: function get() {
      return this._running;
    }
    /**
     * Are all network components there?
     *
     * @type {boolean}
     */

  }, {
    key: "isConnected",
    get: function get() {
      // TODO add a way to check if switch has started or not
      return this.dht.isStarted && this.isStarted;
    }
    /**
     * Registrar notifies a connection successfully with dht protocol.
     *
     * @param {PeerId} peerId - remote peer id
     */

  }, {
    key: "_onPeerConnected",
    value: function () {
      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.dht._add(peerId);

              case 2:
                this._log('added to the routing table: %s', peerId.toB58String());

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _onPeerConnected(_x) {
        return _onPeerConnected2.apply(this, arguments);
      }

      return _onPeerConnected;
    }()
    /**
     * Send a request and record RTT for latency measurements.
     *
     * @async
     * @param {PeerId} to - The peer that should receive a message
     * @param {Message} msg - The message to send.
     */

  }, {
    key: "sendRequest",
    value: function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(to, msg) {
        var id, conn, _yield$conn$newStream, stream;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.isConnected) {
                  _context2.next = 2;
                  break;
                }

                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');

              case 2:
                id = to.toB58String();

                this._log('sending to: %s', id);

                conn = this.dht.registrar.connectionManager.get(to);

                if (conn) {
                  _context2.next = 9;
                  break;
                }

                _context2.next = 8;
                return this.dht.dialer.connectToPeer(to);

              case 8:
                conn = _context2.sent;

              case 9:
                _context2.next = 11;
                return conn.newStream(this.dht.protocol);

              case 11:
                _yield$conn$newStream = _context2.sent;
                stream = _yield$conn$newStream.stream;
                return _context2.abrupt("return", this._writeReadMessage(stream, msg.serialize()));

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sendRequest(_x2, _x3) {
        return _sendRequest.apply(this, arguments);
      }

      return sendRequest;
    }()
    /**
     * Sends a message without expecting an answer.
     *
     * @param {PeerId} to
     * @param {Message} msg
     */

  }, {
    key: "sendMessage",
    value: function () {
      var _sendMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(to, msg) {
        var id, conn, _yield$conn$newStream2, stream;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.isConnected) {
                  _context3.next = 2;
                  break;
                }

                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');

              case 2:
                id = to.toB58String();

                this._log('sending to: %s', id);

                conn = this.dht.registrar.connectionManager.get(to);

                if (conn) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 8;
                return this.dht.dialer.connectToPeer(to);

              case 8:
                conn = _context3.sent;

              case 9:
                _context3.next = 11;
                return conn.newStream(this.dht.protocol);

              case 11:
                _yield$conn$newStream2 = _context3.sent;
                stream = _yield$conn$newStream2.stream;
                return _context3.abrupt("return", this._writeMessage(stream, msg.serialize()));

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sendMessage(_x4, _x5) {
        return _sendMessage.apply(this, arguments);
      }

      return sendMessage;
    }()
    /**
     * Write a message and read its response.
     * If no response is received after the specified timeout
     * this will error out.
     *
     * @param {MuxedStream} stream - the stream to use
     * @param {Uint8Array} msg - the message to send
     */

  }, {
    key: "_writeReadMessage",
    value: function () {
      var _writeReadMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(stream, msg) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _writeReadMessage(_x6, _x7) {
        return _writeReadMessage2.apply(this, arguments);
      }

      return _writeReadMessage;
    }()
    /**
     * Write a message to the given stream.
     *
     * @param {MuxedStream} stream - the stream to use
     * @param {Uint8Array} msg - the message to send
     */

  }, {
    key: "_writeMessage",
    value: function _writeMessage(stream, msg) {
      return pipe([msg], lp.encode(), stream, consume);
    }
  }]);

  return Network;
}();
/**
 * @param {MuxedStream} stream
 * @param {Uint8Array} msg
 */


function writeReadMessage(_x8, _x9) {
  return _writeReadMessage3.apply(this, arguments);
}

function _writeReadMessage3() {
  _writeReadMessage3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(stream, msg) {
    var res;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return pipe([msg], lp.encode(), stream, lp.decode(),
            /*#__PURE__*/

            /**
             * @param {AsyncIterable<Uint8Array>} source
             */
            function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(source) {
                var buf;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return first(source);

                      case 2:
                        buf = _context5.sent;

                        if (!buf) {
                          _context5.next = 5;
                          break;
                        }

                        return _context5.abrupt("return", buf.slice());

                      case 5:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function (_x10) {
                return _ref.apply(this, arguments);
              };
            }());

          case 2:
            res = _context6.sent;

            if (!(res.length === 0)) {
              _context6.next = 5;
              break;
            }

            throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED');

          case 5:
            return _context6.abrupt("return", Message.deserialize(res));

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _writeReadMessage3.apply(this, arguments);
}

module.exports = Network;
},{"err-code":"node_modules/err-code/index.js","it-pipe":"node_modules/it-pipe/index.js","it-length-prefixed":"node_modules/it-length-prefixed/src/index.js","p-timeout":"node_modules/p-timeout/index.js","streaming-iterables":"node_modules/streaming-iterables/dist/index.mjs","it-first":"node_modules/it-first/index.js","libp2p-interfaces/src/topology/multicodec-topology":"node_modules/libp2p-interfaces/src/topology/multicodec-topology.js","./rpc":"node_modules/libp2p-kad-dht/src/rpc/index.js","./constants":"node_modules/libp2p-kad-dht/src/constants.js","./message":"node_modules/libp2p-kad-dht/src/message/index.js","./utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js":[function(require,module,exports) {
'use strict'; // @ts-ignore

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var distance = require('xor-distance');

var utils = require('../utils');

var pMap = require('p-map');

var uint8ArrayEquals = require('uint8arrays/equals');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../').PeerData} PeerData
 */

/**
 * Maintains a list of peerIds sorted by distance from a DHT key.
 */


var PeerDistanceList = /*#__PURE__*/function () {
  /**
   * Creates a new PeerDistanceList.
   *
   * @param {Uint8Array} originDhtKey - the DHT key from which distance is calculated
   * @param {number} capacity - the maximum size of the list
   */
  function PeerDistanceList(originDhtKey, capacity) {
    _classCallCheck(this, PeerDistanceList);

    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    /** @type {{ peerId: PeerId, distance: Uint8Array }[]} */

    this.peerDistances = [];
  }
  /**
   * The length of the list
   */


  _createClass(PeerDistanceList, [{
    key: "length",
    get: function get() {
      return this.peerDistances.length;
    }
    /**
     * The peerIds in the list, in order of distance from the origin key
     */

  }, {
    key: "peers",
    get: function get() {
      return this.peerDistances.map(function (pd) {
        return pd.peerId;
      });
    }
    /**
     * Add a peerId to the list.
     *
     * @param {PeerId} peerId
     */

  }, {
    key: "add",
    value: function () {
      var _add = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peerId) {
        var dhtKey, el;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.peerDistances.find(function (pd) {
                  return uint8ArrayEquals(pd.peerId.id, peerId.id);
                })) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                _context.next = 4;
                return utils.convertPeerId(peerId);

              case 4:
                dhtKey = _context.sent;
                el = {
                  peerId: peerId,
                  distance: distance(this.originDhtKey, dhtKey)
                };
                this.peerDistances.push(el);
                this.peerDistances.sort(function (a, b) {
                  return distance.compare(a.distance, b.distance);
                });
                this.peerDistances = this.peerDistances.slice(0, this.capacity);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function add(_x) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
    /**
     * Indicates whether any of the peerIds passed as a parameter are closer
     * to the origin key than the furthest peerId in the PeerDistanceList.
     *
     * @param {PeerId[]} peerIds
     */

  }, {
    key: "anyCloser",
    value: function () {
      var _anyCloser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peerIds) {
        var dhtKeys, furthestDistance, _iterator, _step, dhtKey, keyDistance;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (peerIds.length) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", false);

              case 2:
                if (this.length) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", true);

              case 4:
                _context2.next = 6;
                return pMap(peerIds, function (peerId) {
                  return utils.convertPeerId(peerId);
                });

              case 6:
                dhtKeys = _context2.sent;
                furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
                _iterator = _createForOfIteratorHelper(dhtKeys);
                _context2.prev = 9;

                _iterator.s();

              case 11:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 18;
                  break;
                }

                dhtKey = _step.value;
                keyDistance = distance(this.originDhtKey, dhtKey);

                if (!(distance.compare(keyDistance, furthestDistance) < 0)) {
                  _context2.next = 16;
                  break;
                }

                return _context2.abrupt("return", true);

              case 16:
                _context2.next = 11;
                break;

              case 18:
                _context2.next = 23;
                break;

              case 20:
                _context2.prev = 20;
                _context2.t0 = _context2["catch"](9);

                _iterator.e(_context2.t0);

              case 23:
                _context2.prev = 23;

                _iterator.f();

                return _context2.finish(23);

              case 26:
                return _context2.abrupt("return", false);

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[9, 20, 23, 26]]);
      }));

      function anyCloser(_x2) {
        return _anyCloser.apply(this, arguments);
      }

      return anyCloser;
    }()
  }]);

  return PeerDistanceList;
}();

module.exports = PeerDistanceList;
},{"xor-distance":"node_modules/xor-distance/index.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js","p-map":"node_modules/p-map/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js"}],"node_modules/heap/lib/heap.js":[function(require,module,exports) {
var define;
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

},{}],"node_modules/heap/index.js":[function(require,module,exports) {
module.exports = require('./lib/heap');

},{"./lib/heap":"node_modules/heap/lib/heap.js"}],"node_modules/libp2p-kad-dht/src/peer-list/peer-queue.js":[function(require,module,exports) {
'use strict'; // @ts-ignore

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Heap = require('heap'); // @ts-ignore


var distance = require('xor-distance');

var debug = require('debug');

var utils = require('../utils');

var log = debug('libp2p:dht:peer-queue');
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * PeerQueue is a heap that sorts its entries (PeerIds) by their
 * xor distance to the inital provided key.
 */

var PeerQueue = /*#__PURE__*/function () {
  /**
   * Create a new PeerQueue.
   *
   * @param {Uint8Array} from - The sha2-256 encoded peer id
   */
  function PeerQueue(from) {
    _classCallCheck(this, PeerQueue);

    log('create: %b', from);
    this.from = from;
    this.heap = new Heap(utils.xorCompare);
  }
  /**
   * Add a new PeerId to the queue.
   *
   * @param {PeerId} id
   */


  _createClass(PeerQueue, [{
    key: "enqueue",
    value: function () {
      var _enqueue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(id) {
        var key, el;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                log('enqueue %s', id.toB58String());
                _context.next = 3;
                return utils.convertPeerId(id);

              case 3:
                key = _context.sent;
                el = {
                  id: id,
                  distance: distance(this.from, key)
                };
                this.heap.push(el);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function enqueue(_x) {
        return _enqueue.apply(this, arguments);
      }

      return enqueue;
    }()
    /**
     * Returns the closest peer to the `from` peer.
     *
     * @returns {PeerId}
     */

  }, {
    key: "dequeue",
    value: function dequeue() {
      var el = this.heap.pop();
      log('dequeue %s', el.id.toB58String());
      return el.id;
    }
  }, {
    key: "length",
    get: function get() {
      return this.heap.size();
    }
  }], [{
    key: "fromPeerId",
    value:
    /**
     * Create from a given peer id.
     *
     * @param {PeerId} id
     * @returns {Promise<PeerQueue>}
     */
    function () {
      var _fromPeerId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(id) {
        var key;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return utils.convertPeerId(id);

              case 2:
                key = _context2.sent;
                return _context2.abrupt("return", new PeerQueue(key));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function fromPeerId(_x2) {
        return _fromPeerId.apply(this, arguments);
      }

      return fromPeerId;
    }()
    /**
     * Create from a given Uint8Array.
     *
     * @param {Uint8Array} keyBuffer
     * @returns {Promise<PeerQueue>}
     */

  }, {
    key: "fromKey",
    value: function () {
      var _fromKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(keyBuffer) {
        var key;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return utils.convertBuffer(keyBuffer);

              case 2:
                key = _context3.sent;
                return _context3.abrupt("return", new PeerQueue(key));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function fromKey(_x3) {
        return _fromKey.apply(this, arguments);
      }

      return fromKey;
    }()
  }]);

  return PeerQueue;
}();

module.exports = PeerQueue;
},{"heap":"node_modules/heap/index.js","xor-distance":"node_modules/xor-distance/index.js","debug":"node_modules/debug/src/browser.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/query/path.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PeerQueue = require('../peer-list/peer-queue');

var utils = require('../utils'); // TODO: Temporary until parallel dial in Switch have a proper
// timeout. Requires async/await refactor of transports and
// dial abort logic. This gives us 30s to complete the `queryFunc`.
// This should help reduce the high end call times of queries


var QUERY_FUNC_TIMEOUT = 30e3;
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * Manages a single Path through the DHT.
 */

var Path = /*#__PURE__*/function () {
  /**
   * Creates a Path.
   *
   * @param {import('./run')} run
   * @param {import('./index').QueryFunc} queryFunc
   */
  function Path(run, queryFunc) {
    _classCallCheck(this, Path);

    this.run = run;
    this.queryFunc = utils.withTimeout(queryFunc, QUERY_FUNC_TIMEOUT);
    if (!this.queryFunc) throw new Error('Path requires a `queryFn` to be specified');
    if (typeof this.queryFunc !== 'function') throw new Error('Path expected `queryFn` to be a function. Got ' + _typeof(this.queryFunc));
    /** @type {PeerId[]} */

    this.initialPeers = [];
    /** @type {PeerQueue | null} */

    this.peersToQuery = null;
    /** @type {import('./index').QueryResult | null} */

    this.res = null;
  }
  /**
   * Add a peer to the set of peers that are used to intialize the path.
   *
   * @param {PeerId} peer
   */


  _createClass(Path, [{
    key: "addInitialPeer",
    value: function addInitialPeer(peer) {
      this.initialPeers.push(peer);
    }
    /**
     * Execute the path
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var queue;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return PeerQueue.fromKey(this.run.query.key);

              case 2:
                queue = _context.sent;
                // Add initial peers to the queue
                this.peersToQuery = queue;
                _context.next = 6;
                return Promise.all(this.initialPeers.map(function (peer) {
                  return _this.addPeerToQuery(peer);
                }));

              case 6:
                _context.next = 8;
                return this.run.workerQueue(this);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute() {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Add a peer to the peers to be queried.
     *
     * @param {PeerId} peer
     */

  }, {
    key: "addPeerToQuery",
    value: function () {
      var _addPeerToQuery = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.run.query.dht._isSelf(peer)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!this.run.peersSeen.has(peer.toB58String())) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return");

              case 4:
                if (!this.peersToQuery) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 7;
                return this.peersToQuery.enqueue(peer);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addPeerToQuery(_x) {
        return _addPeerToQuery.apply(this, arguments);
      }

      return addPeerToQuery;
    }()
  }]);

  return Path;
}();

module.exports = Path;
},{"../peer-list/peer-queue":"node_modules/libp2p-kad-dht/src/peer-list/peer-queue.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/eventemitter3/index.js":[function(require,module,exports) {
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],"node_modules/p-finally/index.js":[function(require,module,exports) {
'use strict';

module.exports = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};
},{}],"node_modules/p-queue/node_modules/p-timeout/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var pFinally = require('p-finally');

var TimeoutError = /*#__PURE__*/function (_Error) {
  _inherits(TimeoutError, _Error);

  var _super = _createSuper(TimeoutError);

  function TimeoutError(message) {
    var _this;

    _classCallCheck(this, TimeoutError);

    _this = _super.call(this, message);
    _this.name = 'TimeoutError';
    return _this;
  }

  return TimeoutError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var pTimeout = function pTimeout(promise, milliseconds, fallback) {
  return new Promise(function (resolve, reject) {
    if (typeof milliseconds !== 'number' || milliseconds < 0) {
      throw new TypeError('Expected `milliseconds` to be a positive number');
    }

    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }

    var timer = setTimeout(function () {
      if (typeof fallback === 'function') {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }

        return;
      }

      var message = typeof fallback === 'string' ? fallback : "Promise timed out after ".concat(milliseconds, " milliseconds");
      var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);

      if (typeof promise.cancel === 'function') {
        promise.cancel();
      }

      reject(timeoutError);
    }, milliseconds); // TODO: Use native `finally` keyword when targeting Node.js 10

    pFinally( // eslint-disable-next-line promise/prefer-await-to-then
    promise.then(resolve, reject), function () {
      clearTimeout(timer);
    });
  });
};

module.exports = pTimeout; // TODO: Remove this for the next major release

module.exports.default = pTimeout;
module.exports.TimeoutError = TimeoutError;
},{"p-finally":"node_modules/p-finally/index.js"}],"node_modules/p-queue/dist/lower-bound.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion

function lowerBound(array, value, comparator) {
  var first = 0;
  var count = array.length;

  while (count > 0) {
    var step = count / 2 | 0;
    var it = first + step;

    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }

  return first;
}

exports.default = lowerBound;
},{}],"node_modules/p-queue/dist/priority-queue.js":[function(require,module,exports) {
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var lower_bound_1 = require("./lower-bound");

var PriorityQueue = /*#__PURE__*/function () {
  function PriorityQueue() {
    _classCallCheck(this, PriorityQueue);

    this._queue = [];
  }

  _createClass(PriorityQueue, [{
    key: "enqueue",
    value: function enqueue(run, options) {
      options = Object.assign({
        priority: 0
      }, options);
      var element = {
        priority: options.priority,
        run: run
      };

      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);

        return;
      }

      var index = lower_bound_1.default(this._queue, element, function (a, b) {
        return b.priority - a.priority;
      });

      this._queue.splice(index, 0, element);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      var item = this._queue.shift();

      return item === null || item === void 0 ? void 0 : item.run;
    }
  }, {
    key: "filter",
    value: function filter(options) {
      return this._queue.filter(function (element) {
        return element.priority === options.priority;
      }).map(function (element) {
        return element.run;
      });
    }
  }, {
    key: "size",
    get: function get() {
      return this._queue.length;
    }
  }]);

  return PriorityQueue;
}();

exports.default = PriorityQueue;
},{"./lower-bound":"node_modules/p-queue/dist/lower-bound.js"}],"node_modules/p-queue/dist/index.js":[function(require,module,exports) {
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var EventEmitter = require("eventemitter3");

var p_timeout_1 = require("p-timeout");

var priority_queue_1 = require("./priority-queue"); // eslint-disable-next-line @typescript-eslint/no-empty-function


var empty = function empty() {};

var timeoutError = new p_timeout_1.TimeoutError();
/**
Promise queue with concurrency control.
*/

var PQueue = /*#__PURE__*/function (_EventEmitter) {
  _inherits(PQueue, _EventEmitter);

  var _super = _createSuper(PQueue);

  function PQueue(options) {
    var _this;

    _classCallCheck(this, PQueue);

    var _a, _b, _c, _d;

    _this = _super.call(this);
    _this._intervalCount = 0;
    _this._intervalEnd = 0;
    _this._pendingCount = 0;
    _this._resolveEmpty = empty;
    _this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions

    options = Object.assign({
      carryoverConcurrencyCount: false,
      intervalCap: Infinity,
      interval: 0,
      concurrency: Infinity,
      autoStart: true,
      queueClass: priority_queue_1.default
    }, options);

    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
      throw new TypeError("Expected `intervalCap` to be a number from 1 and up, got `".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', "` (").concat(_typeof(options.intervalCap), ")"));
    }

    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError("Expected `interval` to be a finite number >= 0, got `".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '', "` (").concat(_typeof(options.interval), ")"));
    }

    _this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    _this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
    _this._intervalCap = options.intervalCap;
    _this._interval = options.interval;
    _this._queue = new options.queueClass();
    _this._queueClass = options.queueClass;
    _this.concurrency = options.concurrency;
    _this._timeout = options.timeout;
    _this._throwOnTimeout = options.throwOnTimeout === true;
    _this._isPaused = options.autoStart === false;
    return _this;
  }

  _createClass(PQueue, [{
    key: "_doesIntervalAllowAnother",
    get: function get() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
  }, {
    key: "_doesConcurrentAllowAnother",
    get: function get() {
      return this._pendingCount < this._concurrency;
    }
  }, {
    key: "_next",
    value: function _next() {
      this._pendingCount--;

      this._tryToStartAnother();

      this.emit('next');
    }
  }, {
    key: "_resolvePromises",
    value: function _resolvePromises() {
      this._resolveEmpty();

      this._resolveEmpty = empty;

      if (this._pendingCount === 0) {
        this._resolveIdle();

        this._resolveIdle = empty;
        this.emit('idle');
      }
    }
  }, {
    key: "_onResumeInterval",
    value: function _onResumeInterval() {
      this._onInterval();

      this._initializeIntervalIfNeeded();

      this._timeoutId = undefined;
    }
  }, {
    key: "_isIntervalPaused",
    value: function _isIntervalPaused() {
      var _this2 = this;

      var now = Date.now();

      if (this._intervalId === undefined) {
        var delay = this._intervalEnd - now;

        if (delay < 0) {
          // Act as the interval was done
          // We don't need to resume it here because it will be resumed on line 160
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          // Act as the interval is pending
          if (this._timeoutId === undefined) {
            this._timeoutId = setTimeout(function () {
              _this2._onResumeInterval();
            }, delay);
          }

          return true;
        }
      }

      return false;
    }
  }, {
    key: "_tryToStartAnother",
    value: function _tryToStartAnother() {
      if (this._queue.size === 0) {
        // We can clear the interval ("pause")
        // Because we can redo it later ("resume")
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }

        this._intervalId = undefined;

        this._resolvePromises();

        return false;
      }

      if (!this._isPaused) {
        var canInitializeInterval = !this._isIntervalPaused();

        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          var job = this._queue.dequeue();

          if (!job) {
            return false;
          }

          this.emit('active');
          job();

          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }

          return true;
        }
      }

      return false;
    }
  }, {
    key: "_initializeIntervalIfNeeded",
    value: function _initializeIntervalIfNeeded() {
      var _this3 = this;

      if (this._isIntervalIgnored || this._intervalId !== undefined) {
        return;
      }

      this._intervalId = setInterval(function () {
        _this3._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
  }, {
    key: "_onInterval",
    value: function _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = undefined;
      }

      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;

      this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */

  }, {
    key: "_processQueue",
    value: function _processQueue() {
      // eslint-disable-next-line no-empty
      while (this._tryToStartAnother()) {}
    }
  }, {
    key: "concurrency",
    get: function get() {
      return this._concurrency;
    },
    set: function set(newConcurrency) {
      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(newConcurrency, "` (").concat(_typeof(newConcurrency), ")"));
      }

      this._concurrency = newConcurrency;

      this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */

  }, {
    key: "add",
    value: function () {
      var _add = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(fn) {
        var _this4 = this;

        var options,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var run = /*#__PURE__*/function () {
                    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                      var operation;
                      return regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _this4._pendingCount++;
                              _this4._intervalCount++;
                              _context.prev = 2;
                              operation = _this4._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? _this4._timeout : options.timeout, function () {
                                if (options.throwOnTimeout === undefined ? _this4._throwOnTimeout : options.throwOnTimeout) {
                                  reject(timeoutError);
                                }

                                return undefined;
                              });
                              _context.t0 = resolve;
                              _context.next = 7;
                              return operation;

                            case 7:
                              _context.t1 = _context.sent;
                              (0, _context.t0)(_context.t1);
                              _context.next = 14;
                              break;

                            case 11:
                              _context.prev = 11;
                              _context.t2 = _context["catch"](2);
                              reject(_context.t2);

                            case 14:
                              _this4._next();

                            case 15:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[2, 11]]);
                    }));

                    return function run() {
                      return _ref.apply(this, arguments);
                    };
                  }();

                  _this4._queue.enqueue(run, options);

                  _this4._tryToStartAnother();

                  _this4.emit('add');
                }));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function add(_x) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
    /**
    Same as `.add()`, but accepts an array of sync or async functions.
     @returns A promise that resolves when all functions are resolved.
    */

  }, {
    key: "addAll",
    value: function () {
      var _addAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(functions, options) {
        var _this5 = this;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", Promise.all(functions.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(function_) {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            return _context3.abrupt("return", _this5.add(function_, options));

                          case 1:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }())));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function addAll(_x2, _x3) {
        return _addAll.apply(this, arguments);
      }

      return addAll;
    }()
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */

  }, {
    key: "start",
    value: function start() {
      if (!this._isPaused) {
        return this;
      }

      this._isPaused = false;

      this._processQueue();

      return this;
    }
    /**
    Put queue execution on hold.
    */

  }, {
    key: "pause",
    value: function pause() {
      this._isPaused = true;
    }
    /**
    Clear the queue.
    */

  }, {
    key: "clear",
    value: function clear() {
      this._queue = new this._queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.
     @returns A promise that settles when the queue becomes empty.
    */

  }, {
    key: "onEmpty",
    value: function () {
      var _onEmpty = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _this6 = this;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(this._queue.size === 0)) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return");

              case 2:
                return _context5.abrupt("return", new Promise(function (resolve) {
                  var existingResolve = _this6._resolveEmpty;

                  _this6._resolveEmpty = function () {
                    existingResolve();
                    resolve();
                  };
                }));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function onEmpty() {
        return _onEmpty.apply(this, arguments);
      }

      return onEmpty;
    }()
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */

  }, {
    key: "onIdle",
    value: function () {
      var _onIdle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this7 = this;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(this._pendingCount === 0 && this._queue.size === 0)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                return _context6.abrupt("return", new Promise(function (resolve) {
                  var existingResolve = _this7._resolveIdle;

                  _this7._resolveIdle = function () {
                    existingResolve();
                    resolve();
                  };
                }));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function onIdle() {
        return _onIdle.apply(this, arguments);
      }

      return onIdle;
    }()
    /**
    Size of the queue.
    */

  }, {
    key: "size",
    get: function get() {
      return this._queue.size;
    }
    /**
    Size of the queue, filtered by the given options.
     For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */

  }, {
    key: "sizeBy",
    value: function sizeBy(options) {
      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
      return this._queue.filter(options).length;
    }
    /**
    Number of pending promises.
    */

  }, {
    key: "pending",
    get: function get() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */

  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
  }, {
    key: "timeout",
    get: function get() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    ,
    set: function set(milliseconds) {
      this._timeout = milliseconds;
    }
  }]);

  return PQueue;
}(EventEmitter);

exports.default = PQueue;
},{"eventemitter3":"node_modules/eventemitter3/index.js","p-timeout":"node_modules/p-queue/node_modules/p-timeout/index.js","./priority-queue":"node_modules/p-queue/dist/priority-queue.js"}],"node_modules/libp2p-kad-dht/src/query/worker-queue.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('p-queue'),
    Queue = _require.default;
/**
 * @typedef {import('peer-id')} PeerId
 */


var WorkerQueue = /*#__PURE__*/function () {
  /**
   * Creates a new WorkerQueue.
   *
   * @param {import('../index')} dht
   * @param {import('./run')} run
   * @param {import('./path')} path
   * @param {Function & {error: Function}} log
   */
  function WorkerQueue(dht, run, path, log) {
    _classCallCheck(this, WorkerQueue);

    this.dht = dht;
    this.run = run;
    this.path = path;
    this.log = log;
    this.concurrency = this.dht.concurrency;
    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated
    // when execute() is called

    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */

    this.execution = null;
    /** @type {Set<PeerId>} */

    this.queuedPeerIds = new Set();
  }
  /**
   * Create the underlying async queue.
   *
   * @returns {Queue}
   */


  _createClass(WorkerQueue, [{
    key: "setupQueue",
    value: function setupQueue() {
      var _this = this;

      var q = new Queue({
        concurrency: this.concurrency
      }); // When all peers in the queue have been processed, stop the worker

      q.on('idle', function () {
        if (_this.path.peersToQuery && !_this.path.peersToQuery.length) {
          _this.log('queue:drain');

          _this.stop();
        }
      }); // When a space opens up in the queue, add some more peers

      q.on('next', function () {
        if (!_this.running) {
          return;
        }

        if (q.pending < _this.concurrency) {
          _this.fill();
        }
      });
      return q;
    }
    /**
     * Stop the worker, optionally providing an error to pass to the worker's
     * callback.
     *
     * @param {Error} [err]
     */

  }, {
    key: "stop",
    value: function stop(err) {
      if (!this.running) {
        return;
      }

      this.running = false;
      this.queue.clear();
      this.log('worker:stop, %d workers still running', this.run.workers.filter(function (w) {
        return w.running;
      }).length);

      if (this.execution) {
        if (err) {
          this.execution.reject(err);
        } else {
          this.execution.resolve();
        }
      }
    }
    /**
     * Use the queue from async to keep `concurrency` amount items running
     * per path.
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        var execPromise;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.running = true; // store the promise resolution functions to be resolved at end of queue

                this.execution = null;
                execPromise = new Promise(function (resolve, reject) {
                  _this2.execution = {
                    resolve: resolve,
                    reject: reject
                  };
                }); // start queue

                this.fill(); // await completion

                _context.next = 6;
                return execPromise;

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute() {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Add peers to the worker queue until there are enough to satisfy the
     * worker queue concurrency.
     * Note that we don't want to take any more than those required to satisfy
     * concurrency from the peers-to-query queue, because we always want to
     * query the closest peers to the key first, and new peers are continuously
     * being added to the peers-to-query queue.
     */

  }, {
    key: "fill",
    value: function fill() {
      var _this3 = this;

      if (!this.path.peersToQuery) {
        return;
      } // Note:
      // - queue.pending: number of items that are currently running
      // - queue.size: the number of items that are waiting to be run


      var _loop = function _loop() {
        var peer = _this3.path.peersToQuery.dequeue(); // store the peer id so we can potentially abort early


        _this3.queuedPeerIds.add(peer);

        _this3.queue.add(function () {
          return _this3.processNext(peer).catch(function (err) {
            _this3.log.error('queue', err);

            _this3.stop(err);
          }).finally(function () {
            _this3.queuedPeerIds.delete(peer);
          });
        });
      };

      while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {
        _loop();
      }
    }
    /**
     * Process the next peer in the queue
     *
     * @param {PeerId} peer
     */

  }, {
    key: "processNext",
    value: function () {
      var _processNext = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
        var continueQuerying, continueQueryingError, state, execError;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.running) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!this.run.peersSeen.has(peer.toB58String())) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return");

              case 4:
                _context2.prev = 4;
                _context2.next = 7;
                return this.run.continueQuerying(this);

              case 7:
                continueQuerying = _context2.sent;
                _context2.next = 13;
                break;

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](4);
                continueQueryingError = _context2.t0;

              case 13:
                if (this.running) {
                  _context2.next = 15;
                  break;
                }

                return _context2.abrupt("return");

              case 15:
                if (!continueQueryingError) {
                  _context2.next = 17;
                  break;
                }

                throw continueQueryingError;

              case 17:
                if (continueQuerying) {
                  _context2.next = 20;
                  break;
                }

                this.stop();
                return _context2.abrupt("return");

              case 20:
                if (!this.run.peersSeen.has(peer.toB58String())) {
                  _context2.next = 22;
                  break;
                }

                return _context2.abrupt("return");

              case 22:
                this.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer

                this.log('queue:work');
                _context2.prev = 24;
                _context2.next = 27;
                return this.execQuery(peer);

              case 27:
                state = _context2.sent;
                _context2.next = 33;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t1 = _context2["catch"](24);
                execError = _context2.t1;

              case 33:
                if (this.running) {
                  _context2.next = 35;
                  break;
                }

                return _context2.abrupt("return");

              case 35:
                this.log('queue:work:done', execError, state);

                if (!execError) {
                  _context2.next = 38;
                  break;
                }

                throw execError;

              case 38:
                if (!(state && state.queryComplete)) {
                  _context2.next = 42;
                  break;
                }

                this.log('query:complete');
                this.run.stop();
                return _context2.abrupt("return");

              case 42:
                // If path is complete, just stop this worker.
                // Note: this.stop() kills the queue and resolves execution
                if (state && state.pathComplete) {
                  this.stop();
                }

              case 43:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[4, 10], [24, 30]]);
      }));

      function processNext(_x) {
        return _processNext.apply(this, arguments);
      }

      return processNext;
    }()
    /**
     * Execute a query on the next peer.
     *
     * @param {PeerId} peer
     */

  }, {
    key: "execQuery",
    value: function () {
      var _execQuery = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peer) {
        var _this4 = this;

        var res, queryError, queryCloser;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.path.queryFunc(peer);

              case 3:
                res = _context4.sent;
                _context4.next = 9;
                break;

              case 6:
                _context4.prev = 6;
                _context4.t0 = _context4["catch"](0);
                queryError = _context4.t0;

              case 9:
                if (this.running) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return");

              case 11:
                if (!queryError) {
                  _context4.next = 14;
                  break;
                }

                this.run.errors.push(queryError);
                return _context4.abrupt("return");

              case 14:
                _context4.t1 = this.run.peersQueried;

                if (!_context4.t1) {
                  _context4.next = 18;
                  break;
                }

                _context4.next = 18;
                return this.run.peersQueried.add(peer);

              case 18:
                if (res) {
                  _context4.next = 20;
                  break;
                }

                return _context4.abrupt("return");

              case 20:
                if (!(res.pathComplete || res.queryComplete)) {
                  _context4.next = 23;
                  break;
                }

                this.path.res = res;
                return _context4.abrupt("return", {
                  pathComplete: res.pathComplete,
                  queryComplete: res.queryComplete
                });

              case 23:
                if (!(res.closerPeers && res.closerPeers.length > 0)) {
                  _context4.next = 27;
                  break;
                }

                /**
                 * @param {import('../').PeerData} closer
                 */
                queryCloser = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(closer) {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!_this4.dht._isSelf(closer.id)) {
                              _context3.next = 2;
                              break;
                            }

                            return _context3.abrupt("return");

                          case 2:
                            _this4.dht._peerDiscovered(closer.id, closer.multiaddrs);

                            _context3.next = 5;
                            return _this4.path.addPeerToQuery(closer.id);

                          case 5:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function queryCloser(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context4.next = 27;
                return Promise.all(res.closerPeers.map(queryCloser));

              case 27:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 6]]);
      }));

      function execQuery(_x2) {
        return _execQuery.apply(this, arguments);
      }

      return execQuery;
    }()
  }]);

  return WorkerQueue;
}();

module.exports = WorkerQueue;
},{"p-queue":"node_modules/p-queue/dist/index.js"}],"node_modules/libp2p-kad-dht/src/query/run.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var PeerDistanceList = require('../peer-list/peer-distance-list');

var EventEmitter = require('events');

var Path = require('./path');

var WorkerQueue = require('./worker-queue');

var utils = require('../utils');
/**
 * @typedef {import('peer-id')} PeerId
 */

/**
 * Manages a single run of the query.
 */


var Run = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Run, _EventEmitter);

  var _super = _createSuper(Run);

  /**
   * Creates a Run.
   *
   * @param {import('./index')} query
   */
  function Run(query) {
    var _this;

    _classCallCheck(this, Run);

    _this = _super.call(this);
    _this.query = query;
    _this.running = false;
    /** @type {WorkerQueue[]} */

    _this.workers = []; // The peers that have been queried (including error responses)

    _this.peersSeen = new Set(); // The errors received when querying peers

    /** @type {Error[]} */

    _this.errors = []; // The closest K peers that have been queried successfully
    // (this member is initialized when the worker queues start)

    /** @type {PeerDistanceList | null} */

    _this.peersQueried = null;
    return _this;
  }
  /**
   * Stop all the workers
   */


  _createClass(Run, [{
    key: "stop",
    value: function stop() {
      if (!this.running) {
        return;
      }

      this.running = false;

      var _iterator = _createForOfIteratorHelper(this.workers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var worker = _step.value;
          worker.stop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Execute the run with the given initial set of peers.
     *
     * @param {PeerId[]} peers
     */

  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peers) {
        var paths, numPaths, i, res, _i, _paths, path;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                /** @type {import('./path')[]} */
                paths = []; // array of states per disjoint path
                // Create disjoint paths

                numPaths = Math.min(this.query.dht.disjointPaths, peers.length);

                for (i = 0; i < numPaths; i++) {
                  paths.push(new Path(this, this.query.makePath(i, numPaths)));
                } // Assign peers to paths round-robin style


                peers.forEach(function (peer, i) {
                  paths[i % numPaths].addInitialPeer(peer);
                }); // Execute the query along each disjoint path

                _context.next = 6;
                return this.executePaths(paths);

              case 6:
                res = {
                  // The closest K peers we were able to query successfully
                  finalSet: new Set(this.peersQueried && this.peersQueried.peers),

                  /** @type {import('./index').QueryResult[]} */
                  paths: []
                }; // Collect the results from each completed path

                for (_i = 0, _paths = paths; _i < _paths.length; _i++) {
                  path = _paths[_i];

                  if (path.res && (path.res.pathComplete || path.res.queryComplete)) {
                    path.res.success = true;
                    res.paths.push(path.res);
                  }
                }

                return _context.abrupt("return", res);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute(_x) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
    /**
     * Execute all paths through the DHT.
     *
     * @param {Array<Path>} paths
     * @returns {Promise<void>}
     */

  }, {
    key: "executePaths",
    value: function () {
      var _executePaths = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(paths) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.running = true;
                this.emit('start');
                _context2.prev = 2;
                _context2.next = 5;
                return Promise.all(paths.map(function (path) {
                  return path.execute();
                }));

              case 5:
                _context2.prev = 5;
                // Ensure all workers are stopped
                this.stop(); // Completed the Run

                this.emit('complete');
                return _context2.finish(5);

              case 9:
                if (!(this.errors.length === this.peersSeen.size)) {
                  _context2.next = 11;
                  break;
                }

                throw this.errors[0];

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2,, 5, 9]]);
      }));

      function executePaths(_x2) {
        return _executePaths.apply(this, arguments);
      }

      return executePaths;
    }()
    /**
     * Initialize the list of queried peers, then start a worker queue for the
     * given path.
     *
     * @param {Path} path
     * @returns {Promise<void>}
     */

  }, {
    key: "workerQueue",
    value: function () {
      var _workerQueue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.init();

              case 2:
                _context3.next = 4;
                return this.startWorker(path);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function workerQueue(_x3) {
        return _workerQueue.apply(this, arguments);
      }

      return workerQueue;
    }()
    /**
     * Create and start a worker queue for a particular path.
     *
     * @param {Path} path
     * @returns {Promise<void>}
     */

  }, {
    key: "startWorker",
    value: function () {
      var _startWorker = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(path) {
        var worker;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                worker = new WorkerQueue(this.query.dht, this, path, this.query._log);
                this.workers.push(worker);
                _context4.next = 4;
                return worker.execute();

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function startWorker(_x4) {
        return _startWorker.apply(this, arguments);
      }

      return startWorker;
    }()
    /**
     * Initialize the list of closest peers we've queried - this is shared by all
     * paths in the run.
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!this.peersQueried) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                if (!this.peersQueriedPromise) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 5;
                return this.peersQueriedPromise;

              case 5:
                return _context6.abrupt("return");

              case 6:
                // This promise is temporarily stored so that others may await its completion
                this.peersQueriedPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  var dhtKey;
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return utils.convertBuffer(_this2.query.key);

                        case 2:
                          dhtKey = _context5.sent;
                          _this2.peersQueried = new PeerDistanceList(dhtKey, _this2.query.dht.kBucketSize);

                        case 4:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }))(); // After PeerDistanceList is initialized, clean up

                _context6.next = 9;
                return this.peersQueriedPromise;

              case 9:
                delete this.peersQueriedPromise;

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * If we've queried K peers, and the remaining peers in the given `worker`'s queue
     * are all further from the key than the peers we've already queried, then we should
     * stop querying on that `worker`.
     *
     * @param {WorkerQueue} worker
     * @returns {Promise<boolean>}
     */

  }, {
    key: "continueQuerying",
    value: function () {
      var _continueQuerying = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(worker) {
        var running, someCloser;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.peersQueried && this.peersQueried.length < this.peersQueried.capacity)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", true);

              case 2:
                // Get all the peers that are currently being queried.
                // Note that this function gets called right after a peer has been popped
                // off the head of the closest peers queue so it will include that peer.
                running = Array.from(worker.queuedPeerIds); // Check if any of the peers that are currently being queried are closer
                // to the key than the peers we've already queried

                _context7.t0 = this.peersQueried;

                if (!_context7.t0) {
                  _context7.next = 8;
                  break;
                }

                _context7.next = 7;
                return this.peersQueried.anyCloser(running);

              case 7:
                _context7.t0 = _context7.sent;

              case 8:
                someCloser = _context7.t0;

                if (!someCloser) {
                  _context7.next = 11;
                  break;
                }

                return _context7.abrupt("return", true);

              case 11:
                return _context7.abrupt("return", false);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function continueQuerying(_x5) {
        return _continueQuerying.apply(this, arguments);
      }

      return continueQuerying;
    }()
  }]);

  return Run;
}(EventEmitter);

module.exports = Run;
},{"../peer-list/peer-distance-list":"node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js","events":"node_modules/events/events.js","./path":"node_modules/libp2p-kad-dht/src/query/path.js","./worker-queue":"node_modules/libp2p-kad-dht/src/query/worker-queue.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/query/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('multiformats/bases/base58'),
    base58btc = _require.base58btc;

var utils = require('../utils');

var Run = require('./run');
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {{from: PeerId, val: Uint8Array}} DHTQueryValue
 * @typedef {{from: PeerId, err: Error}} DHTQueryError
 * @typedef {DHTQueryValue | DHTQueryError} DHTQueryResult
 * @typedef {import('../').PeerData} PeerData
 *
 * @typedef {{ pathComplete?: boolean, queryComplete?: boolean, closerPeers?: PeerData[], peer?: PeerData, success?: boolean }} QueryResult
 */

/**
 * User-supplied function to set up an individual disjoint path. Per-path
 * query state should be held in this function's closure.
 *
 * Accepts the numeric index from zero to numPaths - 1 and returns a function
 * to call on each peer in the query.
 *
 * @typedef {(pathIndex: number, numPaths: number) => QueryFunc } MakeQueryFunc
 */

/**
 * Query function
 *
 * @typedef {(peer: PeerId) => Promise<QueryResult> } QueryFunc
 */

/**
 * Divide peers up into disjoint paths (subqueries). Any peer can only be used once over all paths.
 * Within each path, query peers from closest to farthest away.
 */


var Query = /*#__PURE__*/function () {
  /**
   * Create a new query. The makePath function is called once per disjoint path, so that per-path
   * variables can be created in that scope. makePath then returns the actual query function (queryFunc) to
   * use when on that path.
   *
   * @param {import('../index')} dht - DHT instance
   * @param {Uint8Array} key
   * @param {MakeQueryFunc} makePath - Called to set up each disjoint path. Must return the query function.
   */
  function Query(dht, key, makePath) {
    _classCallCheck(this, Query);

    this.dht = dht;
    this.key = key;
    this.makePath = makePath;
    this._log = utils.logger(this.dht.peerId, 'query:' + base58btc.baseEncode(key));
    this.running = false;
    this._onStart = this._onStart.bind(this);
    this._onComplete = this._onComplete.bind(this);
  }
  /**
   * Run this query, start with the given list of peers first.
   *
   * @param {PeerId[]} peers
   */


  _createClass(Query, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peers) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.dht._queryManager.running) {
                  _context.next = 3;
                  break;
                }

                this._log.error('Attempt to run query after shutdown');

                return _context.abrupt("return", {
                  finalSet: new Set(),
                  paths: []
                });

              case 3:
                if (!(peers.length === 0)) {
                  _context.next = 6;
                  break;
                }

                this._log.error('Running query with no peers');

                return _context.abrupt("return", {
                  finalSet: new Set(),
                  paths: []
                });

              case 6:
                this._run = new Run(this);

                this._log("query running with K=".concat(this.dht.kBucketSize, ", A=").concat(this.dht.concurrency, ", D=").concat(Math.min(this.dht.disjointPaths, peers.length)));

                this._run.once('start', this._onStart);

                this._run.once('complete', this._onComplete);

                return _context.abrupt("return", this._run.execute(peers));

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function run(_x) {
        return _run.apply(this, arguments);
      }

      return run;
    }()
    /**
     * Called when the run starts.
     */

  }, {
    key: "_onStart",
    value: function _onStart() {
      this.running = true;
      this._startTime = Date.now();

      this._log('query:start'); // Register this query so we can stop it if the DHT stops


      this.dht._queryManager.queryStarted(this);
    }
    /**
     * Called when the run completes (even if there's an error).
     */

  }, {
    key: "_onComplete",
    value: function _onComplete() {
      // Ensure worker queues for all paths are stopped at the end of the query
      this.stop();
    }
    /**
     * Stop the query.
     */

  }, {
    key: "stop",
    value: function stop() {
      this._log("query:done in ".concat(Date.now() - (this._startTime || 0), "ms"));

      if (this._run) {
        this._log("".concat(this._run.errors.length, " of ").concat(this._run.peersSeen.size, " peers errored (").concat(this._run.errors.length / this._run.peersSeen.size * 100, "% fail rate)"));
      }

      if (!this.running) {
        return;
      }

      this.running = false;

      if (this._run) {
        this._run.removeListener('start', this._onStart);

        this._run.removeListener('complete', this._onComplete);

        this._run.stop();
      }

      this.dht._queryManager.queryCompleted(this);
    }
  }]);

  return Query;
}();

module.exports = Query;
},{"multiformats/bases/base58":"node_modules/multiformats/cjs/src/bases/base58.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js","./run":"node_modules/libp2p-kad-dht/src/query/run.js"}],"node_modules/libp2p-kad-dht/src/content-fetching/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var errcode = require('err-code');

var pTimeout = require('p-timeout');

var uint8ArrayEquals = require('uint8arrays/equals');

var uint8ArrayToString = require('uint8arrays/to-string');

var libp2pRecord = require('libp2p-record');

var c = require('../constants');

var Query = require('../query');

var utils = require('../utils');

var Record = libp2pRecord.Record;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../query').DHTQueryResult} DHTQueryResult
 */

/**
 * @param {import('../')} dht
 */

module.exports = function (dht) {
  /**
   * @param {Uint8Array} key
   * @param {Uint8Array} rec
   */
  var putLocal = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, rec) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", dht.datastore.put(utils.bufferToKey(key), rec));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function putLocal(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore.
   *
   * @param {Uint8Array} key
   */


  var getLocal = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
      var raw, rec;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              dht._log("getLocal ".concat(uint8ArrayToString(key, 'base32')));

              _context2.next = 3;
              return dht.datastore.get(utils.bufferToKey(key));

            case 3:
              raw = _context2.sent;

              dht._log("found ".concat(uint8ArrayToString(key, 'base32'), " in local datastore"));

              rec = Record.deserialize(raw);
              _context2.next = 8;
              return dht._verifyRecordLocally(rec);

            case 8:
              return _context2.abrupt("return", rec);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function getLocal(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * Send the best record found to any peers that have an out of date record.
   *
   * @param {Uint8Array} key
   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT
   * @param {Uint8Array} best - the best record that was found
   */


  var sendCorrectionRecord = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key, vals, best) {
      var fixupRec;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return utils.createPutRecord(key, best);

            case 2:
              fixupRec = _context4.sent;
              return _context4.abrupt("return", Promise.all(vals.map( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(v) {
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          if (!uint8ArrayEquals(v.val, best)) {
                            _context3.next = 2;
                            break;
                          }

                          return _context3.abrupt("return");

                        case 2:
                          if (!dht._isSelf(v.from)) {
                            _context3.next = 12;
                            break;
                          }

                          _context3.prev = 3;
                          _context3.next = 6;
                          return dht._putLocal(key, fixupRec);

                        case 6:
                          _context3.next = 11;
                          break;

                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](3);

                          dht._log.error('Failed error correcting self', _context3.t0);

                        case 11:
                          return _context3.abrupt("return");

                        case 12:
                          _context3.prev = 12;
                          _context3.next = 15;
                          return dht._putValueToPeer(key, fixupRec, v.from);

                        case 15:
                          _context3.next = 20;
                          break;

                        case 17:
                          _context3.prev = 17;
                          _context3.t1 = _context3["catch"](12);

                          dht._log.error('Failed error correcting entry', _context3.t1);

                        case 20:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[3, 8], [12, 17]]);
                }));

                return function (_x7) {
                  return _ref4.apply(this, arguments);
                };
              }())));

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function sendCorrectionRecord(_x4, _x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }();

  return {
    /**
     * Store the given key/value pair locally, in the datastore.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} rec - encoded record
     */
    _putLocal: function _putLocal(key, rec) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", putLocal(key, rec));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },

    /**
     * Store the given key/value  pair in the DHT.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {object} [options] - put options
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)
     */
    put: function put(key, value) {
      var _arguments = arguments;
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var options, record, counterAll, counterSuccess, minPeers, error;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};

                dht._log('PutValue %b', key); // create record in the dht format


                _context7.next = 4;
                return utils.createPutRecord(key, value);

              case 4:
                record = _context7.sent;
                _context7.next = 7;
                return putLocal(key, record);

              case 7:
                // put record to the closest peers
                counterAll = 0;
                counterSuccess = 0;
                _context7.next = 11;
                return utils.mapParallel(dht.getClosestPeers(key, {
                  shallow: true
                }), /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(peer) {
                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.prev = 0;
                            counterAll += 1;
                            _context6.next = 4;
                            return dht._putValueToPeer(key, record, peer);

                          case 4:
                            counterSuccess += 1;
                            _context6.next = 10;
                            break;

                          case 7:
                            _context6.prev = 7;
                            _context6.t0 = _context6["catch"](0);

                            dht._log.error('Failed to put to peer (%b): %s', peer.id, _context6.t0);

                          case 10:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6, null, [[0, 7]]);
                  }));

                  return function (_x8) {
                    return _ref5.apply(this, arguments);
                  };
                }());

              case 11:
                // verify if we were able to put to enough peers
                minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`

                if (!(minPeers > counterSuccess)) {
                  _context7.next = 16;
                  break;
                }

                error = errcode(new Error("Failed to put value to enough peers: ".concat(counterSuccess, "/").concat(minPeers)), 'ERR_NOT_ENOUGH_PUT_PEERS');

                dht._log.error(error);

                throw error;

              case 16:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    },

    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     *
     * @param {Uint8Array} key
     * @param {object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     */
    get: function get(key) {
      var _arguments2 = arguments;
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var options, vals, recs, i, best;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
                options.timeout = options.timeout || c.minute;

                dht._log('_get %b', key);

                _context8.next = 5;
                return dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);

              case 5:
                vals = _context8.sent;
                recs = vals.map(function (v) {
                  return v.val;
                });
                i = 0;
                _context8.prev = 8;
                i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);
                _context8.next = 16;
                break;

              case 12:
                _context8.prev = 12;
                _context8.t0 = _context8["catch"](8);

                if (!(_context8.t0.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY')) {
                  _context8.next = 16;
                  break;
                }

                throw _context8.t0;

              case 16:
                best = recs[i];

                dht._log('GetValue %b %s', key, best);

                if (best) {
                  _context8.next = 20;
                  break;
                }

                throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');

              case 20:
                _context8.next = 22;
                return sendCorrectionRecord(key, vals, best);

              case 22:
                return _context8.abrupt("return", best);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[8, 12]]);
      }))();
    },

    /**
     * Get the `n` values to the given key without sorting.
     *
     * @param {Uint8Array} key
     * @param {number} nvals
     * @param {object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     */
    getMany: function getMany(key, nvals) {
      var _arguments3 = arguments;
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var options, vals, localRec, id, rtp, errMsg, valsLength, createQuery, query;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                createQuery = function _createQuery(pathIndex, numPaths) {
                  // This function body runs once per disjoint path
                  var pathSize = utils.pathSize(nvals - valsLength, numPaths);
                  var queryResults = 0;
                  /**
                   * Here we return the query function to use on this particular disjoint path
                   *
                   * @param {PeerId} peer
                   */

                  function disjointPathQuery(_x9) {
                    return _disjointPathQuery.apply(this, arguments);
                  }

                  function _disjointPathQuery() {
                    _disjointPathQuery = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(peer) {
                      var rec, peers, lookupErr, results, res;
                      return regeneratorRuntime.wrap(function _callee9$(_context9) {
                        while (1) {
                          switch (_context9.prev = _context9.next) {
                            case 0:
                              _context9.prev = 0;
                              _context9.next = 3;
                              return dht._getValueOrPeers(peer, key);

                            case 3:
                              results = _context9.sent;
                              rec = results.record;
                              peers = results.peers;
                              _context9.next = 13;
                              break;

                            case 8:
                              _context9.prev = 8;
                              _context9.t0 = _context9["catch"](0);

                              if (!(_context9.t0.code !== 'ERR_INVALID_RECORD')) {
                                _context9.next = 12;
                                break;
                              }

                              throw _context9.t0;

                            case 12:
                              lookupErr = _context9.t0;

                            case 13:
                              /** @type {import('../query').QueryResult} */
                              res = {
                                closerPeers: peers
                              };

                              if (rec && rec.value) {
                                vals.push({
                                  val: rec.value,
                                  from: peer
                                });
                                queryResults++;
                              } else if (lookupErr) {
                                vals.push({
                                  err: lookupErr,
                                  from: peer
                                });
                                queryResults++;
                              } // enough is enough


                              if (queryResults >= pathSize) {
                                res.pathComplete = true;
                              }

                              return _context9.abrupt("return", res);

                            case 17:
                            case "end":
                              return _context9.stop();
                          }
                        }
                      }, _callee9, null, [[0, 8]]);
                    }));
                    return _disjointPathQuery.apply(this, arguments);
                  }

                  return disjointPathQuery;
                };

                options = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};
                options.timeout = options.timeout || c.minute;

                dht._log('getMany %b (%s)', key, nvals);

                vals = [];
                _context10.prev = 5;
                _context10.next = 8;
                return getLocal(key);

              case 8:
                localRec = _context10.sent;
                _context10.next = 15;
                break;

              case 11:
                _context10.prev = 11;
                _context10.t0 = _context10["catch"](5);

                if (!(nvals === 0)) {
                  _context10.next = 15;
                  break;
                }

                throw _context10.t0;

              case 15:
                if (localRec) {
                  vals.push({
                    val: localRec.value,
                    from: dht.peerId
                  });
                }

                if (!(vals.length >= nvals)) {
                  _context10.next = 18;
                  break;
                }

                return _context10.abrupt("return", vals);

              case 18:
                _context10.next = 20;
                return utils.convertBuffer(key);

              case 20:
                id = _context10.sent;
                rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);

                dht._log('peers in rt: %d', rtp.length);

                if (!(rtp.length === 0)) {
                  _context10.next = 29;
                  break;
                }

                errMsg = 'Failed to lookup key! No peers from routing table!';

                dht._log.error(errMsg);

                if (!(vals.length === 0)) {
                  _context10.next = 28;
                  break;
                }

                throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');

              case 28:
                return _context10.abrupt("return", vals);

              case 29:
                valsLength = vals.length;
                /**
                 * @param {number} pathIndex
                 * @param {number} numPaths
                 */

                // we have peers, lets send the actual query to them
                query = new Query(dht, key, createQuery);
                _context10.prev = 31;
                _context10.next = 34;
                return pTimeout(query.run(rtp), options.timeout);

              case 34:
                _context10.next = 40;
                break;

              case 36:
                _context10.prev = 36;
                _context10.t1 = _context10["catch"](31);

                if (!(vals.length === 0)) {
                  _context10.next = 40;
                  break;
                }

                throw _context10.t1;

              case 40:
                _context10.prev = 40;
                query.stop();
                return _context10.finish(40);

              case 43:
                return _context10.abrupt("return", vals);

              case 44:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[5, 11], [31, 36, 40, 43]]);
      }))();
    }
  };
};
},{"err-code":"node_modules/err-code/index.js","p-timeout":"node_modules/p-timeout/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","libp2p-record":"node_modules/libp2p-record/src/index.js","../constants":"node_modules/libp2p-kad-dht/src/constants.js","../query":"node_modules/libp2p-kad-dht/src/query/index.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/peer-list/index.js":[function(require,module,exports) {
'use strict';
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../').PeerData} PeerData
 */

/**
 * A list of unique peers.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PeerList = /*#__PURE__*/function () {
  function PeerList() {
    _classCallCheck(this, PeerList);

    /** @type {PeerData[]} */
    this.list = [];
  }
  /**
   * Add a new peer. Returns `true` if it was a new one
   *
   * @param {PeerData} peerData
   */


  _createClass(PeerList, [{
    key: "push",
    value: function push(peerData) {
      if (!this.has(peerData.id)) {
        this.list.push(peerData);
        return true;
      }

      return false;
    }
    /**
     * Check if this PeerData is already in here.
     *
     * @param {PeerId} peerId
     */

  }, {
    key: "has",
    value: function has(peerId) {
      var match = this.list.find(function (i) {
        return i.id.equals(peerId);
      });
      return Boolean(match);
    }
    /**
     * Get the list as an array.
     */

  }, {
    key: "toArray",
    value: function toArray() {
      return this.list.slice();
    }
    /**
     * Remove the last element
     */

  }, {
    key: "pop",
    value: function pop() {
      return this.list.pop();
    }
    /**
     * The length of the list
     */

  }, {
    key: "length",
    get: function get() {
      return this.list.length;
    }
  }]);

  return PeerList;
}();

module.exports = PeerList;
},{}],"node_modules/libp2p-kad-dht/src/peer-list/limited-peer-list.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var PeerList = require('.');
/**
 * @typedef {import('../').PeerData} PeerData
 */

/**
 * Like PeerList but with a length restriction.
 */


var LimitedPeerList = /*#__PURE__*/function (_PeerList) {
  _inherits(LimitedPeerList, _PeerList);

  var _super = _createSuper(LimitedPeerList);

  /**
   * Create a new limited peer list.
   *
   * @param {number} limit
   */
  function LimitedPeerList(limit) {
    var _this;

    _classCallCheck(this, LimitedPeerList);

    _this = _super.call(this);
    _this.limit = limit;
    return _this;
  }
  /**
   * Add a PeerData if it fits in the list
   *
   * @param {PeerData} peerData
   */


  _createClass(LimitedPeerList, [{
    key: "push",
    value: function push(peerData) {
      if (this.length < this.limit) {
        return _get(_getPrototypeOf(LimitedPeerList.prototype), "push", this).call(this, peerData);
      }

      return false;
    }
  }]);

  return LimitedPeerList;
}(PeerList);

module.exports = LimitedPeerList;
},{".":"node_modules/libp2p-kad-dht/src/peer-list/index.js"}],"node_modules/libp2p-kad-dht/src/content-routing/index.js":[function(require,module,exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

var errcode = require('err-code');

var pTimeout = require('p-timeout');

var c = require('../constants');

var LimitedPeerList = require('../peer-list/limited-peer-list');

var Message = require('../message');

var Query = require('../query');

var utils = require('../utils');
/**
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @param {import('../')} dht
 */


module.exports = function (dht) {
  /**
   * Check for providers from a single node.
   *
   * @param {PeerId} peer
   * @param {CID} key
   *
   * @private
   */
  var findProvidersSingle = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peer, key) {
      var msg;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // eslint-disable-line require-await
              msg = new Message(Message.TYPES.GET_PROVIDERS, key.bytes, 0);
              return _context.abrupt("return", dht.network.sendRequest(peer, msg));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function findProvidersSingle(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  return {
    /**
     * Announce to the network that we can provide the value for a given key
     *
     * @param {CID} key
     */
    provide: function provide(key) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var errors, multiaddrs, msg, mapPeer, _mapPeer;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _mapPeer = function _mapPeer3() {
                  _mapPeer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer) {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            dht._log("putProvider ".concat(key, " to ").concat(peer.toB58String()));

                            _context2.prev = 1;
                            _context2.next = 4;
                            return dht.network.sendMessage(peer, msg);

                          case 4:
                            _context2.next = 9;
                            break;

                          case 6:
                            _context2.prev = 6;
                            _context2.t0 = _context2["catch"](1);
                            errors.push(_context2.t0);

                          case 9:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[1, 6]]);
                  }));
                  return _mapPeer.apply(this, arguments);
                };

                mapPeer = function _mapPeer2(_x3) {
                  return _mapPeer.apply(this, arguments);
                };

                dht._log("provide: ".concat(key));
                /** @type {Error[]} */


                errors = []; // Add peer as provider

                _context3.next = 6;
                return dht.providers.addProvider(key, dht.peerId);

              case 6:
                multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];
                msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0);
                msg.providerPeers = [{
                  id: dht.peerId,
                  multiaddrs: multiaddrs
                }];
                /**
                 * @param {PeerId} peer
                 */

                _context3.next = 11;
                return utils.mapParallel(dht.getClosestPeers(key.bytes), mapPeer);

              case 11:
                if (!errors.length) {
                  _context3.next = 13;
                  break;
                }

                throw errcode(new Error("Failed to provide to ".concat(errors.length, " of ").concat(dht.kBucketSize, " peers")), 'ERR_SOME_PROVIDES_FAILED', {
                  errors: errors
                });

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {Object} [options] - findProviders options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */
    findProviders: function findProviders(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        timeout: 60000,
        maxNumProviders: 5
      };
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var providerTimeout, n, out, provs, _iterator, _step, pData, paths, makePath, query, peers, _iterator2, _step2, _pData;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                makePath = function _makePath(pathIndex, numPaths) {
                  // This function body runs once per disjoint path
                  var pathSize = utils.pathSize(n - out.length, numPaths);
                  var pathProviders = new LimitedPeerList(pathSize);
                  paths.push(pathProviders);
                  /**
                   * The query function to use on this particular disjoint path
                   *
                   * @param {PeerId} peer
                   */

                  function queryDisjointPath(_x4) {
                    return _queryDisjointPath.apply(this, arguments);
                  }

                  function _queryDisjointPath() {
                    _queryDisjointPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peer) {
                      var msg, provs;
                      return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.next = 2;
                              return findProvidersSingle(peer, key);

                            case 2:
                              msg = _context4.sent;
                              provs = msg.providerPeers;

                              dht._log("Found ".concat(provs.length, " provider entries for ").concat(key));

                              provs.forEach(function (prov) {
                                pathProviders.push(_objectSpread({}, prov));
                              }); // hooray we have all that we want

                              if (!(pathProviders.length >= pathSize)) {
                                _context4.next = 8;
                                break;
                              }

                              return _context4.abrupt("return", {
                                pathComplete: true
                              });

                            case 8:
                              return _context4.abrupt("return", {
                                closerPeers: msg.closerPeers
                              });

                            case 9:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));
                    return _queryDisjointPath.apply(this, arguments);
                  }

                  return queryDisjointPath;
                };

                providerTimeout = options.timeout || c.minute;
                n = options.maxNumProviders || c.K;

                dht._log("findProviders ".concat(key));

                out = new LimitedPeerList(n);
                _context5.next = 7;
                return _awaitAsyncGenerator(dht.providers.getProviders(key));

              case 7:
                provs = _context5.sent;
                provs.forEach(function (id) {
                  /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */
                  var peerData = dht.peerStore.get(id);

                  if (peerData) {
                    out.push({
                      id: peerData.id,
                      multiaddrs: peerData.addresses.map(function (address) {
                        return address.multiaddr;
                      })
                    });
                  } else {
                    out.push({
                      id: id,
                      multiaddrs: []
                    });
                  }
                }); // All done

                if (!(out.length >= n)) {
                  _context5.next = 28;
                  break;
                }

                // yield values
                _iterator = _createForOfIteratorHelper(out.toArray());
                _context5.prev = 11;

                _iterator.s();

              case 13:
                if ((_step = _iterator.n()).done) {
                  _context5.next = 19;
                  break;
                }

                pData = _step.value;
                _context5.next = 17;
                return pData;

              case 17:
                _context5.next = 13;
                break;

              case 19:
                _context5.next = 24;
                break;

              case 21:
                _context5.prev = 21;
                _context5.t0 = _context5["catch"](11);

                _iterator.e(_context5.t0);

              case 24:
                _context5.prev = 24;

                _iterator.f();

                return _context5.finish(24);

              case 27:
                return _context5.abrupt("return");

              case 28:
                // need more, query the network

                /** @type {LimitedPeerList[]} */
                paths = [];
                /**
                 *
                 * @param {number} pathIndex
                 * @param {number} numPaths
                 */

                query = new Query(dht, key.bytes, makePath);
                peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize);
                _context5.prev = 31;
                _context5.next = 34;
                return _awaitAsyncGenerator(pTimeout(query.run(peers), providerTimeout));

              case 34:
                _context5.next = 40;
                break;

              case 36:
                _context5.prev = 36;
                _context5.t1 = _context5["catch"](31);

                if (!(_context5.t1.name !== pTimeout.TimeoutError.name)) {
                  _context5.next = 40;
                  break;
                }

                throw _context5.t1;

              case 40:
                _context5.prev = 40;
                query.stop();
                return _context5.finish(40);

              case 43:
                // combine peers from each path
                paths.forEach(function (path) {
                  path.toArray().forEach(function (peer) {
                    out.push(peer);
                  });
                });
                _iterator2 = _createForOfIteratorHelper(out.toArray());
                _context5.prev = 45;

                _iterator2.s();

              case 47:
                if ((_step2 = _iterator2.n()).done) {
                  _context5.next = 53;
                  break;
                }

                _pData = _step2.value;
                _context5.next = 51;
                return _pData;

              case 51:
                _context5.next = 47;
                break;

              case 53:
                _context5.next = 58;
                break;

              case 55:
                _context5.prev = 55;
                _context5.t2 = _context5["catch"](45);

                _iterator2.e(_context5.t2);

              case 58:
                _context5.prev = 58;

                _iterator2.f();

                return _context5.finish(58);

              case 61:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[11, 21, 24, 27], [31, 36, 40, 43], [45, 55, 58, 61]]);
      }))();
    }
  };
};
},{"err-code":"node_modules/err-code/index.js","p-timeout":"node_modules/p-timeout/index.js","../constants":"node_modules/libp2p-kad-dht/src/constants.js","../peer-list/limited-peer-list":"node_modules/libp2p-kad-dht/src/peer-list/limited-peer-list.js","../message":"node_modules/libp2p-kad-dht/src/message/index.js","../query":"node_modules/libp2p-kad-dht/src/query/index.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/peer-routing/index.js":[function(require,module,exports) {
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

var errcode = require('err-code');

var pTimeout = require('p-timeout');

var PeerId = require('peer-id');

var crypto = require('libp2p-crypto');

var uint8ArrayToString = require('uint8arrays/to-string');

var c = require('../constants');

var Message = require('../message');

var Query = require('../query');

var utils = require('../utils');
/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */

/**
 * @param {import('../index')} dht
 */


module.exports = function (dht) {
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   *
   * @param {PeerId} peer
   */
  var findPeerLocal = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(peer) {
      var p, peerData;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              dht._log("findPeerLocal ".concat(peer.toB58String()));

              _context.next = 3;
              return dht.routingTable.find(peer);

            case 3:
              p = _context.sent;

              /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */
              peerData = p && dht.peerStore.get(p);

              if (!peerData) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", {
                id: peerData.id,
                multiaddrs: peerData.addresses.map(function (address) {
                  return address.multiaddr;
                })
              });

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function findPeerLocal(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Get a value via rpc call for the given parameters.
   *
   * @param {PeerId} peer
   * @param {Uint8Array} key
   * @returns {Promise<Message>}
   * @private
   */


  var getValueSingle = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(peer, key) {
      var msg;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // eslint-disable-line require-await
              msg = new Message(Message.TYPES.GET_VALUE, key, 0);
              return _context2.abrupt("return", dht.network.sendRequest(peer, msg));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function getValueSingle(_x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * Find close peers for a given peer
   *
   * @param {Uint8Array} key
   * @param {PeerId} peer
   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}
   * @private
   */


  var closerPeersSingle = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, peer) {
      var msg;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              dht._log("closerPeersSingle ".concat(uint8ArrayToString(key, 'base32'), " from ").concat(peer.toB58String()));

              _context3.next = 3;
              return dht.peerRouting._findPeerSingle(peer, new PeerId(key));

            case 3:
              msg = _context3.sent;
              return _context3.abrupt("return", msg.closerPeers.filter(function (peerData) {
                return !dht._isSelf(peerData.id);
              }).map(function (peerData) {
                dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);
                return peerData;
              }));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function closerPeersSingle(_x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
   * Get the public key directly from a node.
   *
   * @param {PeerId} peer
   */


  var getPublicKeyFromNode = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(peer) {
      var pkKey, msg, recPeer;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              pkKey = utils.keyForPublicKey(peer);
              _context4.next = 3;
              return getValueSingle(peer, pkKey);

            case 3:
              msg = _context4.sent;

              if (!(!msg.record || !msg.record.value)) {
                _context4.next = 6;
                break;
              }

              throw errcode(new Error("Node not responding with its public key: ".concat(peer.toB58String())), 'ERR_INVALID_RECORD');

            case 6:
              _context4.next = 8;
              return PeerId.createFromPubKey(msg.record.value);

            case 8:
              recPeer = _context4.sent;

              if (recPeer.equals(peer)) {
                _context4.next = 11;
                break;
              }

              throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');

            case 11:
              return _context4.abrupt("return", recPeer.pubKey);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function getPublicKeyFromNode(_x6) {
      return _ref4.apply(this, arguments);
    };
  }();

  return {
    /**
     * Ask peer `peer` if they know where the peer with id `target` is.
     *
     * @param {PeerId} peer
     * @param {PeerId} target
     * @returns {Promise<Message>}
     * @private
     */
    _findPeerSingle: function _findPeerSingle(peer, target) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var msg;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // eslint-disable-line require-await
                dht._log('findPeerSingle %s', peer.toB58String());

                msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);
                return _context5.abrupt("return", dht.network.sendRequest(peer, msg));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },

    /**
     * Search for a peer with the given ID.
     *
     * @param {PeerId} id
     * @param {Object} [options] - findPeer options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds
     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */
    findPeer: function findPeer(id) {
      var _arguments = arguments,
          _this = this;

      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var options, pi, key, peers, match, peer, query, result, success, peerData;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {
                  timeout: 60000
                };
                options.timeout = options.timeout || c.minute;

                dht._log('findPeer %s', id.toB58String()); // Try to find locally


                _context7.next = 5;
                return findPeerLocal(id);

              case 5:
                pi = _context7.sent;

                if (!(pi != null)) {
                  _context7.next = 9;
                  break;
                }

                dht._log('found local');

                return _context7.abrupt("return", pi);

              case 9:
                _context7.next = 11;
                return utils.convertPeerId(id);

              case 11:
                key = _context7.sent;
                peers = dht.routingTable.closestPeers(key, dht.kBucketSize);

                if (!(peers.length === 0)) {
                  _context7.next = 15;
                  break;
                }

                throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');

              case 15:
                // sanity check
                match = peers.find(function (p) {
                  return p.isEqual(id);
                });

                if (!match) {
                  _context7.next = 21;
                  break;
                }

                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */
                peer = dht.peerStore.get(id);

                if (!peer) {
                  _context7.next = 21;
                  break;
                }

                dht._log('found in peerStore');

                return _context7.abrupt("return", {
                  id: peer.id,
                  multiaddrs: peer.addresses.map(function (address) {
                    return address.multiaddr;
                  })
                });

              case 21:
                // query the network
                query = new Query(dht, id.id, function () {
                  /**
                   * There is no distinction between the disjoint paths, so there are no per-path
                   * variables in dht scope. Just return the actual query function.
                   *
                   * @param {PeerId} peer
                   */
                  var queryFn = /*#__PURE__*/function () {
                    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(peer) {
                      var msg, match;
                      return regeneratorRuntime.wrap(function _callee6$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.next = 2;
                              return _this._findPeerSingle(peer, id);

                            case 2:
                              msg = _context6.sent;
                              match = msg.closerPeers.find(function (p) {
                                return p.id.isEqual(id);
                              }); // found it

                              if (!match) {
                                _context6.next = 6;
                                break;
                              }

                              return _context6.abrupt("return", {
                                peer: match,
                                queryComplete: true
                              });

                            case 6:
                              return _context6.abrupt("return", {
                                closerPeers: msg.closerPeers
                              });

                            case 7:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      }, _callee6);
                    }));

                    return function queryFn(_x7) {
                      return _ref5.apply(this, arguments);
                    };
                  }();

                  return queryFn;
                });
                _context7.prev = 22;
                _context7.next = 25;
                return pTimeout(query.run(peers), options.timeout);

              case 25:
                result = _context7.sent;

              case 26:
                _context7.prev = 26;
                query.stop();
                return _context7.finish(26);

              case 29:
                success = false;
                result.paths.forEach(function (result) {
                  if (result.success && result.peer) {
                    success = true;
                    dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);
                  }
                });

                dht._log('findPeer %s: %s', id.toB58String(), success);

                if (success) {
                  _context7.next = 34;
                  break;
                }

                throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');

              case 34:
                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */
                peerData = dht.peerStore.get(id);

                if (peerData) {
                  _context7.next = 37;
                  break;
                }

                throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');

              case 37:
                return _context7.abrupt("return", {
                  id: peerData.id,
                  multiaddrs: peerData.addresses.map(function (address) {
                    return address.multiaddr;
                  })
                });

              case 38:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[22,, 26, 29]]);
      }))();
    },

    /**
     * Kademlia 'node lookup' operation.
     *
     * @param {Uint8Array} key
     * @param {Object} [options]
     * @param {boolean} [options.shallow=false] - shallow query
     * @returns {AsyncIterable<PeerId>}
     */
    getClosestPeers: function getClosestPeers(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        shallow: false
      };
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var id, tablePeers, q, res, sorted, _iterator, _step, pId;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                dht._log('getClosestPeers to %b', key);

                _context9.next = 3;
                return _awaitAsyncGenerator(utils.convertBuffer(key));

              case 3:
                id = _context9.sent;
                tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);
                q = new Query(dht, key, function () {
                  // There is no distinction between the disjoint paths,
                  // so there are no per-path variables in dht scope.
                  // Just return the actual query function.
                  return /*#__PURE__*/function () {
                    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(peer) {
                      var closer;
                      return regeneratorRuntime.wrap(function _callee8$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              _context8.next = 2;
                              return closerPeersSingle(key, peer);

                            case 2:
                              closer = _context8.sent;
                              return _context8.abrupt("return", {
                                closerPeers: closer,
                                pathComplete: options.shallow ? true : undefined
                              });

                            case 4:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, _callee8);
                    }));

                    return function (_x8) {
                      return _ref6.apply(this, arguments);
                    };
                  }();
                });
                _context9.next = 8;
                return _awaitAsyncGenerator(q.run(tablePeers));

              case 8:
                res = _context9.sent;

                if (!(!res || !res.finalSet)) {
                  _context9.next = 11;
                  break;
                }

                return _context9.abrupt("return", []);

              case 11:
                _context9.next = 13;
                return _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));

              case 13:
                sorted = _context9.sent;
                _iterator = _createForOfIteratorHelper(sorted.slice(0, dht.kBucketSize));
                _context9.prev = 15;

                _iterator.s();

              case 17:
                if ((_step = _iterator.n()).done) {
                  _context9.next = 23;
                  break;
                }

                pId = _step.value;
                _context9.next = 21;
                return pId;

              case 21:
                _context9.next = 17;
                break;

              case 23:
                _context9.next = 28;
                break;

              case 25:
                _context9.prev = 25;
                _context9.t0 = _context9["catch"](15);

                _iterator.e(_context9.t0);

              case 28:
                _context9.prev = 28;

                _iterator.f();

                return _context9.finish(28);

              case 31:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, null, [[15, 25, 28, 31]]);
      }))();
    },

    /**
     * Get the public key for the given peer id.
     *
     * @param {PeerId} peer
     */
    getPublicKey: function getPublicKey(peer) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var peerData, pk, pkKey, value, peerId, addrs;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                dht._log('getPublicKey %s', peer.toB58String()); // local check

                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */


                peerData = dht.peerStore.get(peer);

                if (!(peerData && peerData.id.pubKey)) {
                  _context10.next = 5;
                  break;
                }

                dht._log('getPublicKey: found local copy');

                return _context10.abrupt("return", peerData.id.pubKey);

              case 5:
                _context10.prev = 5;
                _context10.next = 8;
                return getPublicKeyFromNode(peer);

              case 8:
                pk = _context10.sent;
                _context10.next = 18;
                break;

              case 11:
                _context10.prev = 11;
                _context10.t0 = _context10["catch"](5);
                // try dht directly
                pkKey = utils.keyForPublicKey(peer);
                _context10.next = 16;
                return dht.get(pkKey);

              case 16:
                value = _context10.sent;
                pk = crypto.keys.unmarshalPublicKey(value);

              case 18:
                peerId = new PeerId(peer.id, undefined, pk);
                addrs = (peerData && peerData.addresses || []).map(function (address) {
                  return address.multiaddr;
                });
                dht.peerStore.addressBook.add(peerId, addrs);
                dht.peerStore.keyBook.set(peerId, pk);
                return _context10.abrupt("return", pk);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[5, 11]]);
      }))();
    }
  };
};
},{"err-code":"node_modules/err-code/index.js","p-timeout":"node_modules/p-timeout/index.js","peer-id":"node_modules/peer-id/src/index.js","libp2p-crypto":"node_modules/libp2p-crypto/src/index.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","../constants":"node_modules/libp2p-kad-dht/src/constants.js","../message":"node_modules/libp2p-kad-dht/src/message/index.js","../query":"node_modules/libp2p-kad-dht/src/query/index.js","../utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/providers.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var cache = require('hashlru'); // @ts-ignore


var varint = require('varint');

var PeerId = require('peer-id');

var _require = require('interface-datastore'),
    Key = _require.Key;

var _require2 = require('p-queue'),
    Queue = _require2.default;

var c = require('./constants');

var utils = require('./utils');
/**
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('interface-datastore').Datastore} Datastore
 */

/**
 * This class manages known providers.
 * A provider is a peer that we know to have the content for a given CID.
 *
 * Every `cleanupInterval` providers are checked if they
 * are still valid, i.e. younger than the `provideValidity`.
 * If they are not, they are deleted.
 *
 * To ensure the list survives restarts of the daemon,
 * providers are stored in the datastore, but to ensure
 * access is fast there is an LRU cache in front of that.
 */


var Providers = /*#__PURE__*/function () {
  /**
   * @param {Datastore} datastore
   * @param {PeerId} [self]
   * @param {number} [cacheSize=256]
   */
  function Providers(datastore, self, cacheSize) {
    _classCallCheck(this, Providers);

    this.datastore = datastore;
    this._log = utils.logger(self, 'providers');
    /**
     * How often invalid records are cleaned. (in seconds)
     *
     * @type {number}
     */

    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;
    /**
     * How long is a provider valid for. (in seconds)
     *
     * @type {number}
     */

    this.provideValidity = c.PROVIDERS_VALIDITY;
    /**
     * LRU cache size
     *
     * @type {number}
     */

    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE; // @ts-ignore hashlru types are wrong

    this.providers = cache(this.lruCacheSize);
    this.syncQueue = new Queue({
      concurrency: 1
    });
  }
  /**
   * Start the provider cleanup service
   */


  _createClass(Providers, [{
    key: "start",
    value: function start() {
      var _this = this;

      this._cleaner = setInterval(function () {
        return _this._cleanup();
      }, this.cleanupInterval);
    }
    /**
     * Release any resources.
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._cleaner) {
        clearInterval(this._cleaner);
        this._cleaner = null;
      }
    }
    /**
     * Check all providers if they are still valid, and if not delete them.
     *
     * @returns {Promise<void>}
     * @private
     */

  }, {
    key: "_cleanup",
    value: function _cleanup() {
      var _this2 = this;

      return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var start, count, deleteCount, deleted, batch, query, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this2._log('start cleanup');

                start = Date.now();
                count = 0;
                deleteCount = 0;
                deleted = new Map();
                batch = _this2.datastore.batch(); // Get all provider entries from the datastore

                query = _this2.datastore.query({
                  prefix: c.PROVIDERS_KEY_PREFIX
                });
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context.prev = 9;
                _iterator = _asyncIterator(query);

              case 11:
                _context.next = 13;
                return _iterator.next();

              case 13:
                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                  _context.next = 19;
                  break;
                }

                entry = _step.value;

                try {
                  // Add a delete to the batch for each expired entry
                  _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;
                  time = readTime(entry.value);
                  now = Date.now();
                  delta = now - time;
                  expired = delta > _this2.provideValidity;

                  _this2._log('comparing: %d - %d = %d > %d %s', now, time, delta, _this2.provideValidity, expired ? '(expired)' : '');

                  if (expired) {
                    deleteCount++;
                    batch.delete(entry.key);
                    peers = deleted.get(cid) || new Set();
                    peers.add(peerId);
                    deleted.set(cid, peers);
                  }

                  count++;
                } catch (err) {
                  _this2._log.error(err.message);
                }

              case 16:
                _iteratorAbruptCompletion = false;
                _context.next = 11;
                break;

              case 19:
                _context.next = 25;
                break;

              case 21:
                _context.prev = 21;
                _context.t0 = _context["catch"](9);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 25:
                _context.prev = 25;
                _context.prev = 26;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context.next = 30;
                  break;
                }

                _context.next = 30;
                return _iterator.return();

              case 30:
                _context.prev = 30;

                if (!_didIteratorError) {
                  _context.next = 33;
                  break;
                }

                throw _iteratorError;

              case 33:
                return _context.finish(30);

              case 34:
                return _context.finish(25);

              case 35:
                _this2._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore


                if (!deleted.size) {
                  _context.next = 39;
                  break;
                }

                _context.next = 39;
                return batch.commit();

              case 39:
                // Clear expired entries from the cache
                _iterator3 = _createForOfIteratorHelper(deleted);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];
                    key = makeProviderKey(_cid);
                    provs = _this2.providers.get(key);

                    if (provs) {
                      _iterator4 = _createForOfIteratorHelper(_peers);

                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                          _peerId = _step4.value;
                          provs.delete(_peerId);
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }

                      if (provs.size === 0) {
                        _this2.providers.remove(key);
                      } else {
                        _this2.providers.set(key, provs);
                      }
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                _this2._log('Cleanup successful (%dms)', Date.now() - start);

              case 42:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[9, 21, 25, 35], [26,, 30, 34]]);
      })));
    }
    /**
     * Get the currently known provider peer ids for a given CID.
     *
     * @param {CID} cid
     * @returns {Promise<Map<string, Date>>}
     *
     * @private
     */

  }, {
    key: "_getProvidersMap",
    value: function () {
      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cid) {
        var cacheKey, provs;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                cacheKey = makeProviderKey(cid);
                provs = this.providers.get(cacheKey);

                if (provs) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 5;
                return loadProviders(this.datastore, cid);

              case 5:
                provs = _context2.sent;
                this.providers.set(cacheKey, provs);

              case 7:
                return _context2.abrupt("return", provs);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getProvidersMap(_x) {
        return _getProvidersMap2.apply(this, arguments);
      }

      return _getProvidersMap;
    }()
    /**
     * Add a new provider for the given CID.
     *
     * @param {CID} cid
     * @param {PeerId} provider
     * @returns {Promise<void>}
     */

  }, {
    key: "addProvider",
    value: function () {
      var _addProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(cid, provider) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                  var provs, now, dsKey;
                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _this3._log('addProvider %s', cid.toString());

                          _context3.next = 3;
                          return _this3._getProvidersMap(cid);

                        case 3:
                          provs = _context3.sent;

                          _this3._log('loaded %s provs', provs.size);

                          now = new Date();
                          provs.set(utils.encodeBase32(provider.id), now);
                          dsKey = makeProviderKey(cid);

                          _this3.providers.set(dsKey, provs);

                          return _context3.abrupt("return", writeProviderEntry(_this3.datastore, cid, provider, now));

                        case 10:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }))));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function addProvider(_x2, _x3) {
        return _addProvider.apply(this, arguments);
      }

      return addProvider;
    }()
    /**
     * Get a list of providers for the given CID.
     *
     * @param {CID} cid
     * @returns {Promise<Array<PeerId>>}
     */

  }, {
    key: "getProviders",
    value: function () {
      var _getProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(cid) {
        var _this4 = this;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  var provs;
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _this4._log('getProviders %s', cid.toString());

                          _context5.next = 3;
                          return _this4._getProvidersMap(cid);

                        case 3:
                          provs = _context5.sent;
                          return _context5.abrupt("return", _toConsumableArray(provs.keys()).map(function (base32PeerId) {
                            return new PeerId(utils.decodeBase32(base32PeerId));
                          }));

                        case 5:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }))));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getProviders(_x4) {
        return _getProviders.apply(this, arguments);
      }

      return getProviders;
    }()
  }]);

  return Providers;
}();
/**
 * Encode the given key its matching datastore key.
 *
 * @param {CID|string} cid - cid or base32 encoded string
 * @returns {string}
 *
 * @private
 */


function makeProviderKey(cid) {
  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.bytes);
  return c.PROVIDERS_KEY_PREFIX + cid;
}
/**
 * Write a provider into the given store.
 *
 * @param {Datastore} store
 * @param {CID} cid
 * @param {PeerId} peer
 * @param {Date} time
 */


function writeProviderEntry(_x5, _x6, _x7, _x8) {
  return _writeProviderEntry.apply(this, arguments);
}
/**
 * Parse the CID and provider peer id from the key
 *
 * @param {import('interface-datastore').Key} key
 */


function _writeProviderEntry() {
  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(store, cid, peer, time) {
    var dsKey, key, buffer;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            // eslint-disable-line require-await
            dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');
            key = new Key(dsKey);
            buffer = Uint8Array.from(varint.encode(time.getTime()));
            return _context7.abrupt("return", store.put(key, buffer));

          case 4:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _writeProviderEntry.apply(this, arguments);
}

function parseProviderKey(key) {
  var parts = key.toString().split('/');

  if (parts.length !== 4) {
    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);
  }

  return {
    cid: parts[2],
    peerId: parts[3]
  };
}
/**
 * Load providers for the given CID from the store.
 *
 * @param {Datastore} store
 * @param {CID} cid
 * @returns {Promise<Map<PeerId, Date>>}
 *
 * @private
 */


function loadProviders(_x9, _x10) {
  return _loadProviders.apply(this, arguments);
}
/**
 * @param {Uint8Array} buf
 */


function _loadProviders() {
  _loadProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(store, cid) {
    var providers, query, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, _parseProviderKey2, peerId;

    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            providers = new Map();
            query = store.query({
              prefix: makeProviderKey(cid)
            });
            _iteratorAbruptCompletion2 = false;
            _didIteratorError2 = false;
            _context8.prev = 4;
            _iterator2 = _asyncIterator(query);

          case 6:
            _context8.next = 8;
            return _iterator2.next();

          case 8:
            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context8.sent).done)) {
              _context8.next = 15;
              break;
            }

            entry = _step2.value;
            _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;
            providers.set(peerId, readTime(entry.value));

          case 12:
            _iteratorAbruptCompletion2 = false;
            _context8.next = 6;
            break;

          case 15:
            _context8.next = 21;
            break;

          case 17:
            _context8.prev = 17;
            _context8.t0 = _context8["catch"](4);
            _didIteratorError2 = true;
            _iteratorError2 = _context8.t0;

          case 21:
            _context8.prev = 21;
            _context8.prev = 22;

            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {
              _context8.next = 26;
              break;
            }

            _context8.next = 26;
            return _iterator2.return();

          case 26:
            _context8.prev = 26;

            if (!_didIteratorError2) {
              _context8.next = 29;
              break;
            }

            throw _iteratorError2;

          case 29:
            return _context8.finish(26);

          case 30:
            return _context8.finish(21);

          case 31:
            return _context8.abrupt("return", providers);

          case 32:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[4, 17, 21, 31], [22,, 26, 30]]);
  }));
  return _loadProviders.apply(this, arguments);
}

function readTime(buf) {
  return varint.decode(buf);
}

module.exports = Providers;
},{"hashlru":"node_modules/hashlru/index.js","varint":"node_modules/varint/index.js","peer-id":"node_modules/peer-id/src/index.js","interface-datastore":"node_modules/interface-datastore/src/index.js","p-queue":"node_modules/p-queue/dist/index.js","./constants":"node_modules/libp2p-kad-dht/src/constants.js","./utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/p-times/index.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var pMap = require('p-map');

var pTimes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(count, mapper, options) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", pMap(new Array(count).fill(), function (element, index) {
              return mapper(index);
            }, options));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function pTimes(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

module.exports = pTimes; // TODO: Remove this for the next major release

module.exports.default = pTimes;
},{"p-map":"node_modules/p-map/index.js"}],"node_modules/libp2p-kad-dht/src/random-walk.js":[function(require,module,exports) {
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var crypto = require('libp2p-crypto');

var _require = require('multiformats/hashes/sha2'),
    sha256 = _require.sha256;

var PeerId = require('peer-id');

var _require2 = require('abort-controller'),
    AbortController = _require2.AbortController;

var errcode = require('err-code');

var times = require('p-times');

var c = require('./constants');

var _require3 = require('./utils'),
    logger = _require3.logger;
/**
 * @typedef {import('./')} DHT
 * @typedef {import('./').RandomWalkOptions} RandomWalkOptions
 */


var RandomWalk = /*#__PURE__*/function () {
  /**
   * @class
   * @param {DHT} dht
   * @param {RandomWalkOptions} options
   */
  function RandomWalk(dht, options) {
    _classCallCheck(this, RandomWalk);

    if (!dht) {
      throw new Error('Random Walk needs an instance of the Kademlia DHT');
    }

    this._kadDHT = dht;
    this._options = _objectSpread(_objectSpread({}, c.defaultRandomWalk), options);
    this.log = logger(dht.peerId, 'random-walk');
    /** @type {*} */

    this._timeoutId = undefined;
  }
  /**
   * Start the Random Walk process. This means running a number of queries
   * every interval requesting random data. This is done to keep the dht
   * healthy over time.
   *
   * @returns {void}
   */


  _createClass(RandomWalk, [{
    key: "start",
    value: function start() {
      var _this = this;

      if (this._running) {
        return;
      }

      this._running = true; // Don't run twice

      if (this._timeoutId || !this._options.enabled) {
        return;
      } // Start doing random walks after `this._options.delay`


      this._timeoutId = setTimeout(function () {
        // Start runner immediately
        _this._runPeriodically();
      }, this._options.delay);
    }
    /**
     * Stop the random-walk process. Any active
     * queries will be aborted.
     *
     * @returns {void}
     */

  }, {
    key: "stop",
    value: function stop() {
      this._running = false;

      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        this._timeoutId = undefined;
      }

      this._controller && this._controller.abort();
    }
    /**
     * Run function `randomWalk._walk` on every `options.interval` ms
     *
     * @private
     */

  }, {
    key: "_runPeriodically",
    value: function () {
      var _runPeriodically2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._timeoutId) {
                  _context.next = 15;
                  break;
                }

                _context.prev = 1;
                _context.next = 4;
                return this._walk(this._options.queriesPerPeriod, this._options.timeout);

              case 4:
                _context.next = 9;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](1);

                this._kadDHT._log.error('random-walk:error', _context.t0);

              case 9:
                if (this._running) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return");

              case 11:
                _context.next = 13;
                return new Promise(function (resolve) {
                  _this2._timeoutId = setTimeout(resolve, _this2._options.interval);
                });

              case 13:
                _context.next = 0;
                break;

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 6]]);
      }));

      function _runPeriodically() {
        return _runPeriodically2.apply(this, arguments);
      }

      return _runPeriodically;
    }()
    /**
     * Do the random walk work.
     *
     * @param {number} queries
     * @param {number} walkTimeout
     *
     * @private
     */

  }, {
    key: "_walk",
    value: function () {
      var _walk2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(queries, walkTimeout) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.log('start');
                this._controller = new AbortController();
                _context3.prev = 2;
                _context3.next = 5;
                return times(queries, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(index) {
                    var id;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _this3.log('running query %d', index);

                            _context2.prev = 1;
                            _context2.next = 4;
                            return _this3._randomPeerId();

                          case 4:
                            id = _context2.sent;

                            if (_this3._controller) {
                              _context2.next = 7;
                              break;
                            }

                            return _context2.abrupt("return");

                          case 7:
                            _context2.next = 9;
                            return _this3._query(id, {
                              timeout: walkTimeout,
                              signal: _this3._controller.signal
                            });

                          case 9:
                            _context2.next = 16;
                            break;

                          case 11:
                            _context2.prev = 11;
                            _context2.t0 = _context2["catch"](1);

                            if (!(_context2.t0 && _context2.t0.code !== 'ETIMEDOUT')) {
                              _context2.next = 16;
                              break;
                            }

                            _this3.log.error('query %d finished with error', index, _context2.t0);

                            throw _context2.t0;

                          case 16:
                            _this3.log('finished query %d', index);

                          case 17:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[1, 11]]);
                  }));

                  return function (_x3) {
                    return _ref.apply(this, arguments);
                  };
                }());

              case 5:
                _context3.prev = 5;
                this._controller = null;
                this.log('finished queries');
                return _context3.finish(5);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2,, 5, 9]]);
      }));

      function _walk(_x, _x2) {
        return _walk2.apply(this, arguments);
      }

      return _walk;
    }()
    /**
     * The query run during a random walk request.
     *
     * TODO: While query currently supports an abort controller, it is not
     * yet supported by `DHT.findPeer`. Once https://github.com/libp2p/js-libp2p-kad-dht/pull/82
     * is complete, and AbortController support has been added to the
     * DHT query functions, the abort here will just work, provided the
     * functions support `options.signal`. Once done, this todo should be
     * removed.
     *
     * @param {PeerId} id
     * @param {object} options
     * @param {number} options.timeout
     * @param {AbortSignal} options.signal
     *
     * @private
     */

  }, {
    key: "_query",
    value: function () {
      var _query2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(id, options) {
        var peer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.log('query:%s', id.toB58String());
                _context4.prev = 1;
                _context4.next = 4;
                return this._kadDHT.findPeer(id, options);

              case 4:
                peer = _context4.sent;
                _context4.next = 12;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](1);

                if (!(_context4.t0 && _context4.t0.code === 'ERR_NOT_FOUND')) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return");

              case 11:
                throw _context4.t0;

              case 12:
                this.log('query:found', peer); // wait what, there was something found? Lucky day!

                throw errcode(new Error("random-walk: ACTUALLY FOUND PEER: ".concat(peer, ", ").concat(id.toB58String())), 'ERR_FOUND_RANDOM_PEER');

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 7]]);
      }));

      function _query(_x4, _x5) {
        return _query2.apply(this, arguments);
      }

      return _query;
    }()
    /**
     * Generate a random peer id for random-walk purposes.
     *
     * @returns {Promise<PeerId>}
     *
     * @private
     */

  }, {
    key: "_randomPeerId",
    value: function () {
      var _randomPeerId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var digest;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return sha256.digest(crypto.randomBytes(16));

              case 2:
                digest = _context5.sent;
                return _context5.abrupt("return", new PeerId(digest.bytes));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function _randomPeerId() {
        return _randomPeerId2.apply(this, arguments);
      }

      return _randomPeerId;
    }()
  }]);

  return RandomWalk;
}();

module.exports = RandomWalk;
},{"libp2p-crypto":"node_modules/libp2p-crypto/src/index.js","multiformats/hashes/sha2":"node_modules/multiformats/cjs/src/hashes/sha2-browser.js","peer-id":"node_modules/peer-id/src/index.js","abort-controller":"node_modules/abort-controller/browser.js","err-code":"node_modules/err-code/index.js","p-times":"node_modules/p-times/index.js","./constants":"node_modules/libp2p-kad-dht/src/constants.js","./utils":"node_modules/libp2p-kad-dht/src/utils.js"}],"node_modules/libp2p-kad-dht/src/query-manager.js":[function(require,module,exports) {
'use strict';
/**
 * @typedef {import('./query')} Query
 */

/**
 * Keeps track of all running queries.
 */

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var QueryManager = /*#__PURE__*/function () {
  /**
   * Creates a new QueryManager.
   */
  function QueryManager() {
    _classCallCheck(this, QueryManager);

    this.queries = new Set();
    this.running = false;
  }
  /**
   * Called when a query is started.
   *
   * @param {Query} query
   */


  _createClass(QueryManager, [{
    key: "queryStarted",
    value: function queryStarted(query) {
      this.queries.add(query);
    }
    /**
     * Called when a query completes.
     *
     * @param {Query} query
     */

  }, {
    key: "queryCompleted",
    value: function queryCompleted(query) {
      this.queries.delete(query);
    }
    /**
     * Starts the query manager.
     */

  }, {
    key: "start",
    value: function start() {
      this.running = true;
    }
    /**
     * Stops all queries.
     */

  }, {
    key: "stop",
    value: function stop() {
      this.running = false;

      var _iterator = _createForOfIteratorHelper(this.queries),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var query = _step.value;
          query.stop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.queries.clear();
    }
  }]);

  return QueryManager;
}();

module.exports = QueryManager;
},{}],"node_modules/libp2p-kad-dht/src/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _asyncGeneratorDelegate(inner, awaitWrap) { var iter = {}, waiting = false; function pump(key, value) { waiting = true; value = new Promise(function (resolve) { resolve(inner[key](value)); }); return { done: false, value: awaitWrap(value) }; } ; iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; }; iter.next = function (value) { if (waiting) { waiting = false; return value; } return pump("next", value); }; if (typeof inner.throw === "function") { iter.throw = function (value) { if (waiting) { waiting = false; throw value; } return pump("throw", value); }; } if (typeof inner.return === "function") { iter.return = function (value) { if (waiting) { waiting = false; return value; } return pump("return", value); }; } return iter; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var errcode = require('err-code');

var libp2pRecord = require('libp2p-record');

var _require2 = require('interface-datastore'),
    MemoryDatastore = _require2.MemoryDatastore;

var uint8ArrayEquals = require('uint8arrays/equals');

var uint8ArrayToString = require('uint8arrays/to-string');

var RoutingTable = require('./routing');

var utils = require('./utils');

var c = require('./constants');

var Network = require('./network');

var contentFetching = require('./content-fetching');

var contentRouting = require('./content-routing');

var peerRouting = require('./peer-routing');

var Message = require('./message');

var Providers = require('./providers');

var RandomWalk = require('./random-walk');

var QueryManager = require('./query-manager');

var Record = libp2pRecord.Record;
/**
 * @typedef {*} Libp2p
 * @typedef {*} PeerStore
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {*} Dialer
 * @typedef {*} Registrar
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {object} PeerData
 * @property {PeerId} id
 * @property {Multiaddr[]} multiaddrs
 *
 * @typedef {object} RandomWalkOptions
 * @property {boolean} enabled discovery enabled (default: true)
 * @property {number} queriesPerPeriod how many queries to run per period (default: 1)
 * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)
 * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)
 * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)
 */

/**
 * A DHT implementation modeled after Kademlia with S/Kademlia modifications.
 * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.
 */

var KadDHT = /*#__PURE__*/function (_EventEmitter) {
  _inherits(KadDHT, _EventEmitter);

  var _super = _createSuper(KadDHT);

  /**
   * Create a new KadDHT.
   *
   * @param {Object} props
   * @param {Libp2p} props.libp2p - the libp2p instance
   * @param {Dialer} props.dialer - libp2p dialer instance
   * @param {PeerId} props.peerId - peer's peerId
   * @param {PeerStore} props.peerStore - libp2p peerStore
   * @param {Registrar} props.registrar - libp2p registrar instance
   * @param {string} [props.protocolPrefix = '/ipfs'] - libp2p registrar handle protocol
   * @param {boolean} [props.forceProtocolLegacy = false] - WARNING: this is not recommended and should only be used for legacy purposes
   * @param {number} props.kBucketSize - k-bucket size (default 20)
   * @param {boolean} props.clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)
   * @param {number} props.concurrency - alpha concurrency of queries (default 3)
   * @param {Datastore} props.datastore - datastore (default MemoryDatastore)
   * @param {object} props.validators - validators object with namespace as keys and function(key, record, callback)
   * @param {object} props.selectors - selectors object with namespace as keys and function(key, records)
   * @param {RandomWalkOptions} props.randomWalk - randomWalk options
   * @param {function(import('libp2p-record').Record, PeerId): void} [props.onPut] - Called when an entry is added to or changed in the datastore
   * @param {function(import('libp2p-record').Record): void} [props.onRemove] - Called when an entry is removed from the datastore
   */
  function KadDHT(_ref) {
    var _this3;

    var libp2p = _ref.libp2p,
        dialer = _ref.dialer,
        peerId = _ref.peerId,
        peerStore = _ref.peerStore,
        registrar = _ref.registrar,
        _ref$protocolPrefix = _ref.protocolPrefix,
        protocolPrefix = _ref$protocolPrefix === void 0 ? '/ipfs' : _ref$protocolPrefix,
        _ref$forceProtocolLeg = _ref.forceProtocolLegacy,
        forceProtocolLegacy = _ref$forceProtocolLeg === void 0 ? false : _ref$forceProtocolLeg,
        _ref$datastore = _ref.datastore,
        datastore = _ref$datastore === void 0 ? new MemoryDatastore() : _ref$datastore,
        _ref$kBucketSize = _ref.kBucketSize,
        kBucketSize = _ref$kBucketSize === void 0 ? c.K : _ref$kBucketSize,
        _ref$clientMode = _ref.clientMode,
        clientMode = _ref$clientMode === void 0 ? false : _ref$clientMode,
        _ref$concurrency = _ref.concurrency,
        concurrency = _ref$concurrency === void 0 ? c.ALPHA : _ref$concurrency,
        _ref$validators = _ref.validators,
        validators = _ref$validators === void 0 ? {} : _ref$validators,
        _ref$selectors = _ref.selectors,
        selectors = _ref$selectors === void 0 ? {} : _ref$selectors,
        _ref$randomWalk = _ref.randomWalk,
        randomWalk = _ref$randomWalk === void 0 ? {
      enabled: false,
      queriesPerPeriod: 1,
      interval: 300000,
      timeout: 30000,
      delay: 10000
    } : _ref$randomWalk,
        _ref$onPut = _ref.onPut,
        onPut = _ref$onPut === void 0 ? function () {} : _ref$onPut,
        _ref$onRemove = _ref.onRemove,
        onRemove = _ref$onRemove === void 0 ? function () {} : _ref$onRemove;

    _classCallCheck(this, KadDHT);

    _this3 = _super.call(this);

    if (!dialer) {
      throw new Error('libp2p-kad-dht requires an instance of Dialer');
    }
    /**
     * Local reference to the libp2p instance. May be undefined.
     *
     * @type {Libp2p}
     */


    _this3.libp2p = libp2p;
    /**
     * Local reference to the libp2p dialer instance
     *
     * @type {Dialer}
     */

    _this3.dialer = dialer;
    /**
     * Local peer-id
     *
     * @type {PeerId}
     */

    _this3.peerId = peerId;
    /**
     * Local PeerStore
     *
     * @type {PeerStore}
     */

    _this3.peerStore = peerStore;
    /**
     * Local peer info
     *
     * @type {Registrar}
     */

    _this3.registrar = registrar;
    /**
     * Registrar protocol
     *
     * @type {string}
     */

    _this3.protocol = protocolPrefix + (forceProtocolLegacy ? '' : c.PROTOCOL_DHT);
    /**
     * k-bucket size
     *
     * @type {number}
     */

    _this3.kBucketSize = kBucketSize;
    _this3._clientMode = clientMode;
    /**
     * ALPHA concurrency at which each query path with run, defaults to 3
     *
     * @type {number}
     */

    _this3.concurrency = concurrency;
    /**
     * Number of disjoint query paths to use
     * This is set to `kBucketSize`/2 per the S/Kademlia paper
     *
     * @type {number}
     */

    _this3.disjointPaths = Math.ceil(_this3.kBucketSize / 2);
    /**
     * The routing table.
     *
     * @type {RoutingTable}
     */

    _this3.routingTable = new RoutingTable(_this3.peerId, _this3.kBucketSize);
    /**
     * Reference to the datastore, uses an in-memory store if none given.
     *
     * @type {Datastore}
     */

    _this3.datastore = datastore;
    /**
     * Provider management
     *
     * @type {Providers}
     */

    _this3.providers = new Providers(_this3.datastore, _this3.peerId);
    _this3.validators = _objectSpread({
      pk: libp2pRecord.validator.validators.pk
    }, validators);
    _this3.selectors = _objectSpread({
      pk: libp2pRecord.selection.selectors.pk
    }, selectors);
    _this3.network = new Network(_assertThisInitialized(_this3));
    _this3._log = utils.logger(_this3.peerId);
    /**
     * Random walk management
     *
     * @type {RandomWalk}
     */

    _this3.randomWalk = new RandomWalk(_assertThisInitialized(_this3), randomWalk);
    /**
     * Keeps track of running queries
     *
     * @type {QueryManager}
     */

    _this3._queryManager = new QueryManager();
    _this3._running = false; // DHT components

    _this3.contentFetching = contentFetching(_assertThisInitialized(_this3));
    _this3.contentRouting = contentRouting(_assertThisInitialized(_this3));
    _this3.peerRouting = peerRouting(_assertThisInitialized(_this3)); // datastore events

    _this3.onPut = onPut;
    _this3.onRemove = onRemove;
    return _this3;
  }
  /**
   * Is this DHT running.
   */


  _createClass(KadDHT, [{
    key: "isStarted",
    get: function get() {
      return this._running;
    }
    /**
     * Start listening to incoming connections.
     */

  }, {
    key: "start",
    value: function start() {
      if (this._running) {
        return;
      }

      this._running = true;
      this.providers.start();

      this._queryManager.start();

      this.network.start(); // Start random walk, it will not run if it's disabled

      this.randomWalk.start();
    }
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */

  }, {
    key: "stop",
    value: function stop() {
      this._running = false;
      this.randomWalk.stop();
      this.network.stop();

      this._queryManager.stop();

      this.providers.stop();
    }
    /**
     * Store the given key/value  pair in the DHT.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {Object} [options] - put options
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)
     * @returns {Promise<void>}
     */

  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, value) {
        var options,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                return _context.abrupt("return", this.contentFetching.put(key, value, options));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function put(_x, _x2) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     *
     * @param {Uint8Array} key
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     * @returns {Promise<Uint8Array>}
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
        var options,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                return _context2.abrupt("return", this.contentFetching.get(key, options));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x3) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Get the `n` values to the given key without sorting.
     *
     * @param {Uint8Array} key
     * @param {number} nvals
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     */

  }, {
    key: "getMany",
    value: function () {
      var _getMany = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, nvals) {
        var options,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
                return _context3.abrupt("return", this.contentFetching.getMany(key, nvals, options));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getMany(_x4, _x5) {
        return _getMany.apply(this, arguments);
      }

      return getMany;
    }()
    /**
     * Remove the given key from the local datastore.
     *
     * @param {Uint8Array} key
     */

  }, {
    key: "removeLocal",
    value: function () {
      var _removeLocal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key) {
        var dsKey;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._log("removeLocal: ".concat(uint8ArrayToString(key, 'base32')));

                dsKey = utils.bufferToKey(key);
                _context4.prev = 2;
                _context4.next = 5;
                return this.datastore.delete(dsKey);

              case 5:
                _context4.next = 12;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](2);

                if (!(_context4.t0.code === 'ERR_NOT_FOUND')) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return", undefined);

              case 11:
                throw _context4.t0;

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 7]]);
      }));

      function removeLocal(_x6) {
        return _removeLocal.apply(this, arguments);
      }

      return removeLocal;
    }()
    /**
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     */

  }, {
    key: "_putLocal",
    value: function () {
      var _putLocal2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(key, value) {
        var dsKey;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._log("_putLocal: ".concat(uint8ArrayToString(key, 'base32')));

                dsKey = utils.bufferToKey(key);
                _context5.next = 4;
                return this.datastore.put(dsKey, value);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _putLocal(_x7, _x8) {
        return _putLocal2.apply(this, arguments);
      }

      return _putLocal;
    }() // ----------- Content Routing

    /**
     * Announce to the network that we can provide given key's value.
     *
     * @param {CID} key
     * @returns {Promise<void>}
     */

  }, {
    key: "provide",
    value: function () {
      var _provide = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(key) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.contentRouting.provide(key));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function provide(_x9) {
        return _provide.apply(this, arguments);
      }

      return provide;
    }()
    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {Object} [options] - findProviders options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds (default: 60000)
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */

  }, {
    key: "findProviders",
    value: function findProviders(key) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        timeout: 6000,
        maxNumProviders: 5
      };
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, peerData;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context7.prev = 2;
                _iterator = _asyncIterator(_this.contentRouting.findProviders(key, options));

              case 4:
                _context7.next = 6;
                return _awaitAsyncGenerator(_iterator.next());

              case 6:
                if (!(_iteratorAbruptCompletion = !(_step = _context7.sent).done)) {
                  _context7.next = 13;
                  break;
                }

                peerData = _step.value;
                _context7.next = 10;
                return peerData;

              case 10:
                _iteratorAbruptCompletion = false;
                _context7.next = 4;
                break;

              case 13:
                _context7.next = 19;
                break;

              case 15:
                _context7.prev = 15;
                _context7.t0 = _context7["catch"](2);
                _didIteratorError = true;
                _iteratorError = _context7.t0;

              case 19:
                _context7.prev = 19;
                _context7.prev = 20;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context7.next = 24;
                  break;
                }

                _context7.next = 24;
                return _awaitAsyncGenerator(_iterator.return());

              case 24:
                _context7.prev = 24;

                if (!_didIteratorError) {
                  _context7.next = 27;
                  break;
                }

                throw _iteratorError;

              case 27:
                return _context7.finish(24);

              case 28:
                return _context7.finish(19);

              case 29:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[2, 15, 19, 29], [20,, 24, 28]]);
      }))();
    } // ----------- Peer Routing -----------

    /**
     * Search for a peer with the given ID.
     *
     * @param {PeerId} id
     * @param {Object} [options] - findPeer options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds (default: 60000)
     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */

  }, {
    key: "findPeer",
    value: function () {
      var _findPeer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(id) {
        var options,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {
                  timeout: 60000
                };
                return _context8.abrupt("return", this.peerRouting.findPeer(id, options));

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function findPeer(_x10) {
        return _findPeer.apply(this, arguments);
      }

      return findPeer;
    }()
    /**
     * Kademlia 'node lookup' operation.
     *
     * @param {Uint8Array} key
     * @param {Object} [options]
     * @param {boolean} [options.shallow = false] - shallow query
     */

  }, {
    key: "getClosestPeers",
    value: function getClosestPeers(key) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        shallow: false
      };
      return _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this2.peerRouting.getClosestPeers(key, options)), _awaitAsyncGenerator), "t0", 1);

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }))();
    }
    /**
     * Get the public key for the given peer id.
     *
     * @param {PeerId} peer
     */

  }, {
    key: "getPublicKey",
    value: function getPublicKey(peer) {
      return this.peerRouting.getPublicKey(peer);
    } // ----------- Discovery -----------

    /**
     * @param {PeerId} peerId
     * @param {Multiaddr[]} multiaddrs
     */

  }, {
    key: "_peerDiscovered",
    value: function _peerDiscovered(peerId, multiaddrs) {
      this.emit('peer', {
        id: peerId,
        multiaddrs: multiaddrs
      });
    } // ----------- Internals -----------

    /**
     * Returns the routing tables closest peers, for the key of
     * the message.
     *
     * @param {Message} msg
     */

  }, {
    key: "_nearestPeersToQuery",
    value: function () {
      var _nearestPeersToQuery2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(msg) {
        var _this4 = this;

        var key, ids;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return utils.convertBuffer(msg.key);

              case 2:
                key = _context10.sent;
                ids = this.routingTable.closestPeers(key, this.kBucketSize);
                return _context10.abrupt("return", ids.map(function (p) {
                  /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */
                  var peer = _this4.peerStore.get(p);

                  return {
                    id: p,
                    multiaddrs: peer ? peer.addresses.map(function (address) {
                      return address.multiaddr;
                    }) : []
                  };
                }));

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _nearestPeersToQuery(_x11) {
        return _nearestPeersToQuery2.apply(this, arguments);
      }

      return _nearestPeersToQuery;
    }()
    /**
     * Get the nearest peers to the given query, but iff closer
     * than self.
     *
     * @param {Message} msg
     * @param {PeerId} peerId
     */

  }, {
    key: "_betterPeersToQuery",
    value: function () {
      var _betterPeersToQuery2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(msg, peerId) {
        var _this5 = this;

        var closer;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._log('betterPeersToQuery');

                _context11.next = 3;
                return this._nearestPeersToQuery(msg);

              case 3:
                closer = _context11.sent;
                return _context11.abrupt("return", closer.filter(function (closer) {
                  if (_this5._isSelf(closer.id)) {
                    // Should bail, not sure
                    _this5._log.error('trying to return self as closer');

                    return false;
                  }

                  return !closer.id.isEqual(peerId);
                }));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _betterPeersToQuery(_x12, _x13) {
        return _betterPeersToQuery2.apply(this, arguments);
      }

      return _betterPeersToQuery;
    }()
    /**
     * Try to fetch a given record by from the local datastore.
     * Returns the record iff it is still valid, meaning
     * - it was either authored by this node, or
     * - it was received less than `MAX_RECORD_AGE` ago.
     *
     * @param {Uint8Array} key
     */

  }, {
    key: "_checkLocalDatastore",
    value: function () {
      var _checkLocalDatastore2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(key) {
        var dsKey, rawRecord, record;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._log("checkLocalDatastore: ".concat(uint8ArrayToString(key), " %b"), key);

                dsKey = utils.bufferToKey(key); // Fetch value from ds

                _context12.prev = 2;
                _context12.next = 5;
                return this.datastore.get(dsKey);

              case 5:
                rawRecord = _context12.sent;
                _context12.next = 13;
                break;

              case 8:
                _context12.prev = 8;
                _context12.t0 = _context12["catch"](2);

                if (!(_context12.t0.code === 'ERR_NOT_FOUND')) {
                  _context12.next = 12;
                  break;
                }

                return _context12.abrupt("return", undefined);

              case 12:
                throw _context12.t0;

              case 13:
                // Create record from the returned bytes
                record = Record.deserialize(rawRecord);

                if (record) {
                  _context12.next = 16;
                  break;
                }

                throw errcode(new Error('Invalid record'), 'ERR_INVALID_RECORD');

              case 16:
                if (!(record.timeReceived == null || utils.now() - record.timeReceived.getTime() > c.MAX_RECORD_AGE)) {
                  _context12.next = 21;
                  break;
                }

                _context12.next = 19;
                return this.datastore.delete(dsKey);

              case 19:
                this.onRemove(record);
                return _context12.abrupt("return", undefined);

              case 21:
                return _context12.abrupt("return", record);

              case 22:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[2, 8]]);
      }));

      function _checkLocalDatastore(_x14) {
        return _checkLocalDatastore2.apply(this, arguments);
      }

      return _checkLocalDatastore;
    }()
    /**
     * Add the peer to the routing table and update it in the peerStore.
     *
     * @param {PeerId} peerId
     */

  }, {
    key: "_add",
    value: function () {
      var _add2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(peerId) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.routingTable.add(peerId);

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _add(_x15) {
        return _add2.apply(this, arguments);
      }

      return _add;
    }()
    /**
     * Verify a record without searching the DHT.
     *
     * @param {import('libp2p-record').Record} record
     */

  }, {
    key: "_verifyRecordLocally",
    value: function () {
      var _verifyRecordLocally2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(record) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this._log('verifyRecordLocally');

                _context14.next = 3;
                return libp2pRecord.validator.verifyRecord(this.validators, record);

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function _verifyRecordLocally(_x16) {
        return _verifyRecordLocally2.apply(this, arguments);
      }

      return _verifyRecordLocally;
    }()
    /**
     * Is the given peer id our PeerId?
     *
     * @param {PeerId} other
     */

  }, {
    key: "_isSelf",
    value: function _isSelf(other) {
      return other && uint8ArrayEquals(this.peerId.id, other.id);
    }
    /**
     * Store the given key/value pair at the peer `target`.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} rec - encoded record
     * @param {PeerId} target
     */

  }, {
    key: "_putValueToPeer",
    value: function () {
      var _putValueToPeer2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(key, rec, target) {
        var msg, resp;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                msg = new Message(Message.TYPES.PUT_VALUE, key, 0);
                msg.record = Record.deserialize(rec);
                _context15.next = 4;
                return this.network.sendRequest(target, msg);

              case 4:
                resp = _context15.sent;

                if (!(resp.record && !uint8ArrayEquals(resp.record.value, Record.deserialize(rec).value))) {
                  _context15.next = 7;
                  break;
                }

                throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID');

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _putValueToPeer(_x17, _x18, _x19) {
        return _putValueToPeer2.apply(this, arguments);
      }

      return _putValueToPeer;
    }()
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     */

  }, {
    key: "_getValueOrPeers",
    value: function () {
      var _getValueOrPeers2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(peer, key) {
        var msg, peers, record, errMsg;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._getValueSingle(peer, key);

              case 2:
                msg = _context16.sent;
                peers = msg.closerPeers;
                record = msg.record;

                if (!record) {
                  _context16.next = 17;
                  break;
                }

                _context16.prev = 6;
                _context16.next = 9;
                return this._verifyRecordOnline(record);

              case 9:
                _context16.next = 16;
                break;

              case 11:
                _context16.prev = 11;
                _context16.t0 = _context16["catch"](6);
                errMsg = 'invalid record received, discarded';

                this._log(errMsg);

                throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD');

              case 16:
                return _context16.abrupt("return", {
                  record: record,
                  peers: peers
                });

              case 17:
                if (!(peers.length > 0)) {
                  _context16.next = 19;
                  break;
                }

                return _context16.abrupt("return", {
                  peers: peers
                });

              case 19:
                throw errcode(new Error('Not found'), 'ERR_NOT_FOUND');

              case 20:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[6, 11]]);
      }));

      function _getValueOrPeers(_x20, _x21) {
        return _getValueOrPeers2.apply(this, arguments);
      }

      return _getValueOrPeers;
    }()
    /**
     * Get a value via rpc call for the given parameters.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     */

  }, {
    key: "_getValueSingle",
    value: function () {
      var _getValueSingle2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(peer, key) {
        var msg;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                // eslint-disable-line require-await
                msg = new Message(Message.TYPES.GET_VALUE, key, 0);
                return _context17.abrupt("return", this.network.sendRequest(peer, msg));

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _getValueSingle(_x22, _x23) {
        return _getValueSingle2.apply(this, arguments);
      }

      return _getValueSingle;
    }()
    /**
     * Verify a record, fetching missing public keys from the network.
     * Calls back with an error if the record is invalid.
     *
     * @param {import('libp2p-record').Record} record
     * @returns {Promise<void>}
     */

  }, {
    key: "_verifyRecordOnline",
    value: function () {
      var _verifyRecordOnline2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(record) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return libp2pRecord.validator.verifyRecord(this.validators, record);

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function _verifyRecordOnline(_x24) {
        return _verifyRecordOnline2.apply(this, arguments);
      }

      return _verifyRecordOnline;
    }()
  }]);

  return KadDHT;
}(EventEmitter);

module.exports = KadDHT;
module.exports.multicodec = '/ipfs' + c.PROTOCOL_DHT;
},{"events":"node_modules/events/events.js","err-code":"node_modules/err-code/index.js","libp2p-record":"node_modules/libp2p-record/src/index.js","interface-datastore":"node_modules/interface-datastore/src/index.js","uint8arrays/equals":"node_modules/uint8arrays/equals.js","uint8arrays/to-string":"node_modules/uint8arrays/to-string.js","./routing":"node_modules/libp2p-kad-dht/src/routing.js","./utils":"node_modules/libp2p-kad-dht/src/utils.js","./constants":"node_modules/libp2p-kad-dht/src/constants.js","./network":"node_modules/libp2p-kad-dht/src/network.js","./content-fetching":"node_modules/libp2p-kad-dht/src/content-fetching/index.js","./content-routing":"node_modules/libp2p-kad-dht/src/content-routing/index.js","./peer-routing":"node_modules/libp2p-kad-dht/src/peer-routing/index.js","./message":"node_modules/libp2p-kad-dht/src/message/index.js","./providers":"node_modules/libp2p-kad-dht/src/providers.js","./random-walk":"node_modules/libp2p-kad-dht/src/random-walk.js","./query-manager":"node_modules/libp2p-kad-dht/src/query-manager.js"}],"chat-protocol.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildChatProtocol = buildChatProtocol;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator]; if (method == null && Symbol.iterator) method = iterable[Symbol.iterator]; } if (method == null) method = iterable["@@asyncIterator"]; if (method == null) method = iterable["@@iterator"]; if (method == null) throw new TypeError("Object is not async iterable"); return method.call(iterable); }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

// based on str2ab from https://gist.github.com/skratchdot/e095036fad80597f1c1a
function str2ab(str) {
  var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char

  var bufView = new Uint16Array(buf);

  for (var i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }

  return new Uint8Array(bufView.buffer, bufView.byteOffset, bufView.byteLength);
} // based on https://www.dreamincode.net/forums/topic/353343-how-to-convert-uint8array-to-uint16array-or-string/


function ab2str(uint8buf) {
  var buf = new ArrayBuffer(uint8buf.length);
  var bufView = new Uint16Array(buf);
  var count = 0;

  for (var i = 0; i < bufView.length; i++) {
    bufView[i] = uint8buf[count++] + (uint8buf[count++] << 8);
  }

  return String.fromCharCode.apply(null, bufView);
} // based on buildEventManager from https://whistlr.info/2020/async-generators-input/


function buildChatProtocol(messageCallback) {
  var resolve = function resolve() {};

  var queue = [];

  function generator() {
    return _generator.apply(this, arguments);
  }

  function _generator() {
    _generator = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (queue.length) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return _awaitAsyncGenerator(new Promise(function (r) {
                return resolve = r;
              }));

            case 3:
              _context.next = 5;
              return str2ab(queue.shift());

            case 5:
              _context.next = 0;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _generator.apply(this, arguments);
  }

  return {
    pushMessage: function pushMessage(message) {
      queue.push(message);

      if (queue.length === 1) {
        resolve();
      }
    },
    streamSource: generator(),
    streamProcessor: function () {
      var _streamProcessor = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(source) {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, buf;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context2.prev = 2;
                _iterator = _asyncIterator(source);

              case 4:
                _context2.next = 6;
                return _iterator.next();

              case 6:
                if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                  _context2.next = 12;
                  break;
                }

                buf = _step.value;
                messageCallback(ab2str(buf.slice()));

              case 9:
                _iteratorAbruptCompletion = false;
                _context2.next = 4;
                break;

              case 12:
                _context2.next = 18;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](2);
                _didIteratorError = true;
                _iteratorError = _context2.t0;

              case 18:
                _context2.prev = 18;
                _context2.prev = 19;

                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context2.next = 23;
                  break;
                }

                _context2.next = 23;
                return _iterator.return();

              case 23:
                _context2.prev = 23;

                if (!_didIteratorError) {
                  _context2.next = 26;
                  break;
                }

                throw _iteratorError;

              case 26:
                return _context2.finish(23);

              case 27:
                return _context2.finish(18);

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 14, 18, 28], [19,, 23, 27]]);
      }));

      function streamProcessor(_x) {
        return _streamProcessor.apply(this, arguments);
      }

      return streamProcessor;
    }()
  };
}
},{}],"node_modules/vue-class-component/dist/vue-class-component.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDecorator = createDecorator;
exports.mixins = mixins;
exports.default = void 0;

var _vue = _interopRequireDefault(require("vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
} // The rational behind the verbose Reflect-feature check below is the fact that there are polyfills
// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.
// Without this check consumers will encounter hard to track down runtime errors.


function reflectionIsSupported() {
  return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
}

function copyReflectionMetadata(to, from) {
  forwardMetadata(to, from);
  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
    forwardMetadata(to.prototype, from.prototype, key);
  });
  Object.getOwnPropertyNames(from).forEach(function (key) {
    forwardMetadata(to, from, key);
  });
}

function forwardMetadata(to, from, propertyKey) {
  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
  metaKeys.forEach(function (metaKey) {
    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

    if (propertyKey) {
      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
    } else {
      Reflect.defineMetadata(metaKey, metadata, to);
    }
  });
}

var fakeArray = {
  __proto__: []
};
var hasProto = fakeArray instanceof Array;

function createDecorator(factory) {
  return function (target, key, index) {
    var Ctor = typeof target === 'function' ? target : target.constructor;

    if (!Ctor.__decorators__) {
      Ctor.__decorators__ = [];
    }

    if (typeof index !== 'number') {
      index = undefined;
    }

    Ctor.__decorators__.push(function (options) {
      return factory(options, key, index);
    });
  };
}

function mixins() {
  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {
    Ctors[_key] = arguments[_key];
  }

  return _vue.default.extend({
    mixins: Ctors
  });
}

function isPrimitive(value) {
  var type = _typeof(value);

  return value == null || type !== 'object' && type !== 'function';
}

function warn(message) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-class-component] ' + message);
  }
}

function collectDataFromConstructor(vm, Component) {
  // override _init to prevent to init as Vue instance
  var originalInit = Component.prototype._init;

  Component.prototype._init = function () {
    var _this = this; // proxy to actual vm


    var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)

    if (vm.$options.props) {
      for (var key in vm.$options.props) {
        if (!vm.hasOwnProperty(key)) {
          keys.push(key);
        }
      }
    }

    keys.forEach(function (key) {
      Object.defineProperty(_this, key, {
        get: function get() {
          return vm[key];
        },
        set: function set(value) {
          vm[key] = value;
        },
        configurable: true
      });
    });
  }; // should be acquired class property values


  var data = new Component(); // restore original _init to avoid memory leak (#209)

  Component.prototype._init = originalInit; // create plain data object

  var plainData = {};
  Object.keys(data).forEach(function (key) {
    if (data[key] !== undefined) {
      plainData[key] = data[key];
    }
  });

  if ("development" !== 'production') {
    if (!(Component.prototype instanceof _vue.default) && Object.keys(plainData).length > 0) {
      warn('Component class must inherit Vue or its descendant class ' + 'when class property is used.');
    }
  }

  return plainData;
}

var $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6
];

function componentFactory(Component) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.name = options.name || Component._componentTag || Component.name; // prototype props.

  var proto = Component.prototype;
  Object.getOwnPropertyNames(proto).forEach(function (key) {
    if (key === 'constructor') {
      return;
    } // hooks


    if ($internalHooks.indexOf(key) > -1) {
      options[key] = proto[key];
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(proto, key);

    if (descriptor.value !== void 0) {
      // methods
      if (typeof descriptor.value === 'function') {
        (options.methods || (options.methods = {}))[key] = descriptor.value;
      } else {
        // typescript decorated data
        (options.mixins || (options.mixins = [])).push({
          data: function data() {
            return _defineProperty({}, key, descriptor.value);
          }
        });
      }
    } else if (descriptor.get || descriptor.set) {
      // computed properties
      (options.computed || (options.computed = {}))[key] = {
        get: descriptor.get,
        set: descriptor.set
      };
    }
  });
  (options.mixins || (options.mixins = [])).push({
    data: function data() {
      return collectDataFromConstructor(this, Component);
    }
  }); // decorate options

  var decorators = Component.__decorators__;

  if (decorators) {
    decorators.forEach(function (fn) {
      return fn(options);
    });
    delete Component.__decorators__;
  } // find super


  var superProto = Object.getPrototypeOf(Component.prototype);
  var Super = superProto instanceof _vue.default ? superProto.constructor : _vue.default;
  var Extended = Super.extend(options);
  forwardStaticMembers(Extended, Component, Super);

  if (reflectionIsSupported()) {
    copyReflectionMetadata(Extended, Component);
  }

  return Extended;
}

var reservedPropertyNames = [// Unique id
'cid', // Super Vue constructor
'super', // Component options that will be used by the component
'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets
'component', 'directive', 'filter'];
var shouldIgnore = {
  prototype: true,
  arguments: true,
  callee: true,
  caller: true
};

function forwardStaticMembers(Extended, Original, Super) {
  // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable
  Object.getOwnPropertyNames(Original).forEach(function (key) {
    // Skip the properties that should not be overwritten
    if (shouldIgnore[key]) {
      return;
    } // Some browsers does not allow reconfigure built-in properties


    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

    if (extendedDescriptor && !extendedDescriptor.configurable) {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),
    // the sub class properties may be inherited properties from the super class in TypeScript.
    // We need to exclude such properties to prevent to overwrite
    // the component options object which stored on the extended constructor (See #192).
    // If the value is a referenced value (object or function),
    // we can check equality of them and exclude it if they have the same reference.
    // If it is a primitive value, it will be forwarded for safety.

    if (!hasProto) {
      // Only `cid` is explicitly exluded from property forwarding
      // because we cannot detect whether it is a inherited property or not
      // on the no `__proto__` environment even though the property is reserved.
      if (key === 'cid') {
        return;
      }

      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
        return;
      }
    } // Warn if the users manually declare reserved properties


    if ("development" !== 'production' && reservedPropertyNames.indexOf(key) >= 0) {
      warn("Static property name '".concat(key, "' declared on class '").concat(Original.name, "' ") + 'conflicts with reserved property name of Vue internal. ' + 'It may cause unexpected behavior of the component. Consider renaming the property.');
    }

    Object.defineProperty(Extended, key, descriptor);
  });
}

function Component(options) {
  if (typeof options === 'function') {
    return componentFactory(options);
  }

  return function (Component) {
    return componentFactory(Component, options);
  };
}

Component.registerHooks = function registerHooks(keys) {
  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
};

var _default = Component;
exports.default = _default;
},{"vue":"node_modules/vue/dist/vue.runtime.esm.js"}],"node_modules/vue-property-decorator/lib/decorators/Emit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emit = Emit;

var __spreadArrays = void 0 && (void 0).__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}; // Code copied from Vue/src/shared/util.js


var hyphenateRE = /\B([A-Z])/g;

var hyphenate = function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
};
/**
 * decorator of an event-emitter function
 * @param  event The name of the event
 * @return MethodDecorator
 */


function Emit(event) {
  return function (_target, propertyKey, descriptor) {
    var key = hyphenate(propertyKey);
    var original = descriptor.value;

    descriptor.value = function emitter() {
      var _this = this;

      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var emit = function (returnValue) {
        var emitName = event || key;

        if (returnValue === undefined) {
          if (args.length === 0) {
            _this.$emit(emitName);
          } else if (args.length === 1) {
            _this.$emit(emitName, args[0]);
          } else {
            _this.$emit.apply(_this, __spreadArrays([emitName], args));
          }
        } else {
          args.unshift(returnValue);

          _this.$emit.apply(_this, __spreadArrays([emitName], args));
        }
      };

      var returnValue = original.apply(this, args);

      if (isPromise(returnValue)) {
        returnValue.then(emit);
      } else {
        emit(returnValue);
      }

      return returnValue;
    };
  };
}

function isPromise(obj) {
  return obj instanceof Promise || obj && typeof obj.then === 'function';
}
},{}],"node_modules/vue-property-decorator/lib/decorators/Inject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Inject = Inject;

var _vueClassComponent = require("vue-class-component");

/**
 * decorator of an inject
 * @param from key
 * @return PropertyDecorator
 */
function Inject(options) {
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, key) {
    if (typeof componentOptions.inject === 'undefined') {
      componentOptions.inject = {};
    }

    if (!Array.isArray(componentOptions.inject)) {
      componentOptions.inject[key] = options || key;
    }
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js"}],"node_modules/vue-property-decorator/lib/helpers/provideInject.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.needToProduceProvide = needToProduceProvide;
exports.produceProvide = produceProvide;
exports.inheritInjected = inheritInjected;
exports.reactiveInjectKey = void 0;

function needToProduceProvide(original) {
  return typeof original !== 'function' || !original.managed && !original.managedReactive;
}

function produceProvide(original) {
  var provide = function () {
    var _this = this;

    var rv = typeof original === 'function' ? original.call(this) : original;
    rv = Object.create(rv || null); // set reactive services (propagates previous services if necessary)

    rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});

    for (var i in provide.managed) {
      rv[provide.managed[i]] = this[i];
    }

    var _loop_1 = function (i) {
      rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`

      Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {
        enumerable: true,
        configurable: true,
        get: function () {
          return _this[i];
        }
      });
    };

    var this_1 = this;

    for (var i in provide.managedReactive) {
      _loop_1(i);
    }

    return rv;
  };

  provide.managed = {};
  provide.managedReactive = {};
  return provide;
}
/** Used for keying reactive provide/inject properties */


var reactiveInjectKey = '__reactiveInject__';
exports.reactiveInjectKey = reactiveInjectKey;

function inheritInjected(componentOptions) {
  // inject parent reactive services (if any)
  if (!Array.isArray(componentOptions.inject)) {
    componentOptions.inject = componentOptions.inject || {};
    componentOptions.inject[reactiveInjectKey] = {
      from: reactiveInjectKey,
      default: {}
    };
  }
}
},{}],"node_modules/vue-property-decorator/lib/decorators/InjectReactive.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InjectReactive = InjectReactive;

var _vueClassComponent = require("vue-class-component");

var _provideInject = require("../helpers/provideInject");

/**
 * decorator of a reactive inject
 * @param from key
 * @return PropertyDecorator
 */
function InjectReactive(options) {
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, key) {
    if (typeof componentOptions.inject === 'undefined') {
      componentOptions.inject = {};
    }

    if (!Array.isArray(componentOptions.inject)) {
      var fromKey_1 = !!options ? options.from || options : key;
      var defaultVal_1 = !!options && options.default || undefined;
      if (!componentOptions.computed) componentOptions.computed = {};

      componentOptions.computed[key] = function () {
        var obj = this[_provideInject.reactiveInjectKey];
        return obj ? obj[fromKey_1] : defaultVal_1;
      };

      componentOptions.inject[_provideInject.reactiveInjectKey] = _provideInject.reactiveInjectKey;
    }
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/provideInject":"node_modules/vue-property-decorator/lib/helpers/provideInject.js"}],"node_modules/vue-property-decorator/lib/helpers/metadata.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyMetadata = applyMetadata;

/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */
var reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';

function applyMetadata(options, target, key) {
  if (reflectMetadataIsSupported) {
    if (!Array.isArray(options) && typeof options !== 'function' && !options.hasOwnProperty('type') && typeof options.type === 'undefined') {
      var type = Reflect.getMetadata('design:type', target, key);

      if (type !== Object) {
        options.type = type;
      }
    }
  }
}
},{}],"node_modules/vue-property-decorator/lib/decorators/Model.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Model = Model;

var _vueClassComponent = require("vue-class-component");

var _metadata = require("../helpers/metadata");

/**
 * decorator of model
 * @param  event event name
 * @param options options
 * @return PropertyDecorator
 */
function Model(event, options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, key) {
    (0, _metadata.applyMetadata)(options, target, key);
    (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[k] = options;
      componentOptions.model = {
        prop: k,
        event: event || k
      };
    })(target, key);
  };
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/metadata":"node_modules/vue-property-decorator/lib/helpers/metadata.js"}],"node_modules/vue-property-decorator/lib/decorators/ModelSync.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelSync = ModelSync;

var _vueClassComponent = require("vue-class-component");

var _metadata = require("../helpers/metadata");

/**
 * decorator of synced model and prop
 * @param propName the name to interface with from outside, must be different from decorated property
 * @param  event event name
 * @param options options
 * @return PropertyDecorator
 */
function ModelSync(propName, event, options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, key) {
    (0, _metadata.applyMetadata)(options, target, key);
    (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[propName] = options;
      componentOptions.model = {
        prop: propName,
        event: event || k
      };
      (componentOptions.computed || (componentOptions.computed = {}))[k] = {
        get: function () {
          return this[propName];
        },
        set: function (value) {
          // @ts-ignore
          this.$emit(event, value);
        }
      };
    })(target, key);
  };
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/metadata":"node_modules/vue-property-decorator/lib/helpers/metadata.js"}],"node_modules/vue-property-decorator/lib/decorators/Prop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Prop = Prop;

var _vueClassComponent = require("vue-class-component");

var _metadata = require("../helpers/metadata");

/**
 * decorator of a prop
 * @param  options the options for the prop
 * @return PropertyDecorator | void
 */
function Prop(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, key) {
    (0, _metadata.applyMetadata)(options, target, key);
    (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[k] = options;
    })(target, key);
  };
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/metadata":"node_modules/vue-property-decorator/lib/helpers/metadata.js"}],"node_modules/vue-property-decorator/lib/decorators/PropSync.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropSync = PropSync;

var _vueClassComponent = require("vue-class-component");

var _metadata = require("../helpers/metadata");

/**
 * decorator of a synced prop
 * @param propName the name to interface with from outside, must be different from decorated property
 * @param options the options for the synced prop
 * @return PropertyDecorator | void
 */
function PropSync(propName, options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, key) {
    (0, _metadata.applyMetadata)(options, target, key);
    (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
      ;
      (componentOptions.props || (componentOptions.props = {}))[propName] = options;
      (componentOptions.computed || (componentOptions.computed = {}))[k] = {
        get: function () {
          return this[propName];
        },
        set: function (value) {
          this.$emit("update:" + propName, value);
        }
      };
    })(target, key);
  };
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/metadata":"node_modules/vue-property-decorator/lib/helpers/metadata.js"}],"node_modules/vue-property-decorator/lib/decorators/Provide.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Provide = Provide;

var _vueClassComponent = require("vue-class-component");

var _provideInject = require("../helpers/provideInject");

/**
 * decorator of a provide
 * @param key key
 * @return PropertyDecorator | void
 */
function Provide(key) {
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
    var provide = componentOptions.provide;
    (0, _provideInject.inheritInjected)(componentOptions);

    if ((0, _provideInject.needToProduceProvide)(provide)) {
      provide = componentOptions.provide = (0, _provideInject.produceProvide)(provide);
    }

    provide.managed[k] = key || k;
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/provideInject":"node_modules/vue-property-decorator/lib/helpers/provideInject.js"}],"node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProvideReactive = ProvideReactive;

var _vueClassComponent = require("vue-class-component");

var _provideInject = require("../helpers/provideInject");

/**
 * decorator of a reactive provide
 * @param key key
 * @return PropertyDecorator | void
 */
function ProvideReactive(key) {
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, k) {
    var provide = componentOptions.provide;
    (0, _provideInject.inheritInjected)(componentOptions);

    if ((0, _provideInject.needToProduceProvide)(provide)) {
      provide = componentOptions.provide = (0, _provideInject.produceProvide)(provide);
    }

    provide.managedReactive[k] = key || k;
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","../helpers/provideInject":"node_modules/vue-property-decorator/lib/helpers/provideInject.js"}],"node_modules/vue-property-decorator/lib/decorators/Ref.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ref = Ref;

var _vueClassComponent = require("vue-class-component");

/**
 * decorator of a ref prop
 * @param refKey the ref key defined in template
 */
function Ref(refKey) {
  return (0, _vueClassComponent.createDecorator)(function (options, key) {
    options.computed = options.computed || {};
    options.computed[key] = {
      cache: false,
      get: function () {
        return this.$refs[refKey || key];
      }
    };
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js"}],"node_modules/vue-property-decorator/lib/decorators/VModel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VModel = VModel;

var _vueClassComponent = require("vue-class-component");

/**
 * decorator for capturings v-model binding to component
 * @param options the options for the prop
 */
function VModel(options) {
  if (options === void 0) {
    options = {};
  }

  var valueKey = 'value';
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, key) {
    ;
    (componentOptions.props || (componentOptions.props = {}))[valueKey] = options;
    (componentOptions.computed || (componentOptions.computed = {}))[key] = {
      get: function () {
        return this[valueKey];
      },
      set: function (value) {
        this.$emit('input', value);
      }
    };
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js"}],"node_modules/vue-property-decorator/lib/decorators/Watch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Watch = Watch;

var _vueClassComponent = require("vue-class-component");

/**
 * decorator of a watch function
 * @param  path the path or the expression to observe
 * @param  WatchOption
 * @return MethodDecorator
 */
function Watch(path, options) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.deep,
      deep = _a === void 0 ? false : _a,
      _b = options.immediate,
      immediate = _b === void 0 ? false : _b;
  return (0, _vueClassComponent.createDecorator)(function (componentOptions, handler) {
    if (typeof componentOptions.watch !== 'object') {
      componentOptions.watch = Object.create(null);
    }

    var watch = componentOptions.watch;

    if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {
      watch[path] = [watch[path]];
    } else if (typeof watch[path] === 'undefined') {
      watch[path] = [];
    }

    watch[path].push({
      handler: handler,
      deep: deep,
      immediate: immediate
    });
  });
}
},{"vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js"}],"node_modules/vue-property-decorator/lib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Vue", {
  enumerable: true,
  get: function () {
    return _vue.default;
  }
});
Object.defineProperty(exports, "Component", {
  enumerable: true,
  get: function () {
    return _vueClassComponent.default;
  }
});
Object.defineProperty(exports, "Mixins", {
  enumerable: true,
  get: function () {
    return _vueClassComponent.mixins;
  }
});
Object.defineProperty(exports, "Emit", {
  enumerable: true,
  get: function () {
    return _Emit.Emit;
  }
});
Object.defineProperty(exports, "Inject", {
  enumerable: true,
  get: function () {
    return _Inject.Inject;
  }
});
Object.defineProperty(exports, "InjectReactive", {
  enumerable: true,
  get: function () {
    return _InjectReactive.InjectReactive;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _Model.Model;
  }
});
Object.defineProperty(exports, "ModelSync", {
  enumerable: true,
  get: function () {
    return _ModelSync.ModelSync;
  }
});
Object.defineProperty(exports, "Prop", {
  enumerable: true,
  get: function () {
    return _Prop.Prop;
  }
});
Object.defineProperty(exports, "PropSync", {
  enumerable: true,
  get: function () {
    return _PropSync.PropSync;
  }
});
Object.defineProperty(exports, "Provide", {
  enumerable: true,
  get: function () {
    return _Provide.Provide;
  }
});
Object.defineProperty(exports, "ProvideReactive", {
  enumerable: true,
  get: function () {
    return _ProvideReactive.ProvideReactive;
  }
});
Object.defineProperty(exports, "Ref", {
  enumerable: true,
  get: function () {
    return _Ref.Ref;
  }
});
Object.defineProperty(exports, "VModel", {
  enumerable: true,
  get: function () {
    return _VModel.VModel;
  }
});
Object.defineProperty(exports, "Watch", {
  enumerable: true,
  get: function () {
    return _Watch.Watch;
  }
});

var _vue = _interopRequireDefault(require("vue"));

var _vueClassComponent = _interopRequireWildcard(require("vue-class-component"));

var _Emit = require("./decorators/Emit");

var _Inject = require("./decorators/Inject");

var _InjectReactive = require("./decorators/InjectReactive");

var _Model = require("./decorators/Model");

var _ModelSync = require("./decorators/ModelSync");

var _Prop = require("./decorators/Prop");

var _PropSync = require("./decorators/PropSync");

var _Provide = require("./decorators/Provide");

var _ProvideReactive = require("./decorators/ProvideReactive");

var _Ref = require("./decorators/Ref");

var _VModel = require("./decorators/VModel");

var _Watch = require("./decorators/Watch");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"vue":"node_modules/vue/dist/vue.runtime.esm.js","vue-class-component":"node_modules/vue-class-component/dist/vue-class-component.esm.js","./decorators/Emit":"node_modules/vue-property-decorator/lib/decorators/Emit.js","./decorators/Inject":"node_modules/vue-property-decorator/lib/decorators/Inject.js","./decorators/InjectReactive":"node_modules/vue-property-decorator/lib/decorators/InjectReactive.js","./decorators/Model":"node_modules/vue-property-decorator/lib/decorators/Model.js","./decorators/ModelSync":"node_modules/vue-property-decorator/lib/decorators/ModelSync.js","./decorators/Prop":"node_modules/vue-property-decorator/lib/decorators/Prop.js","./decorators/PropSync":"node_modules/vue-property-decorator/lib/decorators/PropSync.js","./decorators/Provide":"node_modules/vue-property-decorator/lib/decorators/Provide.js","./decorators/ProvideReactive":"node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js","./decorators/Ref":"node_modules/vue-property-decorator/lib/decorators/Ref.js","./decorators/VModel":"node_modules/vue-property-decorator/lib/decorators/VModel.js","./decorators/Watch":"node_modules/vue-property-decorator/lib/decorators/Watch.js"}],"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"node_modules/vue-hot-reload-api/dist/index.js":[function(require,module,exports) {
var Vue // late bind
var version
var map = Object.create(null)
if (typeof window !== 'undefined') {
  window.__VUE_HOT_MAP__ = map
}
var installed = false
var isBrowserify = false
var initHookName = 'beforeCreate'

exports.install = function (vue, browserify) {
  if (installed) { return }
  installed = true

  Vue = vue.__esModule ? vue.default : vue
  version = Vue.version.split('.').map(Number)
  isBrowserify = browserify

  // compat with < 2.0.0-alpha.7
  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init'
  }

  exports.compatible = version[0] >= 2
  if (!exports.compatible) {
    console.warn(
      '[HMR] You are using a version of vue-hot-reload-api that is ' +
        'only compatible with Vue.js core ^2.0.0.'
    )
    return
  }
}

/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if(map[id]) { return }

  var Ctor = null
  if (typeof options === 'function') {
    Ctor = options
    options = Ctor.options
  }
  makeOptionsHot(id, options)
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  }
}

/**
 * Check if module is recorded
 *
 * @param {String} id
 */

exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined'
}

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render
    options.render = function (h, ctx) {
      var instances = map[id].instances
      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent)
      }
      return render(h, ctx)
    }
  } else {
    injectHook(options, initHookName, function() {
      var record = map[id]
      if (!record.Ctor) {
        record.Ctor = this.constructor
      }
      record.instances.push(this)
    })
    injectHook(options, 'beforeDestroy', function() {
      var instances = map[id].instances
      instances.splice(instances.indexOf(this), 1)
    })
  }
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook(options, name, hook) {
  var existing = options[name]
  options[name] = existing
    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]
    : [hook]
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg)
    } catch (e) {
      console.error(e)
      console.warn(
        'Something went wrong during Vue component hot-reload. Full reload required.'
      )
    }
  }
}

function updateOptions (oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key]
    }
  }
  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1]
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id]
  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate()
    })
    return
  }
  if (typeof options === 'function') {
    options = options.options
  }
  if (record.Ctor) {
    record.Ctor.options.render = options.render
    record.Ctor.options.staticRenderFns = options.staticRenderFns
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render
      instance.$options.staticRenderFns = options.staticRenderFns
      // reset static trees
      // pre 2.5, all static trees are cached together on the instance
      if (instance._staticTrees) {
        instance._staticTrees = []
      }
      // 2.5.0
      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = []
      }
      // 2.5.3
      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = []
      }

      // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)

      // 2.6: temporarily mark rendered scoped slots as unstable so that
      // child components can be forced to update
      var restore = patchScopedSlots(instance)
      instance.$forceUpdate()
      instance.$nextTick(restore)
    })
  } else {
    // functional or no instance created yet
    record.options.render = options.render
    record.options.staticRenderFns = options.staticRenderFns

    // handle functional component re-render
    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options)
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles
        if (injectStyles) {
          var render = options.render
          record.options.render = function (h, ctx) {
            injectStyles.call(ctx)
            return render(h, ctx)
          }
        }
      }
      record.options._Ctor = null
      // 2.5.3
      if (Array.isArray(record.options.cached)) {
        record.options.cached = []
      }
      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate()
      })
    }
  }
})

exports.reload = tryWrap(function (id, options) {
  var record = map[id]
  if (options) {
    if (typeof options === 'function') {
      options = options.options
    }
    makeOptionsHot(id, options)
    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options
      }
      var newCtor = record.Ctor.super.extend(options)
      // prevent record.options._Ctor from being overwritten accidentally
      newCtor.options._Ctor = record.options._Ctor
      record.Ctor.options = newCtor.options
      record.Ctor.cid = newCtor.cid
      record.Ctor.prototype = newCtor.prototype
      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release()
      }
    } else {
      updateOptions(record.options, options)
    }
  }
  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate()
    } else {
      console.warn(
        'Root or manually mounted instance modified. Full reload required.'
      )
    }
  })
})

// 2.6 optimizes template-compiled scoped slots and skips updates if child
// only uses scoped slots. We need to patch the scoped slots resolving helper
// to temporarily mark all scoped slots as unstable in order to force child
// updates.
function patchScopedSlots (instance) {
  if (!instance._u) { return }
  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js
  var original = instance._u
  instance._u = function (slots) {
    try {
      // 2.6.4 ~ 2.6.6
      return original(slots, true)
    } catch (e) {
      // 2.5 / >= 2.6.7
      return original(slots, null, true)
    }
  }
  return function () {
    instance._u = original
  }
}

},{}],"App.vue":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

require("babel-polyfill");

var libp2p_1 = __importDefault(require("libp2p"));

var libp2p_websockets_1 = __importDefault(require("libp2p-websockets"));

var libp2p_webrtc_star_1 = __importDefault(require("libp2p-webrtc-star"));

var libp2p_noise_1 = require("libp2p-noise");

var libp2p_mplex_1 = __importDefault(require("libp2p-mplex"));

var libp2p_bootstrap_1 = __importDefault(require("libp2p-bootstrap"));

var libp2p_kad_dht_1 = __importDefault(require("libp2p-kad-dht"));

var peer_id_1 = __importDefault(require("peer-id"));

var it_pipe_1 = __importDefault(require("it-pipe"));

var chat_protocol_1 = require("./chat-protocol");

var vue_property_decorator_1 = require("vue-property-decorator");

var chatProtocol = "/chat/1.0.0";

var App = function (_super) {
  __extends(App, _super);

  function App() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.myPeerId = "";
    _this.otherPeerId = "";
    _this.otherPeerMultiaddrs = [];
    _this.otherPeerProtocols = [];
    _this.otherPeerMultiaddr = "";
    _this.otherPeerProtocol = "";
    _this.remotePeerId = "";
    _this.chatStream = "";
    _this.chatMessage = "";
    _this.messages = [];
    return _this;
  }

  App.prototype.init = function () {
    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, pushMessage, streamSource, streamProcessor;

      var _c;

      var _this = this;

      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            _a = this;
            return [4
            /*yield*/
            , libp2p_1.default.create({
              addresses: {
                listen: ["/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star", "/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star"]
              },
              modules: {
                transport: [libp2p_websockets_1.default, libp2p_webrtc_star_1.default],
                connEncryption: [libp2p_noise_1.NOISE],
                streamMuxer: [libp2p_mplex_1.default],
                peerDiscovery: [libp2p_bootstrap_1.default],
                dht: libp2p_kad_dht_1.default
              },
              config: {
                peerDiscovery: (_c = {}, _c[libp2p_bootstrap_1.default.tag] = {
                  enabled: true,
                  list: ["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN", "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb", "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp", "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa", "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt"]
                }, _c),
                dht: {
                  enabled: true
                }
              }
            })];

          case 1:
            _a.libp2p = _d.sent();
            return [4
            /*yield*/
            , this.libp2p.start()];

          case 2:
            _d.sent();

            this.myPeerId = this.libp2p.peerId.toB58String();
            _b = chat_protocol_1.buildChatProtocol(function (msg) {
              _this.messages.push("> " + msg);
            }), pushMessage = _b.pushMessage, streamSource = _b.streamSource, streamProcessor = _b.streamProcessor;
            this.pushMessage = pushMessage;
            this.streamSource = streamSource;
            this.libp2p.handle(chatProtocol, function (_a) {
              var connection = _a.connection,
                  stream = _a.stream,
                  protocol = _a.protocol;
              _this.remotePeerId = connection.remoteAddr.getPeerId();
              it_pipe_1.default(stream, streamProcessor);
            });
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  App.prototype.mounted = function () {
    this.init();
  };

  App.prototype.findOtherPeer = function () {
    return __awaiter(this, void 0, void 0, function () {
      var peerId, result;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            peerId = peer_id_1.default.parse(this.otherPeerId);
            return [4
            /*yield*/
            , this.libp2p.peerRouting.findPeer(peerId)];

          case 1:
            result = _a.sent();
            this.otherPeerMultiaddrs = result.multiaddrs;
            this.otherPeerProtocols = this.libp2p.peerStore.protoBook.get(peerId);
            this.otherPeerMultiaddr = this.otherPeerMultiaddrs[0];
            this.otherPeerProtocol = chatProtocol;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  App.prototype.dialProtocol = function () {
    return __awaiter(this, void 0, void 0, function () {
      var peerId, _a, stream, protocol;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            peerId = peer_id_1.default.parse(this.otherPeerId);
            return [4
            /*yield*/
            , this.libp2p.dialProtocol(peerId, chatProtocol)];

          case 1:
            _a = _b.sent(), stream = _a.stream, protocol = _a.protocol;
            it_pipe_1.default(this.streamSource, stream);
            this.chatStream = stream;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  App.prototype.sendMessage = function () {
    this.pushMessage(this.chatMessage);
    this.messages.push("< " + this.chatMessage);
    this.chatMessage = "";
  };

  App = __decorate([vue_property_decorator_1.Component], App);
  return App;
}(vue_property_decorator_1.Vue);

exports.default = App;
        var $6f9d4c = exports.default || module.exports;
      
      if (typeof $6f9d4c === 'function') {
        $6f9d4c = $6f9d4c.options;
      }
    
        /* template */
        Object.assign($6f9d4c, (function () {
          var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c("p", [_vm._v("Your peerId: " + _vm._s(_vm.myPeerId))]),
      _vm._v(" "),
      _c("p", [
        _vm._v("\n    Other peerId:\n    "),
        _c("input", {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.otherPeerId,
              expression: "otherPeerId"
            }
          ],
          staticStyle: { width: "420px" },
          attrs: { type: "text" },
          domProps: { value: _vm.otherPeerId },
          on: {
            input: function($event) {
              if ($event.target.composing) {
                return
              }
              _vm.otherPeerId = $event.target.value
            }
          }
        }),
        _c("button", { on: { click: _vm.findOtherPeer } }, [
          _vm._v("\n      Find\n    ")
        ])
      ]),
      _vm._v(" "),
      _vm._l(_vm.otherPeerMultiaddrs, function(multiaddr, idx) {
        return _c("p", { key: "ma_" + idx }, [
          _vm._v(
            "\n    Other peer multiaddr: " +
              _vm._s(multiaddr.toString()) +
              "\n  "
          )
        ])
      }),
      _vm._v(" "),
      _vm._l(_vm.otherPeerProtocols, function(protocol, idx) {
        return _c("p", { key: "p_" + idx }, [
          _vm._v("\n    Other peer protocol: " + _vm._s(protocol) + "\n  ")
        ])
      }),
      _vm._v(" "),
      _vm.otherPeerMultiaddrs.length > 0 && _vm.otherPeerProtocols.length > 0
        ? _c("div", [
            _c("p", [
              _vm._v(
                "\n      " +
                  _vm._s(_vm.otherPeerMultiaddr) +
                  _vm._s(_vm.otherPeerProtocol) +
                  "\n      "
              ),
              _c("button", { on: { click: _vm.dialProtocol } }, [
                _vm._v("Dial protocol")
              ])
            ])
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.remotePeerId
        ? _c("p", [
            _vm._v(
              "\n    Remote peer connected: " +
                _vm._s(_vm.remotePeerId.toString()) +
                "\n  "
            )
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm._l(_vm.messages, function(msg, idx) {
        return _c("p", { key: "msg_" + idx }, [
          _vm._v("\n    " + _vm._s(msg) + "\n  ")
        ])
      }),
      _vm._v(" "),
      _vm.chatStream
        ? _c("div", [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.chatMessage,
                  expression: "chatMessage"
                }
              ],
              staticStyle: { width: "600px" },
              attrs: { type: "text" },
              domProps: { value: _vm.chatMessage },
              on: {
                input: function($event) {
                  if ($event.target.composing) {
                    return
                  }
                  _vm.chatMessage = $event.target.value
                }
              }
            }),
            _c("button", { on: { click: _vm.sendMessage } }, [
              _vm._v("\n      Send message\n    ")
            ])
          ])
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
    /* hot reload */
    (function () {
      if (module.hot) {
        var api = require('vue-hot-reload-api');
        api.install(require('vue'));
        if (api.compatible) {
          module.hot.accept();
          if (!module.hot.data) {
            api.createRecord('$6f9d4c', $6f9d4c);
          } else {
            api.reload('$6f9d4c', $6f9d4c);
          }
        }

        
        var reloadCSS = require('_css_loader');
        module.hot.dispose(reloadCSS);
        module.hot.accept(reloadCSS);
      
      }
    })();
},{"babel-polyfill":"../../../../node_modules/babel-polyfill/lib/index.js","libp2p":"node_modules/libp2p/src/index.js","libp2p-websockets":"node_modules/libp2p-websockets/src/index.js","libp2p-webrtc-star":"node_modules/libp2p-webrtc-star/src/index.js","libp2p-noise":"node_modules/libp2p-noise/dist/src/index.js","libp2p-mplex":"node_modules/libp2p-mplex/src/index.js","libp2p-bootstrap":"node_modules/libp2p-bootstrap/src/index.js","libp2p-kad-dht":"node_modules/libp2p-kad-dht/src/index.js","peer-id":"node_modules/peer-id/src/index.js","it-pipe":"node_modules/it-pipe/index.js","./chat-protocol":"chat-protocol.js","vue-property-decorator":"node_modules/vue-property-decorator/lib/index.js","_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js","vue-hot-reload-api":"node_modules/vue-hot-reload-api/dist/index.js","vue":"node_modules/vue/dist/vue.runtime.esm.js"}],"index.js":[function(require,module,exports) {
"use strict";

var _vue = _interopRequireDefault(require("vue"));

var _App = _interopRequireDefault(require("./App.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

new _vue.default({
  render: function render(createElement) {
    return createElement(_App.default);
  }
}).$mount('#app');
},{"vue":"node_modules/vue/dist/vue.runtime.esm.js","./App.vue":"App.vue"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "41513" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/libp2p-browser-example.e31bb0bc.js.map